XXD(1)                                                                                                                                                                                               XXD(1)

名前
       xxd - 16 進ダンプを作成したり、元に戻したり。

書式
       xxd -h[elp]
       xxd [options] [infile [outfile]]
       xxd -r[evert] [options] [infile [outfile]]

説明
       ファイルや標準入力から  16 進ダンプを作成します。 16 進ダンプから元のバイナリに戻すこともできます。 uuencode(1) や uudecode(1) のように、バイナリデータを、メールに貼り付け可能な ASCII 形式に変換で
       きたり、標準出力に出力することもできます。 さらに、バイナリファイルにパッチを当てるという使い方もできます。

オプション
       infile を指定しなかった場合は、標準入力が読み込まれます。 infile に `-' を指定した場合も、標準入力から読み込まれます。 outfile を指定しなかった (または `-' を指定した) 場合は、標準出力に出力されま
       す。

       引数の解釈処理は適当なので注意してください。 パラメータを取らない引数は最初の一文字だけチェックされます。 引数の文字とパラメータの間のスペースは省略可能です。 パラメータは 10 進数、16 進数、8 進数
       で指定できます。 -c8 、 -c 8 、 -c 010 、 -cols 8 はすべて同じ意味です。

       -a | -autoskip
              オートスキップ: 連続した nul 行を一つの '*' で置き換える。

       -b | -bits
              ビット (2進数) ダンプ。 1 オクテットが "1" と "0" の 8 文字で出力されます。 各行の行頭には 16 進数の行番号が表示されます。 行末には ASCII (または EBCDIC)  で表した場合の文字が表示されます。
              このモードでは -p、-i は機能しません。

       -e     リトルエンディアンの 16 進ダンプに切り替える。 このオプションは、バイトのグループをリトルエンディアンのバイト順のワードとして扱います。 標準のグルーピングは 4 バイトですが、 -g を使うことで
              変更可能です。 このオプションは 16 進ダンプのみに適用され、ASCII (あるいは EBCDIC) 表示は変更されません。 このモードでは -r、-p、-i は機能しません。

       -c cols | -cols cols
              一行 <cols> オクテットで出力する。標準設定は 16 (-i: 12, -ps: 30, -b: 6)。最大 256。 -ps には最大値がありません。 -ps 付きの場合、0 を指定すると単一の長い行で出力されます。

       -C | -capitalize
              -i を使用した際に、C インクルードファイル形式の変数名を大文字にする。

       -d     オフセットを 16 進の代わりに 10 進で表示する。

       -E | -EBCDIC
              右端に出力される文字のエンコーディングを ASCII から EBCDIC に変更する。 16 進ダンプの出力形式は変更されません。 -r、-p、-i が同時に指定された場合は何の効果もありません。

       -g bytes | -groupsize bytes
              出力を  <bytes> バイト (2 文字の 16 進数、または 8 文字の 2 進数) ごとにスペースで区切ります。 区切らずに出力するには -g 0 を指定してください。 <Bytes> の標準設定は 2 で、リトルエンディアン
              モードの場合は 4 、 2 進ダンプの場合は 1 です。 ポストスクリプト形式やインクルード形式で出力するときは、このオプションは使われません。

       -h | -help
              コマンドの説明を出力して終了する。変換は実行されません。

       -i | -include
              C インクルードファイル形式で出力する。 入力ファイルの名前が付けられた静的配列の定義が出力されます。 標準入力の場合は定義の中身だけ出力されます。

       -l len | -len len
              <len> オクテットだけ出力する。

       -n name  |  -name name
              -i が使われたときに変数名の出力を上書きする。 配列は name と名付けられ、長さは name_len と名付けられます。

       -o offset
              表示されるファイル位置に <offset> を加算する。

       -p | -ps | -postscript | -plain
              ポストスクリプト形式の 16 進ダンプを出力する。別名 プレーン 16 進ダンプ。

       -r | -revert
              元に戻す: 16 進ダンプからバイナリ形式に変換 (またはパッチ) します。 ファイルへ出力する場合、出力先のファイルは切り詰めされません。 行番号や特定の書式がないプレーン 16 進ダンプを読み込む場合
              は、 -r -p の組み合わせを使ってください。空白と改行は無視されます。 16 進ダンプの代わりにビットダンプを読み込むには、 -r -b の組み合わせを使ってください。

       -R when
              16 進の値に基づいて、16 進の値とその値の両方が同じ色でカラー表示される。 たいていは、表示可能文字と非表示可能文字を区別するのに有用です。 when は never, always, あるいは  auto  (デフォルト:
              auto) のいずれかです。 $NO_COLOR 環境変数が設定されているときは、カラー表示は無効化されます。

       -seek offset
              -r の後で使われた場合: 16 進ダンプを出力するファイルの位置に <offset> を加える。

       -s [+][-]seek
              infile  の <seek> バイト目 (絶対位置、または相対位置) から開始する。 + は、現在の標準入力の位置から相対的な位置を示します (標準入力から読み込むときのみ意味があります)。 - は、入力の終わりか
              らの文字数を示します (+ と同時に指定した場合は、現在の標準入力の位置から手前の位置を示します)。 -s 引数を指定しなかった場合は、現在のファイル位置から開始されます。

       -u     16 進数の表記に大文字を使います。指定がない場合は小文字で出力されます。

       -v | -version
              バージョンを表示します。

警告
       xxd -r では行番号の評価に関しての暗黙のルールがいくつかあります。 出力ファイルがシーク可能なら、各行の行番号が順番通りに並んでなくても構いません。 位置が飛んでいても重なっていても大丈夫です。 その
       場合、次の位置に移動するために lseek(2) が使われます。 出力ファイルがシーク不可なら、「隙間」だけが処理可能です。 隙間は null バイトで埋められます。

       xxd -r は不正な入力をエラーにしません。ゴミは静かに読み飛ばされます。

       16 進ダンプを編集するときは注意が必要です。 xxd -r は必要な桁 (-c 引数参照) だけ 16 進データを読み込んで、行の残りを無視します。 つまり、ASCII  (または  EBCDIC)  を示している列への変更は無視されま
       す。 xxd -r -p でプレーン形式 (ポストスクリプト形式) の 16 進ダンプを元に戻す場合は、列の数は影響しません。 2 桁の 16 進数と認識できるものはすべて変換されます。

       % xxd -i file
       と
       % xxd -i < file
       の結果は違います。注意してください。

       xxd  -s  +seek と xxd -s seek, の違いは、lseek(2) を使って入力を "巻き戻す" かどうかです。'+' が意味を持つのは、入力が標準入力で、xxd が起動されたときに標準入力のファイル位置がファイルの先頭ではな
       かった場合です。 以下の例が分かりやすいかもしれません (もっと混乱するかも!):

       `cat' が既に標準入力を終わりまで読んでいるので、読む前に標準入力を巻き戻す必要がある。
       % sh -c "cat > plain_copy; xxd -s 0 > hex_copy" < file

       ファイル位置 0x480 (=1024+128) 前方から 16 進ダンプする。 `+' は 「現在地からの相対位置」を意味するので、dd が 1k 処理した後から、さらに `128' 進めます。
       % sh -c "dd of=plain_snippet bs=1k count=1; xxd -s +128 > hex_snippet" < file

       ファイル位置 0x100 (=1024-768) から 16 進ダンプする。
       % sh -c "dd of=plain_snippet bs=1k count=1; xxd -s +-768 > hex_snippet" < file

       このような使い方はあまりしませんし、`+' を使うこともほとんどないでしょう。 -s を使うときはいつでも、strace(1) や truss(1) を使って、xxd の働きをチェックすることをお勧めします。

例
       ファイル の最初の三行 (16 進数で 0x30 バイト) 以降を出力する。
       % xxd -s 0x30 file

       ファイル の最後から三行 (16 進数で 0x30 バイト) を出力する。
       % xxd -s -0x30 file

       120 バイトを、平文 16 進ダンプ形式で一行に 20 オクテットずつ出力する。
       % xxd -l 120 -ps -c 20 xxd.1
       2e54482058584420312022417567757374203139
       39362220224d616e75616c207061676520666f72
       20787864220a2e5c220a2e5c222032317374204d
       617920313939360a2e5c22204d616e2070616765
       20617574686f723a0a2e5c2220202020546f6e79
       204e7567656e74203c746f6e79407363746e7567

       この man ページの先頭から 120 バイトを一行に 12 オクテットずつ 16 進ダンプする。
       % xxd -l 120 -c 12 xxd.1
       0000000: 2e54 4820 5858 4420 3120 2241  .TH XXD 1 "A
       000000c: 7567 7573 7420 3139 3936 2220  ugust 1996"
       0000018: 224d 616e 7561 6c20 7061 6765  "Manual page
       0000024: 2066 6f72 2078 7864 220a 2e5c   for xxd"..\
       0000030: 220a 2e5c 2220 3231 7374 204d  "..\" 21st M
       000003c: 6179 2031 3939 360a 2e5c 2220  ay 1996..\"
       0000048: 4d61 6e20 7061 6765 2061 7574  Man page aut
       0000054: 686f 723a 0a2e 5c22 2020 2020  hor:..\"
       0000060: 546f 6e79 204e 7567 656e 7420  Tony Nugent
       000006c: 3c74 6f6e 7940 7363 746e 7567  <tony@sctnug

       xxd.1 の日付部分だけを出力する。
       % xxd -s 0x36 -l 13 -c 13 xxd.1
       0000036: 3231 7374 204d 6179 2031 3939 36  21st May 1996

       input_file を output_file にコピーし、先頭に 0x00 を 100 バイト分付け加える。
       % xxd input_file | xxd -r -s 100 > output_file

       xxd.1 の日付を修正する。
       % echo "0000037: 3574 68" | xxd -r - xxd.1
       % xxd -s 0x36 -l 13 -c 13 xxd.1
       0000036: 3235 7468 204d 6179 2031 3939 36  25th May 1996

       中身がすべて 0x00 の 65537 バイトのファイルを作成する。 ただし、最後のバイトだけは 'A' (hex 0x41)。
       % echo "010000: 41" | xxd -r > file

       作成したファイルをオートスキップを使って 16 進ダンプする。
       % xxd -a -c 12 file
       0000000: 0000 0000 0000 0000 0000 0000  ............
       *
       000fffc: 0000 0000 40                   ....A

       一文字の 'A' からなる 1 バイトのファイルを作成する。
        '-r -s' の後に指定した数値がファイル中の行番号に加算され、結果、余計なバイトが飛ばされる。
       % echo "010000: 41" | xxd -r -s -0x10000 > file

       vim(1) の中から xxd をフィルタとして実行し、 マークされた `a' から `z' までの領域を 16 進ダンプする。
       :'a,'z!xxd

       vim(1) の中から xxd をフィルタとして実行し、 マークされた `a' から `z' までの領域をバイナリに戻す。
       :'a,'z!xxd -r

       vim(1) の中から xxd をフィルタとして実行し、16 進ダンプされた行を元に戻す。 戻したい行にカーソルを移動して:
       !!xxd -r

       シリアル行から一文字読み込む
       % xxd -c1 < /dev/term/b &
       % stty < /dev/term/b -echo -opost -isig -icanon min 1
       % echo -n foo > /dev/term/b

返り値
       以下のエラー値が返ります:

       0      エラーなし。

       -1     操作がサポートされていない (xxd -r -i はまだ不可です)。

       1      引数の解釈に関するエラー。

       2      入力ファイルに関する問題。

       3      出力ファイルに関する問題。

       4,5    指定された位置へシークできなかった。

関連項目
       uuencode(1), uudecode(1), patch(1)

警告
       この奇妙なツールは作者が使いやすいように作られています。 自己責任で使ってください。ファイルをコピーし、それを調べ、ウィザードたれ。

バージョン
       このマニュアルは xxd バージョン 1.7 について説明しています。

著者
       (c) 1990-1997 by Juergen Weigert
       <jnweiger@informatik.uni-erlangen.de>

       私の功績として自由に配布してください。
       儲かったら教えてください。
       損しても知りません。

       マニュアルは Tony Nugent
       <tony@sctnugen.ppp.gu.edu.au> <T.Nugent@sct.gu.edu.au>
       によって書かれ、 Bram Moolenaar が少し変更を加え、 Juergen Weigert が編集しました。

Manual page for xxd                                                                             August 1996                                                                                          XXD(1)
