Shellish(3pm)                                                                       User Contributed Perl Documentation                                                                       Shellish(3pm)

NAME
       Regexp::Shellish - Shell-like regular expressions

SYNOPSIS
          use Regexp::Shellish qw( :all ) ;

          $re = compile_shellish( 'a/c*d' ) ;

          ## This next one's like 'a*d' except that it'll
          ## match 'a/d'.
          $re = compile_shellish( 'a**d' ) ;

          ## And here '**' won't match 'a/d', but behaves
          ## like 'a*d', except for the possibility of high
          ## cpu time consumption.
          $re = compile_shellish( 'a**d', { star_star => 0 } ) ;

          ## The next two result in identical $re1 and $re2.
          ## The second is a noop so that Regexp references can
          ## be easily accomodated.
          $re1 = compile_shellish( 'a{b,c}d' ) ;
          $re2 = compile_shellish( qr/\A(?:a(?:b|c)d)\Z/ ) ;

          @matches = shellish_glob( $re, @possibilities ) ;

DESCRIPTION
       Provides shell-like regular expressions.  The wildcards provided are "?", "*" and "**", where "**" is like "*" but matches "/".  See "compile_shellish" for details.

       Case sensitivity and constructs like <**>, "(a*b)", and "{a,b,c}" can be disabled.

       compile_shellish
           Compiles a string containing a 'shellish' regular expression, returning a Regexp reference.  Regexp references passed in are passed through unmolested.

           Here are the transformation rules from shellish expression terms to perl regular expression terms:

              Shellish  Perl RE
              ========  =======
              *         [^/]*
              ?         .
              **        .*               ## unless { star_star   => 0 }
              ...       .*               ## unless { dot_dot_dot => 0 }

              (         (                ## unless { parens => 0 }
              )         )                ## unless { parens => 0 }

              {a,b,c}   (?:a|b|c)        ## unless { braces => 0 }

              \a        a                ## These are de-escaped and
              \*        \*               ## passed to quotemeta()

           The wildcards treat newlines as normal characters.

           Parens group in to $1..$n, since they are passed through unmolested (unless option parens => 0 is passed).  This is useless when using glob_shellish(), though.

           The final parameter can be a hash reference containing options:

              compile_shellish(
                 '**',
                 {
                    anchors        => 0,   ## Doesn't put ^ and $ around the
                                           ## resulting regexp
                    case_sensitive => 0,   ## Make case insensitive
                    dot_dot_dot    => 0,   ## '...' is now just three '.' chars
                    star_star      => 0,   ## '**' is now two '*' wildcards
                    parens         => 0,   ## '(', ')' are now regular chars
                    braces         => 0,   ## '{', '}' are now regular chars
                 }
              ) ;

           No option affects Regexps passed through.

       shellish_glob
           Pass a regular expression and a list of possible values, get back a list of matching values.

              my @matches = shellish_glob( '*/*', @possibilities ) ;
              my @matches = shellish_glob( '*/*', @possibilities, \%options ) ;

AUTHOR
       Barrie Slaymaker <barries@slaysys.com>

perl v5.34.0                                                                                     2022-10-13                                                                                   Shellish(3pm)
