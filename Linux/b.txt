b(1)                        General Commands Manual                       b(1)

NAME
       b - build system driver

SYNOPSIS
       b --help
       b --version
       b [options] [variables] [buildspec]

       buildspec = meta-operation(operation(target...[,parameters])...)...

DESCRIPTION
       The build2 build system driver executes a set of meta-operations on op‐
       erations on targets according to the build specification, or  buildspec
       for short.  This process can be controlled by specifying driver options
       and build system variables.

       Note that options, variables, and buildspec fragments can be  specified
       in  any order. To avoid treating an argument that starts with '-' as an
       option, add the '--' separator. To avoid treating an argument that con‐
       tains '=' as a variable, add the second '--' separator.

       All  components  in  the buildspec can be omitted. If meta-operation is
       omitted, then it defaults to perform. If operation is omitted, then  it
       defaults  to the default operation for this meta-operation. For perform
       it is update. Finally, if target is omitted, then it  defaults  to  the
       current  working  directory. A meta-operation on operation is called an
       action. Some operations and meta-operations may take additional parame‐
       ters. For example:

       $ b                       # perform(update(./))
       $ b foo/                  # perform(update(foo/))
       $ b foo/ bar/             # perform(update(foo/ bar/))
       $ b update                # perform(update(./))
       $ b 'clean(../)'          # perform(clean(../))
       $ b perform               # perform(update(./))
       $ b configure             # configure(?(./))
       $ b 'configure(../)'      # configure(?(../))
       $ b clean update          # perform(clean(./) update(./))
       $ b configure update      # configure(?(./)) perform(update(./))
       $ b 'create(conf/, cxx)'  # create(?(conf/), cxx)

       Notice the question mark used to show the (imaginary) default operation
       for the configure meta-operation. For configure the  default  operation
       is  "all operations". That is, it will configure all the operations for
       the specified target.

       You can also "generate" multiple operations for the same  set  of  tar‐
       gets.  Compare:

       $ b 'clean(foo/ bar/)' 'update(foo/ bar/)'
       $ b '{clean update}(foo/ bar/)'

       Some more useful buildspec examples:

       $ b '{clean update}(...)'        # rebuild
       $ b '{clean update clean}(...)'  # make sure builds
       $ b '{clean test clean}(...)'    # make sure passes tests
       $ b '{clean disfigure}(...)'     # similar to distclean

       In  POSIX  shells parenthesis are special characters and must be quoted
       when used in a buildspec. Besides being  an  inconvenience  in  itself,
       quoting also inhibits path auto-completion. To help with this situation
       a shortcut syntax is available for  executing  a  single  operation  or
       meta-operation, for example:

       $ b clean: foo/ bar/                # clean(foo/ bar/)
       $ b configure: src/@out/            # configure(src/@out/)
       $ b create: conf/, cxx              # create(conf/, cxx)
       $ b configure: config.cxx=g++ src/  # configure(src/) config.cxx=g++

       To activate the shortcut syntax the first buildspec argument must start
       with an operation or meta-operation name and end with a colon  (:).  To
       transform  the shortcut syntax to the normal buildspec syntax the colon
       is replaced with the opening parenthesis ('('), the rest of the  build‐
       spec  arguments  are  treated  as is, and the final closing parenthesis
       (')') is added.

       For each target the driver expects to find buildfile either in the tar‐
       get's  directory  or,  if  the  directory  is  part  of  the  out  tree
       (out_base), in the corresponding src directory (src_base).

       For example, assuming foo/ is the source directory of a project:

       $ b foo/              # out_base=src_base=foo/
       $ b foo-out/          # out_base=foo-out/ src_base=foo/
       $ b foo-out/exe{foo}  # out_base=foo-out/ src_base=foo/

       An exception to this requirement is a directory target in  which  case,
       provided  the  directory  has subdirectories, an implied buildfile with
       the following content is assumed:

       # Implied directory buildfile: build all subdirectories.
       #
       ./: */

       In the above example, we assumed that the build system driver was  able
       to  determine  the  association  between out_base and src_base. In case
       src_base and out_base are not the same directory, this is  achieved  in
       one  of  two  ways:  the config module (which implements the configure,
       disfigure, and create meta-operations) saves this association  as  part
       of  the configuration process. If, however, the association hasn't been
       saved, then we have to specify src_base explicitly using the  following
       extended target syntax:

       src-base/@target

       Continuing with the previous example:

       $ b foo/@foo-out/exe{foo}  # out_base=foo-out/ src_base=foo/

       Normally, you would need to specify src_base explicitly only once, dur‐
       ing configuration. For example, a typical usage would be:

       $ b configure: foo/@foo-out/  # src_base is saved
       $ b foo-out/                  # no need to specify src_base
       $ b clean: foo-out/exe{foo}   # no need to specify src_base

       Besides in and out of source builds, build2 also supports configuring a
       project's source directory as forwarded to an out of source build. With
       such a forwarded configuration in place, if we  run  the  build  system
       driver  from  the  source directory, it will automatically build in the
       output directory and backlink (using symlinks or another suitable mech‐
       anism)  certain "interesting" targets (executables, documentation, etc)
       to the source directory for easy access. Continuing with  the  previous
       example:

       $ b configure: foo/@foo-out/,forward  # foo/ forwarded to foo-out/
       $ cd foo/
       $ b                                   # build in foo-out/
       $ ./foo                               # symlink to foo-out/foo

       The  ability to specify build2 variables as part of the command line is
       normally used to pass configuration values, for example:

       $ b config.cxx=clang++ config.cxx.coptions=-O3

       Similar to buildspec, POSIX shells often inhibit  path  auto-completion
       on the right hand side of a variable assignment. To help with this sit‐
       uation the assignment can be broken down into  three  separate  command
       line arguments, for example:

       $ b config.import.libhello = ../libhello/

       The build system has the following built-in and pre-defined meta-opera‐
       tions:

       perform
              Perform an operation.

       configure
              Configure all operations supported by a project and save the re‐
              sult  in  the  project's build/config.build file. Implemented by
              the config module. For example:

              $ b configure                      \
                  config.cxx=clang++             \
                  config.cxx.coptions=-O3        \
                  config.install.root=/usr/local \
                  config.install.root.sudo=sudo

              Use the forward parameter to instead configure a  source  direc‐
              tory as forwarded to an out of source build. For example:

              $ b configure: src/@out/,forward

       disfigure
              Disfigure  all  operations supported by a project and remove the
              project's build/config.build file.  Implemented  by  the  config
              module.

              Use  the  forward parameter to instead disfigure forwarding of a
              source directory to an out of source build. For example:

              $ b disfigure: src/,forward

       create
              Create and configure a configuration project. Implemented by the
              config module.

              Normally  a  build2  project  is created manually by writing the
              bootstrap.build and config.build files, adding source files, and
              so on. However, a special kind of project, which we call config‐
              uration, is often useful. Such a project doesn't have any source
              files  of  its  own.   Instead, it serves as an amalgamation for
              building other projects as part of it. Doing it this way has two
              major benefits: sub-projects automatically resolve their imports
              to other projects in the amalgamation and sub-projects  inherits
              their  configuration  from  the  amalgamation (which means if we
              want to change something, we only need to do it in one place).

              As an example, let's assume we have two C++ projects:  the  lib‐
              hello library in libhello/ and the hello executable that imports
              it in hello/. And we want to build hello with clang++.

              One way to do it would be to configure and build each project in
              its own directory, for example:

              $ b configure: libhello/@libhello-clang/ config.cxx=clang++
              $ b configure: hello/@hello-clang/ config.cxx=clang++ \
                  config.import.libhello=libhello-clang/

              The  two  drawbacks, as mentioned above, are the need to explic‐
              itly resolve the import and having to make changes  in  multiple
              places  should,  for  example, we want to switch from clang++ to
              g++.

              We can, however, achieve the same end result but without any  of
              the drawbacks using the configuration project:

              $ b create: clang/,cxx config.cxx=clang++  # Creates clang/.
              $ b configure: libhello/@clang/libhello/
              $ b configure: hello/@clang/hello/

              The targets passed to the create meta-operation must be directo‐
              ries which should either not exist or be empty.  For  each  such
              directory  create first initializes a project as described below
              and then configures it by executing  the  configure  meta-opera‐
              tion.

              The first optional parameter to create is the list of modules to
              load in root.build. By default, create appends  .config  to  the
              names  of  these  modules  so that only their configurations are
              loaded. You can override this behavior by specifying the  period
              (.)   after the module name. You can also instruct create to use
              the optional module load by prefixing the module name  with  the
              question mark (?).

              The  second optional parameter is the list of modules to load in
              bootstrap.build. If not specified, then the test, dist, and  in‐
              stall modules are loaded by default. The config module is always
              loaded first.

              Besides creating project's bootstrap.build and root.build,  cre‐
              ate also writes the root buildfile with the following contents:

              ./: {*/ -build/}

              If  used,  this  buildfile  will build all the sub-projects cur‐
              rently present in the configuration.

       dist
              Prepare a distribution containing all files necessary to perform
              all operations in a project. Implemented by the dist module.

       info
              Print basic information (name, version, source and output direc‐
              tories, etc) about one or more projects  to  STDOUT,  separating
              multiple  projects with a blank line. Each project is identified
              by its root directory target. For example:

              $ b info: libfoo/ libbar/

       The build system has the following built-in and pre-defined operations:

       update
              Update a target.

       clean
              Clean a target.

       test
              Test a target. Performs update as a  pre-operation.  Implemented
              by the test module.

       update-for-test
              Update a target for testing. This operation is equivalent to the
              update pre-operation as executed by the test operation  and  can
              be  used  to  only  update what is necessary for testing. Imple‐
              mented by the test module.

       install
              Install a target. Performs update  as  a  pre-operation.  Imple‐
              mented by the install module.

       uninstall
              Uninstall  a  target. Performs update as a pre-operation. Imple‐
              mented by the install module.

       update-for-install
              Update a target for installation. This operation  is  equivalent
              to the update pre-operation as executed by the install operation
              and can be used to only update what is necessary  for  installa‐
              tion. Implemented by the install module.

       Note  that  buildspec  and  command line variable values are treated as
       buildfile fragments and so can use quoting and escaping as well as con‐
       tain  variable  expansions and evaluation contexts. However, to be more
       usable on various platforms, escaping in these two situations  is  lim‐
       ited  to  the  effective  sequences  of \', \", \\, \$, and \( with all
       other sequences interpreted as is. Together with double-quoting this is
       sufficient to represent any value. For example:

       $ b config.install.root=c:\projects\install
       $ b "config.install.root='c:\Program Files (x86)\test\'"
       $ b 'config.cxx.poptions=-DFOO_STR="foo"'

OPTIONS
       -v     Print actual commands being executed. This options is equivalent
              to --verbose 2.

       -V     Print all underlying commands being executed.  This  options  is
              equivalent to --verbose 3.

       --quiet|-q
              Run  quietly,  only printing error messages in most contexts. In
              certain contexts (for example, while updating build system  mod‐
              ules)  this  verbosity level may be ignored. Use --silent to run
              quietly in all contexts. This option is equivalent to  --verbose
              0.

       --silent
              Run quietly, only printing error messages in all contexts.

       --verbose level
              Set  the diagnostics verbosity to level between 0 and 6. Level 0
              disables any non-error messages (but see the difference  between
              --quiet  and  --silent)  while level 6 produces lots of informa‐
              tion, with level 1 being the default. The  following  additional
              types of diagnostics are produced at each level:

              1.  High-level information messages.

              2.  Essential underlying commands being executed.

              3.  All underlying commands being executed.

              4.  Information that could be helpful to the user.

              5.  Information that could be helpful to the developer.

              6.  Even more detailed information.

       --stat Display build statistics.

       --dump phase
              Dump  the  build  system  state after the specified phase. Valid
              phase values are load (after loading buildfiles) and match  (af‐
              ter  matching  rules to targets). Repeat this option to dump the
              state after multiple phases.

       --progress
              Display build progress. If printing to a terminal  the  progress
              is  displayed  by  default  for  low verbosity levels. Use --no-
              progress to suppress.

       --no-progress
              Don't display build progress.

       --jobs|-j num
              Number of active jobs to perform in parallel. This includes both
              the  number of active threads inside the build system as well as
              the  number  of  external  commands  (compilers,  linkers,  etc)
              started but not yet finished. If this option is not specified or
              specified with the 0 value, then the number of  available  hard‐
              ware threads is used.

       --max-jobs|-J num
              Maximum  number  of  jobs (threads) to create. The default is 8x
              the number of active jobs (--jobs|j) on 32-bit architectures and
              32x on 64-bit. See the build system scheduler implementation for
              details.

       --queue-depth|-Q num
              The queue depth as a multiplier over the number of active  jobs.
              Normally we want a deeper queue if the jobs take long (for exam‐
              ple, compilation) and shorter if they are  quick  (for  example,
              simple  tests). The default is 4. See the build system scheduler
              implementation for details.

       --max-stack num
              The maximum stack size in KBytes  to  allow  for  newly  created
              threads. For pthreads-based systems the driver queries the stack
              size of the main thread and uses the same size for creating  ad‐
              ditional threads. This allows adjusting the stack size using fa‐
              miliar mechanisms, such  as  ulimit.   Sometimes,  however,  the
              stack  size  of  the main thread is excessively large.  As a re‐
              sult, the driver checks if it is greater than a predefined limit
              (64MB  on 64-bit systems and 32MB on 32-bit ones) and caps it to
              a more sensible value (8MB) if that's the case. This option  al‐
              lows  you to override this check with the special zero value in‐
              dicating that the main thread stack size should be used as is.

       --serial-stop|-s
              Run serially and stop at the first error. This mode is useful to
              investigate  build  failures that are caused by build system er‐
              rors rather than compilation errors. Note that if you don't want
              to  keep  going but still want parallel execution, add --jobs|-j
              (for example -j 0 for default concurrency).

       --dry-run|-n
              Print commands without actually executing them. Note  that  com‐
              mands  that  are required to create an accurate build state will
              still be executed and the extracted auxiliary dependency  infor‐
              mation  saved.  In other words, this is not the "don't touch the
              filesystem" mode but rather "do minimum amount of work  to  show
              what needs to be done". Note also that only the perform meta-op‐
              eration supports this mode.

       --match-only
              Match the rules but do not execute the operation. This  mode  is
              primarily useful for profiling.

       --structured-result
              Write  the  result  of  execution  in a structured form. In this
              mode, instead of printing to STDERR diagnostics  messages  about
              the  outcome  of executing actions on targets, the driver writes
              to STDOUT a structured  result  description  one  line  per  the
              buildspec  action/target  pair. Each line has the following for‐
              mat:

              state meta-operation operation target

              Where state can be one of unchanged, changed, or failed. If  the
              action  is  a pre or post operation, then the outer operation is
              specified in parenthesis. For example:

              unchanged perform update(test) /tmp/dir{hello/}
              changed perform test /tmp/dir{hello/}

              Note that only the perform meta-operation  supports  the  struc‐
              tured result output.

       --mtime-check
              Perform  file  modification time sanity checks. These checks can
              be helpful in diagnosing spurious rebuilds and  are  enabled  by
              default  for  the  staged version of the build system. Use --no-
              mtime-check to disable.

       --no-mtime-check
              Don't perform file modification time sanity checks.

       --no-column
              Don't print column numbers in diagnostics.

       --no-line
              Don't print line and column numbers in diagnostics.

       --buildfile path
              The alternative file to read build information from. The default
              is  buildfile  or  build2file,  depending on the project's build
              file/directory naming scheme. If path is  '-',  then  read  from
              STDIN. Note that this option only affects the files read as part
              of the buildspec processing. Specifically, it has no  effect  on
              the  source  and include directives. As a result, this option is
              primarily intended for testing rather than  changing  the  build
              file names in real projects.

       --config-guess path
              The  path  to  the config.guess(1) script that should be used to
              guess the host machine triplet. If this option is not specified,
              then b will fall back on to using the target it was built for as
              host.

       --config-sub path
              The path to the config.sub(1) script  that  should  be  used  to
              canonicalize  machine triplets. If this option is not specified,
              then b will use  its  built-in  canonicalization  support  which
              should be sufficient for commonly-used platforms.

       --pager path
              The  pager  program  to be used to show long text. Commonly used
              pager programs are less and more. You  can  also  specify  addi‐
              tional  options  that should be passed to the pager program with
              --pager-option. If an empty string is  specified  as  the  pager
              program, then no pager will be used. If the pager program is not
              explicitly specified, then b will try to use less. If it is  not
              available, then no pager will be used.

       --pager-option opt
              Additional option to be passed to the pager program. See --pager
              for more information on the pager program. Repeat this option to
              specify multiple pager options.

       --default-options dir
              The directory to load additional default options files from.

       --no-default-options
              Don't load default options files.

       --help Print usage information and exit.

       --version
              Print version and exit.

DEFAULT OPTIONS FILES
       Instead of having a separate config file format for tool configuration,
       the build2 toolchain uses default options files which contain the  same
       options  as  what can be specified on the command line. The default op‐
       tions files are like options files that one can specify with --options-
       file except that they are loaded by default.

       The  default options files for the build system driver are called b.op‐
       tions and are searched for in the .build2/ subdirectory of the home di‐
       rectory and in the system directory (for example, /etc/build2/) if con‐
       figured.

       Once the search is complete, the files are loaded in the reverse order,
       that  is, beginning from the system directory (if any), followed by the
       home directory, and finishing off with the  options  specified  on  the
       command  line.   In  other  words,  the  files are loaded from the more
       generic to the more specific with the command line options  having  the
       ability to override any values specified in the default options files.

       If  a  default  options  file  contains  --no-default-options, then the
       search is stopped at the directory containing this file  and  no  outer
       files are loaded. If this option is specified on the command line, then
       none of the default options files are searched for or loaded.

       An additional directory containing default options files can be  speci‐
       fied  with  --default-options. Its configuration files are loaded after
       the home directory.

       The order in which default options files are loaded is  traced  at  the
       verbosity level 3 (-V option) or higher.

EXIT STATUS
       Non-zero exit status is returned in case of an error.

ENVIRONMENT
       The  HOME environment variable is used to determine the user's home di‐
       rectory. If it is not set, then getpwuid(3) is used instead. This value
       is  used  to shorten paths printed in diagnostics by replacing the home
       directory with ~/. It is also made  available  to  buildfile's  as  the
       build.home variable.

BUGS
       Send bug reports to the users@build2.org mailing list.

COPYRIGHT
       Copyright (c) 2014-2020 the build2 authors.

       Permission  is  granted to copy, distribute and/or modify this document
       under the terms of the MIT License.

build2 0.13.0                      July 2020                              b(1)
