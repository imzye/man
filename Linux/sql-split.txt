SQL-SPLIT(1)                                                                          User Contributed Perl Documentation                                                                          SQL-SPLIT(1)

NAME
       sql-split - SQL splitting command line utility

SYNOPSIS
           sql-split [ OPTIONS ] [ FILE(S) ]
           sql-split --man

DESCRIPTION
       This program tries to split any SQL code (even containing non-standard and/or procedural extensions, at least the ones from the most popular DBMSs) into the atomic statements it is composed of.

       The given FILES are read and split one by one, and the resulting statements are printed to the standard output, separated by a customizable string (see below).  Each given file must contain only full
       SQL statements, that is, no single atomic statement can span multiple files.

       If no file is given, or if one of the file names is a "-" (dash), the SQL code is read from STDIN, so that this program can be used as a filter or even interactively.

       Consider however that this is by no means a validating parser, so that errors in SQL code will not be detected (and can even lead to incorrect splitting).

OPTIONS
   -t, --terminators
       It causes the trailing terminator tokens to be kept in the returned atomic statements (by default they are discarded instead).

       The strings currently recognized as terminators (depending on the context) are:

       •   ";" (the semicolon character);

       •   any string defined by the MySQL "DELIMITER" command;

       •   an ";" followed by an "/" (forward-slash character) on its own line;

       •   an ";" followed by an "." (dot character) on its own line, followed by an "/" on its own line;

       •   an "/" on its own line regardless of the preceding characters (only if the "slash_terminates" option, explained below, is set).

       The multi-line terminators above are always treated as a single token, that is they are discarded (or returned) as a whole (regardless of the "--no-slash-terminates" option value).

   -x, --spaces, --extra-spaces
       It causes the space characters around the statements, if any, to be kept in the returned atomic statements (by default they are trimmed instead). A mnemonic for the short version is "X-tra spaces".

   -c, --comments
       It causes the comments, if any, to be kept in the returned atomic statements (by default any comment is discarded instead).

       Both SQL and multi-line C-style comments are recognized.

   -m, --empty, --empty-statements
       It causes the empty statements to be returned (by default, they are discarded instead).

       A statement is considered empty when it contains no characters other than the terminator and space characters. A statement composed solely of comments is not recognized as empty and it is therefore
       returned, if the "--comments" option is used. Note instead that an empty statement is recognized as such regardless of the use of the "--terminators" and "--extra-spaces" options.

       A mnemonic for this option is keep "M-ty" statements.

   --no-slash, --no-slash-terminates
       By default a "/" (forward-slash) on its own line, even without a preceding semicolon, is admitted as a candidate terminator.

       When this option is used instead, a forward-slash on its own line is treated as a statement terminator only if preceded by a semicolon or by a dot and a semicolon.

       If you are dealing with Oracle's SQL, you should not use this option, since a slash (alone, without a preceding semicolon) is often used as a terminator, as it is permitted by SQL*Plus (on non-block
       statements).

       With SQL dialects other than Oracle, there is the (theoretical) possibility that a slash on its own line could pass the additional checks and be considered a terminator (while it shouldn't). This
       chance should be really tiny (it has never been observed in real world code indeed). Though negligible, this option will anyway rule out that risk.

   -s, --oss, --output-statement-separator string
       The string which will be printed between every pair of returned atomic statements. By default, it is a "--" (double dash) on its own line.

       To use special characters (such as newlines) when passing such string, please consult your shell docs (for example, in Bash the above mentioned default separator could be defined as "$'\n--\n'").

       Note that the last returned statement (for each processed file) will not be followed by such separator.

   -f, --ofs, --output-file-separator string
       The string which will be printed between the groups of statements coming from different files. By default it is the "-- >>>*<<< --" string on its own line.

       Similarly to the statement separator, the file separator will not be printed after the last file.

   -e, --error, --on-error value
       It controls the program behavior in case one of the given files is not accessible.

       It can take the following values:

       •   "stop" or 0, which causes the program to die at the first file which can not be opened, but it prints all the statements split that far (this is the default);

       •   "continue" or 1, which causes the program, when it encounters a file error, to just emit a warning (on STDERR) and continue with the next file;

       •   "no-output" or 2, which, just like "stop", causes the program to die at the first file error, but in this case it does not print any statement, not even those coming from the previous (already
           read) files; in other words, the statements are printed out only if (and after) all of the given files have been successfully read.

       The above listed string values are case-insensitive.

   -h, -?, --help
       It prints a brief help message and exits.

   --man
       It shows the full man page.

   --version
       It prints the program version and exits.

SUPPORTED DBMSs
       sql-split aims to cover the widest possible range of DBMSs, SQL dialects and extensions (even proprietary), in a (nearly) fully transparent way for the user.

       Currently it has been tested mainly on SQLite, PostgreSQL, MySQL and Oracle.

   Procedural Extensions
       Procedural code is by far the most complex to handle.

       Currently any block of code which start with "FUNCTION", "PROCEDURE", "DECLARE", "CREATE" or "CALL" is correctly recognized, as well as anonymous "BEGIN ... END" blocks, dollar quoted blocks and
       blocks delimited by a "DELIMITER"-defined custom terminator, therefore a wide range of procedural extensions should be handled correctly. However, only PL/SQL, PL/PgSQL and MySQL code has been tested
       so far.

LIMITATIONS
       None currently known (other than the lack of tests on SQL dialects different from the ones described above).

   Non-limitations
       To be split correctly, the given input must, in general, be syntactically valid SQL. For example, an unbalanced "BEGIN" or a misspelled keyword could, under certain circumstances, confuse the parser
       and make it trip over the next statement terminator, thus returning non-split statements. This should not be a problem though, as the original (invalid) SQL code would have been unusable anyway
       (remember that this is NOT a validating parser!)

SEE ALSO
       •   SQL::SplitStatement (perldoc SQL::SplitStatement)

COPYRIGHT
       Copyright 2011 Emanuele Zeppieri <emazep@cpan.org>.

LICENSE
       This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

       See <http://www.perl.com/perl/misc/Artistic.html>

NO WARRANTY
       This program comes with NO WARRANTIES of any kind. It not only may cause loss of data and hardware damaging, but it may also cause several bad diseases to nearby people, including, but not limited to,
       diarrhoea, gonorrhea and dysmenorrhea.  Don't say you haven't been warned.

perl v5.34.0                                                                                       2021-07-22                                                                                      SQL-SPLIT(1)
