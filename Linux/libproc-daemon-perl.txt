Proc::Daemon(3pm)                                                                   User Contributed Perl Documentation                                                                   Proc::Daemon(3pm)

NAME
       Proc::Daemon - Run Perl program(s) as a daemon process.

SYNOPSIS
           use Proc::Daemon;

           $daemon = Proc::Daemon->new(
               work_dir => '/my/daemon/directory',
               .....
           );

           $Kid_1_PID = $daemon->Init;

           unless ( $Kid_1_PID ) {
               # code executed only by the child ...
           }

           $Kid_2_PID = $daemon->Init( {
                           work_dir     => '/other/daemon/directory',
                           exec_command => 'perl /home/my_script.pl',
                        } );

           $pid = $daemon->Status( ... );

           $stopped = $daemon->Kill_Daemon( ... );

DESCRIPTION
       This module can be used by a Perl program to initialize itself as a daemon or to execute ("exec") a system command as daemon. You can also check the status of the daemon (alive or dead) and you
       can kill the daemon.

       A daemon is a process that runs in the background with no controlling terminal. Generally servers (like FTP, HTTP and SIP servers) run as daemon processes. Do not make the mistake to think that a
       daemon is a server. ;-)

       Proc::Daemon does the following:

       1.  The script forks a child.

       2.  The child changes the current working directory to the value of 'work_dir'.

       3.  The child clears the file creation mask.

       4.  The child becomes a session leader, which detaches the program from the controlling terminal.

       5.  The child forks another child (the final daemon process). This prevents the potential of acquiring a controlling terminal at all and detaches the daemon completely from the first parent.

       6.  The second child closes all open file descriptors (unless you define "dont_close_fh" and/or "dont_close_fd").

       7.  The second child opens STDIN, STDOUT and STDERR to the location defined in the constructor ("new").

       8.  The second child returns to the calling script, or the program defined in 'exec_command' is executed and the second child never returns.

       9.  The  first  child  transfers  the PID of the second child (daemon) to the parent. Additionally the PID of the daemon process can be written into a file if 'pid_file' is defined. Then the first
           child exits.

       10. If the parent script is looking for a return value, then the PID(s) of the child/ren will be returned. Otherwise the parent will exit.

       NOTE: Because of the second fork the daemon will not be a session-leader and therefore Signals will not be send to other members of his process group. If you need the functionality of  a  session-
       leader you may want to call POSIX::setsid() manually at your daemon.

       INFO: Since "fork" is not performed the same way on Windows systems as on Linux, this module does not work with Windows. Patches appreciated!

CONSTRUCTOR
       new ( %ARGS )
           The constructor creates a new Proc::Daemon object based on the hash %ARGS. The following keys from %ARGS are used:

           work_dir
                   Defines the path to the working directory of your daemon. Defaults to "/".

           setuid  Sets  the  real  user  identifier ($<) and the effective user identifier ($>) for the daemon process using "POSIX::setuid( ... )", in case you want to run your daemon under a different
                   user from the parent. Obviously the first user must have the rights to switch to the new user otherwise it will stay the same. It is helpful to define  the  argument  "setuid"  if  you
                   start your script at boot time by init with the superuser, but wants the daemon to run under a normal user account.

           setgid  Sets  the  real group identifier ($() and the effective group identifier ($)) for the daemon process using "POSXI::setgid( ... )", just like "setuid".  As with "setuid", the first user
                   must have the rights to switch to the new group, otherwise the group id will not be changed.

           child_STDIN
                   Defines the path to STDIN for your daemon. Defaults to "/dev/null". Default Mode is '<' (read). You can define other Mode the same way as you do using Perls "open"  in  a  two-argument
                   form.

           child_STDOUT
                   Defines  the  path  where  the  output  of your daemon will go. Defaults to "/dev/null". Default Mode is '+>' (write/read). You can define other Mode the same way as you do using Perls
                   "open" in a two-argument form.

           child_STDERR
                   Defines the path where the error output of your daemon will go. Defaults to "/dev/null". Default Mode is '+>' (write/read). You can define other Mode the same way as you do using Perls
                   "open" in a two-argument form, see example below.

           dont_close_fh
                   If you define it, it must be an arrayref with file handles you want to preserve from the parent into the child (daemon). This may be the case if you have code below a "__DATA__"  token
                   in your script or module called by "use" or "require".

                       dont_close_fh => [ 'main::DATA', 'PackageName::DATA', $my_filehandle, ... ],

                   You  can  add  any kind of file handle to the array (expression in single quotes or a scalar variable), including 'STDIN', 'STDOUT' and 'STDERR'. Logically the path settings from above
                   ("child_STDIN", ...) will be ignored in this case.

                   DISCLAIMER: Using this argument may not detach your daemon fully from the parent! Use it at your own risk.

           dont_close_fd
                   Same function and disclaimer as "dont_close_fh", but instead of file handles you write the numeric file descriptors inside the arrayref.

           pid_file
                   Defines the path to a file (owned by the parent user) where the PID of the daemon process will be stored. Defaults to "undef" (= write no file).

           file_umask
                   Defines umask for "pid_file", "child_STDIN", "child_STDOUT" and "child_STDERR" files. Defaults to 066 (other users may not modify or read the files).

           exec_command
                   Scalar or arrayref with system command(s) that will be executed by the daemon via Perls "exec PROGRAM_LIST". In this case the child will never return to the parents process!

           Example:

               my $daemon = Proc::Daemon->new(
                   work_dir     => '/working/daemon/directory',
                   child_STDOUT => '/path/to/daemon/output.file',
                   child_STDERR => '+>>debug.txt',
                   pid_file     => 'pid.txt',
                   exec_command => 'perl /home/my_script.pl',
                 # or:
                 # exec_command => [ 'perl /home/my_script.pl', 'perl /home/my_other_script.pl' ],
               );

           In this example:

           •       the PID of the daemon will be returned to $daemon in the parent process and a pid-file will be created at "/working/daemon/directory/pid.txt".

           •       STDOUT will be open with Mode '+>' (write/read) to "/path/to/daemon/output.file" and STDERR will be open to "/working/daemon/directory/debug.txt" with Mode '+>>' (write/read opened for
                   appending).

           •       the script "/home/my_script.pl" will be executed by "perl" and run as daemon. Therefore the child process will never return to this parent script.

METHODS
       Init( [ { %ARGS } ] )
           Become a daemon.

           If used for the first time after "new", you call "Init" with the object reference to start the daemon.

               $pid = $daemon->Init();

           If you want to use the object reference created by "new" for other daemons, you write "Init( { %ARGS } )". %ARGS are the same as described in "new". Notice that  you  shouldn't  call  "Init()"
           without argument in this case, or the next daemon will execute and/or write in the same files as the first daemon. To prevent this use at least an empty anonymous hash here.

               $pid = $daemon->Init( {} );
               @pid = $daemon->Init( {
                   work_dir     => '/other/daemon/directory',
                   exec_command => [ 'perl /home/my_second_script.pl', 'perl /home/my_third_script.pl' ],
               } );

           If you don't need the Proc::Daemon object reference in your script, you can also use the method without object reference:

               $pid = Proc::Daemon::Init();
               # or
               $pid = Proc::Daemon::Init( { %ARGS } );

           "Init" returns the PID (scalar) of the daemon to the parent, or the PIDs (array) of the daemons created if "exec_command" has more then one program to execute. See examples above.

           "Init" returns 0 to the child (daemon).

           If you call the "Init" method in the context without looking for a return value (void context) the parent process will "exit" here like in earlier versions:

               Proc::Daemon::Init();

       Status( [ $ARG ] )
           This function checks the status of the process (daemon). Returns the PID number (alive) or 0 (dead).

           $ARG can be a string with:

           •       "undef", in this case it tries to get the PID to check out of the object reference settings.

           •       a PID number to check.

           •       the path to a file containing the PID to check.

           •       the command line entry of the running program to check. This requires Proc::ProcessTable to be installed.

       Kill_Daemon( [ $ARG [, SIGNAL] ] )
           This function kills the Daemon process. Returns the number of processes successfully killed (which mostly is not the same as the PID number), or 0 if the process wasn't found.

           $ARG  is  the  same  as of "Status()". SIGNAL is an optional signal name or number as required by Perls "kill" function and listed out by "kill -l" on your system. Default value is 9 ('KILL' =
           non-catchable, non-ignorable kill).

       Fork
           Is like the Perl built-in "fork", but it retries to fork over 30 seconds if necessary and if possible to fork at all. It returns the child PID to the parent process and 0 to the child process.
           If the fork is unsuccessful it "warn"s and returns "undef".

OTHER METHODS
       Proc::Daemon also defines some other functions. See source code for more details:

       OpenMax( [ $NUMBER ] )
           Returns the maximum file descriptor number. If undetermined $NUMBER will be returned.

       adjust_settings
           Does some fixes/adjustments on the "new" settings together with "fix_filename".

       fix_filename( $KEYNAME )
           Prevents double use of same filename in different processes.

       get_pid( [ $STRING ] )
           Returns the wanted PID if it can be found.

       get_pid_by_proc_table_attr( $ATTR, $MATCH )
           Returns the wanted PID by looking into the process table, or "undef". Requires the "Proc::ProcessTable" module to be installed.

NOTES
       "Proc::Daemon::init" is still available for backwards capability.

       Proc::Daemon is now taint safe (assuming it is not passed any tainted parameters).

AUTHORS
       Primary-maintainer and code writer until version 0.03:

       •   Earl Hood, earl@earlhood.com, http://www.earlhood.com/

       Co-maintainer and code writer since version 0.04 until version 0.14:

       •   Detlef Pilzecker, http://search.cpan.org/~deti/, http://www.secure-sip-server.net/

       Co-maintainer and code writer since version 0.15:

       •   Pavel Denisov, http://search.cpan.org/~akreal/

CREDITS
       Initial implementation of "Proc::Daemon" derived from the following sources:

       •   "Advanced Programming in the UNIX Environment" by W. Richard Stevens.  Addison-Wesley, Copyright 1992.

       •   "UNIX Network Programming", Vol 1, by W. Richard Stevens.  Prentice-Hall PTR, Copyright 1998.

PREREQUISITES
       This module requires the "POSIX" module to be installed.

       The "Proc::ProcessTable" module is not essentially required but it can be useful if it is installed (see above).

REPOSITORY
       <https://github.com/akreal/Proc-Daemon>

SEE ALSO
       perl(1), POSIX, Proc::ProcessTable

COPYRIGHT
       This module is Copyright (C) 1997-2015 by Earl Hood, Detlef Pilzecker and Pavel Denisov.

       All Rights Reserved.

       This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.

perl v5.34.0                                                                                     2022-06-17                                                                               Proc::Daemon(3pm)
