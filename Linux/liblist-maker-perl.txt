List::Maker(3pm)                                                                    User Contributed Perl Documentation                                                                    List::Maker(3pm)

NAME
       List::Maker - Generate more sophisticated lists than just $a..$b

VERSION
       This document describes List::Maker version 0.005

SYNOPSIS
           use List::Maker;

           @list = <1..10>;                      # (1,2,3,4,5,6,7,8,9,10)

           @list = <10..1>;                      # (10,9,8,7,6,5,4,3,2,1)

           @list = <1,3,..10>;                   # (1,3,5,7,9)
           @list = <1..10 x 2>;                  # (1,3,5,7,9)

           @list = <0..10 : prime N>;            # (2,3,5,7)
           @list = <1,3,..30  : /7/>;            # (7,17,27)

           @list = < ^10 >;                      # (0,1,2,3,4,5,6,7,8,9)
           @list = < ^@array >;                  # (0..$#array)

           @words = < a list of words >;         # ('a', 'list', 'of', 'words')
           @words = < 'a list' "of words" >;     # ('a list', 'of words')

           use List::Maker 'listify';
           @list = listify '1..10';              # (1,2,3,4,5,6,7,8,9,10)

           use List::Maker 'make_list';
           @list = make_list '10..1';            # (10,9,8,7,6,5,4,3,2,1)

           use List::Maker 'ql';
           @list = ql'1..10 x 2';                # (1,3,5,7,9)

DESCRIPTION
       The List::Maker module hijacks Perl's built-in file globbing syntax ("< *.pl >" and "glob '*.pl'") and retargets it at list creation.

       The rationale is simple: most people rarely if ever glob a set of files, but they have to create lists in almost every program they write. So the list construction syntax should be easier than the
       filename expansion syntax.

       Alternatively, you can load the module with an explicit name, and it creates a subroutine of that name that builds the same kinds of lists for you (leaving the globbing mechanism unaltered).

INTERFACE
       Within any file in which the module has been explicitly loaded:

           use List::Maker;

       angle brackets no longer expand a shell pattern into a list of files.  Instead, they expand a list specification into a list of values.

       Under Perl 5.10 and later the module is also lexically scoped in its effects. That is, under Perls that support it, the change in the behaviour of angle brackets is confined to the specific
       lexical scope into which the module was imported.

       Under Perl 5.8 and earlier, loading the module changes the effect of "<...>" and "glob()" for the remainder of the current package in the current file.

       This means:

           # Code                  Under 5.8 or earlier    Under 5.10 or later
           ====================    ====================    ===================
           @list = <1..10>;        normal glob()           normal glob()
           {
               use List::Maker;    installs in file        installs in block
               @list = <1..10>;    generates list          generates list
           }
           @list = <1..10>;        generates list          normal glob()

   Numeric lists
       Numeric list specifications may take any of the following forms:

           Type           Syntax                  For example     Produces
           ==========     ===================     ===========     ===========
           Count up       <MIN..MAX>              <1..5>          (1,2,3,4,5)
           Count down     <MAX..MIN>              <5..1>          (5,4,3,2,1)
           Count to       < ^LIMIT >              < ^5 >          (0,1,2,3,4)
           Count by       <START..END x STEP>     <1..10 x 3>     (1,4,7,10)
           Count via      <START, NEXT,..END>     <1, 3,..10>     (1,3,5,7,9)

       The numbers don't have to be integers either:

           @scores = <0.5..4.5>;      # same as: (0.5, 1.5, 2.5, 3.5, 4.5)

           @steps = <1..0 x -0.2>;    # same as: (1, 0.8, 0.6, 0.4, 0.2, 0)

   Filtered numeric lists
       Any of the various styles of numeric list may also have a filter applied to it, by appending a colon, followed by a boolean expression:

           @odds   = <1..100 : \$_ % 2 != 0 >;

           @primes = <3,5..99> : is_prime(\$_) >;

           @available = < ^$max : !allocated{\$_} >

           @ends_in_7 = <1..1000 : /7$/ >

       The boolean expression is tested against each element of the list, and only those for which it is true are retained. During these tests each element is aliased to $_. However, since angle brackets
       interpolate, it's necessary to escape any explicit reference to $_ within the filtering expression, as in the first three examples above.

       That often proves to be annoying, so the module also allows the candidate value to be referred to using any single uppercase letter (which is replaced with "\$_" when the filter is applied. So the
       previous examples could also be written:

           @odds   = <1..100 : N % 2 != 0 >;

           @primes = <3,5..99> : is_prime(N) >;

           @available = < ^$max : !allocated{N} >

       or (since the specific letter is irrelevant):

           @odds   = <1..100 : X % 2 != 0 >;

           @primes = <3,5..99> : is_prime(I) >;

           @available = < ^$max : !allocated{T} >

   Randomly selecting from lists
       In addition to (or instead of) specifying a filter on a list, you can also select a specific number of the list's items at random, by appending ":pick" N to the list specification.

       For example:

           $N_random_percentages = <0..100 : pick $N >;

           @any_three_primes = <3,5..99> : is_prime(I) : pick 3>;

           $one_available = < ^$max : !allocated{T} :pick>

       The requested number of elements are picked at random, and without replacement. If the number of elements to be picked is omitted, a single element is randomly picked.

       You can also pick with replacement (which is equivalent to rolling some number of M-sided dice, with one list element on each face), by using ":roll" instead of ":pick":

           $N_nonunique_random_percentages = <0..100 : roll $N >;

           @three_nonunique_primes = <3,5..99> : is_prime(I) : roll 3>;

           $one_available = < ^$max : !allocated{T} :roll>

       If the number of elements to be rolled is omitted, a single element is randomly rolled (which is exactly the same as randomly picking it).

       Note that, because each requested "roll" is independent, it's entirely possible for one or more values to be selected repeatedly.

   String lists
       Any list specification that doesn't conform to one of the four pattern described above is taken to be a list of whitespace-separated strings, like a "qw{...}" list:

           @words = <Eat at Joe's>;     # same as: ( 'Eat', 'at', 'Joe\'s' )

       However, unlike a "qw{...}", these string lists interpolate (before listification):

           $whose = q{Joe's};

           @words = <Eat at $whose>;    # same as: ( 'Eat', 'at', 'Joe\'s' )

       More interestingly, the words in these lists can be quoted to change the default whitespace separation. For example:

           @names = <Tom Dick "Harry Potter">;
                               # same as: ( 'Tom', 'Dick', 'Harry Potter' )

       Single quotes may be also used, but this may be misleading, since the overall list still interpolates in that case:

           @names = <Tom Dick '$Harry{Potter}'>;
                               # same as: ( 'Tom', 'Dick', "$Harry{Potter}" )

       In a scalar context, any string list is converted to the standard English representation:

           $names = <Tom>;                       # 'Tom'
           $names = <Tom Dick>;                  # 'Tom and Dick'
           $names = <Tom Dick 'Harry Potter'>;   # 'Tom, Dick, and Harry Potter'

   Perl 6 repetition list operator
       List::Maker also understands the Perl 6 "xx" listification operator:

           @affirmations = <'aye' xx 5>;         # ('aye','aye','aye','aye','aye')

   Random number generation
       The module understands two syntaxes for generating random numbers. It can generate a random number within a range:

           $random = < 2r5.5 >;     # 2 <= Random number < 5.5

       It can also generate an "NdS" dice roll (i.e. the sum of rolling N dice, each with S sides):

           $roll = < 3d12 >;        # Sum of three 12-sided dice

       The dice notation cares nothing for the laws of physics or rationality and so it will even allow you to specify a non-integer number of "fractal dice", each with an non-integer numbers of sides:

           $roll = < 3.7d12.3 >;    # Sum of three-point-seven 12.3-sided dice

       In a list context, the dice notation returns the results of each of the individual die rolls (including the partial result of a "fractal" roll)

           @rolls = < 3d12 >;       # (6, 5, 12)
           @rolls = < 3.7d12.3 >;   # (6.1256, 5.9876, 12.0012, 0.3768)

       The values returned in list context will always add up to the value that would have been returned in a scalar context.

   User-defined syntax via "add_handler"
       You can add new syntax variations to the "<...>" format using the "add_handler()" function:

           add_handler($pattern => $sub_ref, $pattern => $sub_ref...);

       Each pattern is added to the list of syntax checkers and, if it matches, the corresponding subroutine is called to furnish the result of the "<...>". User-defined handlers are tested in the same
       order that they are defined, but before the standard built-in formats described above.

ALTERNATE INTERFACE
       If an argument is passed to the "use List::Maker" statement, then that argument is used as the name of a subroutine to be installed in the current package. That subroutine then expects a single
       argument, which may be used to generate any of the lists described above.

       In other words, passing an argument to "use List::Maker" creates an explicit list-making subroutine, rather than hijacking the built-in "<..>" and "glob()".

       For example:

           use List::Maker 'range';

           for (range '1..100 x 5') {
               print "$_: $result{$_}\n";
           }

           use List::Maker 'roll';

           if (roll '3d12' > 20) {
               print "The $creature hits you\n";
           }

           use List::Maker 'conjoin';

           print scalar conjoin @names;

DIAGNOSTICS
       "Sequence <%s, %s, %s...> will never reach %s"
           The specified numeric list didn't make sense. Typically, because you specified an increasing list with a negative step size (or vice versa).

CONFIGURATION AND ENVIRONMENT
       List::Maker requires no configuration files or environment variables.

DEPENDENCIES
       None.

INCOMPATIBILITIES
       Using  this  module  normally  prevents  you  from  using  the  built-in  behaviours of "<...>" or "glob()" in any files that directly "use" the module (though files that don't load the module are
       unaffected). In files that use the module, you would need to use the "File::Glob" module directly:

           use File::Glob;

           my @files = bsd_glob("*.pl");

       Alternatively, export the list maker by name (see "ALTERNATE INTERFACE").

BUGS AND LIMITATIONS
       The lists generated are not lazy. So this:

           for (<1..10000000>) {
               ...
           }

       will be vastly slower than:

           for (1..10000000) {
               ...
           }

       Please report any bugs or feature requests to "bug-list-maker@rt.cpan.org", or through the web interface at <http://rt.cpan.org>.

AUTHOR
       Damian Conway  "<DCONWAY@CPAN.org>"

LICENCE AND COPYRIGHT
       Copyright (c) 2005, Damian Conway "<DCONWAY@CPAN.org>". All rights reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See perlartistic.

DISCLAIMER OF WARRANTY
       BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING  THE  COPYRIGHT  HOLDERS
       AND/OR  OTHER  PARTIES  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
       FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU  ASSUME  THE  COST  OF  ALL  NECESSARY  SERVICING,
       REPAIR, OR CORRECTION.

       IN  NO  EVENT  UNLESS  REQUIRED  BY  APPLICABLE  LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE
       LICENCE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT  NOT  LIMITED  TO
       LOSS  OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS
       BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

perl v5.36.0                                                                                     2022-11-19                                                                                List::Maker(3pm)
