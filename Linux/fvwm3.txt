FVWM3STYLES(1)                                                                                                                                                                               FVWM3STYLES(1)

NAME
       fvwm3styles - fvwm styles

CONTROLLING WINDOW STYLES
       For readability, the commands in this section are not sorted alphabetically. The description of the Style command can be found at the end of this section.

       The commands: FocusStyle, Style, and WindowStyle can accept optional conditional components to match some properties of a window.

       For example:

           Style (Name mc) Sticky

       Will make a window whose name matched 'mc' Sticky.

           Style (Name mc, Class XTerm) StartIconic

       This example will start an xterm(1) window whose WM_CLASS matches 'XTerm' and name is 'mc'.

       A valid list of properties to test against are:

       •   Resource

       •   Class

       •   Name

       •   Icon

       •   WindowID

       The matching of the properties specified for any Style line are ANDed together, and for styles to be applied, all properties must match.

       NOTE: To destroy a style line with window properties, DestroyStyle should be used. For example:

           DestroyStyle (Name mc, Class XTerm)

       It is not required to specify the style arguments when destroying a style, only the property components are required.

       Existing Style lines in the form:

           Style Application* Sticky, StartIconic

       are still supported, and their behaviour remains unchanged.

                                                                               ∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼

       FocusStyle stylename options
           works exactly like the Style command, but accepts only the focus policy related styles beginning with "FP". The prefix can be removed, but at the cost of a little bit of time. FocusStyle is
           meant to make the configuration file more readable. Example:

               FocusStyle * EnterToFocus, !LeaveToUnfocus

           is equivalent to

               Style * FPEnterToFocus, !FPLeaveToUnfocus

       DestroyStyle style
           deletes the style named style. The changes take effect immediately. Note that style is not a wild-carded search string, but rather a case-sensitive string that should exactly match the
           original Style command.

           Destroying style "*" can be done, but isn’t really to be recommended. For example:

               DestroyStyle Application*

           This removes all settings for the style named "Application*", NOT all styles starting with "Application".

       DestroyWindowStyle
           deletes the styles set by the WindowStyle command on the selected window. The changes take effect immediately.

       UpdateStyles
           All pending updates of all windows' styles and looks are applied immediately. E.g. if Style, WindowStyle or TitleStyle commands were issued inside a fvwm function.

       Style stylename options ...
           The Style command is used to set attributes of a window to values other than the default or to set the window manager default styles.

           stylename can be a window’s name, class, visible name, or resource string. It may contain the wildcards '*' and '?', which are matched in the usual Unix filename manner. Multiple style options
           in a single Style command are read from left to right as if they were issued one after each other in separate commands. A given style always overrides all conflicting styles that have been
           issued earlier (or further left on the same style line).

           Note: windows that have no name (WM_NAME) are given a name of "Untitled", and windows that do not have a class (WM_CLASS, res_class) are given class "NoClass" and those that do not have a
           resource (WM_CLASS, res_name) are given resource "NoResource".

           If a window has the resource "fvwmstyle" set, the value of that resource is used in addition to any window names when selecting the style.

           options is a comma separated list containing one or more of the following keywords. Each group of style names is separated by slashes ('/'). The last style in these groups is the default.
           BorderWidth, HandleWidth, CornerLength, !Icon / Icon, MiniIcon, IconBox, IconGrid, IconFill, IconSize, !Title / Title, TitleAtBottom / TitleAtLeft / TitleAtRight / TitleAtTop,
           LeftTitleRotatedCW / LeftTitleRotatedCCW, RightTitleRotatedCCW / RightTitleRotatedCW, TopTitleRotated / TopTitleNotRotated, BottomTitleRotated / BottomTitleNotRotated, !UseTitleDecorRotation /
           UseTitleDecorRotation, StippledTitle / !StippledTitle, StippledIconTitle / !StippledIconTitle, IndexedWindowName / ExactWindowName, IndexedIconName / ExactIconName, TitleFormat /
           IconTitleFormat / !Borders / Borders, !Handles / Handles, WindowListSkip / WindowListHit, CirculateSkip / CirculateHit, CirculateSkipShaded / CirculateHitShaded, CirculateSkipIcon /
           CirculateHitIcon, Layer, StaysOnTop / StaysOnBottom / StaysPut, Sticky / Slippery, StickyAcrossPages / !StickyAcrossPages, StickyAcrossDesks / !StickyAcrossDesks, !StickyStippledTitle /
           StickyStippledTitle, !StickyStippledIconTitle / StickyStippledIconTitle, StartIconic / StartNormal,  Colorset, HilightColorset, BorderColorset, HilightBorderColorset, IconTitleColorset,
           HilightIconTitleColorset, IconBackgroundColorset, IconTitleRelief, IconBackgroundRelief, IconBackgroundPadding, Font, IconFont, StartsOnDesk / StartsOnPage / StartsAnyWhere, StartsOnScreen,
           StartShaded / !StartShaded, ManualPlacementHonorsStartsOnPage / ManualPlacementIgnoresStartsOnPage, CaptureHonorsStartsOnPage / CaptureIgnoresStartsOnPage, RecaptureHonorsStartsOnPage /
           RecaptureIgnoresStartsOnPage, StartsOnPageIncludesTransients / StartsOnPageIgnoresTransients, IconTitle / !IconTitle, MwmButtons / FvwmButtons, MwmBorder / FvwmBorder, MwmDecor / !MwmDecor,
           MwmFunctions / !MwmFunctions, HintOverride / !HintOverride, !Button / Button, ResizeHintOverride / !ResizeHintOverride, OLDecor / !OLDecor, StickyIcon / SlipperyIcon, StickyAcrossPagesIcon /
           !StickyAcrossPagesIcon, StickyAcrossDesksIcon / !StickyAcrossDesksIcon, ManualPlacement / CascadePlacement / MinOverlapPlacement / MinOverlapPercentPlacement / TileManualPlacement /
           TileCascadePlacement / PositionPlacement, MinOverlapPlacementPenalties, MinOverlapPercentPlacementPenalties, DecorateTransient / NakedTransient, DontRaiseTransient / RaiseTransient,
           DontLowerTransient / LowerTransient, DontStackTransientParent / StackTransientParent, SkipMapping / ShowMapping, ScatterWindowGroups / KeepWindowGroupsOnDesk, UseDecor, UseStyle, !UsePPosition
           / NoPPosition / UsePPosition, !UseUSPosition, NoUSPosition / UseUSPosition, !UseTransientPPosition, NoTransientPPosition / UseTransientPPosition, !UseTransientUSPosition /
           NoTransientUSPosition / UseTransientUSPosition, !UseIconPosition / NoIconPosition / UseIconPosition, Lenience / !Lenience, ClickToFocus / SloppyFocus / MouseFocus|FocusFollowsMouse /
           NeverFocus, ClickToFocusPassesClickOff / ClickToFocusPassesClick, ClickToFocusRaisesOff / ClickToFocusRaises, MouseFocusClickRaises / MouseFocusClickRaisesOff, GrabFocus / GrabFocusOff,
           GrabFocusTransientOff / GrabFocusTransient, FPFocusClickButtons, FPFocusClickModifiers, !FPSortWindowlistByFocus / FPSortWindowlistByFocus, FPClickRaisesFocused / !FPClickRaisesFocused,
           FPClickDecorRaisesFocused / !FPClickDecorRaisesFocused, FPClickIconRaisesFocused / !FPClickIconRaisesFocused, !FPClickRaisesUnfocused / FPClickRaisesUnfocused, FPClickDecorRaisesUnfocused /
           !FPClickDecorRaisesUnfocused, FPClickIconRaisesUnfocused / !FPClickIconRaisesUnfocused, FPClickToFocus / !FPClickToFocus, FPClickDecorToFocus / !FPClickDecorToFocus, FPClickIconToFocus /
           !FPClickIconToFocus, !FPEnterToFocus / FPEnterToFocus, !FPLeaveToUnfocus / FPLeaveToUnfocus, !FPFocusByProgram / FPFocusByProgram, !FPFocusByFunction / FPFocusByFunction,
           FPFocusByFunctionWarpPointer / !FPFocusByFunctionWarpPointer, FPLenient / !FPLenient, !FPPassFocusClick / FPPassFocusClick, !FPPassRaiseClick / FPPassRaiseClick, FPIgnoreFocusClickMotion /
           !FPIgnoreFocusClickMotion, FPIgnoreRaiseClickMotion / !FPIgnoreRaiseClickMotion, !FPAllowFocusClickFunction / FPAllowFocusClickFunction, !FPAllowRaiseClickFunction / FPAllowRaiseClickFunction,
           FPGrabFocus / !FPGrabFocus, !FPGrabFocusTransient / FPGrabFocusTransient, FPOverrideGrabFocus / !FPOverrideGrabFocus, FPReleaseFocus / !FPReleaseFocus, !FPReleaseFocusTransient /
           FPReleaseFocusTransient, FPOverrideReleaseFocus / !FPOverrideReleaseFocus, StartsLowered / StartsRaised, IgnoreRestack / AllowRestack, FixedPosition / VariablePosition, FixedUSPosition /
           VariableUSPosition, FixedPPosition / VariablePPosition, FixedSize / VariableSize, FixedUSSize / VariableUSSize, FixedPSize / VariablePSize, !Closable / Closable, !Iconifiable / Iconifiable,
           !Maximizable / Maximizable, !AllowMaximizeFixedSize / AllowMaximizeFixedSize, IconOverride / NoIconOverride / NoActiveIconOverride, DepressableBorder / FirmBorder, MinWindowSize,
           MaxWindowSize, IconifyWindowGroups / IconifyWindowGroupsOff, ResizeOpaque / ResizeOutline, BackingStore / BackingStoreOff / BackingStoreWindowDefault, Opacity / ParentalRelativity, SaveUnder /
           SaveUnderOff, WindowShadeShrinks / WindowShadeScrolls, WindowShadeSteps, WindowShadeAlwaysLazy / WindowShadeBusy / WindowShadeLazy, EWMHDonateIcon / EWMHDontDonateIcon, EWMHDonateMiniIcon /
           EWMHDontDonateMiniIcon, EWMHMiniIconOverride / EWMHNoMiniIconOverride, EWMHUseStackingOrderHints / EWMHIgnoreStackingOrderHints, EWMHIgnoreStateHints / EWMHUseStateHints, EWMHIgnoreStrutHints
           / EWMHUseStrutHints, EWMHIgnoreWindowType / !EWMHIgnoreWindowType, EWMHMaximizeIgnoreWorkingArea / EWMHMaximizeUseWorkingArea / EWMHMaximizeUseDynamicWorkingArea,
           EWMHPlacementIgnoreWorkingArea / EWMHPlacementUseWorkingArea / EWMHPlacementUseDynamicWorkingArea, MoveByProgramMethod, Unmanaged, State, SnapGrid, SnapAttraction, EdgeMoveDelay,
           EdgeResizeDelay. EdgeMoveResistance, InitialMapCommand

           In the above list some options are listed as style-option/opposite-style-option. The opposite-style-option for entries that have them describes the fvwm default behavior and can be used if you
           want to change the fvwm default behavior.

           Focus policy
               ClickToFocus instructs fvwm to give the focus to a window when it is clicked in. The default MouseFocus (or its alias FocusFollowsMouse) tells fvwm to give a window the focus as soon as
               the pointer enters the window, and take it away when the pointer leaves the window. SloppyFocus is similar, but doesn’t give up the focus if the pointer leaves the window to pass over the
               root window or a ClickToFocus window (unless you click on it, that is), which makes it possible to move the mouse out of the way without losing focus. A window with the style NeverFocus
               never receives the focus. This is useful for modules like FvwmButtons. for example. Note: Once any of the "FP..." styles has been used, the defaults that come with the basic focus policies
               are not restored when the latter are used again. For example, once !FPGrabFocus has been used, using ClickToFocus does not restore FPGrabFocus.

               The focus model can be augmented with several additional options. In fvwm-2.5.3 and later, there are a large number of advanced options beginning with "FP" or "!FP". These options shall
               replace the older options one day and are described first. Using any of these new options may limit compatibility with older releases. In general, options beginning with "FP" turn a
               feature on, while those beginning with "!FP" turn it off.

           Focusing the window
               With FPEnterToFocus, when the pointer enters a window it receives focus.

               With FPLeaveToUnfocus a window loses focus when the pointer leaves it.

               With FPClickToFocus, FPClickDecorToFocus or FPClickIconToFocus, a window receives focus when the inside of the window or the decorations or its icon is clicked.

               The FPFocusByProgram style allows windows to take the focus themselves.

               The !FPFocusByFunction style forbids that a window receives the focus via the Focus and FlipFocus commands.

               The FPFocusByFunctionWarpPointer style controls if the pointer is warped to a selected window when the Focus command is used.

               FPLenient allows focus on windows that do not want it, like FvwmPager or xclock.

               The FPFocusClickButtons style takes a list of mouse buttons that can be clicked to focus or raise a window when the appropriate style is used. The default is to use the first three buttons
               ("123").

               The FPFocusClickModifiers style takes a list of modifier keys just like the Key command. The exact combination of modifier keys must be pressed for the click to focus or raise a window to
               work. The default is to use no modifiers ("N").

               With the FPPassFocusClick style, the click that was used to focus a window is passed to the application.

               With the FPAllowFocusClickFunction style, the click that was used to focus a window can also trigger a normal action that was bound to the window with the Mouse command).

               If the FPIgnoreFocusClickMotion style is used, clicking in a window and then dragging the pointer with the button held down does not count as the click to focus the window. Instead, the
               application processes these events normally. This is useful to select text in a terminal window with the mouse without raising the window. However, mouse bindings on the client window are
               not guaranteed to work anymore (see Mouse command). This style forces the initial click to be passed to the application. The distance that the pointer must be moved to trigger this is
               controlled by the MoveThreshold command.

               The FPSortWindowlistByFocus and !FPSortWindowlistByFocus styles control whether the internal window list is sorted in the order the windows were focused or in the order they were created.
               The latter is the default for ClickToFocus and SloppyFocus.

               Clicking the window to raise

               The styles FPClickRaisesFocused, FPClickDecorRaisesFocused and FPClickIconRaisesFocused allow one to raise the window when the interior or the decorations or the icon of the window is
               clicked while the window is already focused.

               The styles FPClickRaisesUnfocused, FPClickDecorRaisesUnfocused and FPClickIconRaisesUnfocused allow one to raise the window when the interior or the decorations or the icon of the window
               is clicked while the window is not yet focused.

               With the FPPassRaiseClick style, the click that was used to raise the window is passed to the application.

               With the FPAllowRaiseClickFunction style, the click that was used to raise the window can also trigger a normal action that was bound to the window with the Mouse command.

               If the FPIgnoreRaiseClickMotion style is used, clicking in a window and then dragging the pointer with the button held down does not count as the click to raise the window. Instead, the
               application processes these events normally. This is useful to select text in a terminal window with the mouse without raising the window. However, mouse bindings on the client window are
               not guaranteed to work anymore (see Mouse command. Note that this style forces that the initial click is passed to the application. The distance that the pointer must be moved to trigger
               this is controlled by the MoveThreshold command.

               Grabbing the focus when a new window is created

               New normal or transient windows with the FPGrabFocus or FPGrabFocusTransient style automatically receive the focus when they are created. FPGrabFocus is the default for windows with the
               ClickToFocus style. Note that even if these styles are disabled, the application may take the focus itself. Fvwm can not prevent this.

               The OverrideGrabFocus style instructs fvwm to never take away the focus from such a window via the GrabFocus or GrabFocusTransient styles. This can be useful if you like to have transient
               windows receive the focus immediately, for example in a web browser, but not while you are working in a terminal window or a text processor.

               The above three styles are accompanied by FPReleaseFocus, FPReleaseFocusTransient and FPOverrideReleaseFocus. These control if the focus is returned to another window when the window is
               closed. Otherwise no window or the window under the pointer receives the focus.

               ClickToFocusPassesClickOff and ClickToFocusPassesClick controls whether a mouse click to focus a window is sent to the application or not. Similarly,
               ClickToFocusRaisesOff/MouseFocusClickRaisesOff and ClickToFocusRaises/MouseFocusClickRaises control if the window is raised (but depending on the focus model).

               Note: in fvwm versions prior to 2.5.3, the "Click..." options applied only to windows with ClickToFocus while the "Mouse..." options applied to windows with a different focus policy. This
               is no longer the case.

               The old GrabFocus style is equivalent to using FPGrabFocus
               FPReleaseFocus.

               The old GrabFocusTransient style is equivalent to using FPGrabFocusTransient + FPReleaseFocusTransient.

               Lenience is equivalent to the new style FPLenient.

       Window title
           The Title and !Title options determine whether the window is decorated with a title-bar. By default all windows have a title-bar. NoTitle is equivalent to !Title but is deprecated.

           Windows with the TitleAtBottom, TitleAtLeft or TitleAtRight style have a title-bar below, to the left or to the right of the window instead of above as usual. The TitleAtTop style restores the
           default placement. Even if the window has the !Title style set, this affects the WindowShade command. Please check the WindowShade command for interactions between that command and these
           styles. Titles on the left or right side of the windows are augmented by the following styles:

           Normally, the text in titles on the left side of a window is rotated counterclockwise by 90 degrees from the normal upright position and 90 degrees clockwise for titles on the right side. It
           can also be rotated in the opposite directions with LeftTitleRotatedCW if TitleAtLeft is used, and with RightTitleRotatedCCW if TitleAtRight is used. The defaults can be restored with
           LeftTitleRotatedCCW and RightTitleRotatedCW. A normal horizontal text may be rotated as well with TopTitleRotated if TitleAtTop is used, and with BottomTitleRotated if TitleAtBottom is used.
           The defaults can be restored with TopTitleNotRotated and BottomTitleNotRotated.

           By default the title bar decoration defined using the TitleStyle command is rotated following the title text rotation (see the previous paragraph). This can be disabled by using the
           !UseTitleDecorRotation style. UseTitleDecorRotation reverts back to the default.

           With the StippledTitle style, titles are drawn with the same effect that is usually reserved for windows with the Sticky, StickyAcrossPages or StickyAcrossDesks style. !StippledTitle reverts
           back to normal titles. StippledTitleOff is equivalent to !StippledTitle but is deprecated.

           Colorset takes the colorset number as its sole argument and overrides the colors set by Color. Instead, the corresponding colors from the given colorset are used. Note that all other features
           of a colorset are not used. Use the Colorset decoration style in the TitleStyle and ButtonStyle command for that. To stop using the colorset, the colorset number is omitted.

           BorderColorset takes eight positive integers as its arguments and will apply the given colorsets to the eight individual components of the window border.

           For backwards compatibility, if one integer is supplied, that is applied to all window border components.

           The border is split up into the following definitions, and is the same order as the colorsets which will be applied to the border.

               BorderColorset North, North East, East, South East, South, South West, West, North West

           North, East, South, and West refer to the top, left, bottom, and right sides of the window border.

           NE, SE, SW, and NW refer to the window handles.

           NOTE: due to how window handles are rendered, there is no way to make one complete edge of a window the same color as defined by either North, South, East, or West.

           The HilightBorderColorset style option works the same as BorderColorset but is used when the window has the focus.

           !IconTitle disables displaying icon labels while the opposite style IconTitle enables icon labels (default behaviour). NoIconTitle is equivalent to !IconTitle but is deprecated.

           IconTitleColorset takes the colorset number as its sole argument and overrides the colors set by Color or Colorset. To stop using this colorset, the argument is omitted.

           HilightIconTitleColorset takes the colorset number as its sole argument and overrides the colors set by HilightColorset. To stop using this colorset, the argument is omitted.

           IconBackgroundColorset takes the colorset number as its sole argument and uses it to set a background for the icon picture. By default the icon picture is not drawn onto a background image. To
           restore the default, the argument is omitted.

           IconTitleRelief takes one numeric argument that may be between -50 and +50 pixels and defines the thickness of the 3D relief drawn around the icon title. With negative values the icon title
           gets a pressed in look. The default is 2 and it is restored if the argument is omitted.

           IconBackgroundRelief takes one numeric argument that may be between -50 and +50 pixels and defines the thickness of the 3D relief drawn around the icon picture background (if any). With
           negative values the icon background gets a pressed in look. The default is 2 and it is restored if the argument is omitted.

           IconBackgroundPadding takes one numeric argument that may be between 0 and 50 pixels and defines the amount of free space between the relief of the icon background picture (if any) and the
           icon picture. The default is 2 and it is restored if the argument is omitted.

           The Font and IconFont options take the name of a font as their sole argument. This font is used in the window or icon title. By default the font given in the DefaultFont command is used. To
           revert back to the default, use the style without the name argument.

           The deprecated IndexedWindowName style causes fvwm to use window titles in the form

               name (i)

           where name is the exact window name and i is an integer which represents the i th window with name as window name. This has been replaced with:

               TitleFormat %n (%t)

           ExactWindowName restores the default which is to use the exact window name. Deprecated in favour of:

               TitleFormat %n

           IndexedIconName and ExactIconName work the same as IndexedWindowName and ExactWindowName styles but for the icon titles. Both are deprecated in favour of:

               IconTitleFormat %n (%t)
               IconTitleFormat %n

           TitleFormat describes what the visible name of a window should look like, with the following placeholders being valid:

           %n
               Insert the window’s name.

           %i
               Insert the window’s icon name.

           %c
               Insert the window’s class name.

           %r
               Insert the window’s resource name.

           %t
               Insert the window count.

           %I
               Insert the window ID.

           %%
               Insert a literal '%' character.

               Any amount of whitespace may be used, along with other characters to make up the string — but a valid TitleFormat string must contain at least one of the placeholders mentioned. No quote
               stripping is performed on the string, so for example the following is printed verbatim:

                   TitleFormat " %n " -> [%t] ->      [%c]

               Note: It’s perfectly possible to use a TitleFormat which can result in wiping out the visible title altogether. For example:

                   TitleFormat %z

               Simply because the placeholder '%z' isn’t supported. This is not a bug but rather a facet of how the formatting parser works.

           IconTitleFormat describes what the visible icon name of a window should look like, with the options being the same as TitleFormat.

       Title buttons
           Button and !Button take a numeric argument which is the number of the title-bar button which is to be shown or omitted. NoButton is equivalent to !Button but is deprecated.

           MwmButtons makes the Maximize button look pressed-in when the window is maximized. See the MwmDecorMax flag in ButtonStyle for more information. To switch this style off again, use the
           FvwmButtons style.

       Borders
           !Borders suppresses the window border (but not the title) completely. The Borders style enables them again. Without borders, all other styles affecting window borders are meaningless.

           MwmBorder makes the 3D bevel more closely match Mwm’s. FvwmBorder turns off the previous option.

           With the !Handles style, the window does not get the handles in the window corners that are commonly used to resize it. With !Handles, the width from the BorderWidth style is used. By default,
           or if Handles is specified, the width from the HandleWidth style is used. NoHandles is equivalent to !Handles but is deprecated.

           HandleWidth takes a numeric argument which is the width of the border to place the window if it does have resize-handles. Using HandleWidth without an argument restores the default.

           CornerLength takes a single numeric argument which is the length, in pixels, of the corner handles. The default is the title height. Using CornerLength without an argument restores the
           default.

           BorderWidth takes a numeric argument which is the width of the border to place the window if it does not have resize-handles. It is used only if the !Handles style is specified too. Using
           BorderWidth without an argument restores the default.

           DepressableBorder makes the border parts of the window decoration look sunken in when a button is pressed over them. This can be disabled again with the FirmBorder style.

       Icons, shading, maximizing, movement, resizing
           Icon takes an (optional) unquoted string argument which is the icon bitmap or pixmap to use. Icons specified this way override pixmap icons, but not icon windows or the ewmh icon, provided by
           the client in the application (with the WM_HINTS property or with the ewmh _NET_WM_ICON property). The IconOverride style changes the behavior to override any client-provided icons; the
           NoIconOverride style changes the behavior to not override any client-provided icons; the default overriding behavior can be activated with the NoActiveIconOverride style. With this style, fvwm
           uses application provided icons if the icon is changed but uses the icon provided in the configuration file until then.

           There is one exception to these rules, namely

               Style * Icon unknown.xpm

           doesn’t force the unknown.xpm icon on every window, it just sets the default icon like the DefaultIcon command. If you really want all windows to have the same icon, you can use

               Style ** Icon unknown.xpm

           If the NoIcon attribute is set then the specified window simply disappears when it is iconified. The window can be recovered through the window-list. If Icon is set without an argument then
           the NoIcon attribute is cleared but no icon is specified. An example which allows only the FvwmPager module icon to exist:

               Style * NoIcon
               Style FvwmPager Icon

           IconBox takes no argument, four numeric arguments (plus optionally a screen specification), an X11 geometry string or the string "none":

               IconBox [screen scr-spec] l t r b

           or

               IconBox geometry

           Where l is the left coordinate, t is the top, r is right and b is bottom. Negative coordinates indicate distance from the right or bottom of the screen. If the first argument is the word
           screen, the scr-spec argument specifies the RandR screen on which the IconBox is defined ´or the additional 'w' for the screen where the window center is located. This is only useful with
           multiple screens. The "l t r b" specification is more flexible than an X11 geometry. For example:

               IconBox -80 240 -1 -1

           defines a box that is 80 pixels wide from the right edge, 240 pixels down from the top, and continues to the bottom of the screen.

           Perhaps it is easier to use is an X11 geometry string though:

               IconBox 1000x70-1-1

           places an 1000 by 70 pixel icon box on the bottom of the screen starting in the lower right hand corner of the screen. One way to figure out a geometry like this is to use a window that
           resizes in pixel increments, for example, xv. Then resize and place the xv window where you want the iconbox. Then use FvwmIdent to read the windows geometry. The icon box is a region of the
           screen where fvwm attempts to put icons for any matching window, as long as they do not overlap other icons. Multiple icon boxes can be defined as overflow areas. When the first icon box is
           full, the second one is filled. All the icon boxes for one style must be defined in one Style command. For example:

               Style * IconBox -80 240 -1 -1, \
                 IconBox 1000x70-1-1

           A Style command with the IconBox option replaces any icon box defined previously by another Style command for the same style. That’s why the backslash in the previous example is required.

           Note: The geometry for the icon box command takes the additional screen specifier "@w" in case RandR is used. This designates the screen where the window center is located. The additional
           screen specifier is not allowed anywhere else.

           If you never define an icon box, or you fill all the icon boxes, fvwm has a default icon box that covers the screen, it fills top to bottom, then left to right, and has an 80x80 pixel grid. To
           disable all but the default icon box you can use IconBox without arguments in a separate Style command. To disable all icon boxes including the default icon box, the argument "none" can be
           specified.

           Hint: You can auto arrange your icons in the icon box with a simple fvwm function. Put the "DeiconifyAndRearrange" function below in your configuration file:

               AddToFunc DeiconifyAndRearrange
                + C Iconify off
                + C All (CurrentPage, Iconic) PlaceAgain Icon

           And then replace all places where you call the Iconify command to de-iconify an icon with a call to the new function. For example replace

               AddToFunc IconFunc
                + C Iconify off
                + M Raise
                + M Move
                + D Iconify off

               Mouse 1 I A Iconify off

           with

               AddToFunc IconFunc
                + C DeiconifyAndRearrange
                + M Raise
                + M Move
                + D DeiconifyAndRearrange

               Mouse 1 I A DeiconifyAndRearrange

           IconGrid takes 2 numeric arguments greater than zero.

               IconGrid x y

           Icons are placed in an icon box by stepping through the icon box using the x and y values for the icon grid, looking for a free space. The default grid is 3 by 3 pixels which gives a tightly
           packed appearance. To get a more regular appearance use a grid larger than your largest icon. Use the IconSize argument to clip or stretch an icon to a maximum size. An IconGrid definition
           must follow the IconBox definition that it applies to:

               Style * IconBox -80x240-1-1, IconGrid 90 90

           IconFill takes 2 arguments.

               IconFill Bottom Right

           Icons are placed in an icon box by stepping through the icon box using these arguments to control the direction the box is filled in. By default the direction is left to right, then top to
           bottom. This would be expressed as:

               IconFill left top

           To fill an icon box in columns instead of rows, specify the vertical direction (top or bottom) first. The directions can be abbreviated or spelled out as follows: "t", "top", "b", "bot",
           "bottom", "l", "lft", "left", "r", "rgt", "right". An IconFill definition must follow the IconBox definition that it applies to:

               Style * IconBox -80x240-1-1, IconFill b r

           IconSize sets limits on the size of an icon image. Both user-provided and application-provided icon images are affected.

               IconSize [ width height [ maxwidth maxheight ] ]

           All arguments are measured in pixels. When all four arguments are passed to IconSize, width and height represent the minimum size of an icon, and maxwidth and maxheight represent the maximum
           size of an icon. Icon images that are smaller than the minimum size are padded. Icon images that are bigger than the maximum size are clipped.

           If only two arguments are passed to IconSize, width and height represent the absolute size of an icon. Icons covered by this style are padded or clipped to achieve the given size.

           If no arguments are specified, the default values are used for each dimension. This effectively places no limits on the size of an icon.

           The value of "-1" can be used in place of any of the arguments to specify the default value for that dimension.

           In addition to the numeric arguments, 1 additional argument can be "Stretched", "Adjusted", or "Shrunk".

           Note that module provided icon managers are not affected by this style.

           MiniIcon specifies a pixmap to use as the miniature icon for the window. This miniature icon can be drawn in a title-bar button (see ButtonStyle), and can be used by various fvwm modules
           (FvwmIconMan and FvwmPager). It takes the name of a pixmap as an argument.

           WindowShadeShrinks and WindowShadeScrolls control if the contents of a window that is being shaded with the WindowShade command are scrolled (default) or if they stay in place. The shrinking
           mode is a bit faster

           The WindowShadeSteps option selects the number of steps for animation when shading a window with WindowShade. It takes one number as its argument. If the number has a trailing 'p' it sets the
           number of pixels to use as the step size instead of a fixed number of steps. 0 disables the animation. This happens too if the argument is omitted or invalid.

           The WindowShade command has two modes of operation: busy and lazy shading. Busy shading can be 50% slower than lazy shading, but the latter can look strange under some conditions, for example,
           if the window borders, buttons or the title are filled with a tiled pixmap. Also, the window handles are not drawn in lazy mode and the border relief may only be drawn partially right before
           the window reaches the shaded state or tight after leaves the unshaded state. By default, fvwm uses lazy mode if there are no bad visual effects (not counting the window handles) and busy mode
           otherwise. Use the WindowShadeAlwaysLazy or WindowShadeBusy to force using the lazy or busy mode. The default setting is restored with WindowShadeLazy.

           ResizeOpaque instructs fvwm to resize the corresponding windows with their contents visible instead of using an outline. Since this causes the application to redraw frequently it can be quite
           slow and make the window flicker excessively, depending on the amount of graphics the application redraws. The ResizeOutline style (default) negates the ResizeOpaque style. Many applications
           do not like their windows being resized opaque, e.g. XEmacs, Netscape or terminals with a pixmap background. If you do not like the result, do not use the ResizeOpaque style for these windows.
           To exempt certain windows from opaque resizing you could use these lines in your configuration file:

               Style * ResizeOpaque
               Style rxvt ResizeOutline
               Style emacs ResizeOutline

           Sticky makes the window sticky, i.e. it is always visible on each page and each desk. The opposite style, Slippery reverts back to the default.

           StickyIcon makes the window sticky when it’s iconified. It de-iconifies on top the active desktop. SlipperyIcon reverts back to the default.

           StickyAcrossPages and StickyAcrossPagesIcon work like Sticky and StickyIcon, but stick the window only across pages, not desks while StickyAcrossDesks and StickyAcrossDesksIcon works the other
           way round.

           Windows that have been marked as Sticky or StickyAcrossDesks or StickyAcrossPages will have stipples drawn on the titlebar. This can be negated with the !StickyStippledTitle style. The style
           StickyStippledTitle puts back the stipples where that window has also been marked as Sticky. Note that this is the default style for Sticky windows. Sticky icons will have stipples drawn on
           the icon title. This can be disabled in the same way with the !StickyStippledIconTitle style.

           Windows with the StartIconic style are shown as icons initially. Note that some applications counteract that by deiconifying themselves. The default is to not iconify windows and can be set
           with the StartNormal style.

           StickyIcon makes the window sticky when it’s iconified. It de-iconifies on top the active desktop. SlipperyIcon reverts back to the default.

           StickyIconPage works like StickyIcon, but sticks the icon only across pages, not desks while StickyIconDesk works the other way round.

           StippledIconTitle works like StippledTitle in that it draws stipples on the titles of icons but doesn’t make the icon sticky.

           IgnoreRestack makes fvwm ignore attempts of clients to raise or lower their own windows. By default, the opposite style, AllowRestack is active.

           FixedPosition and FixedUSPosition make fvwm ignore attempts of the user to move the window. It is still possible to move the window by resizing it. To allow the user to move windows, use the
           VariablePosition or VariableUSPosition style.

           FixedSize and FixedUSSize make fvwm ignore attempts of the user to resize the window. To allow the user to resize windows, use the VariableSize or VariableUSSize style.

           FixedPPosition and FixedPSize make fvwm ignore attempts of the program to move or resize its windows. To allow this kind of actions, use the VariablePPosition or VariablePSize style. These
           styles may sometimes affect the initial placement and dimensions of new windows (depending on the application). If windows are created at strange places, try either the VariablePPosition or
           !UsePPosition styles. The FixedPSize style may screw up window dimensions for some applications. Do Not use this style in this case.

           MoveByProgramMethod affects how fvwm reacts to requests by the application to move its windows. By default, fvwm tries to detect which method to use, but it sometimes detects the wrong method.
           You may come across a window that travels across the screen by a few pixels when the application resizes it, moves to a screen border with the frame decorations off screen, that remembers its
           position for the next time it starts but appears in a slighly shifted position, or that attepmts to become full screen but has the. Try out both options, UseGravity and IgnoreGravity on the
           window (and that window only) and see if that helps. By default, fvwm uses the AutoDetect method. Once the method was detected, it is never changed again. As long as fvwm can not detect the
           proper method, it uses IgnoreGravity. To force fvwm to retry the detection, use one of the other two options first and then use AutoDetect again.

           Note: This option was introduced to alleviate a problem with the ICCCM specification. The ICCCM clearly states that the UseGravity option should be used, but traditionally applications ignored
           this rule.

           Closable enables the functions Close, Delete and Destroy to be performed on the windows. This is on by default. The opposite, !Closable, inhibits the window to be closed.

           Iconifiable enables the function Iconify to be performed on the windows. This is on by default. The opposite, !Iconifiable, inhibits the window from being iconified.

           Maximizable enables the function Maximize to be performed on the windows. This is on by default. The opposite, !Maximizable, inhibits the window from being maximized.

           AllowMaximizeFixedSize enables the function Maximize to be performed on windows that are not resizable, unless maximization has been disabled either using the style !Maximizable or through WM
           hints. This is on by default. The opposite, !AllowMaximizeFixedSize, inhibits all windows that are not resizable from being maximized.

           ResizeHintOverride instructs fvwm to ignore the program supplied minimum and maximum size as well as the resize step size (the character size in many applications). This can be handy for
           broken applications that refuse to be resized. Do not use it if you do not need it. The default (opposite) style is NoResizeOverride.

           MinWindowSize [ width [ p | c ] height [ p | c ] ] Tells fvwm the minimum width and height of a window. The values are the percentage of the total screen area. If the letter 'p' is appended to
           either of the values, the numbers are interpreted as pixels. If the letter 'c' is appended to either of the values, the numbers are in terms of the client window’s size hints, which can be
           useful for windows such as terminals to specify the number of rows or columns. This command is useful to deal with windows that freak out if their window becomes too small. If you omit the
           parameters or their values are invalid, both limits are set to 0 pixels (which is the default value).

           MaxWindowSize [ width [ p | c ] height [ p | c ] ] Tells fvwm the maximum width and height of a window. The values are the percentage of the total screen area. If the letter 'p' is appended to
           either of the values, the numbers are interpreted as pixels. If the letter 'c' is appended to either of the values, the numbers are in terms of the client window’s size hints, which can be
           useful for windows such as terminals to specify the number of rows or columns. This command is useful to force large application windows to be fully visible. Neither height nor width may be
           less than 100 pixels. If you omit the parameters or their values are invalid, both limits are set to 32767 pixels (which is the default).

           With IconifyWindowGroups all windows in the same window group are iconified and deiconified at once when any window in the group is (de)iconified. The default is IconifyWindowGroupsOff, which
           disables this behavior. Although a number of applications use the window group hint, it is rarely used in a proper way, so it is probably best to use IconifyWindowGroups only for selected
           applications.

           The option SnapAttraction affects interactive window movement: If during an interactive move the window or icon comes within proximity pixels of another the window or icon, it is moved to make
           the borders adjoin. The default of 0 means that no snapping happens. Calling this command without arguments turns off snap attraction and restores the default behavior. Please refer also to
           the SnapGrid option.

           The second argument optional and may be set to one of the five following values: With All both icons and windows snap to other windows and other icons. SameType lets windows snap only to
           windows, and icons snap only to icons. With Windows windows snap only to other windows. Similarly with Icons icons snap only to other icons. With None no snapping takes place. This option can
           be useful in conjunction with the thirs argument if you only want to snap against the screen edges. The default behavior is All.

           The third and last optional argument may be set to one of the four following values:

           •   With Screen the already snapping icons or windows, which is controlled by the second argument, will snap now also to the screen edges.

           •   ScreenWindows snaps only windows to the screen edges.

           •   ScreenIcons snaps only icons to the screen edges.

           •   ScreenAll snaps windows and icons to the screen edges.

           The option SnapGrid defines an invisible grid on the screen. During an interactive move a window or icon is positioned such that its location (top left corner) is coincident with the nearest
           grid point. The default x-grid-size and y-grid-size setting are both 1, which is effectively no grid all.

           An interactive move with both SnapGrid and SnapAttraction results in the window being moved to be adjacent to the nearest window border (if within snap proximity) or grid position. The window
           moves the shortest distance possible to satisfy both SnapGrid and SnapAttraction. Note that the x and y coordinates are not coupled. For example, a window may snap to another window on the x
           axis while snapping to a grid point on the y axis. Using this style without arguments reinstates the default settings.

           The styles EdgeMoveDelay and EdgeResizeDelay define how hard it is to change the desktop viewport by moving or resizing a window over the edge of the screen. The parameter tells how many
           milliseconds the pointer must spend on the screen edge before fvwm moves the viewport. The command EdgeScroll determines how far the viewport is scrolled. If -1 is given as the delay, page
           flipping is disabled completely. The defaults are no delay for moving (0) and no flipping for resizing (-1). Using these styles without any argument restores the default settings. Note that,
           with

               EdgeScroll 0 0

           it is still possible to move or resize windows across the edge of the current screen. See also EdgeThickness.

           The option EdgeMoveResistance makes it easier to place a window directly adjacent to a RandR screen’s edge. It takes one or two parameters. The first parameter tells how many pixels over an
           outside edge of the screen a window’s edge must move before it actually moves partially off the screen. The optional second parameter does the same as the first, but for inside edges (shared
           edge between two RandR monitors). If omitted, there is no resistance between inside edges. Note that the center of the window being moved determines the screen on which the window should be
           kept. Both values are 0 (no resistance) by default. To restore the defaults, the option EdgeMoveResistance can be used without any parameters.

           The option InitialMapCommand allows for any valid fvwm command or function to run when the window is initially mapped by fvwm. Example:

               Style MyWindow StartsOnPage 0 0, InitialMapCommand Iconify

           This would hence place the window called MyWindow on page 0 0 for the current desk, and immediately run the Iconify command on that window.

           Note that should InitialMapCommand be used as a global option for all windows, but there is a need that some windows should not have this command applied, then an action of Nop can be used on
           those windows, as in the following example:

               Style * InitialMapCommand Iconify
               Style XTeddy InitialMapCommand Nop

       Window Manager placement
           Applications can place windows at a particular spot on the screen either by window manager hints or a geometry specification. When they do neither, then the window manager steps in to find a
           place for the window. Fvwm knows several ways to deal with this situation. The default is TileCascadePlacement.

           PositionPlacement [Center|UnderMouse|move-arguments] When used without an argument, new windows are placed in the top left corner of the display. With the argument Center, all new window
           appear at the center of the screen, and with UnderMouse, windows are centered under the mouse pointer where possible. If the window is unable to fit on the screen because the pointer is at the
           edge of the screen, then the window is forced on-screen using this option. If any other move-arguments are given, they are interpreted exactly as the Move command does (with the exception that
           references to the current window position do not work as the window has not been placed yet).

           CascadePlacement automatically place new windows in a cascading fashion.

           TileCascadePlacement automatically places new windows in a smart location - a location in which they do not overlap any other windows on the screen. If no such position can be found
           CascadePlacement is used as a fall-back method.

           TileManualPlacement This is the same as TileCascadePlacement, but uses ManualPlacement as the fall-back method.

           MinOverlapPlacement automatically places new windows in a location in which the overlapping area in pixels of other windows is minimized. By default this placement policy tries to avoid
           overlapping icons and windows on higher layers. This can be configured with the MinOverlapPlacementPenalties style.

           MinOverlapPercentPlacement is similar to MinOverlapPlacement but tries to minimize the overlapped percentages of other windows instead of the overlapped area in pixels. This placement policy
           tries to avoid covering other windows completely and tries even harder not to cover small windows. This can be configured with the MinOverlapPlacementPenalties and
           MinOverlapPercentPlacementPenalties styles.

           MinOverlapPlacementPenalties takes at most 6 positive or null decimal arguments:

               normal ontop icon sticky below strut

           if trailing arguments are missing the default is used which is:

               1 5 10 1 0.05 50

           To reset this style to the default values, prefix it with a '!'. This style configures the MinOverlapPlacement and MinOverlapPercentPlacement placement policy. The normal factor affects normal
           windows, the ontop factor affects windows with a greater layer than the window being placed, the icon factor affects icons, the sticky factor affects sticky windows, the below factor affects
           windows with a smaller layer than the window being placed, the strut factor affects the complement of the EWMH working area if the window being placed has the EWMHPlacementUseWorkingArea style
           and windows with an EWMH strut hint (i.e., a "please do not cover me" hint) if the window being placed has the EWMHPlacementUseDynamicWorkingArea style. These factors represent the amount of
           area that these types of windows (or area) are counted as, when a new window is placed. For example, by default the area of ontop windows is counted 5 times as much as normal windows. So
           MinOverlapPlacement and MinOverlapPercentPlacement covers 5 times as much area of another window before it will cover an ontop window. To treat ontop windows the same as other windows, set
           this to 1. To really, really avoid putting windows under ontop windows, set this to a high value, say 1000. This style affects the window already mapped and not the window which is currently
           placed. There is one exception to this rule: in the case of the window being placed has the EWMHPlacementUseWorkingArea style the strut factor affects the placed window.

           MinOverlapPercentPlacementPenalties takes at most 4 positive or null integer arguments:

               cover_100 cover_95 cover_85 cover_75

           if trailing arguments are missing the defaults are used which are:

               12 6 4 1

           To reset this style to the default values, prefix it with a '!'. This style affects the MinOverlapPercentPlacement placement policy and is similar to the MinOverlapPlacementPenalties style.
           The cover_xx factor is used when the window being placed covers at least xx percent of the window. This factor is added to the factor determined by the MinOverlapPlacementPenalties style.

           ManualPlacement (aka active placement). The user is required to place every new window manually. The window only shows as a rubber band until a place is selected manually. The window is placed
           when a mouse button or any key except Escape is pressed. Escape aborts manual placement which places the window in the top left corner of the screen. If mouse button 2 is pressed during the
           initial placement of a window (respectively Shift and mouse button 1 in case Mwm emulation has been enabled with the Emulate command), the user is asked to resize the window too.

           It is possible to define buttons usable to place windows with the Move command and the special context 'P' for placement (see Move command). However, you can’t redefine the way to also resize
           the window other than the way it is affected by the Emulate command. The button used for placing the window can be checked with the PlacedByButton condition (see Current command).

           Example:

               Style * ManualPlacement

               *FvwmEvent: PassID
               *FvwmEvent: add_window GrowDownFunc
               AddToFunc StartFunction
               + I FvwmEvent

               AddToFunc GrowDownFunc
               + I windowid $0 (PlacedByButton 3) \
               Resize bottomright keep -0p

           Now, whenever a window is created and the user presses button 3 to finish initial placement, the window is automatically enlarged until it hits the bottom screen border.

           Old placement styles DumbPlacement / SmartPlacement / SmartPlacementOff, CleverPlacement / CleverPlacementOff, ActivePlacement / RandomPlacement, ActivePlacementsHonorsStartsOnPage /
           ActivePlacementsHonorsStartsOnPageOff are still supported but will be removed in the future. The old and new styles can be translated according to the following table:

               Style * DumbPlacement, RandomPlacement
               -->
               Style * CascadePlacement

               Style * DumbPlacement, ActivePlacement
               -->
               Style * ManualPlacement

               Style * SmartPlacement, \
               RandomPlacement, CleverPlacementOff
               -->
               Style * TileCascadePlacement

               Style * SmartPlacement, \
               ActivePlacement, CleverPlacementOff
               -->
               Style * TileManualPlacement

               Style * SmartPlacement, CleverPlacement
               -->
               Style * MinOverlapPlacement

               Style * SmartPlacement, \
               ActivePlacement, CleverPlacement
               -->
               Style * MinOverlapPercentPlacement

               Style * ActivePlacementsHonorsStartsOnPage
               -->
               Style * ManualPlacementsHonorsStartsOnPage

               Style * ActivePlacementsHonorsStartsOnPageOff
               -->
               Style * ManualPlacementsHonorsStartsOnPageOff

       Placement policy options and window stacking
           !UsePPosition instructs fvwm to ignore the program specified position (PPosition hint) when adding new windows. Using PPosition is required for some applications, but if you do not have one of
           those it’s a real headache. Many programs set PPosition to something obnoxious like 0,0 (upper left corner). Note: !UsePPosition is equivalent to the deprecated option !UsePPosition

           !UseUSPosition works like !UsePPosition but applies suppresses using the user specified position indicated by the program (USPosition hint). It is generally a bad thing to override the user’s
           choice, but some applications misuse the USPosition hint to force their windows to a certain spot on the screen without the user’s consent. Note: !UseUSPosition is equivalent to the deprecated
           option !USPosition

           NoUseTransientPPosition and UseTransientPPosition work like !UsePPosition and UsePPosition but apply only to transient windows. Note: !UseTransientPPosition is equivalent to the deprecated
           option !TransientPPosition

           NoUseIconPosition instructs fvwm to ignore the program specified icon position (IconPosition hint) when iconifying the window. Note: !UseIconPosition is equivalent to the deprecated option
           !IconPosition

           StartsOnDesk takes a numeric argument which is the desktop number on which the window should be initially placed. Note that standard Xt programs can also specify this via a resource (e.g.
           "-xrm '*Desk: 1'").

           StartsOnPage takes 1, 2, or 3 numeric arguments. If one or three arguments are given, the first (or only) argument is the desktop number. If three arguments are given, the 2nd and 3rd
           arguments identify the x,y page position on the virtual window. If two arguments are given, they specify the page position, and indicate no desk preference. If only one argument is given,
           StartsOnPage functions exactly like StartsOnDesk. For those standard Xt programs which understand this usage, the starting desk/page can also be specified via a resource (e.g., "-xrm '*page: 1
           0 2'"). StartsOnPage in conjunction with SkipMapping is a useful technique when you want to start an app on some other page and continue with what you were doing, rather than waiting for it to
           appear.

           StartsOnScreen takes one argument. It must be a valid RandR name. A new window is placed on the specified screen. The default is to place windows on the screen that contains the mouse pointer
           at the time the window is created. However, those windows which are not placed by fvwm (i.e., those with a USPosition hint from a user specified geometry) are normally placed in a position
           relative to all identified screens.

           StartsOnPageIncludesTransients causes the StartsOnPage style to be applied even for transient windows. This is not usually useful, since transients are usually pop ups that you want to appear
           in your visible viewport; but occasionally an application uses a transient for something like a startup window that needs to be coerced into place.

           ManualPlacementIgnoresStartsOnPage suppresses StartsOnPage or StartsOnDesk placement in the event that both ManualPlacement and SkipMapping are in effect when a window is created. This
           prevents you from interactively placing a window and then wondering where it disappeared to, because it got placed on a different desk or page. ManualPlacementHonorsStartsOnPage allows this to
           happen anyway. The option has no effect if SkipMapping is not in effect, because fvwm switches to the proper desk/page to perform interactive placement. The default is
           ManualPlacementIgnoresStartsOnPage; ManualPlacementHonorsStartsOnPage matches the way the old StartsOnDesk style used to handle the situation.

           CaptureHonorsStartsOnPage causes the initial capture (of an already existing window) at startup to place the window according to the StartsOnPage and StartsOnScreen desk, page and screen
           specification. CaptureIgnoresStartsOnPage causes fvwm to ignore these settings (including StartsOnDesk) on initial capture. The default is CaptureIgnoresStartsOnPage.

           RecaptureHonorsStartsOnPage causes a window to be placed according to, or revert to, the StartsOnPage and StartsOnScreen desk, page and screen specification on Restart.
           RecaptureIgnoresStartsOnPage causes fvwm to respect the current window position on Restart. The default is RecaptureIgnoresStartsOnPage.

           Layer accepts one optional argument: a non-negative integer. This is the layer the window is put in. If no argument is given, any previously set value is deleted and the default layer is
           implied.

           StaysOnTop puts the window in the top layer. This layer can be changed by the command DefaultLayers; the default is 6.

           StaysPut puts the window in the put layer. This layer can be changed by the command DefaultLayers; the default is 4.

           StaysOnBottom puts the window in the bottom layer. This layer can be changed by the command DefaultLayers; the default is 2.

           StartsLowered instructs fvwm to put the window initially at the bottom of its layer rather than the default StartsRaised.

           StartShaded tells fvwm to shade the window. An optional direction argument may be given, which can be one of "North", "South", "West", "East", "NorthWest", "NorthEast", "SouthWest",
           "SouthEast" or if no direction is given, the default is to shade north.

           SkipMapping tells fvwm not to switch to the desk the window is on when it gets mapped initially (useful with StartsOnDesk or StartsOnPage).

           KeepWindowGroupsOnDesk makes new windows that have the window group hint set appear on the same desk as the other windows of the same group. Since this behavior may be confusing, the default
           setting is ScatterWindowGroups. The window group hint is ignored when placing windows in this case.

       Transient windows
           DecorateTransient causes transient windows, which are normally left undecorated, to be given the usual fvwm decorations (title bar, buttons, etc.). Note that some pop-up windows, such as the
           xterm menus, are not managed by the window manager and still do not receive decorations. NakedTransient (the default) causes transient windows not to be given the standard decorations. You can
           only bind keys or mouse buttons to the sides and the client part of an undecorated window ('S' and ´W' contexts in bindings, see Mouse and Key commands).

           A window with the RaiseTransient style that has transient windows raises all its transients when it is raised. The DontRaiseTransient style disables this behavior. All windows are then treated
           as if they had no transients.

           A window with the LowerTransient style that has transient windows lowers all its transients when it is lowered. The DontLowerTransient style disables this behavior. All windows are then
           treated as if they had no transients.

           The StackTransientParent style augments RaiseTransient and LowerTransient styles. Raising a window with StackTransientParent style transfers the raise action to the main window if the window
           being raised is a transient and its main window has RaiseTransient style; this effect makes raise on a transient act just like raise on its main - the whole group is raised. Similar behavior
           holds for lowering a whole group of transients when the main has LowerTransient style. DontStackTransientParent turns this behavior off. (Dont)StackTransientParent has no effect if
           RaiseTransient and LowerTransient are not used.

           A reasonable emulation of Motif raise/lower on transients is possible like this

               Style * RaiseTransient
               Style * LowerTransient
               Style * StackTransientParent

       Extended Window Manager Hints styles
           To understand the used terminology in this sub section, please read the Extended Window Manager Hints section.

           EWMHDonateIcon instructs fvwm to set the application ewmh icon hint with the icon that is used by fvwm if the application does not provide such hint (and if the icon used by fvwm is not an
           icon window). EWMHDonateMiniIcon does the same thing for mini icons. This allows compliant pager, taskbar, iconbox ...etc to display the same (mini) icons as fvwm. Note that on some hardware
           (e.g., 8-bit displays) these styles can slow down window mapping and that in general only one of these styles is needed by a compliant application. EWMHDontDonateIcon and
           EWMHDontDonateMiniIcon restore the defaults which are to not set any ewmh (mini) icons hints.

           By default, if an application provides an ewmh icon hint of small size (i.e., height and width less than or equal to 22), then fvwm uses this icon as its mini icon. EWMHMiniIconOverride
           instructs fvwm to ignore ewmh icons and to use the mini icon provided by the MiniIcon style. EWMHNoMiniIconOverride restores the default.

           EWMHUseStackingOrderHints causes fvwm to use EWMH hints and respect EWMH hints which change the window layer. EWMHIgnoreStackingOrderHints causes fvwm to ignore EWMH layer hints.

           An application can ask for some reserved space on the desktop by a hint. In the EWMH terminology such a hint is called a strut and it is used to compute the working area and may be used for
           window placement and in the maximize command. EWMHIgnoreStrutHints causes fvwm to ignore such hints, as EWMHUseStrutHints, causes fvwm to use it which is the default.

           EWMHIgnoreStateHints causes fvwm to ignore initial EWMH state hints when a new window is mapped. The default EWMHUseStateHints causes fvwm to accept such hints.

           EWMHIgnoreWindowType causes fvwm to ignore EWMH window type specification. The default !EWMHIgnoreWindowType causes fvwm to style windows of specified types as such.

           EWMHMaximizeIgnoreWorkingArea causes fvwm to ignore the EWMH working area when it executes a Maximize command. With EWMHMaximizeUseWorkingArea the EWMH working area is used as with
           EWMHMaximizeUseDynamicWorkingArea the EWMH dynamic working area is used (the default).

           EWMHPlacementIgnoreWorkingArea causes fvwm to ignore the EWMH working area when it places (or places again) a window. With EWMHPlacementUseWorkingArea the EWMH working area is taken in account
           as with EWMHPlacementUseDynamicWorkingArea the EWMH dynamic working area is taken in account (the default). Note that with the MinOverlapPlacement and MinOverlapPercentPlacement placement
           policy, the way the EWMH (dynamic) working area is taken in account is configurable with the MinOverlapPlacementPenalties style.

       Miscellaneous
           The BackingStore, BackingStoreOff and BackingStoreWindowDefault determine if the X server uses backing store for the window or not. BackingStore means that the X server tries to keep the
           obscured parts of a window in memory. This is usually slower if the client runs on the same machine as the X server, but can be much faster if the connection is slow (see also SaveUnder
           below). BackingStoreOff disables backing store for the window. By default, fvwm does not enable or disable backing store itself but leaves is as the window requested it. To revert back to the
           application’s choice, use the BackingStoreWindowDefault style.

           Note: This style is useless if the X server does not allow backing store.

           SaveUnder enables the corresponding window attribute in the X server. For a window using this style, the X server tries to store the graphics below it in memory which is usually slower if the
           client runs on the same machine as the X server. SaveUnder may speed up fvwm if the connection to the X server is slow (e.g. over a modem link). To disable save under, use the SaveUnderOff
           style. This is the default. See also BackingStore above.

           Note: This style is useless if the X server does not allow save under.

           ParentalRelativity enables clients that use a background pixmap of type ParentRelative to achieve transparency. Fvwm modules that support transparent colorsets require this setting. Opacity is
           the default and should be used for all non-transparent clients for better performance.

           MwmDecor makes fvwm attempt to recognize and respect the mwm decoration hints that applications occasionally use. To switch this style off, use the NoDecorHint style.

           MwmFunctions makes fvwm attempt to recognize and respect the mwm prohibited operations hints that applications occasionally use. HintOverride makes fvwm shade out operations that mwm would
           prohibit, but it lets you perform the operation anyway. NoFuncHint allows turns off the mwm hints completely.

           OLDecor makes fvwm attempt to recognize and respect the olwm and olvwm hints that many older XView and OLIT applications use. Switch this option off with NoOLDecor.

           UseDecor This style is deprecated and will be removed in the future. There are plans to replace it with a more flexible solution in fvwm-3.0.

           UseDecor accepts one argument: the name of a decor created with AddToDecor. If no decor name is specified, the "Default" decor is used. Windows do not actually contain decors, but are always
           assigned to one. If the decor is later modified with AddToDecor, the changes are visible for all windows which are assigned to it. The decor for a window can be reassigned with ChangeDecor.

           UseStyle This style is deprecated and will be removed in the future. There are plans to replace it with a more flexible solution in fvwm-3.0.

           UseStyle takes one arg, which is the name of another style. That way you can have unrelated window names easily inherit similar traits without retyping. For example:

               Style rxvt UseStyle XTerm

           Warning: If a style is built from one or more parent styles and the parent styles are changed, the derived style is not modified. To achieve this you have to issue the UseStyle line again.

           Unmanaged Windows with the Unmanaged style option are ignored by fvwm. They are not decorated, can not be moved or resized, etc. You probably want to use Bugopts RaiseOverUnmanaged too. This
           option can be turned off with the !Unmanaged style.

           State sets the initial value of one of the 32 user defined states which are associated with each window. The state number ranges from 0 to 31 and must be given as an argument. The states have
           no meaning in fvwm, but they can be checked in conditional commands like Next with the State condition and manipulated with the State command.

               # turn on state 11 for xterms ...
               Style xterm State 11
               # ... but not for rxvts.
               Style rxvt !State 11

           Windows with the WindowListSkip styles do not appear in the menu that is created with the WindowList command or the lists shown in modules like FvwmIconMan. In the modules, the style can
           usually be ignored with an option. Please refer to the man page of the module in question for further information. To disable this feature, use the default style WindowListHit.

           The styles CirculateSkip and CirculateHit control whether the window is considered by conditional commands, for example Next, Prev or All. Windows with CirculateSkip, are never selected by
           conditional commands. However, the styles can be overridden explicitly in the condition with the CirculateHit, CirculateHitIcon or CirculateHitShaded conditions, and some conditional commands,
           e.g. Current and All, do this by default. The styles CirculateSkipIcon, CirculateHitIcon, CirculateSkipShaded and CirculateHitShaded work like CirculateSkip and CirculateHit but apply only to
           iconic or shaded windows. Note: if multiple ...Skip... options are combined, windows are only selected if they match none of the given conditions. So, with

               Style * CirculateSkipIcon, CirculateSkipShaded

           only windows that are neither iconic nor shaded are selected. Note: For historical reasons, the conditional commands understand the names of these styles as condition names. Take care not to
           confuse them.

       Examples

               # Change default fvwm behavior to no title-
               # bars on windows! Also define a default icon.

               Style *       !Title,                      \
                             Icon unknown1.xpm,           \
                             BorderWidth 4,               \
                             HandleWidth 5

               # now, window specific changes:
               Style Fvwm* !Handles, Sticky,              \
                           WindowListSkip,                \
                           BorderWidth 0
               Style FvwmPager   StaysOnTop, BorderWidth 0
               Style *lock       !Handles, Sticky,        \
                                 StaysOnTop, WindowListSkip
               Style xbiff       Sticky, WindowListSkip
               Style FvwmButtons !Handles, Sticky,        \
                                 WindowListSkip
               Style sxpm        !Handles

               # Put title-bars back on xterms only!
               Style xterm     Title, Color black/grey

               Style rxvt        Icon term.xpm
               Style xterm       Icon rterm.xpm
               Style xcalc       Icon xcalc.xpm
               Style xbiff       Icon mail1.xpm
               Style xmh         Icon mail1.xpm,         \
                                 StartsOnDesk 2
               Style xman        Icon xman.xpm
               Style matlab      Icon math4.xpm,         \
                                 StartsOnDesk 3
               Style xmag        Icon magnifying_glass2.xpm
               Style xgraph      Icon graphs.xpm
               Style FvwmButtons Icon toolbox.xpm
               Style Maker       StartsOnDesk 1
               Style signal      StartsOnDesk 3

               # Fire up Netscape on the second desk, in the
               # middle of my 3x3 virtual desktop, and do not
               # bother me with it...
               Style Netscape* SkipMapping,              \
                         StartsOnPage 1 1 1

           Note that all properties for a window are or’ed together. In the above example "FvwmPager" gets the property StaysOnTop via an exact window name match but also gets !Handles, Sticky and
           WindowListSkip by a match to "Fvwm*". It gets !Title by virtue of a match to "*". If conflicting styles are specified for a window, then the last style specified is used.

       WindowStyle options
           sets attributes (styles) on the selected window. The options are exactly the same as for the Style command.

WINDOW STYLES
       AddButtonStyle button [state] [style] [-- [!]flag ...]
           Adds a button style to button. button can be a button number, or one of "All", "Left" or "Right". state can be "ActiveUp", "ActiveDown", "InactiveUp" or "InactiveDown", or "Active" (the same
           as both "ActiveUp" and "ActiveDown") or "Inactive" (the same as both "InactiveUp" and "InactiveDown") or any of these 6 with "Toggled" prepended. The "Active" states apply to the focused
           window, the "Inactive" ones apply to all other windows. The "Up" states apply to the non pressed buttons, the "Down" ones apply to pressed buttons. The "Toggled" prefix refers to maximized,
           shaded or sticky windows that have the corresponding MwmDecor... button style set. Additionally, the following shortcuts may be used: "AllNormal", "AllToggled", "AllActive", "AllInactive",
           "AllUp", "AllDown". They are actually different masks for 4 individual states from 8 total. These are supported too: "AllActiveUp", "AllActiveDown", "AllInactiveUp", "AllInactiveDown".

           If state is omitted, then the style is added to every state. If the style and flags are enclosed in parentheses, then multiple state definitions can be placed on a single line. Flags for
           additional button styles cannot be changed after definition.

           Buttons are drawn in the order of definition, beginning with the most recent button style, followed by those added with AddButtonStyle. To clear the button style stack, change style flags, or
           for descriptions of available styles and flags, see the ButtonStyle command.

           Examples:

               **ButtonStyle** 1 Pixmap led.xpm -- Top Left
               **ButtonStyle** 1 ActiveDown HGradient 8 grey black
               **ButtonStyle All** --  UseTitleStyle
               AddButtonStyle 1 \
                       ActiveUp (Pixmap a.xpm) \
                       ActiveDown (Pixmap b.xpm -- Top)
               AddButtonStyle 1 Vector 4 50x30@1 70x70@0 30x70@0 50x30@1

           Initially for this example all button states are set to a pixmap. The second line replaces the "ActiveDown" state with a gradient (it overrides the pixmap assigned to it in the line before,
           which assigned the same style to every state). Then, the UseTitleStyle flag is set for all buttons, which causes fvwm to draw any styles set with TitleStyle before drawing the buttons.
           Finally, AddButtonStyle is used to place additional pixmaps for both "ActiveUp" and "ActiveDown" states and a vector button style is drawn on top of all states.

       AddTitleStyle [state] [style] [-- [!]flag ...]
           Adds a title style to the title-bar. state can be "ActiveUp", "ActiveDown", "InactiveUp" or "InactiveDown", or "Active" (the same as both "ActiveUp" and "ActiveDown") or "Inactive" (the same
           as both "InactiveUp" and "InactiveDown") or any of these 6 with "Toggled" prepended. If state is omitted, then the style is added to every state. If the style and flags are enclosed in
           parentheses, then multiple state definitions can be placed on a single line. This command is quite similar to the AddButtonStyle command.

           Title-bars are drawn in the order of definition, beginning with the most recent TitleStyle, followed by those added with AddTitleStyle. To clear the title style stack, change style flags, or
           for the descriptions of available styles and flags, see the TitleStyle and ButtonStyle commands.

       AddToDecor decor
           This command is deprecated and will be removed in the future. There are plans to replace it with a more flexible solution in fvwm-3.0.

           Add or divert commands to the decor named decor. A decor is a name given to the set of commands which affect button styles, title-bar styles and border styles. If decor does not exist it is
           created; otherwise the existing decor is modified.

           New decors start out exactly like the "default" decor without any style definitions. A given decor may be applied to a set of windows with the UseDecor option of the Style command. Modifying
           an existing decor affects all windows which are currently assigned to it.

           AddToDecor is similar in usage to the AddToMenu and AddToFunc commands, except that menus and functions are replaced by ButtonStyle, AddButtonStyle, TitleStyle, AddTitleStyle and BorderStyle
           commands. Decors created with AddToDecor can be manipulated with ChangeDecor, DestroyDecor, UpdateDecor and the Style option.

           The following example creates a decor "FlatDecor" and style "FlatStyle". They are distinct entities:

               AddToDecor FlatDecor
               + ButtonStyle All Active (-- flat) Inactive (-- flat)
               + TitleStyle  -- flat
               + BorderStyle -- HiddenHandles NoInset

               Style FlatStyle \
                       UseDecor FlatDecor, HandleWidth 4, Colorset 0

               Style xterm UseStyle FlatStyle

           An existing window’s decor may be reassigned with ChangeDecor. A decor can be destroyed with DestroyDecor.

               DestroyDecor FlatDecor
               AddToDecor FlatDecor ...

               Style FlatStyle UseDecor FlatDecor

           and now apply the style again:

               Style xterm UseStyle FlatStyle

       BorderStyle state [style] [-- [!]flag ...]
           Defines a border style for windows. state can be either "Active" or "Inactive". If state is omitted, then the style is set for both states. If the style and flags are enclosed in parentheses,
           then multiple state definitions can be specified per line.

           style is a subset of the available button styles, and can only be TiledPixmap (uniform pixmaps which match the bevel colors work best this way) or Colorset. If a '!' is prefixed to any flag,
           the behavior is negated. If style is not specified, then one can change flags without resetting the style.

           The HiddenHandles flag hides the corner handle dividing lines on windows with handles (this option has no effect for !Handles windows). By default, HiddenHandles is disabled.

           The NoInset flag supplements HiddenHandles. If given, the inner bevel around the window frame is not drawn. If HiddenHandles is not specified, the frame looks a little strange.

           Raised causes a raised relief pattern to be drawn (default). Sunk causes a sunken relief pattern to be drawn. Flat inhibits the relief pattern from being drawn.

           To decorate the active and inactive window borders with a textured pixmap, one might specify:

               BorderStyle Active TiledPixmap marble.xpm
               BorderStyle Inactive TiledPixmap granite.xpm
               BorderStyle Active -- HiddenHandles NoInset

           To clear the style for both states:

               BorderStyle Simple

           To clear for a single state:

               BorderStyle Active Simple

           To unset a flag for a given state:

               BorderStyle Inactive -- !NoInset

           title-bar buttons can inherit the border style with the UseBorderStyle flag (see ButtonStyle).

       ButtonState [ActiveDown bool] [Inactive bool] [InactiveDown bool]
           The ButtonState command controls which states of the window titles and title buttons are used. The default is to use all four states: "ActiveUp", "ActiveDown", "InactiveUp" and "InactiveDown"
           (see ButtonStyle and TitleStyle commands). The bool argument after the key word controls if the designated state is used ("True") or not ("False"). The bool flag is the same as other commands,
           and not limited to just "True" or "False"; "Yes" and "No" may also be used. The "ActiveUp" state cannot be deactivated. If no arguments are provided or the given arguments are invalid, the
           default is restored.

           If ActiveDown argument is "False", no different button style for the pressed down buttons used, instead "ActiveUp" state is used even when button is pressed.

           If Inactive argument is "False", focused and unfocused windows look similarly, the corresponding "Active" states are always used.

           If InactiveDown argument is "False" (only applied when Inactive is "True"), the pressed titles and title buttons in non-focused windows are drawn using "InactiveUp" or "ActiveUp" states
           depending on the values of the other key words.

       ButtonStyle button [state] [style] [-- [!]flag ...]
           Sets the button style for a title-bar button. button is the title-bar button number between 0 and 9, or one of "All", "Left", "Right", or "Reset". Button numbering is described in the Mouse
           command section. If the style and flags are enclosed in parentheses, then multiple state definitions can be specified per line.

           state refers to which button state should be set. Button states are defined as follows: "ActiveUp" and "ActiveDown" refer to the un-pressed and pressed states for buttons on active windows;
           while the "InactiveUp" and "InactiveDown" states denote buttons on inactive windows. The shortcut "Active" denotes both "ActiveUp" and "ActiveDown" states. Shortcut "Inactive" denotes both
           "InactiveUp" and "InactiveDown" states. The similar state names like just described, but with the "Toggled" prefix are used instead for title buttons which have one of the MwmDecorMax,
           MwmDecorShade, MwmDecorStick or MwmDecorLayer hints, if the window is maximized, shaded, sticky or placed on specific layer, respectively.

               AddToDecor Default
               + ButtonStyle 6                   \
                 Vector 4 50x25@1 85x75@0 15x75@0 50x25@1
               + ButtonStyle 6 ToggledActiveUp   \
                 Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
               + ButtonStyle 6 ToggledActiveDown \
                 Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
               + ButtonStyle 6 ToggledInactive   \
                 Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
               + ButtonStyle 6 - MwmDecorShade
               Mouse 0 6 N WindowShade

           Additionally, the following shortcuts may be used: "AllNormal", "AllToggled", "AllActive", "AllInactive", "AllUp", "AllDown". They are actually different masks for 4 individual states from 8
           total. These are supported too: "AllActiveUp", "AllActiveDown", "AllInactiveUp", "AllInactiveDown".

           If state is specified, that particular button state is set. If state is omitted, every state is set. Specifying a style destroys the current style (use AddButtonStyle to avoid this).

           If style is omitted, then state-dependent flags can be set for the primary button style without destroying the current style. Examples (each line should be considered independent):

               ButtonStyle Left -- flat
               ButtonStyle All ActiveUp (-- flat) Inactive (-- flat)

           The first line sets every state of the left buttons to flat, while the second sets only the "ActiveUp" and "Inactive" states of every button to flat (only flags are changed; the buttons'
           individual styles are not changed).

           If you want to reset all buttons to their defaults:

               ButtonStyle Reset

           To reset the "ActiveUp" button state of button 1 to the default:

               ButtonStyle 1 ActiveUp Default

           To reset all button states of button 1 to the default of button number 2:

               ButtonStyle 1 Default 2

           For any button, multiple state definitions can be given on one line by enclosing the style and flags in parentheses. If only one definition per line is given the parentheses can be omitted.

           flags affect the specified state. If a '!' is prefixed to any flag, its behavior is negated. The available state-dependent flags for all styles are described here (the ButtonStyle entry deals
           with state-independent flags).

           Raised causes a raised relief pattern to be drawn.

           Sunk causes a sunken relief pattern to be drawn.

           Flat inhibits the relief pattern from being drawn.

           UseTitleStyle causes the given button state to render the current title style before rendering the buttons' own styles. The Raised, Flat and Sunk TitleStyle flags are ignored since they are
           redundant in this context.

           UseBorderStyle causes the button to inherit the decorated BorderStyle options.

           Raised, Sunk and Flat are mutually exclusive, and can be specified for the initial ButtonStyle only. UseTitleStyle and UseBorderStyle are also mutually exclusive (both can be off however). The
           default is Raised with both UseBorderStyle and UseTitleStyle left unset.

           Important

           for the "ActiveDown" and "InactiveDown" states: When a button is pressed, the relief is inverted. Because of this, to obtain the raised look in "ActiveDown" or "InactiveDown" states you must
           specify the opposite of the desired relief (i.e. Sunk for "ActiveDown" or "InactiveDown"). This behavior is consistent, but may seem confusing at first. The same applies to the "Toggled"
           states.

           Button styles are classified as non-destructive, partially destructive, or fully destructive. Non-destructive styles do not affect the image. Partially destructive styles can obscure some or
           all parts of the underlying image (i.e. Pixmap). Fully destructive styles obscure the entire underlying image (i.e. Solid or one of the gradient styles). Thus, if stacking styles with
           AddButtonStyle (or AddTitleStyle for title-bars), use care in sequencing styles to minimize redraw.

           The available styles are:

           Simple, Default, Solid, Colorset, Vector, ?Gradient, Pixmap, AdjustedPixmap, ShrunkPixmap, StretchedPixmap, TiledPixmap, MiniIcon

           The description of these styles and their arguments follow:

           The Simple style does nothing. There are no arguments, and this style is an example of a non-destructive button style.

           The Default style conditionally accepts one argument: a number which specifies the default button number to load. If the style command given is ButtonStyle or AddButtonStyle, the argument is
           optional (if given, it overrides the current button). If a command other than ButtonStyle or AddButtonStyle is used, the number must be specified.

           The Solid style fills the button with a solid color. The relief border color is not affected. The color is specified as a single argument. This style is fully destructive.

           The Colorset cs [alpha] style fills the button with the Colorset cs. The optional alpha argument is a percentage between 0 and 100. It causes fvwm to merge the colorset background onto the
           button using this percentage. If the percentage is 0 the colorset background is hidden and if it is 100 the colorset background is fully applied. The default is 100. So, the destructiveness
           depends on the alpha argument.

           The Vector num X[offsetp]xY[offsetp]@C ... style draws a line pattern. Since this is a standard button style, the keyword Vector is optional, num is a number of point specifications of the
           form X[offsetp]xY[offsetp]@C ... X and Y are point coordinates inside the button, given in percents (from 0 to 100). An optional absolute offset in pixels, can be given as "+<offset>p" for a
           positive or "-<offset>p" for a negative offset.

           C specifies a line color (0 - the shadow color, 1 - the highlight color, 2 - the background color, 3 - the foreground color, 4 - only move the point, do not draw). The first point color is not
           used. You can use up to 10000 points in a line pattern. This style is partially destructive.

           The specification is a little cumbersome:

               ButtonStyle 2 Vector 4 50x30@1 70x70@0 30x70@0 50x30@1

           then the button 2 decoration uses a 4-point pattern consisting of a line from (x=50,y=30) to (70,70) in the shadow color (@0), and then to (30,70) in the shadow color, and finally to (50,30)
           in the highlight color (@1). Is that too confusing? See the fvwm web pages for some examples with screenshots.

           A more complex example of Vector:

               ButtonStyle 8 Vector 10 45x65@2 45x75@3 \
               20x75@3 20x50@3 35x50@3 35x65@1 35x25@1 \
               75x25@1 75x65@0 35x65@0
               ButtonStyle 0 Vector 10 45x65@2 45x75@0 \
               20x75@0 20x50@1 45x50@1 45x65@0 75x65@3 \
               75x25@3 35x25@3 35x47@3

           The Gradient styles denote color gradients. Fill in the question mark with any one of the defined gradient types. Please refer to the Color Gradients section for a description of the gradient
           syntax. The gradient styles are fully destructive.

           The Pixmap style displays a pixmap. A pixmap should be specified as an argument. For example, the following would give button number 2 the same pixmap for all 4 states (2 active and 2
           inactive), and button number 4 all different pixmaps.

               ButtonStyle 2 Pixmap my_pixmap.xpm
               ButtonStyle 4 \
               ActiveUp (Pixmap activeup.xpm) \
               ActiveDown (Pixmap activedown.xpm) \
               Inactive (Pixmap inactiveup.xpm)
               ButtonStyle 4 \
               InactiveDown Pixmap inactivedown.xpm

           The pixmap specification can be given as an absolute or relative pathname (see ImagePath). If the pixmap cannot be found, the button style reverts to Simple. Flags specific to the Pixmap style
           are Left, Right, Top, and Bottom. These can be used to justify the pixmap (default is centered for both directions). Pixmap transparency is used for the color "None." This style is partially
           destructive.

           The AdjustedPixmap style is similar to the Pixmap style. But the image is resized to exactly fit the button.

           The ShrunkPixmap style is similar to the Pixmap style. But if the image is bigger than the button the image is resized to fit into the button.

           The StretchedPixmap style is similar to the Pixmap style. But if the image is smaller than the button the image is resized to cover the button.

           The TiledPixmap style accepts a pixmap to be tiled as the button background. One pixmap is specified as an argument. Pixmap transparency is not used. This style is fully destructive.

           The MiniIcon style draws the window’s miniature icon in the button, which is specified with the MiniIcon option of the Style command. This button style accepts no arguments. Example:

               Style *     MiniIcon mini-bx2.xpm
               Style xterm MiniIcon mini-term.xpm
               Style Emacs MiniIcon mini-doc.xpm

               ButtonStyle 1 MiniIcon

       ButtonStyle button - [!]flag ...
           Sets state-independent flags for the specified button. State-independent flags affect button behavior. Each flag is separated by a space. If a '!' is prefixed to the flag then the behavior is
           negated. The special flag Clear clears any existing flags.

           The following flags are usually used to tell fvwm which buttons should be affected by mwm function hints (see MwmFunctions option of the Style command. This is not done automatically since you
           might have buttons bound to complex functions, for instance.

           MwmDecorMenu should be assigned to title-bar buttons which display a menu. The default assignment is the leftmost button. When a window with the MwmFunctions Style option requests not to show
           this button, it is hidden.

           MwmDecorMin should be assigned to title-bar buttons which minimize or iconify the window. The default assignment is the second button over from the rightmost button. When a window with the
           MwmFunctions Style option requests not to show this button, it is hidden.

           MwmDecorMax should be assigned to title-bar buttons which maximize the window. The default assignment is the rightmost button. When a window with the MwmFunctions Style option requests not to
           show this button, it is hidden. When the window is maximized, the vector pattern on the button looks pressed in.

           MwmDecorShade should be assigned to title-bar buttons which shade the window (see WindowShade command). When the window is shaded, the vector pattern on the button looks pressed in.

           MwmDecorStick should be assigned to title-bar buttons which make the window sticky. When the window is sticky, the vector pattern on the button looks pressed in.

           The flag MwmDecorLayer layer should be assigned to title-bar buttons which place the window in the layer numbered layer. When the window is on that specific layer, the vector pattern on the
           button looks pressed in.

       ChangeDecor decor
           This command is deprecated and will be removed in the future. There are plans to replace it with a more flexible solution in fvwm-3.0.

           Changes the decor of a window to decor. decor is "Default" or the name of a decor defined with AddToDecor. If decor is invalid, nothing occurs. If called from somewhere in a window or its
           border, then that window is affected. If called from the root window the user is allowed to select the target window. ChangeDecor only affects attributes which can be set using the AddToDecor
           command.

               ChangeDecor CustomDecor1

       DestroyDecor [recreate] decor
           This command is deprecated and will be removed in the future. There are plans to replace it with a more flexible solution in fvwm-3.0.

           Deletes the decor defined with AddToDecor, so that subsequent references to it are no longer valid. Windows using this decor revert to the "Default" decor. The optional parameter recreate
           tells fvwm not to throw away the decor completely but to throw away only its contents. If the decor is created again later, windows do not use it before the UseDecor style is applied again
           unless the decor was destroyed with the recreate option. The decor named "Default" cannot be destroyed.

               DestroyDecor CustomDecor1

       TitleStyle [justification] [Height [num]] [MinHeight [num]]
           Sets attributes for the title-bar. Justifications can be Centered, RightJustified or LeftJustified. Height sets the title bar’s height to an amount in pixels. MinHeight sets the minimal height
           in pixels of the title bar. Defaults are Centered, the window’s font height and no minimal height. To reset the font height to the default value, omit the num argument after the Height
           keyword. The MinHeight height is reset by Height or if given with no argument. Example:

               TitleStyle LeftJustified Height 24

       TitleStyle [state] [style] [-- [!]flag ...]
           Sets the style for the title-bar. See also AddTitleStyle and ButtonStyle state can be one of "ActiveUp", "ActiveDown", "InactiveUp", or "InactiveDown". Shortcuts like "Active" and "Inactive"
           are allowed. The states with the "Toggled" prefix are allowed too, the title itself does not use "Toggled" states, but these states are used for the buttons with ButtonStyle UseTitleStyle. If
           state is omitted, then the style is added to every state. If parentheses are placed around the style and flags, then multiple state definitions can be given per line. style can be omitted so
           that flags can be set while not destroying the current style.

           If a '!' is prefixed to any flag, its behavior is negated. Valid flags for each state include Raised, Flat and Sunk (these are mutually exclusive). The default is Raised. See the note in
           ButtonStyle regarding the "ActiveDown" state. Examples:

               TitleStyle ActiveUp HGradient 16 navy black
               TitleStyle \
               ActiveDown (Solid red -- flat) \
               Inactive (TiledPixmap wood.xpm)
               TitleStyle \
               ActiveUp (-- Flat) \
               ActiveDown (-- Raised) \
               InactiveUp (-- Flat) \
               InactiveDown (-- Sunk)

           This sets the "ActiveUp" state to a horizontal gradient, the "ActiveDown" state to solid red, and the "Inactive" states to a tiled wood pixmap. Finally, "ActiveUp" and "InactiveUp" are set to
           look flat, while "ActiveDown" set to be sunk (the Raised flag for the "ActiveDown" state causes it to appear sunk due to relief inversion), and "InactiveDown" is set to look raised. An example
           which sets flags for all states:

               TitleStyle -- flat

           For a flattened look:

               TitleStyle -- flat
               ButtonStyle All Active (-- flat) Inactive (-- flat)

           TitleStyle accepts all the ButtonStyle styles and arguments:

           Simple, Default, Solid, Colorset, Vector, ?Gradient, Pixmap, AdjustedPixmap, ShrunkPixmap, StretchedPixmap, TiledPixmap, MiniIcon.

           See the ButtonStyle command for a description of all these styles and their arguments.

           In addition to these styles TitleStyle accepts a powerful MultiPixmap option. This allows you to specify different pixmaps, colorsets or colors for different parts of the titlebar. Some of
           them are tiled or stretched to fit a particular space; others are discrete "transition" images. The definable sections are:

           Main
               The full titlebar

           LeftMain
               Left of title text

           RightMain
               Right of title text

           UnderText
               Underneath title text

           LeftOfText
               just to the left of the title text

           RightOfText
               just to the right of the title text

           LeftEnd
               at the far left end of the titlebar (just after left buttons if any)

           RightEnd
               at the far right end of the titlebar (just before right buttons if any)

           Buttons
               under buttons in case of UseTitleStyle

           LeftButtons
               under left buttons in case of UseTitleStyle

           RightButtons
               under right buttons in case of UseTitleStyle

           None of these are mandatory except for Main (or, if you do not define Main you must define both LeftMain and RightMain). If no Buttons pixmaps are defined and UseTitleStyle is specified for
           one or more buttons, Main, LeftMain or RightMain are used as appropriate.

           The syntax for this style type is:

               MultiPixmap section style arg, ...

           continuing for whatever you want to define. The style can be either TiledPixmap, AdjustedPixmap, Colorset or Solid. See the ButtonStyle command for the description of these styles. In the case
           of a transition section, LeftEnd, LeftOfText, RightOfText or RightEnd, AdjustedPixmap only resize the pixmap in the "y" direction. For the Colorset and Solid styles a width of the half of the
           title bar height is assumed for the transition sections.

           An example:

               MultiPixmap Main AdjustedPixmap foo.xpm, \
                     UnderText TiledPixmap bar.xpm, \
                     Buttons Colorset 2

           Note that the old syntax is still supported: if the style is omitted, TiledPixmap is assumed and adding "(stretched)" between the section and the file name implies AdjustedPixmap.

       UpdateDecor [decor]
           This command is deprecated and will be removed in the future. There are plans to replace it with a more flexible solution in fvwm-3.0.

           This command is kept mainly for backward compatibility. Since all elements of a decor are updated immediately when they are changed, this command is mostly useless.

           Updates window decorations. decor is an optional argument which specifies the decor to update. If given, only windows which are assigned to that particular decor are updated. This command is
           useful, for instance, after a ButtonStyle, TitleStyle or BorderStyle (possibly used in conjunction with AddToDecor). Specifying an invalid decor results in all windows being updated.

                                                                                                 2025-10-05                                                                                  FVWM3STYLES(1)
