PROGVIS(1)                                                                                General Commands Manual                                                                                PROGVIS(1)

NAME
       progvis - visualization tool for concurrent C/C++ programs

SYNOPSIS
       progvis

DESCRIPTION
       Progvis  is a program visualization tool aimed at concurrent C/C++ programs. It allows loading arbitrary programs and stepping through them. The tool also informs about a number of concurrency is‐
       sues, such as race conditions. Only a subset of C/C++ is supported. For C, most notably void pointers are not supported (for type safety). For C++, only fundamental language constructs are  imple‐
       mented (e.g. no templates). Much of the standard libraries both for C and C++ are not implemented either.

SYNCHRONIZATION
       The system provides C-style synchronization primitives as implemented in Pintos, see: http://www.scs.stanford.edu/07au-cs140/pintos/pintos_6.html#SEC97 In summary, they are as follows:

       struct semaphore
              An implementation of a semaphore.

       sema_init(struct semaphore *sema, int value)
              Initialize a semaphore object to a particular (positive) value.

       sema_up(struct semaphore *sema)
              Increase the counter in the semaphore. Also known as signal.

       sema_down(struct semaphore *sema)
              Decrease the counter in the semaphore, waits if it would become less than zero. Also known as wait.

       struct lock
              An implementation of a lock.

       lock_init(struct lock *lock)
              Initialize a lock.

       lock_acquire(struct lock *lock)
              Acquire a lock. Might wait.

       lock_release(struct lock *lock)
              Release a lock. Has to be done by the same thread that called lock_acquire.

       struct condition
              Implementation of a condition variable.

       cond_init(struct condition *cond)
              Initialize a condition variable.

       cond_wait(struct condition *cond, struct lock *lock)
              Cause  the  current  thread to wait until the condition is signalled. Assumes that the lock is held. The lock will be released while the thread is waiting, but it will be re-acquired before
              cond_wait returns.

       cond_signal(struct condition *cond, struct lock *lock)
              Wake one thread that is currently waiting inside cond_wait. Assumes that the lock is held.

       cond_broadcast(struct condition *cond, struct lock *lock)
              Wake all threads that are currently waiting inside cond_wait.

ATOMIC OPERATIONS
       A number of atomic operations are also supported. Most of these are generic, meaning that they are overloaded to work for more than one type. Here, we use P to mean any pointer type, I to mean any
       integer type (i.e. signed and unsigned integers, as well as booleans), and P/I to mean any pointer or integer type.

       I test_and_set(I *v)
              Read v and return its value, also setting v to 1.

       I atomic_add(I *v, I add)
              Adds add to the value pointed to by v. Returns the old value.

       I atomic_sub(I *v, I sub)
              Subtracts sub from the value pointed to by v. Returns the old value.

       P/I atomic_read(P/I *v)
              Read from v and return the value.

       void atomic_write(P/I *to, P/I v)
              Write to to.

       P/I atomic_swap(P/I *v, P/I replace)
              Read the value pointed to by v, and replace it with the value replace. Returns the old value.

       P/I compare_and_swap(P/I *v, P/I compare, P/I swap)
              Read the value from v, if it was equal to compare, replace it with swap. Returns the old value.

SEE ALSO
       storm(1) - the language in which Progvis is implemented.

                                                                                              October 15 2023                                                                                    PROGVIS(1)
