RECV(2)                                                                                       Sistem Çağrıları                                                                                      RECV(2)

İSİM
       recv - bağlantılı soket üzerinden ileti alır
       recvfrom - bağlantısız soket üzerinden ileti alır
       recvmsg - soket üzerinden bir dizi ileti alır

BİLDİRİM
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t recv (int sockfd, void *buf, size_t len, int flags);

       ssize_t recvfrom (int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);

       ssize_t recvmsg (int sockfd, struct msghdr *msg, int flags);

AÇIKLAMA
       recv(),  recvfrom()  ve  recvmsg()  sistem çağrıları bir soketten veri almak için kullanılır. Bu sistem çağrıları hem bağlantılı hem de bağlantısız soketlerde kullanılabilir. Bu sayfada önce bu üç
       çağrının genel özellikleri ve ardından aralarındaki fark anlatılmıştır.

       recv() ve read(2) arasındaki tek fark flags değişkeninin varlığıdır. flags değişkenine sıfır değeri atanmış recv() genel olarak read(2) ile eşdeğerdir (ancak yine  de  EK  BİLGİ  bölümüne  bakın).
       Ayrıca aşagıdaki

           recv(sockfd, buf, len, flags);

       çağrısı

           recvfrom(sockfd, buf, len, flags, NULL, NULL);

       çağrısına eşdeğerdir.

       Üç sistem çağrısı da başarı durumunda iletinin boyutunu döndürür. Eğer ileti verilen tampona sığamayacak kadar uzunsa, iletiyi alan soket türüne bağlı olarak fazlalık baytlar atılabilir.

       Eğer sokette ileti yoksa ve soket engellemesiz değilse çağrılar bir iletinin gelmesini bekler (fcntl(2) sayfasına bakın), eğer soket engellemeliyse -1 döner ve errno harici değişkenine EAGAIN veya
       EWOULDBLOCK sabitlerinden bir tanesi atanır. Bu sistem çağrıları, talep edilen miktarın tamamının alınmasını beklemek yerine mevcut olan tüm verileri döndürür.

       Bir uygulamada select(2), poll(2) veya epoll(2) çağrıları kullanılarak sokete fazla verinin ne zaman geleceğine karar verilebilir.

   flags değerleri
       flags değişkeninin değeri aşağıdaki değerlerin VEYAlanmasıyla elde edilir.

       MSG_CMSG_CLOEXEC (sadece recvmsg() için geçerlidir, Linux 2.6.23 ve sonrası)
           SCM_RIGHTS  işlemi  kullanılarak  sağlanan  UNIX  alan  dosya  tanıtıcısını  (unix(7)  sayfasında  açıklanmıştır) close-on-exec kipine ayarlar. Bu kip, open(2) çağrısına ait O_CLOEXEC ile aynı
           sebeplerden ötürü kullanışlıdır.

       MSG_DONTWAIT (Linux 2.2. ve sonrası)
           Engellemesiz işlemi etkinleştirir; eğer işlem engellenirse, EAGAIN veya EWOULDBLOCK döner. O_NONBLOCK seçeneği  tanımlanmış  (fcntl(2)  üzerinden  F_SETFL  işlemi  ile)  gibi  davranır,  fakat
           MSG_DONTWAIT  çağrıya  özel  olmasıyla fark oluşturur. O_NONBLOCK seçeneği ise açık dosya tanıtıcısı içindir (open(2) sayfasına bakın), çağrı sürecindeki tüm evreleri ve aynı zamanda aynı açık
           dosyanın dosya tanıtıcılarına sahip diğer süreçleri de etkiler.

       MSG_ERRQUEUE (Linux 2.2 ve sonrası)
           Bu seçenek, hata kuyruğunun soket hata kuyruğundan alınmasını belirtir. Hata, protokole bağlı türden yardımcı veri olarak iletilir (IPv4 için IP_RECVERR). Kullanıcı yeteri boyutta  bir  tampon
           belirtmelidir.  Daha  ayrıntılı  bilgi için cmsg(3) ve ip(7) sayfalarına bakın. Esas paketteki hataya sebep olan yük msg_iovec ile normal veri olarak aktarılır. Hataya sebep olan verikatarının
           özgün hedef adresi msg_name ile sağlanır.

           sock_extended_err yapısında sağlanan hatalar:

               #define SO_EE_ORIGIN_NONE    0
               #define SO_EE_ORIGIN_LOCAL   1
               #define SO_EE_ORIGIN_ICMP    2
               #define SO_EE_ORIGIN_ICMP6   3

               struct sock_extended_err
               {
                   uint32_t ee_errno;   /* Hata sayısı */
                   uint8_t  ee_origin;  /* Hatanın kaynağı */
                   uint8_t  ee_type;    /* Tür */
                   uint8_t  ee_code;    /* Kod */
                   uint8_t  ee_pad;     /* Dolgu */
                   uint32_t ee_info;    /* Ek bilgiler */
                   uint32_t ee_data;    /* Diğer veriler */
                   /* Fazladan veri takip edebilir */
               };

               struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);

           ee_errno kuyruğa alınmış errno hata numarasını içerir. ee_origin  hatanın  kodda  oluştuğu  yeri  gösterir.  Diğer  alanlar  protokole  özeldir.  SOCK_EE_OFFENDER  makrosu,  yardımcı  iletinin
           göstericisinden  kaynaklanan  hatanın kaynaklandığı ağ nesnesinin adresine bir gösterici döndürür. Eğer adres bilinmiyorsa, sockaddr yapısının sa_family alanı AF_UNSPEC içerirken yapının diğer
           alanları tanımsız kalır. Hataya sebep olan paket yükü normal veri olarak aktarılır.

           Yerel hatalar için adres belirtilmez (bu, cmsghdr üyesi cmsg_len ile sınanabilir). Hata alımı için msghdr değişkenine MSG_ERRQUEUE atanır. Bir hata aktarıldıktan sonra, bekleyen soket  hatası,
           hata kuyruğundaki sonraki hataya göre yeniden oluşturulur ve sonraki soket işleminde aktarılır.

       MSG_OOB
           Bu  seçenek  normalde  veri  akımında  alınmayacak  bantdışı (Out Of Band) veri alındısı isteğinde bulunur. Bazı protokoller hızlandırılmış veriyi normal veri kuyruğunun başına yerleştirir, bu
           yüzden bu seçenek bu tür protokollerde kullanılamaz.

       MSG_PEEK
           Bu seçenek alım işlemini, alım kuyruğunun başındaki veriyi kuyruktaki veriyi silmeden almasına neden olur. Bu sebepten, sonraki alım çağrısında aynı veriyi döndürür.

       MSG_TRUNC (Linux 2.2 ve sonrası)
           Ham (AF_PACKET), İnternet verikatarı (Linux 2.4.27/2.6.8 ve sonrası), ağ bağlantısı (Linux 2.6.22 ve sonrası) ve UNIX verikatarı (Linux 3.4 ve sonrası)  soketleri  için:  Tampona  aktarılandan
           büyük olsa bile, paketin veya verikatarının gerçek uzunluğunu döndürür.

           İnternet akım soketleriyle kullanmak için tcp(7) sayfasına bakın.

       MSG_WAITALL (Linux 2.2. ve sonrası)
           Bu seçenek, tüm istekler tamamlandığında işlemin engellemesi içindir. Ancak çağrı, bir sinyal yakaladığında, bir hata veya bağlantı kopması meydana geldiğinde, alınacak kuyruktaki verinin türü
           alınan veri türünden farklıysa daha az veri döndürür. Bu seçeneğin verikatarı soketleri için herhangi bir etkisi yoktur.

   recvfrom()
       recvfrom() gelen iletiyi buf tamponuna yerleştirir. Çağrıcı tamponun boyutunu len değişkeni ile belirtmelidir.

       Eğer  src_addr  NULL  değilse ve ilgili protokol iletinin kaynak adresini sağlıyorsa src_addr tampon içine yerleştirilen kaynak adrese göstericidir. Bu durumda, addrlen hem aktarılan değere hem de
       dönen sonuca göstericidir. addrlen, çağrıdan önce src_addr ile ilişkilendirilmiş tamponun boyutuna gösterici olmalıdır. İşlev döndüğünde, addrlen, kaynak adresin gerçek boyutunu gösterecek şekilde
       güncellenir. Sağlanan tampon çok küçükse döndürülen adres kırpılır; bu durumda, addrlen çağrıdan önceki boyuttan daha büyük bir değer döndürür.

       Eğer çağrıcı kaynak adresiyle ilgilenmiyorsa src_addr ve addrlen değişkenlerinde NULL aktarmalıdır.

   recv()
       recv() çağrısı normalde connected (bağlantılı) soketlerle kullanılır (connect(2) sayfasına bakın). Bu çağrı:

           recvfrom(fd, buf, len, flags, NULL, 0);

       çağrısıyla eşdeğerdir.

   recvmsg()
       recvmsg(), msghdr yapısını kullanarak doğrudan sağlanan değişken sayısını azaltır. Bu yapı, <sys/socket.h> içerisinde şu şekilde tanımlanmıştır:

           struct iovec {         /* Dağıtma/toplama dizisinin öğeleri */
               void  *iov_base;              /* Başlangıç adresi */
               size_t iov_len;               /* Aktarılacak bayt saysı */
           };

           struct msghdr {
               void         *msg_name;       /* İsteğe bağlı adres */
               socklen_t     msg_namelen;    /* Adresin boyutu */
              struct iovec *msg_iov;         /* Dağıtma/toplama dizisi */
               size_t        msg_iovlen;     /* msg_iov dizisinin öğe sayısı*/
               void         *msg_control;    /* Yardımcı veri tamponu, aşağıya bakın*/
               size_t        msg_controllen; /* Yardımcı veri tampon boyutu */
               int           msg_flags;      /* Alınan iletideki seçenekler */
           };

       Soket bağlantısızsa, msg_name alanı çağrıcı tarafından tahsis edilen kaynak adresi döndürmek için kullanılan tampona göstericidir. Çağrıcı çağrıyı yapmadan  önce  tamponun  boyutunu  msg_namelen’e
       belirtmelidir; başarılı bir çağrıdan sonra msg_namelen dönen adresin uzunluğunu içerir. Eğer uygulama kaynak adresi bilmeye ihtiyaç duymuyorsa msg_name NULL olarak belirtilebilir.

       readv(2) sayfasında açıklandığı üzere, msg_iov ve msg_iovlen alanları dağıtma-toplama konumlarını belirler.

       msg_controllen  uzunluğundaki  msg_control alanı, diğer protokollere ait denetim iletileri veya çeşitli yardımcı verilere göstericidir. recvmsg() çağrıldığında, msg_controllen msg_control içindeki
       kullanılabilir tamponun boyutunu içermelidir; başarılı bir çağrıda denetim ileti dizisinin boyutunu içerir.

       İletinin yapısı:

           struct cmsghdr {
               size_t cmsg_len;    /* Başlıkla beraber verinin bayt sayısı
                                      (POSIX’de veri türü socklen_t’dir) */
               int    cmsg_level;  /* Kaynak protokol */
               int    cmsg_type;   /* Protokole özgü tür */
           /* devamında,
               unsigned char cmsg_data[];  */
           };

       Yardımcı veriye sadece cmsg(3) içinde tanımlanan makrolarla erişilmedir.

       Örnek olarak, Linux bu yardımcı veri mekanizmasını genişletilmiş hataları, IP seçeneklerini veya UNIX alan soketleri üzerinden dosya tanıtıcılarını aktarmak için kullanır. Yardımcı  verinin  diğer
       çeşitli soket alanlarında kullanımına ilişkin ayrıntılı bilgi için unix(7) ve ip(7) sayfalarına bakın.

       msghdr yapısına ait msg_flags alanı, recvmsg() dönüdüğünde şu sabitler için sınanabilir:

       MSG_EOR
           Döndürülen verilerin bir kaydı tamamladığını yani kayıt sonunu (End Of Record) belirtir (genellikle SOCK_SEQPACKET türündeki soketlerle kullanılır).

       MSG_TRUNC
           Verikatarının sağlanan tampondan daha uzun olmasından dolayı kalan kısmın atılacağını belirtir.

       MSG_CTRUNC
           Yardımcı veri için tampondaki boşluğun az olmasından dolayı denetim verisinin atılacağını belirtir.

       MSG_OOB
           Hızlandırılmış veya bantdışı (Out Of Band) veri alındığını belirtir.

       MSG_ERRQUEUE
           Bir veri alınmadığını ancak soket hata kuyruğundaki genişletilmiş bir hatanın alındığını belirtir.

DÖNÜŞ DEĞERİ
       Başarı durumunda bu çağrılar alınan baytların sayısını döndürür. Hata durumunda, -1 döner ve hata errno değişkenine atanır.

       Akım soketinin bağlantısı karşıdan düzenli ollarak kapatılıyorsa dönen değer 0 olur (geleneksel dosya sonu dönüş değeri).

       Çeşitli alanlardaki verikatarı soketleri (örneğin UNIX ve İnternet alan soketleri) sıfır uzunluktaki verikatarlarına izin verir. Böyle bir verikatarı alınırsa dönüş değeri 0 olur.

       Eğer akım soketinden istenilen bayt boyutu 0 ise aynı şekilde 0 değeri döner.

HATALAR
       Soket  katmanı  tarafından  üretilen  bazı  standart hatalar vardır. Ayrıca, kullanılan protokol modülleri tarafından üretilen ve döndürülen hatalar da olabilir; bilgi için bunlarla ilgili kılavuz
       sayfalarına bakın.

       EAGAIN veya EWOULDBLOCK
           Soket engellemesiz olarak işaretlenmiş ama talep edilen işlem soketi engelleyecek veya veri alım zaman aşımı ayarlanmış ve veri gelmeden önce zaman aşımı süresi dolmuş. POSIX.1 her iki hatanın
           da döndürülmesine izin verir ve bu sabitlerin aynı değerde olmasını gerektirmez, bu bakımdan taşınabilir uygulamalar her iki seçeneği de sınamalıdır.

       EBADF
           Belirtilen sockfd geçerli bir açık dosya tanıtıcısı değil.

       ECONNREFUSED
           Uzak konak ağ bağlantısını reddetti (genelde sebep, talep edilen hizmeti çalıştırmamasıdır).

       EFAULT
           Alım tamponu göstericisi/göstericileri süreç adres alanının dışını gösteriyor.

       EINTR
           Herhangi bir veri alınmadan aktarım bir sinyal ile kesilmiş; signal(7) sayfasına bakın.

       EINVAL
           Belirtilen değişken geçersiz.

       ENOMEM
           recvmsg() için yeterli bellek ayrılamıyor.

       ENOTCONN
           Soket, bağlantılı bir protokolle ilişkilendirilmiş ancak bağlanmamış (connect(2) ve accept(2) sayfalarına bakın).

       ENOTSOCK
           Belirtilen sockfd’nin bir soketle ilgisi yok.

UYUMLULUK
       POSIX.1-2001, POSIX.1-2008, 4.4BSD (Bu arayüzler ilk defa 4.2BSD ile ortaya çıktı.)

       POSIX.1 sadece MSG_OOB, MSG_PEEK ve MSG_WAITALL seçeneklerini açıklar.

EK BİLGİ
       Eğer sıfır uzunluğunda bir verikatarı beklemedeyse, sıfır flags değişkenli read(2) ve recv() farklı davranışlar sergiler. Bu koşullarda, recv()  bekleyen  verikatarını  tüketirken  read(2)  hiçbir
       etkiye sahip değildir (verikatarı beklemede kalır).

       socklen_t POSIX ile icat edilmiştir. Ayrıca accept(2) sayfasına bakın.

       POSIX.1’e göre, msghdr yapısının msg_controllen alanı socklen_t türünde, msg_iovlen alanı ise int türünde olmalıdır, fakat glibc ikisine de size_t türünü atar.

       Tek çağrıda çok sayıda verikatarı alabilmek için kullanılan Linux’a özgü sistem çağrısı hakkında bilgi edinmek için recvmmsg(2) sayfasına bakın.

ÖRNEKLER
       recvfrom() kullanım örneği getaddrinfo(3) sayfasında verilmiştir.

İLGİLİ BELGELER
       fcntl(2), getsockopt(2), read(2), recvmmsg(2), select(2), shutdown(2), socket(2), cmsg(3), sockatmark(3), ip(7), ipv6(7), socket(7), tcp(7), udp(7), unix(7)

ÇEVİREN
       © 2022 Fatih Koçer
       Bu çeviri özgür yazılımdır: Yasaların izin verdiği ölçüde HİÇBİR GARANTİ YOKTUR.
       Lütfen,  çeviri  ile  ilgili  bildirimde  bulunmak  veya  çeviri  yapmak için https://github.com/TLBP/manpages-tr/issues adresinde "New Issue" düğmesine tıklayıp yeni bir konu açınız ve isteğinizi
       belirtiniz.

Linux man-pages 5.10                                                                           11 Kasım 2020                                                                                        RECV(2)
