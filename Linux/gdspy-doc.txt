GDSPY(1)                                                                                           gdspy                                                                                           GDSPY(1)

NAME
       gdspy - gdspy Documentation

       gdspy is a Python module that allows the creation of GDSII stream files.

       Most features of the GDSII format are implemented, including support for polygons with any number of vertices.

       GDSII format references:

       • http://boolean.klaasholwerda.nl/interface/bnf/gdsformat.html

       • http://www.artwork.com/gdsii/gdsii/

       • http://www.buchanan1.net/stream_description.html

       For installation instructions and other information, please check out the GitHub repository or the README file included with the source.

GETTING STARTED
       GDSII  files  contain a hierarchical representation of any polygonal geometry.  They are mainly used in the microelectronics industry for the design of mask layouts, but are also employed in other
       areas.

       Because it is a hierarchical format, repeated structures, such as identical transistors, can be defined once and referenced multiple times in the layout, reducing the file size.

       There is one important limitation in the GDSII format: it only supports weakly simple polygons, that is, polygons whose segments are allowed to intersect, but not cross.

       In particular, curves and shapes with holes are not directly supported.  Holes can be defined, nonetheless, by connecting their boundary to the boundary of the enclosing shape.   In  the  case  of
       curves, they must be approximated by a polygon.  The number of points in the polygonal approximation can be increased to better approximate the original curve up to some acceptable error.

       The  original  GDSII  format limits the number of vertices in a polygon to 199.  Most modern software disregards this limit and allows an arbitrary number of points per polygon.  Gdspy follows the
       modern version of GDSII, but this is an important issue to keep in mind if the generated file is to be used in older systems.

       The units used to represent shapes in the GDSII format are defined by the user.  The default unit in gdspy is 1 µm (10⁻⁶ m), but that can be easily changed by the user.

   First GDSII
       Let's create our first GDSII file:

          import gdspy

          # Create the geometry: a single rectangle.
          rect = gdspy.Rectangle((0, 0), (2, 1))
          cell = gdspy.Cell('FIRST')
          cell.add(rect)

          # Save all created cells in file 'first.gds'.
          gdspy.write_gds('first.gds')

          # Optionally, display all cells using the internal viewer.
          gdspy.LayoutViewer()

       After importing the gdspy module, we create a gdspy.Rectangle with opposing corners at positions (0, 0) and (2, 1).

       Then a gdspy.Cell is created and the rectangle is added to the cell.  All shapes in the GDSII format exist inside cells.  A cell can be imagined as a piece of paper where the layout  will  be  de‐
       fined.  Later, the cells can be used to create a hierarchy of geometries, ass we'll see in References.

       Finally, the whole structure is saved in a file called "first.gds" in the current directory.  By default, all created cells are included in this operation.

       The GDSII file can be opened in a number of viewers and editors, such as KLayout.  Alternatively, gdspy includes a simple viewer that can also be used: gdspy.LayoutViewer.

   Polygons
       General polygons can be defined by an ordered list of vertices.  The orientation of the vertices (clockwise/counter-clockwise) is not important.

          # Create a polygon from a list of vertices
          points = [(0, 0), (2, 2), (2, 6), (-6, 6), (-6, -6), (-4, -4), (-4, 4), (0, 4)]
          poly = gdspy.Polygon(points)

       [image]

   Holes
       As mentioned in Getting Started, holes have to be connected to the outer boundary of the polygon, as in the following example:

          # Manually connect the hole to the outer boundary
          cutout = gdspy.Polygon(
              [(0, 0), (5, 0), (5, 5), (0, 5), (0, 0), (2, 2), (2, 3), (3, 3), (3, 2), (2, 2)]
          )

       [image]

   Circles
       The  gdspy.Round class creates circles, ellipses, doughnuts, arcs and slices.  In all cases, the arguments tolerance or number_of_points will control the number of vertices used to approximate the
       curved shapes.

       If the number of vertices in the polygon is larger than max_points (199 by default), it will be fractured in many smaller polygons with at most max_points vertices each.

          # Circle centered at (0, 0), with radius 2 and tolerance 0.1
          circle = gdspy.Round((0, 0), 2, tolerance=0.01)

          # To create an ellipse, simply pass a list with 2 radii.
          # Because the tolerance is small (resulting a large number of
          # vertices), the ellipse is fractured in 2 polygons.
          ellipse = gdspy.Round((4, 0), [1, 2], tolerance=1e-4)

          # Circular arc example
          arc = gdspy.Round(
              (2, 4),
              2,
              inner_radius=1,
              initial_angle=-0.2 * numpy.pi,
              final_angle=1.2 * numpy.pi,
              tolerance=0.01,
          )

       [image]

   Curves
       Constructing complex polygons by manually listing all vertices in gdspy.Polygon can be challenging.  The class gdspy.Curve can be used to facilitate the  creation  of  polygons  by  drawing  their
       shapes step-by-step.  It uses a syntax similar to the SVG path specification.

       A short summary of the available methods is presented below:
                                                                                   ┌────────┬───────────────────────────────┐
                                                                                   │ Method │ Primitive                     │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ L/l    │ Line segments                 │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ H/h    │ Horizontal line segments      │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ V/v    │ Vertical line segments        │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ C/c    │ Cubic Bezier curve            │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ S/s    │ Smooth cubic Bezier curve     │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ Q/q    │ Quadratic Bezier curve        │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ T/t    │ Smooth quadratic Bezier curve │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ B/b    │ General degree Bezier curve   │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ I/i    │ Smooth interpolating curve    │
                                                                                   ├────────┼───────────────────────────────┤
                                                                                   │ arc    │ Elliptical arc                │
                                                                                   └────────┴───────────────────────────────┘

       The  uppercase  version  of  the  methods  considers  that  all  coordinates are absolute, whereas the lowercase considers that they are relative to the current end point of the curve.  Except for
       gdspy.Curve.I(), gdspy.Curve.i() and gdspy.Curve.arc(), they accept variable numbers of arguments that are used as coordinates to construct the primitive.

          # Construct a curve made of a sequence of line segments
          c1 = gdspy.Curve(0, 0).L(1, 0, 2, 1, 2, 2, 0, 2)
          p1 = gdspy.Polygon(c1.get_points())

          # Construct another curve using relative coordinates
          c2 = gdspy.Curve(3, 1).l(1, 0, 2, 1, 2, 2, 0, 2)
          p2 = gdspy.Polygon(c2.get_points())

       [image]

       Coordinate pairs can be given as a complex number: real and imaginary parts are used as x and y coordinates, respectively.  That is useful to define points in polar coordinates.

       Elliptical arcs have syntax similar to gdspy.Round, but they allow for an extra rotation of the major axis of the ellipse.

          # Use complex numbers to facilitate writing polar coordinates
          c3 = gdspy.Curve(0, 2).l(4 * numpy.exp(1j * numpy.pi / 6))
          # Elliptical arcs have syntax similar to gdspy.Round
          c3.arc((4, 2), 0.5 * numpy.pi, -0.5 * numpy.pi)
          p3 = gdspy.Polygon(c3.get_points())

       [image]

       Other curves can be constructed as cubic, quadratic and general-degree Bezier curves.  Additionally,  a  smooth  interpolating  curve  can  be  calculated  with  the  methods  gdspy.Curve.I()  and
       gdspy.Curve.i(), which have a number of arguments to control the shape of the curve.

          # Cubic Bezier curves can be easily created with C and c
          c4 = gdspy.Curve(0, 0).c(1, 0, 1, 1, 2, 1)
          # Smooth continuation with S or s
          c4.s(1, 1, 0, 1).S(numpy.exp(1j * numpy.pi / 6), 0, 0)
          p4 = gdspy.Polygon(c4.get_points())

          # Similarly for quadratic Bezier curves
          c5 = gdspy.Curve(5, 3).Q(3, 2, 3, 0, 5, 0, 4.5, 1).T(5, 3)
          p5 = gdspy.Polygon(c5.get_points())

          # Smooth interpolating curves can be built using I or i, including
          # closed shapes
          c6 = gdspy.Curve(0, 3).i([(1, 0), (2, 0), (1, -1)], cycle=True)
          p6 = gdspy.Polygon(c6.get_points())

       [image]

   Transformations
       All  polygons can be transformed trough gdspy.PolygonSet.translate(), gdspy.PolygonSet.rotate(), gdspy.PolygonSet.scale(), and gdspy.PolygonSet.mirror().  The transformations are applied in-place,
       i.e., no polygons are created.

          poly = gdspy.Rectangle((-2, -2), (2, 2))
          poly.rotate(numpy.pi / 4)
          poly.scale(1, 0.5)

       [image]

   Layer and Datatype
       All shapes in the GDSII format are tagged with 2 properties: layer and datatype (or texttype in the case of gdspy.Label).  They are always 0 by default, but can be any integer in the range from  0
       to 255.

       These  properties have no predefined meaning.  It is up to the system using the GDSII file to chose with to do with those tags.  For example, in the CMOS fabrication process, each layer could rep‐
       resent a different lithography level.

       In the example below, a single file stores different fabrication masks in separate layer and datatype configurations.

          # Layer/datatype definitions for each step in the fabrication
          ld_fulletch = {"layer": 1, "datatype": 3}
          ld_partetch = {"layer": 2, "datatype": 3}
          ld_liftoff = {"layer": 0, "datatype": 7}

          p1 = gdspy.Rectangle((-3, -3), (3, 3), **ld_fulletch)
          p2 = gdspy.Rectangle((-5, -3), (-3, 3), **ld_partetch)
          p3 = gdspy.Rectangle((5, -3), (3, 3), **ld_partetch)
          p4 = gdspy.Round((0, 0), 2.5, number_of_points=6, **ld_liftoff)

       [image]

   References
       References give the GDSII format its hierarchical features.  They work by reusing a cell content in another cell (without actually copying the whole geometry).  As a  simplistic  example,  imagine
       the we are designing a simple electronic circuit that uses hundreds of transistors, but they all have the same shape.  We can draw the transistor just once and reference it throughout the circuit,
       rotating or mirroring each instance as necessary.

       Besides creating single references with gdspy.CellReference, it is possible to create full 2D arrays with a single entity using gdspy.CellArray.  Both are exemplified below.

          # Create a cell with a component that is used repeatedly
          contact = gdspy.Cell("CONTACT")
          contact.add([p1, p2, p3, p4])

          # Create a cell with the complete device
          device = gdspy.Cell("DEVICE")
          device.add(cutout)
          # Add 2 references to the component changing size and orientation
          ref1 = gdspy.CellReference(contact, (3.5, 1), magnification=0.25)
          ref2 = gdspy.CellReference(contact, (1, 3.5), magnification=0.25, rotation=90)
          device.add([ref1, ref2])

          # The final layout has several repetitions of the complete device
          main = gdspy.Cell("MAIN")
          main.add(gdspy.CellArray(device, 3, 2, (6, 7)))

       [image]

   Paths
       Besides  polygons,  the GDSII format defines paths, witch are polygonal chains with associated width and end caps.  The width is a single number, constant throughout the path, and the end caps can
       be flush, round, or extended by a custom distance.

       There is no specification for the joins between adjacent segments, so it is up to the system using the GDSII file to specify those.  Usually the joins are straight extensions of  the  path  bound‐
       aries up to some beveling limit.  Gdspy also uses this specification for the joins.

       It is possible to circumvent all of the above limitations within gdspy by storing paths as polygons in the GDSII file.  The disadvantage of this solution is that other software will not be able to
       edit the geometry as paths, since that information is lost.

       The construction of paths (either GDSII paths or polygonal paths) in gdspy is quite rich.  There are 3 classes that can be used depending on the requirements of the desired path.

   Polygonal-Only Paths
       The class gdspy.Path is designed to allow the creation of path-like polygons in a piece-wise manner.  It is the most computationally efficient class between the three because it does not calculate
       joins.  That means the user is responsible for designing the joins.  The paths can end up with discontinuities if care is not taken when creating them.

          # Start a path at (0, 0) with width 1
          path1 = gdspy.Path(1, (0, 0))

          # Add a segment to the path goin in the '+y' direction
          path1.segment(4, "+y")

          # Further segments or turns will folow the current path direction
          # to ensure continuity
          path1.turn(2, "r")
          path1.segment(1)
          path1.turn(3, "rr")

       [image]

       Just  as  with  Circles,  all  curved geometry is approximated by line segments.  The number of segments is similarly controlled by a tolerance or a number_of_points argument.  Curves also include
       fracturing to limit the number of points in each polygon.

       More complex paths can be constructed with the methods gdspy.Path.bezier(), gdspy.Path.smooth(), and gdspy.Path.parametric().  The example below demonstrates a couple of possibilities.

          path2 = gdspy.Path(0.5, (0, 0))

          # Start the path with a smooth Bezier S-curve
          path2.bezier([(0, 5), (5, 5), (5, 10)])

          # We want to add a spiral curve to the path.  The spiral is defined
          # as a parametric curve.  We make sure spiral(0) = (0, 0) so that
          # the path is continuous.
          def spiral(u):
              r = 4 - 3 * u
              theta = 5 * u * numpy.pi
              x = r * numpy.cos(theta) - 4
              y = r * numpy.sin(theta)
              return (x, y)

          # It is recommended to also define the derivative of the parametric
          # curve, otherwise this derivative must be calculated nummerically.
          # The derivative is used to define the side boundaries of the path,
          # so, in this case, to ensure continuity with the existing S-curve,
          # we make sure the the direction at the start of the spiral is
          # pointing exactly upwards, as if is radius were constant.
          # Additionally, the exact magnitude of the derivative is not
          # important; gdspy only uses its direction.
          def dspiral_dt(u):
              theta = 5 * u * numpy.pi
              dx_dt = -numpy.sin(theta)
              dy_dt = numpy.cos(theta)
              return (dx_dt, dy_dt)

          # Add the parametric spiral to the path
          path2.parametric(spiral, dspiral_dt)

       [image]

       The width of the path does not have to be constant.  Each path component can linearly taper the width of the path by using the final_width argument.  In the case of a parametric curve,  more  com‐
       plex width changes can be created by setting final_width to a function.

       Finally, parallel paths can be created simultaneously with the help of arguments number_of_paths, distance, and final_distance.

          # Start 3 parallel paths with center-to-center distance of 1.5
          path3 = gdspy.Path(0.1, (-5.5, 3), number_of_paths=3, distance=1.5)

          # Add a segment tapering the widths up to 0.5
          path3.segment(2, "-y", final_width=0.5)

          # Add a bezier curve decreasing the distance between paths to 0.75
          path3.bezier([(0, -2), (1, -3), (3, -3)], final_distance=0.75)

          # Add a parametric section to modulate the width with a sinusoidal
          # shape.  Note that the algorithm that determines the number of
          # evaluations of the parametric curve does not take the width into
          # consideration, so we have to manually increase this parameter.
          path3.parametric(
              lambda u: (5 * u, 0),
              lambda u: (1, 0),
              final_width=lambda u: 0.4 + 0.1 * numpy.cos(10 * numpy.pi * u),
              number_of_evaluations=256,
          )

          # Add a circular turn and a final tapering segment.
          path3.turn(3, "l")
          path3.segment(2, final_width=1, final_distance=1.5)

       [image]

   Flexible Paths
       Although  very  efficient,  gdspy.Path  is limited in the type of path it can provide.  For example, if we simply want a path going through a sequence of points, we need a class that can correctly
       compute the joins between segments.  That's one of the advantages of class gdspy.FlexPath.  Other path construction methods are similar to those in gdspy.Path.

       A few features of gdspy.FlexPath are:

       • paths can be stored as proper GDSII paths;

       • end caps and joins can be specified by the user;

       • each parallel path can have a different width;

       • spacing between parallel paths is arbitrary; the user specifies the offset of each path individually.

          # Path defined by a sequence of points and stored as a GDSII path
          sp1 = gdspy.FlexPath(
              [(0, 0), (3, 0), (3, 2), (5, 3), (3, 4), (0, 4)], 1, gdsii_path=True
          )

          # Other construction methods can still be used
          sp1.smooth([(0, 2), (2, 2), (4, 3), (5, 1)], relative=True)

          # Multiple parallel paths separated by 0.5 with different widths,
          # end caps, and joins.  Because of the join specification, they
          # cannot be stared as GDSII paths, only as polygons.
          sp2 = gdspy.FlexPath(
              [(12, 0), (8, 0), (8, 3), (10, 2)],
              [0.3, 0.2, 0.4],
              0.5,
              ends=["extended", "flush", "round"],
              corners=["bevel", "miter", "round"],
          )
          sp2.arc(2, -0.5 * numpy.pi, 0.5 * numpy.pi)
          sp2.arc(1, 0.5 * numpy.pi, 1.5 * numpy.pi)

       [image]

       The following example shows other features, such as width tapering, arbitrary offsets, and custom joins and end caps.

          # Path corners and end caps can be custom functions.
          # This corner function creates 'broken' joins.
          def broken(p0, v0, p1, v1, p2, w):
              # Calculate intersection point p between lines defined by
              # p0 + u0 * v0 (for all u0) and p1 + u1 * v1 (for all u1)
              den = v1[1] * v0[0] - v1[0] * v0[1]
              lim = 1e-12 * (v0[0] ** 2 + v0[1] ** 2) * (v1[0] ** 2 + v1[1] ** 2)
              if den ** 2 < lim:
                  # Lines are parallel: use mid-point
                  u0 = u1 = 0
                  p = 0.5 * (p0 + p1)
              else:
                  dx = p1[0] - p0[0]
                  dy = p1[1] - p0[1]
                  u0 = (v1[1] * dx - v1[0] * dy) / den
                  u1 = (v0[1] * dx - v0[0] * dy) / den
                  p = 0.5 * (p0 + v0 * u0 + p1 + v1 * u1)
              if u0 <= 0 and u1 >= 0:
                  # Inner corner
                  return [p]
              # Outer corner
              return [p0, p2, p1]

          # This end cap function creates pointy caps.
          def pointy(p0, v0, p1, v1):
              r = 0.5 * numpy.sqrt(numpy.sum((p0 - p1) ** 2))
              v0 /= numpy.sqrt(numpy.sum(v0 ** 2))
              v1 /= numpy.sqrt(numpy.sum(v1 ** 2))
              return [p0, 0.5 * (p0 + p1) + 0.5 * (v0 - v1) * r, p1]

          # Paths with arbitrary offsets from the center and multiple layers.
          sp3 = gdspy.FlexPath(
              [(0, 0), (0, 1)],
              [0.1, 0.3, 0.5],
              offset=[-0.2, 0, 0.4],
              layer=[0, 1, 2],
              corners=broken,
              ends=pointy,
          )
          sp3.segment((3, 3), offset=[-0.5, -0.1, 0.5])
          sp3.segment((4, 1), width=[0.2, 0.2, 0.2], offset=[-0.2, 0, 0.2])
          sp3.segment((0, -1), relative=True)

       [image]

       The corner type 'circular bend' (together with the bend_radius argument) can be used to automatically curve the path.  This feature is used in Example: Integrated Photonics.

          # Path created with automatic bends of radius 5
          points = [(0, 0), (0, 10), (20, 0), (18, 15), (8, 15)]
          sp4 = gdspy.FlexPath(
              points, 0.5, corners="circular bend", bend_radius=5, gdsii_path=True
          )

          # Same path, generated with natural corners, for comparison
          sp5 = gdspy.FlexPath(points, 0.5, layer=1, gdsii_path=True)

       [image]

   Robust Paths
       In some situations, gdspy.FlexPath is unable to properly calculate all the joins.  This often happens when the width or offset of the path is relatively large with respect to  the  length  of  the
       segments being joined.  Curves that join other curves or segments at sharp angles are an example of such situation.

       The  class  gdspy.RobustPath  can be used in such scenarios where robustness is more important than efficiency due to sharp corners or large offsets in the paths.  The drawbacks of using gdspy.Ro‐
       bustPath are the loss in computation efficiency (compared to the other 2 classes) and the impossibility of specifying corner shapes.  The advantages are, as mentioned earlier, more robustness when
       generating the final geometry, and freedom to use custom functions to parameterize the widths or offsets of the paths in any construction method.

          # Create 4 parallel paths in different layers
          lp = gdspy.RobustPath(
              (50, 0),
              [2, 0.5, 1, 1],
              [0, 0, -1, 1],
              ends=["extended", "round", "flush", "flush"],
              layer=[0, 2, 1, 1],
          )
          lp.segment((45, 0))
          lp.segment(
              (5, 0),
              width=[lambda u: 2 + 16 * u * (1 - u), 0.5, 1, 1],
              offset=[
                  0,
                  lambda u: 8 * u * (1 - u) * numpy.cos(12 * numpy.pi * u),
                  lambda u: -1 - 8 * u * (1 - u),
                  lambda u: 1 + 8 * u * (1 - u),
              ],
          )
          lp.segment((0, 0))
          lp.smooth(
              [(5, 10)],
              angles=[0.5 * numpy.pi, 0],
              width=0.5,
              offset=[-0.25, 0.25, -0.75, 0.75],
          )
          lp.parametric(
              lambda u: numpy.array((45 * u, 4 * numpy.sin(6 * numpy.pi * u))),
              offset=[
                  lambda u: -0.25 * numpy.cos(24 * numpy.pi * u),
                  lambda u: 0.25 * numpy.cos(24 * numpy.pi * u),
                  -0.75,
                  0.75,
              ],
          )

       [image]

       Note that, analogously to gdspy.FlexPath, gdspy.RobustPath can be stored as a GDSII path as long as its width is kept constant.

   Text
       In the context of a GDSII file, text is supported in the form of labels, which are ASCII annotations placed somewhere in the geometry of a given cell.  Similar to polygons, labels are tagged  with
       layer and texttype values (texttype is the label equivalent of the polygon datatype).  They are supported by the class gdspy.Label.

       Additionally, gdspy offers the possibility of creating text as polygons to be included with the geometry.  The class gdspy.Text creates polygonal text that can be used in the same way as any other
       polygons in gdspy.  The font used to render the characters contains only horizontal and vertical edges, which is important for some laser writing systems.

          # Label anchored at (1, 3) by its north-west corner
          label = gdspy.Label("Sample label", (1, 3), "nw")

          # Horizontal text with height 2.25
          htext = gdspy.Text("12345", 2.25, (0.25, 6))

          # Vertical text with height 1.5
          vtext = gdspy.Text("ABC", 1.5, (10.5, 4), horizontal=False)

          rect = gdspy.Rectangle((0, 0), (10, 6), layer=10)

       [image]

   Geometry Operations
       Gdspy offers a number of functions and methods to modify existing geometry.  The most useful operations include gdspy.boolean(), gdspy.slice(), gdspy.offset(), and gdspy.PolygonSet.fillet().

   Boolean Operations
       Boolean  operations (gdspy.boolean()) can be performed on polygons, paths and whole cells.  Four operations are defined: union ('or'), intersection ('and'), subtraction ('not'), and symmetric sub‐
       traction ('xor').

       They can be computationally expensive, so it is usually advisable to avoid using boolean operations whenever possible.  If they are necessary, keeping the number of vertices is all polygons as low
       as possible also helps.

          # Create some text
          text = gdspy.Text("GDSPY", 4, (0, 0))
          # Create a rectangle extending the text's bounding box by 1
          bb = numpy.array(text.get_bounding_box())
          rect = gdspy.Rectangle(bb[0] - 1, bb[1] + 1)

          # Subtract the text from the rectangle
          inv = gdspy.boolean(rect, text, "not")

       [image]

   Slice Operation
       As the name indicates, a slice operation subdivides a set of polygons along horizontal or vertical cut lines.

       In a few cases, a boolean operation can be substituted by one or more slice operations.  Because gdspy.slice() is ususally much simpler than gdspy.boolean(), it is a good idea to use the former if
       possible.

          ring1 = gdspy.Round((-6, 0), 6, inner_radius=4)
          ring2 = gdspy.Round((0, 0), 6, inner_radius=4)
          ring3 = gdspy.Round((6, 0), 6, inner_radius=4)

          # Slice the first ring across x=-3, the second ring across x=-3
          # and x=3, and the third ring across x=3
          slices1 = gdspy.slice(ring1, -3, axis=0)
          slices2 = gdspy.slice(ring2, [-3, 3], axis=0)
          slices3 = gdspy.slice(ring3, 3, axis=0)

          slices = gdspy.Cell("SLICES")

          # Keep only the left side of slices1, the center part of slices2
          # and the right side of slices3
          slices.add(slices1[0])
          slices.add(slices2[1])
          slices.add(slices3[1])

       [image]

   Offset Operation
       The function gdspy.offset() expands or contracts polygons by a fixed amount.  It can operate on individual polygons or sets of them, in which case it may make sense to use the argument  join_first
       to operate on the whole geometry as if a boolean 'or' was executed beforehand.

          rect1 = gdspy.Rectangle((-4, -4), (1, 1))
          rect2 = gdspy.Rectangle((-1, -1), (4, 4))

          # Offset both polygons
          # Because we join them first, a single polygon is created.
          outer = gdspy.offset([rect1, rect2], 0.5, join_first=True, layer=1)

       [image]

   Fillet Operation
       The  method gdspy.PolygonSet.fillet() can be used to round polygon corners.  It doesn't have a join_first argument as gdspy.offset(), so if it will be used on a polygon, that polygon should proba‐
       bly not be fractured.

          multi_path = gdspy.Path(2, (-3, -2))
          multi_path.segment(4, "+x")
          multi_path.turn(2, "l").turn(2, "r")
          multi_path.segment(4)

          # Create a copy with joined polygons and no fracturing
          joined = gdspy.boolean(multi_path, None, "or", max_points=0)
          joined.translate(0, -5)

          # Fillet applied to each polygon in the path
          multi_path.fillet(0.5)

          # Fillet applied to the joined copy
          joined.fillet(0.5)

       [image]

   GDSII Library
       All the information used to create a GDSII file is kept within an instance of GdsLibrary.  Besides all the geometric and hierarchical information, this class also holds a name and  the  units  for
       all  entities.  The name can be any ASCII string.  It is simply stored in the GDSII file and has no other purpose in gdspy.  The units require some attention because they can impact the resolution
       of the polygons in the library when written to a file.

   Units in GDSII
       Two values are defined: unit and precision.  The value of unit defines the unit size—in meters—for all entities in the library.  For example, if unit = 1e-6 (10⁻⁶ m, the default value),  a  vertex
       at (1, 2) should be interpreted as a vertex in real world position (1 × 10⁻⁶ m, 2 × 10⁻⁶ m).  If unit changes to 0.001, then that same vertex would be located (in real world coordinates) at (0.001
       m, 0.002 m), or (1 mm, 2 mm).

       The  value of precision has to do with the type used to store coordinates in the GDSII file: signed 4-byte integers.  Because of that, a finer coordinate grid than 1 unit is usually desired to de‐
       fine coordinates.  That grid is defined, in meters, by precision, which defaults to 1e-9 (10⁻⁹ m).  When the GDSII file is written, all vertices are snapped to the grid defined by precision.   For
       example,  for the default values of unit and precision, a vertex at (1.0512, 0.0001) represents real world coordinates (1.0512 × 10⁻⁶ m, 0.0001 × 10⁻⁶ m), or (1051.2 × 10⁻⁹ m, 0.1 × 10⁻⁹ m), which
       will be rounded to integers: (1051 × 10⁻⁹ m, 0 × 10⁻⁹ m), or (1.051 × 10⁻⁶ m, 0 × 10⁻⁶ m).  The actual coordinate values written in the GDSII file will be the integers (1051, 0).  By reducing  the
       value of precision from 10⁻⁹ m to 10⁻¹² m, for example, the coordinates will have 3 additional decimal places of precision, so the stored values would be (1051200, 100).

       The  downside  of increasing the number of decimal places in the file is reducing the range of coordinates that can be stored (in real world units).  That is because the range of coordinate values
       that can be written in the file are [-(2³²); 2³¹ - 1] = [-2,147,483,648; 2,147,483,647].  For the default precsision, this range is [-2.147483648 m; 2.147483647 m].  If precision is set  to  10⁻¹²
       m, the same range is reduced by 1000 times: [-2.147483648 mm; 2.147483647 mm].

   Saving a GDSII File
       To save a GDSII file, the easiest way is to use gdspy.write_gds(), as in the First GDSII.  That function accepts arguments unit and precision to change the default values, as explained in the sec‐
       tion above.

       In  reality,  it  calls the gdspy.GdsLibrary.write_gds() method from a global gdspy.GdsLibrary instance: gdspy.current_library.  This instance automatically holds all cells created by gdspy unless
       specifically told not to with the argument exclude_from_current set to True in gdspy.Cell.

       That means that after saving a file, if a new GDSII library is to be started from scratch using the global instance, it is important to reinitialize it with:

          gdspy.current_library = gdspy.GdsLibrary()

   Loading a GDSII File
       To load an existing GDSII file (or to work simultaneously with multiple libraries), a new instance of GdsLibrary can be created or an existing one can be used:

          # Load a GDSII file into a new library
          gdsii = gdspy.GdsLibrary(infile='filename.gds')

          # Use the current global library to load the file
          gdspy.current_library.read_gds('filename.gds')

       In either case, care must be taken to merge the units from the library and the file, which is controlled by the argument units in  gdspy.GdsLibrary.read_gds()  (keyword  argument  in  gdspy.GdsLi‐
       brary).

       Access  to  the  cells in the loaded library is provided through the dictionary gdspy.GdsLibrary.cell_dict (cells indexed by name).  The method gdspy.GdsLibrary.top_level() can be used to find the
       top-level cells in the library (cells on the top of the hierarchy, i.e., cell that are not referenced by any other cells) and gdspy.GdsLibrary.extract() can be used to import a given cell and  all
       of its dependencies into gdspy.current_library.

   Examples
   Integrated Photonics
       This example demonstrates the use of gdspy primitives to create more complex structures.

       These structures are commonly used in the field of integrated photonics.

       photonics.py

       photonics.gds

          ######################################################################
          #                                                                    #
          #  Copyright 2009-2019 Lucas Heitzmann Gabrielli.                    #
          #  This file is part of gdspy, distributed under the terms of the    #
          #  Boost Software License - Version 1.0.  See the accompanying       #
          #  LICENSE file or <http://www.boost.org/LICENSE_1_0.txt>            #
          #                                                                    #
          ######################################################################

          import numpy
          import gdspy

          def grating(period, number_of_teeth, fill_frac, width, position, direction, lda=1, sin_theta=0,
                      focus_distance=-1, focus_width=-1, tolerance=0.001, layer=0, datatype=0):
              '''
              Straight or focusing grating.

              period          : grating period
              number_of_teeth : number of teeth in the grating
              fill_frac       : filling fraction of the teeth (w.r.t. the period)
              width           : width of the grating
              position        : grating position (feed point)
              direction       : one of {'+x', '-x', '+y', '-y'}
              lda             : free-space wavelength
              sin_theta       : sine of incidence angle
              focus_distance  : focus distance (negative for straight grating)
              focus_width     : if non-negative, the focusing area is included in
                                the result (usually for negative resists) and this
                                is the width of the waveguide connecting to the
                                grating
              tolerance       : same as in `path.parametric`
              layer           : GDSII layer number
              datatype        : GDSII datatype number

              Return `PolygonSet`
              '''
              if focus_distance < 0:
                  p = gdspy.L1Path((position[0] - 0.5 * width,
                                    position[1] + 0.5 * (number_of_teeth - 1 + fill_frac) * period),
                                   '+x', period * fill_frac, [width], [], number_of_teeth, period,
                                   layer=layer, datatype=datatype)
              else:
                  neff = lda / float(period) + sin_theta
                  qmin = int(focus_distance / float(period) + 0.5)
                  p = gdspy.Path(period * fill_frac, position)
                  c3 = neff**2 - sin_theta**2
                  w = 0.5 * width
                  for q in range(qmin, qmin + number_of_teeth):
                      c1 = q * lda * sin_theta
                      c2 = (q * lda)**2
                      p.parametric(lambda t: (width * t - w,
                                              (c1 + neff * numpy.sqrt(c2 - c3 * (width * t - w)**2)) / c3),
                                   tolerance=tolerance, max_points=0, layer=layer, datatype=datatype)
                      p.x = position[0]
                      p.y = position[1]
                  sz = p.polygons[0].shape[0] // 2
                  if focus_width == 0:
                      p.polygons[0] = numpy.vstack((p.polygons[0][:sz, :], [position]))
                  elif focus_width > 0:
                      p.polygons[0] = numpy.vstack((p.polygons[0][:sz, :],
                                                    [(position[0] + 0.5 * focus_width, position[1]),
                                                     (position[0] - 0.5 * focus_width, position[1])]))
                  p.fracture()
              if direction == '-x':
                  return p.rotate(0.5 * numpy.pi, position)
              elif direction == '+x':
                  return p.rotate(-0.5 * numpy.pi, position)
              elif direction == '-y':
                  return p.rotate(numpy.pi, position)
              else:
                  return p

          if __name__ == '__main__':
              # Examples

              # Negative resist example
              width = 0.45
              bend_radius = 50.0
              ring_radius = 20.0
              taper_len = 50.0
              input_gap = 150.0
              io_gap = 500.0
              wg_gap = 20.0
              ring_gaps = [0.06 + 0.02 * i for i in range(8)]

              ring = gdspy.Cell('NRing')
              ring.add(gdspy.Round((ring_radius, 0), ring_radius, ring_radius - width, tolerance=0.001))

              grat = gdspy.Cell('NGrat')
              grat.add(grating(0.626, 28, 0.5, 19, (0, 0), '+y', 1.55,
                               numpy.sin(numpy.pi * 8 / 180), 21.5, width,
                               tolerance=0.001))

              taper = gdspy.Cell('NTaper')
              taper.add(gdspy.Path(0.12, (0, 0)).segment(taper_len, '+y', final_width=width))

              c = gdspy.Cell('Negative')
              for i, gap in enumerate(ring_gaps):
                  path = gdspy.FlexPath([(input_gap * i, taper_len)], width=width,
                                        corners='circular bend', bend_radius=bend_radius,
                                        gdsii_path=True)
                  path.segment((0, 600 - wg_gap * i), relative=True)
                  path.segment((io_gap, 0), relative=True)
                  path.segment((0, 300 + wg_gap * i), relative=True)
                  c.add(path)
                  c.add(gdspy.CellReference(ring, (input_gap * i + width / 2 + gap, 300)))
              c.add(gdspy.CellArray(taper, len(ring_gaps), 1, (input_gap, 0), (0, 0)))
              c.add(gdspy.CellArray(grat, len(ring_gaps), 1, (input_gap, 0), (io_gap, 900 + taper_len)))

              # Positive resist example
              width = 0.45
              ring_radius = 20.0
              big_margin = 10.0
              small_margin = 5.0
              taper_len = 50.0
              bus_len = 400.0
              input_gap = 150.0
              io_gap = 500.0
              wg_gap = 20.0
              ring_gaps = [0.06 + 0.02 * i for i in range(8)]

              ring_margin = gdspy.Rectangle((0, -ring_radius - big_margin),
                                            (2 * ring_radius + big_margin, ring_radius + big_margin))
              ring_hole = gdspy.Round((ring_radius, 0), ring_radius, ring_radius - width, tolerance=0.001)
              ring_bus = gdspy.Path(small_margin, (0, taper_len), number_of_paths=2,
                                    distance=small_margin + width)
              ring_bus.segment(bus_len, '+y')

              p = gdspy.Path(small_margin, (0, 0), number_of_paths=2, distance=small_margin + width)
              p.segment(21.5, '+y', final_distance=small_margin + 19)
              grat = gdspy.Cell('PGrat').add(p)
              grat.add(grating(0.626, 28, 0.5, 19, (0, 0), '+y', 1.55,
                               numpy.sin(numpy.pi * 8 / 180), 21.5, tolerance=0.001))

              p = gdspy.Path(big_margin, (0, 0), number_of_paths=2, distance=big_margin + 0.12)
              p.segment(taper_len, '+y', final_width=small_margin, final_distance=small_margin + width)
              taper = gdspy.Cell('PTaper').add(p)

              c = gdspy.Cell('Positive')
              for i, gap in enumerate(ring_gaps):
                  path = gdspy.FlexPath([(input_gap * i, taper_len + bus_len)],
                                        width=[small_margin, small_margin],
                                        offset=small_margin + width, gdsii_path=True)
                  path.segment((0, 600 - bus_len - bend_radius - wg_gap * i), relative=True)
                  path.turn(bend_radius, 'r')
                  path.segment((io_gap - 2 * bend_radius, 0), relative=True)
                  path.turn(bend_radius, 'l')
                  path.segment((0, 300 - bend_radius + wg_gap * i), relative=True)
                  c.add(path)
                  dx = width / 2 + gap
                  c.add(gdspy.boolean(
                      gdspy.boolean(ring_bus, gdspy.copy(ring_margin, dx, 300), 'or', precision=1e-4),
                      gdspy.copy(ring_hole, dx, 300), 'not', precision=1e-4).translate(input_gap * i, 0))
              c.add(gdspy.CellArray(taper, len(ring_gaps), 1, (input_gap, 0), (0, 0)))
              c.add(gdspy.CellArray(grat, len(ring_gaps), 1, (input_gap, 0), (io_gap, 900 + taper_len)))

              # Save to a gds file and check out the output
              gdspy.write_gds('photonics.gds')
              gdspy.LayoutViewer()

   Using System Fonts
       This example uses matplotlib to render text using any typeface present in the system.  The glyph paths are then transformed into polygon arrays that can be used to create gdspy.PolygonSet objects.

       fonts.py

       fonts.gds

          ######################################################################
          #                                                                    #
          #  Copyright 2009-2019 Lucas Heitzmann Gabrielli.                    #
          #  This file is part of gdspy, distributed under the terms of the    #
          #  Boost Software License - Version 1.0.  See the accompanying       #
          #  LICENSE file or <http://www.boost.org/LICENSE_1_0.txt>            #
          #                                                                    #
          ######################################################################

          from matplotlib.font_manager import FontProperties
          from matplotlib.textpath import TextPath
          import gdspy

          def render_text(text, size=None, position=(0, 0), font_prop=None, tolerance=0.1):
              path = TextPath(position, text, size=size, prop=font_prop)
              polys = []
              xmax = position[0]
              for points, code in path.iter_segments():
                  if code == path.MOVETO:
                      c = gdspy.Curve(*points, tolerance=tolerance)
                  elif code == path.LINETO:
                      c.L(*points)
                  elif code == path.CURVE3:
                      c.Q(*points)
                  elif code == path.CURVE4:
                      c.C(*points)
                  elif code == path.CLOSEPOLY:
                      poly = c.get_points()
                      if poly.size > 0:
                          if poly[:, 0].min() < xmax:
                              i = len(polys) - 1
                              while i >= 0:
                                  if gdspy.inside(poly[:1], [polys[i]], precision=0.1 * tolerance)[0]:
                                      p = polys.pop(i)
                                      poly = gdspy.boolean([p], [poly], 'xor', precision=0.1 * tolerance,
                                                           max_points=0).polygons[0]
                                      break
                                  elif gdspy.inside(polys[i][:1], [poly], precision=0.1 * tolerance)[0]:
                                      p = polys.pop(i)
                                      poly = gdspy.boolean([p], [poly], 'xor', precision=0.1 * tolerance,
                                                           max_points=0).polygons[0]
                                  i -= 1
                          xmax = max(xmax, poly[:, 0].max())
                          polys.append(poly)
              return polys

          if __name__ == "__main__":
              fp = FontProperties(family='serif', style='italic')
              text = gdspy.PolygonSet(render_text('Text rendering', 10, font_prop=fp), layer=1)
              gdspy.Cell('TXT').add(text)
              gdspy.write_gds('fonts.gds')
              gdspy.LayoutViewer()

API REFERENCE
   Geometry Construction
   PolygonSet
       class gdspy.PolygonSet(polygons, layer=0, datatype=0)
              Bases: object

              Set of polygonal objects.

              Parameters

                     • polygons (iterable of array-like[N][2]) -- List containing the coordinates of the vertices of each polygon.

                     • layer (integer) -- The GDSII layer number for this element.

                     • datatype (integer) -- The GDSII datatype for this element (between 0 and 255).

              Variables

                     • polygons (list of numpy array[N][2]) -- Coordinates of the vertices of each polygon.

                     • layers (list of integer) -- The GDSII layer number for each element.

                     • datatypes (list of integer) -- The GDSII datatype for each element (between 0 and 255).

                 Notes

                        The last point should not be equal to the first (polygons are automatically closed).

                        The original GDSII specification supports only a maximum of 199 vertices per polygon.

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal  to  the  number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array of numbers, one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi (integer) -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of  this  number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              translate(dx, dy)
                     Translate this polygon.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

   Polygon
       class gdspy.Polygon(points, layer=0, datatype=0)
              Bases: gdspy.PolygonSet

              Polygonal geometric object.

              Parameters

                     • points (array-like[N][2]) -- Coordinates of the vertices of the polygon.

                     • layer (integer) -- The GDSII layer number for this element.

                     • datatype (integer) -- The GDSII datatype for this element (between 0 and 255).

                 Notes

                        The last point should not be equal to the first (polygons are automatically closed).

                        The original GDSII specification supports only a maximum of 199 vertices per polygon.
              Examples.sp
              >>> triangle_pts = [(0, 40), (15, 40), (10, 50)]
              >>> triangle = gdspy.Polygon(triangle_pts)
              >>> myCell.add(triangle)

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal  to  the  number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array of numbers, one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi (integer) -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of  this  number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              translate(dx, dy)
                     Translate this polygon.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

   Rectangle
       class gdspy.Rectangle(point1, point2, layer=0, datatype=0)
              Bases: gdspy.PolygonSet

              Rectangular geometric object.

              Parameters

                     • point1 (array-like[2]) -- Coordinates of a corner of the rectangle.

                     • point2 (array-like[2]) -- Coordinates of the corner of the rectangle opposite to point1.

                     • layer (integer) -- The GDSII layer number for this element.

                     • datatype (integer) -- The GDSII datatype for this element (between 0 and 255).
              Examples.sp
              >>> rectangle = gdspy.Rectangle((0, 0), (10, 20))
              >>> myCell.add(rectangle)

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal  to  the  number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array of numbers, one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi (integer) -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of  this  number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              translate(dx, dy)
                     Translate this polygon.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

   Round
       class gdspy.Round(center, radius, inner_radius=0, initial_angle=0, final_angle=0, tolerance=0.01, number_of_points=None, max_points=199, layer=0, datatype=0)
              Bases: gdspy.PolygonSet

              Circular geometric object.

              Represent a circle, ellipse, ring or their sections.

              Parameters

                     • center (array-like[2]) -- Coordinates of the center of the circle/ring.

                     • radius  (number,  array-like[2])  -- Radius of the circle/outer radius of the ring.  To build an ellipse an array of 2 numbers can be used, representing the radii in the horizontal
                       and vertical directions.

                     • inner_radius (number, array-like[2]) -- Inner radius of the ring. To build an elliptical hole, an array of 2 numbers can be used, representing the radii in the horizontal and  ver‐
                       tical directions.

                     • initial_angle (number) -- Initial angle of the circular/ring section (in radians).

                     • final_angle (number) -- Final angle of the circular/ring section (in radians).

                     • tolerance (float) -- Approximate curvature resolution.  The number of points is automatically calculated.

                     • number_of_points (integer or None) -- Manually define the number of vertices that form the object (polygonal approximation).  Overrides tolerance.

                     • max_points  (integer) -- If the number of points in the element is greater than max_points, it will be fractured in smaller polygons with at most max_points each.  If max_points is
                       zero no fracture will occur.

                     • layer (integer) -- The GDSII layer number for this element.

                     • datatype (integer) -- The GDSII datatype for this element (between 0 and 255).

                 Notes

                        The original GDSII specification supports only a maximum of 199 vertices per polygon.
              Examples.sp
              >>> circle = gdspy.Round((30, 5), 8)
              >>> ell_ring = gdspy.Round((50, 5), (8, 7), inner_radius=(5, 4))
              >>> pie_slice = gdspy.Round((30, 25), 8, initial_angle=0,
              ...                             final_angle=-5.0*numpy.pi/6.0)
              >>> arc = gdspy.Round((50, 25), 8, inner_radius=5,
              ...                       initial_angle=-5.0*numpy.pi/6.0,
              ...                       final_angle=0)

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal to the number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array  of  numbers,  one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi  (integer)  -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of this number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              translate(dx, dy)
                     Translate this polygon.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

   Text
       class gdspy.Text(text, size, position=(0, 0), horizontal=True, angle=0, layer=0, datatype=0)
              Bases: gdspy.PolygonSet

              Polygonal text object.

              Each letter is formed by a series of polygons.

              Parameters

                     • text (string) -- The text to be converted in geometric objects.

                     • size (number) -- Height of the character.  The width of a character and the distance between characters are this value multiplied by 5 / 9 and 8 / 9,  respectively.   For  vertical
                       text, the distance is multiplied by 11 / 9.

                     • position (array-like[2]) -- Text position (lower left corner).

                     • horizontal (bool) -- If True, the text is written from left to right; if False, from top to bottom.

                     • angle (number) -- The angle of rotation of the text.

                     • layer (integer) -- The GDSII layer number for these elements.

                     • datatype (integer) -- The GDSII datatype for this element (between 0 and 255).
              Examples.sp
              >>> text = gdspy.Text('Sample text', 20, (-10, -100))
              >>> myCell.add(text)

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal  to  the  number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array of numbers, one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi (integer) -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of  this  number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              translate(dx, dy)
                     Translate this polygon.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

   Path
       class gdspy.Path(width, initial_point=(0, 0), number_of_paths=1, distance=0)
              Bases: gdspy.PolygonSet

              Series of geometric objects that form a path or a collection of parallel paths.

              Parameters

                     • width (number) -- The width of each path.

                     • initial_point (array-like[2]) -- Starting position of the path.

                     • number_of_paths (positive integer) -- Number of parallel paths to create simultaneously.

                     • distance (number) -- Distance between the centers of adjacent paths.

              Variables

                     • x (number) -- Current position of the path in the x direction.

                     • y (number) -- Current position of the path in the y direction.

                     • w (number) -- Half-width of each path.

                     • n (integer) -- Number of parallel paths.

                     • direction ('+x', '-x', '+y', '-y' or number) -- Direction or angle (in radians) the path points to.

                     • distance (number) -- Distance between the centers of adjacent paths.

                     • length (number) -- Length of the central path axis.  If only one path is created, this is the real length of the path.

              translate(dx, dy)
                     Translate this object.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            Path

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            Path

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            Path

                        Notes

                               The direction of the path is not modified by this method and its width is scaled only by scalex.

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            Path

              segment(length, direction=None, final_width=None, final_distance=None, axis_offset=0, layer=0, datatype=0)
                     Add a straight section to the path.

                     Parameters

                            • length (number) -- Length of the section to add.

                            • direction ('+x', '-x', '+y', '-y' or number) -- Direction or angle (in radians) of rotation of the segment.

                            • final_width (number) -- If set, the paths of this segment will have their widths linearly changed from their current value to this one.

                            • final_distance (number) -- If set, the distance between paths is linearly change from its current value to this one along this segment.

                            • axis_offset (number) -- If set, the paths will be offset from their direction by this amount.

                            • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                            • datatype  (integer,  list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths,
                              the list is repeated.

                     Returns
                            out -- This object.

                     Return type
                            Path

              arc(radius, initial_angle, final_angle, tolerance=0.01, number_of_points=None, max_points=199, final_width=None, final_distance=None, layer=0, datatype=0)
                     Add a curved section to the path.

                     Parameters

                            • radius (number) -- Central radius of the section.

                            • initial_angle (number) -- Initial angle of the curve (in radians).

                            • final_angle (number) -- Final angle of the curve (in radians).

                            • tolerance (float) -- Approximate curvature resolution.  The number of points is automatically calculated.

                            • number_of_points (integer or None) -- Manually define the number of vertices that form the object (polygonal approximation).  Overrides tolerance.

                            • max_points (integer) -- If the number of points in the element is greater than max_points, it will be fractured in  smaller  polygons  with  at  most  max_points  each.   If
                              max_points is zero no fracture will occur.

                            • final_width (number) -- If set, the paths of this segment will have their widths linearly changed from their current value to this one.

                            • final_distance (number) -- If set, the distance between paths is linearly change from its current value to this one along this segment.

                            • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                            • datatype  (integer,  list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths,
                              the list is repeated.

                     Returns
                            out -- This object.

                     Return type
                            Path

                        Notes

                               The original GDSII specification supports only a maximum of 199 vertices per polygon.

              turn(radius, angle, tolerance=0.01, number_of_points=None, max_points=199, final_width=None, final_distance=None, layer=0, datatype=0)
                     Add a curved section to the path.

                     Parameters

                            • radius (number) -- Central radius of the section.

                            • angle ('r', 'l', 'rr', 'll' or number) -- Angle (in radians) of rotation of the path.  The values 'r' and 'l' represent 90-degree turns cw and ccw, respectively; the  values
                              'rr' and 'll' represent analogous 180-degree turns.

                            • tolerance (float) -- Approximate curvature resolution.  The number of points is automatically calculated.

                            • number_of_points (integer or None) -- Manually define the number of vertices that form the object (polygonal approximation).  Overrides tolerance.

                            • max_points  (integer)  --  If  the  number  of  points  in the element is greater than max_points, it will be fractured in smaller polygons with at most max_points each.  If
                              max_points is zero no fracture will occur.

                            • final_width (number) -- If set, the paths of this segment will have their widths linearly changed from their current value to this one.

                            • final_distance (number) -- If set, the distance between paths is linearly change from its current value to this one along this segment.

                            • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                            • datatype (integer, list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number  of  paths,
                              the list is repeated.

                     Returns
                            out -- This object.

                     Return type
                            Path

                        Notes

                               The original GDSII specification supports only a maximum of 199 vertices per polygon.

              parametric(curve_function, curve_derivative=None, tolerance=0.01, number_of_evaluations=5, max_points=199, final_width=None, final_distance=None, relative=True, layer=0, datatype=0)
                     Add a parametric curve to the path.

                     curve_function will be evaluated uniformly in the interval [0, 1] at least number_of_points times.  More points will be added to the curve at the midpoint between evaluations if that
                     points presents error larger than tolerance.

                     Parameters

                            • curve_function  (callable)  -- Function that defines the curve.  Must be a function of one argument (that varies from 0 to 1) that returns a 2-element array with the coordi‐
                              nates of the curve.

                            • curve_derivative (callable) -- If set, it should be the derivative of the curve function.  Must be a function of one argument (that varies from 0 to 1) that returns a 2-ele‐
                              ment array.  If None, the derivative will be calculated numerically.

                            • tolerance (number) -- Acceptable tolerance for the approximation of the curve function by a finite number of evaluations.

                            • number_of_evaluations (integer) -- Initial number of points where the curve function will be evaluated.  According to tolerance, more evaluations will be performed.

                            • max_points (integer) -- Elements will be fractured until each polygon has at most max_points.  If max_points is less than 4, no fracture will occur.

                            • final_width (number or function) -- If set to a number, the paths of this segment will have their widths linearly changed from their current value to this one.  If set to  a
                              function, it must be a function of one argument (that varies from 0 to 1) and returns the width of the path.

                            • final_distance  (number  or function) -- If set to a number, the distance between paths is linearly change from its current value to this one.  If set to a function, it must
                              be a function of one argument (that varies from 0 to 1) and returns the width of the path.

                            • relative (bool) -- If True, the return values of curve_function are used as offsets from the current path position, i.e., to ensure a continuous path, curve_function(0) must
                              be (0, 0).  Otherwise, they are used as absolute coordinates.

                            • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                            • datatype (integer, list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number  of  paths,
                              the list is repeated.

                     Returns
                            out -- This object.

                     Return type
                            Path

                        Notes

                               The norm of the vector returned by curve_derivative is not important.  Only the direction is used.

                               The original GDSII specification supports only a maximum of 199 vertices per polygon.
                     Examples.sp
                     >>> def my_parametric_curve(t):
                     ...         return (2**t, t**2)
                     >>> def my_parametric_curve_derivative(t):
                     ...         return (0.69315 * 2**t, 2 * t)
                     >>> my_path.parametric(my_parametric_curve,
                     ...                    my_parametric_curve_derivative)

              bezier(points, tolerance=0.01, number_of_evaluations=5, max_points=199, final_width=None, final_distance=None, relative=True, layer=0, datatype=0)
                     Add a Bezier curve to the path.

                     A Bezier curve is added to the path starting from its current position and finishing at the last point in the points array.

                     Parameters

                            • points (array-like[N][2]) -- Control points defining the Bezier curve.

                            • tolerance (number) -- Acceptable tolerance for the approximation of the curve function by a finite number of evaluations.

                            • number_of_evaluations (integer) -- Initial number of points where the curve function will be evaluated.  According to tolerance, more evaluations will be performed.

                            • max_points (integer) -- Elements will be fractured until each polygon has at most max_points.  If max_points is zero no fracture will occur.

                            • final_width  (number or function) -- If set to a number, the paths of this segment will have their widths linearly changed from their current value to this one.  If set to a
                              function, it must be a function of one argument (that varies from 0 to 1) and returns the width of the path.

                            • final_distance (number or function) -- If set to a number, the distance between paths is linearly change from its current value to this one.  If set to a function,  it  must
                              be a function of one argument (that varies from 0 to 1) and returns the width of the path.

                            • relative (bool) -- If True, all coordinates in the points array are used as offsets from the current path position, i.e., if the path is at (1, -2) and the last point in the
                              array is (10, 25), the constructed Bezier will end at (1 + 10, -2 + 25) = (11, 23).  Otherwise, the points are used as absolute coordinates.

                            • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                            • datatype  (integer,  list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths,
                              the list is repeated.

                     Returns
                            out -- This object.

                     Return type
                            Path

                        Notes

                               The original GDSII specification supports only a maximum of 199 vertices per polygon.

              smooth(points, angles=None, curl_start=1, curl_end=1, t_in=1, t_out=1, cycle=False, tolerance=0.01, number_of_evaluations=5, max_points=199, final_widths=None, final_distances=None, rela‐
              tive=True, layer=0, datatype=0)
                     Add a smooth interpolating curve through the given points.

                     Uses the Hobby algorithm
                     [1]_
                      to calculate a smooth interpolating curve made of cubic Bezier segments between each pair of points.

                     Parameters

                            • points (array-like[N][2]) -- Vertices in the interpolating curve.

                            • angles (array-like[N + 1] or None) -- Tangent angles at each point (in radians).  Any angles defined as None are automatically calculated.

                            • curl_start (number) -- Ratio between the mock curvatures at the first point and at its neighbor.  A value of 1 renders the first segment a good approximation for a  circular
                              arc.  A value of 0 will better approximate a straight segment.  It has no effect for closed curves or when an angle is defined for the first point.

                            • curl_end  (number)  -- Ratio between the mock curvatures at the last point and at its neighbor.  It has no effect for closed curves or when an angle is defined for the first
                              point.

                            • t_in (number or array-like[N + 1]) -- Tension parameter when arriving at each point.  One value per point or a single value used for all points.

                            • t_out (number or array-like[N + 1]) -- Tension parameter when leaving each point.  One value per point or a single value used for all points.

                            • cycle (bool) -- If True, calculates control points for a closed curve, with an additional segment connecting the first and last points.

                            • tolerance (number) -- Acceptable tolerance for the approximation of the curve function by a finite number of evaluations.

                            • number_of_evaluations (integer) -- Initial number of points where the curve function will be evaluated.  According to tolerance, more evaluations will be performed.

                            • max_points (integer) -- Elements will be fractured until each polygon has at most max_points.  If max_points is zero no fracture will occur.

                            • final_widths (array-like[M]) -- Each element corresponds to the final width of a segment in the whole curve.  If an element is a number, the paths of this segment will  have
                              their  widths  linearly changed to this value.  If a function, it must be a function of one argument (that varies from 0 to 1) and returns the width of the path.  The length
                              of the array must be equal to the number of segments in the curve, i.e., M = N - 1 for an open curve and M = N for a closed one.

                            • final_distances (array-like[M]) -- Each element corresponds to the final distance between paths of a segment in the whole curve.  If an element is a number, the distance be‐
                              tween paths is linearly change to this value.  If a function, it must be a function of one argument (that varies from 0 to 1) and returns the width of the path.  The  length
                              of the array must be equal to the number of segments in the curve, i.e., M = N - 1 for an open curve and M = N for a closed one.

                            • relative (bool) -- If True, all coordinates in the points array are used as offsets from the current path position, i.e., if the path is at (1, -2) and the last point in the
                              array is (10, 25), the constructed curve will end at (1 + 10, -2 + 25) = (11, 23).  Otherwise, the points are used as absolute coordinates.

                            • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                            • datatype  (integer,  list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths,
                              the list is repeated.

                     Returns
                            out -- This object.

                     Return type
                            Path

                        Notes

                               The original GDSII specification supports only a maximum of 199 vertices per polygon.
                     References

              [1]  Hobby, J.D.  Discrete Comput. Geom. (1986) 1: 123.  DOI: 10.1007/BF02187690

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal to the number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array  of  numbers,  one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi  (integer)  -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of this number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

   PolyPath
       class gdspy.PolyPath(points, width, number_of_paths=1, distance=0, corners='miter', ends='flush', max_points=199, layer=0, datatype=0)
              Bases: gdspy.PolygonSet

              Series of geometric objects that form a polygonal path or a collection of parallel polygonal paths.

              Deprecated since version 1.4: PolyPath is deprecated in favor of FlexPath and will be removed in a future version of Gdspy.

              Parameters

                     • points (array-like[N][2]) -- Points along the center of the path.

                     • width (number or array-like[N]) -- Width of the path.  If an array is given, width at each endpoint.

                     • number_of_paths (positive integer) -- Number of parallel paths to create simultaneously.

                     • distance (number or array-like[N]) -- Distance between the centers of adjacent paths.  If an array is given, distance at each endpoint.

                     • corners ('miter' or 'bevel') -- Type of joins.

                     • ends ('flush', 'round', 'extended') -- Type of end caps for the paths.

                     • max_points (integer) -- The paths will be fractured in polygons with at most max_points (must be at least 4).  If max_points is zero no fracture will occur.

                     • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                     • datatype (integer, list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths, the list
                       is repeated.

                 Notes

                        The bevel join will give strange results if the number of paths is greater than 1.

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal to the number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array  of  numbers,  one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi  (integer)  -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of this number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              translate(dx, dy)
                     Translate this polygon.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

   L1Path
       class gdspy.L1Path(initial_point, direction, width, length, turn, number_of_paths=1, distance=0, max_points=199, layer=0, datatype=0)
              Bases: gdspy.PolygonSet

              Series of geometric objects that form a path or a collection of parallel paths with Manhattan geometry.

              Deprecated since version 1.4: L1Path is deprecated in favor of FlexPath and will be removed in a future version of Gdspy.

              Parameters

                     • initial_point (array-like[2]) -- Starting position of the path.

                     • direction ('+x', '+y', '-x', '-y') -- Starting direction of the path.

                     • width (number) -- The initial width of each path.

                     • length (array-like) -- Lengths of each section to add.

                     • turn (array-like) -- Direction to turn before each section.  The sign indicate the turn direction (ccw is positive), and the modulus is a multiplicative factor for the  path  width
                       after each turn.  Must have 1 element less then length.

                     • number_of_paths (positive integer) -- Number of parallel paths to create simultaneously.

                     • distance (number) -- Distance between the centers of adjacent paths.

                     • max_points (integer) -- The paths will be fractured in polygons with at most max_points (must be at least 6).  If max_points is zero no fracture will occur.

                     • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                     • datatype (integer, list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths, the list
                       is repeated.

              Variables

                     • x (number) -- Final position of the path in the x direction.

                     • y (number) -- Final position of the path in the y direction.

                     • direction ('+x', '-x', '+y', '-y' or number) -- Direction or angle (in radians) the path points to.  The numerical angle is returned only after a rotation of the object.
              Examples.sp
              >>> length = [10, 30, 15, 15, 15, 15, 10]
              >>> turn = [1, -1, -1, 3, -1, 1]
              >>> l1path = gdspy.L1Path((0, 0), '+x', 2, length, turn)
              >>> myCell.add(l1path)

              rotate(angle, center=(0, 0))
                     Rotate this object.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            L1Path

              area(by_spec=False)
                     Calculate the total area of this polygon set.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              fillet(radius, points_per_2pi=128, max_points=199, precision=0.001)
                     Round the corners of these polygons and fractures them into polygons with less vertices if necessary.

                     Parameters

                            • radius (number, array-like) -- Radius of the corners.  If number: all corners filleted by that amount.  If array: specify fillet radii on a per-polygon basis (length must be
                              equal  to  the  number of polygons in this PolygonSet).  Each element in the array can be a number (all corners filleted by the same amount) or another array of numbers, one
                              per polygon vertex.  Alternatively, the array can be flattened to have one radius per PolygonSet vertex.

                            • points_per_2pi (integer) -- Number of vertices used to approximate a full circle.  The number of vertices in each corner of the polygon will be the fraction of  this  number
                              corresponding to the angle encompassed by that corner with respect to 2 pi.

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5, otherwise the resulting polygon is not fractured).

                            • precision (float) -- Desired precision for rounding vertice coordinates in case of fracturing.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              fracture(max_points=199, precision=0.001)
                     Slice these polygons in the horizontal and vertical directions so that each resulting piece has at most max_points.  This operation occurs in place.

                     Parameters

                            • max_points (integer) -- Maximal number of points in each resulting polygon (at least 5 for the fracture to occur).

                            • precision (float) -- Desired precision for rounding vertice coordinates.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              get_bounding_box()
                     Calculate the bounding box of the polygons.

                     Returns
                            out -- Bounding box of this polygon in the form [[x_min, y_min], [x_max, y_max]], or None if the polygon is empty.

                     Return type
                            Numpy array[2, 2] or None

              mirror(p1, p2=(0, 0))
                     Mirror the polygons over a line through points 1 and 2

                     Parameters

                            • p1 (array-like[2]) -- first point defining the reflection line

                            • p2 (array-like[2]) -- second point defining the reflection line

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              scale(scalex, scaley=None, center=(0, 0))
                     Scale this object.

                     Parameters

                            • scalex (number) -- Scaling factor along the first axis.

                            • scaley (number or None) -- Scaling factor along the second axis.  If None, same as scalex.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              translate(dx, dy)
                     Translate this polygon.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            PolygonSet

   FlexPath
       class gdspy.FlexPath(points, width, offset=0, corners='natural', ends='flush', bend_radius=None, tolerance=0.01, precision=0.001, max_points=199, gdsii_path=False, width_transform=True, layer=0,
       datatype=0)
              Bases: object

              Path object.

              This class keeps information about the constructive parameters of the path and calculates its boundaries only upon request.

              It can be stored as a proper path element in the GDSII format, unlike Path.  In this case, the width must be constant along the whole path.

              Parameters

                     • points (array-like[N][2]) -- Points along the center of the path.

                     • width (number, list) -- Width of each parallel path being created.  The number of parallel paths being created is defined by the length of this list.

                     • offset  (number,  list)  --  Offsets of each parallel path from the center.  If width is not a list, the length of this list is used to determine the number of parallel paths being
                       created.  Otherwise, offset must be a list with the same length as width, or a number, which is used as distance between adjacent paths.

                     • corners ('natural', 'miter', 'bevel', 'round', 'smooth', 'circular bend', callable, list) -- Type of joins.  A callable must receive 6 arguments (vertex and direction  vector  from
                       both segments being joined, the center and width of the path) and return a list of vertices that make the join.  A list can be used to define the join for each parallel path.

                     • ends  ('flush',  'extended', 'round', 'smooth', 2-tuple, callable, list) -- Type of end caps for the paths.  A 2-element tuple represents the start and end extensions to the paths.
                       A callable must receive 4 arguments (vertex and direction vectors from both sides of the path and return a list of vertices that make the end cap.  A list can be used to define the
                       end type for each parallel path.

                     • bend_radius (number, list) -- Bend radii for each path when corners is 'circular bend'.  It has no effect for other corner types.

                     • tolerance (number) -- Tolerance used to draw the paths and calculate joins.

                     • precision (number) -- Precision for rounding the coordinates of vertices when fracturing the final polygonal boundary.

                     • max_points (integer) -- If the number of points in the polygonal path boundary is greater than max_points, it will be fractured in smaller polygons with at  most  max_points  each.
                       If max_points is zero no fracture will occur.

                     • gdsii_path (bool) -- If True, treat this object as a GDSII path element.  Otherwise, it will be converted into polygonal boundaries when required.

                     • width_transform  (bool)  -- If gdsii_path is True, this flag indicates whether the width of the path should transform when scaling this object.  It has no effect when gdsii_path is
                       False.

                     • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                     • datatype (integer, list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths, the list
                       is repeated.

                 Notes

                        The value of tolerance should not be smaller than precision, otherwise there would be wasted computational effort in calculating the paths.

              get_polygons(by_spec=False)
                     Calculate the polygonal boundaries described by this path.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with the polygons of each individual pair (layer, datatype).

                     Returns
                            out -- List containing the coordinates of the vertices of each polygon, or dictionary with the list of polygons (if by_spec is True).

                     Return type
                            list of array-like[N][2] or dictionary

              to_polygonset()
                     Create a PolygonSet representation of this object.

                     The resulting object will be fractured according to the parameter max_points used when instantiating this object.

                     Returns
                            out -- A PolygonSet that contains all boundaries for this path.  If the path is empty, returns None.

                     Return type
                            PolygonSet or None

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     If FlexPath.gdsii_path is True, GDSII path elements are created instead of boundaries.  Such paths do not support variable widths, but their memeory footprint is  smaller  than  full
                     polygonal boundaries.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              area(by_spec=False)
                     Calculate the total area of this object.

                     This functions creates a PolgonSet from this object and calculates its area, which means it is computationally expensive.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              translate(dx, dy)
                     Translate this path.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction

                            • dy (number) -- Distance to move in the y-direction

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              rotate(angle, center=(0, 0))
                     Rotate this path.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              scale(scale, center=(0, 0))
                     Scale this path.

                     Parameters

                            • scale (number) -- Scaling factor.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              transform(translation, rotation, scale, x_reflection, array_trans=None)
                     Apply a transform to this path.

                     Parameters

                            • translation (Numpy array[2]) -- Translation vector.

                            • rotation (number) -- Rotation angle.

                            • scale (number) -- Scaling factor.

                            • x_reflection (bool) -- Reflection around the first axis.

                            • array_trans (Numpy aray[2]) -- Translation vector before rotation and reflection.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

                        Notes

                               Applies the transformations in the same order as a CellReference or a CellArray.  If width_transform is False, the widths are not scaled.

              segment(end_point, width=None, offset=None, relative=False)
                     Add a straight section to the path.

                     Parameters

                            • end_point (array-like[2]) -- End position of the straight segment.

                            • width  (number,  list)  -- If a number, all parallel paths are linearly tapered to this width along the segment.  A list can be used where each element defines the width for
                              one of the parallel paths in this object.  This argument has no effect if the path was created with gdsii_path True.

                            • offset (number, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  A list can be used where  each  element  de‐
                              fines the absolute offset (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, end_point is used as an offset from the current path position, i.e., if the path is at (1, -2) and the end_point is (10, 25), the segment will be
                              constructed from (1, -2) to (1 + 10, -2 + 25) = (11, 23).  Otherwise, end_point is used as an absolute coordinate.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              arc(radius, initial_angle, final_angle, width=None, offset=None)
                     Add a circular arc section to the path.

                     Parameters

                            • radius (number) -- Radius of the circular arc.

                            • initial_angle (number) -- Initial angle of the arc.

                            • final_angle (number) -- Final angle of the arc.

                            • width  (number,  list)  -- If a number, all parallel paths are linearly tapered to this width along the segment.  A list can be used where each element defines the width for
                              one of the parallel paths in this object.  This argument has no effect if the path was created with gdsii_path True.

                            • offset (number, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  A list can be used where  each  element  de‐
                              fines the absolute offset (not offset increase) for one of the parallel paths in this object.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              turn(radius, angle, width=None, offset=None)
                     Add a circular turn to the path.

                     The initial angle of the arc is calculated from the last path segment.

                     Parameters

                            • radius (number) -- Radius of the circular arc.

                            • angle  ('r', 'l', 'rr', 'll' or number) -- Angle (in radians) of rotation of the path.  The values 'r' and 'l' represent 90-degree turns cw and ccw, respectively; the values
                              'rr' and 'll' represent analogous 180-degree turns.

                            • width (number, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  A list can be used where each element defines  the  width  for
                              one of the parallel paths in this object.  This argument has no effect if the path was created with gdsii_path True.

                            • offset  (number,  list)  -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  A list can be used where each element de‐
                              fines the absolute offset (not offset increase) for one of the parallel paths in this object.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              parametric(curve_function, width=None, offset=None, relative=True)
                     Add a parametric curve to the path.

                     Parameters

                            • curve_function (callable) -- Function that defines the curve.  Must be a function of one argument (that varies from 0 to 1) that returns a 2-element Numpy array with the co‐
                              ordinates of the curve.

                            • width (number, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  A list can be used where each element defines  the  width  for
                              one of the parallel paths in this object.  This argument has no effect if the path was created with gdsii_path True.

                            • offset  (number,  list)  -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  A list can be used where each element de‐
                              fines the absolute offset (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, the return values of curve_function are used as offsets from the current path position, i.e., to ensure a continuous path, curve_function(0) must
                              be (0, 0).  Otherwise, they are used as absolute coordinates.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              bezier(points, width=None, offset=None, relative=True)
                     Add a Bezier curve to the path.

                     A Bezier curve is added to the path starting from its current position and finishing at the last point in the points array.

                     Parameters

                            • points (array-like[N][2]) -- Control points defining the Bezier curve.

                            • width (number, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  A list can be used where each element defines  the  width  for
                              one of the parallel paths in this object.  This argument has no effect if the path was created with gdsii_path True.

                            • offset  (number,  list)  -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  A list can be used where each element de‐
                              fines the absolute offset (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, all coordinates in the points array are used as offsets from the current path position, i.e., if the path is at (1, -2) and the last point in the
                              array is (10, 25), the constructed Bezier will end at (1 + 10, -2 + 25) = (11, 23).  Otherwise, the points are used as absolute coordinates.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

              smooth(points, angles=None, curl_start=1, curl_end=1, t_in=1, t_out=1, cycle=False, width=None, offset=None, relative=True)
                     Add a smooth interpolating curve through the given points.

                     Uses the Hobby algorithm
                     [1]_
                      to calculate a smooth interpolating curve made of cubic Bezier segments between each pair of points.

                     Parameters

                            • points (array-like[N][2]) -- Vertices in the interpolating curve.

                            • angles (array-like[N + 1] or None) -- Tangent angles at each point (in radians).  Any angles defined as None are automatically calculated.

                            • curl_start (number) -- Ratio between the mock curvatures at the first point and at its neighbor.  A value of 1 renders the first segment a good approximation for a  circular
                              arc.  A value of 0 will better approximate a straight segment.  It has no effect for closed curves or when an angle is defined for the first point.

                            • curl_end  (number)  -- Ratio between the mock curvatures at the last point and at its neighbor.  It has no effect for closed curves or when an angle is defined for the first
                              point.

                            • t_in (number or array-like[N + 1]) -- Tension parameter when arriving at each point.  One value per point or a single value used for all points.

                            • t_out (number or array-like[N + 1]) -- Tension parameter when leaving each point.  One value per point or a single value used for all points.

                            • cycle (bool) -- If True, calculates control points for a closed curve, with an additional segment connecting the first and last points.

                            • width (number, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  A list can be used where each element defines  the  width  for
                              one of the parallel paths in this object.  This argument has no effect if the path was created with gdsii_path True.

                            • offset  (number,  list)  -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  A list can be used where each element de‐
                              fines the absolute offset (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, all coordinates in the points array are used as offsets from the current path position, i.e., if the path is at (1, -2) and the last point in the
                              array is (10, 25), the constructed curve will end at (1 + 10, -2 + 25) = (11, 23).  Otherwise, the points are used as absolute coordinates.

                     Returns
                            out -- This object.

                     Return type
                            FlexPath

                        Notes

                               Arguments width and offset are repeated for each cubic Bezier that composes this path element.
                     References

              [1]  Hobby, J.D.  Discrete Comput. Geom. (1986) 1: 123.  DOI: 10.1007/BF02187690

   RobustPath
       class gdspy.RobustPath(initial_point, width, offset=0, ends='flush', tolerance=0.01, precision=0.001, max_points=199, max_evals=1000, gdsii_path=False, width_transform=True, layer=0, datatype=0)
              Bases: object

              Path object with lazy evaluation.

              This class keeps information about the constructive parameters of the path and calculates its boundaries only upon request.  The benefits are that joins and path components  can  be  calcu‐
              lated automatically to ensure continuity (except in extreme cases).

              It can be stored as a proper path element in the GDSII format, unlike Path.  In this case, the width must be constant along the whole path.

              The downside of RobustPath is that it is more computationally expensive than the other path classes.

              Parameters

                     • initial_point (array-like[2]) -- Starting position of the path.

                     • width (number, list) -- Width of each parallel path being created.  The number of parallel paths being created is defined by the length of this list.

                     • offset  (number,  list)  --  Offsets of each parallel path from the center.  If width is not a list, the length of this list is used to determine the number of parallel paths being
                       created.  Otherwise, offset must be a list with the same length as width, or a number, which is used as distance between adjacent paths.

                     • ends ('flush', 'extended', 'round', 'smooth', 2-tuple, list) -- Type of end caps for the paths.  A 2-element tuple represents the start and end extensions to the paths.  A list can
                       be used to define the end type for each parallel path.

                     • tolerance (number) -- Tolerance used to draw the paths and calculate joins.

                     • precision (number) -- Precision for rounding the coordinates of vertices when fracturing the final polygonal boundary.

                     • max_points (integer) -- If the number of points in the polygonal path boundary is greater than max_points, it will be fractured in smaller polygons with at  most  max_points  each.
                       If max_points is zero no fracture will occur.

                     • max_evals (integer) -- Limit to the maximal number of evaluations when calculating each path component.

                     • gdsii_path (bool) -- If True, treat this object as a GDSII path element.  Otherwise, it will be converted into polygonal boundaries when required.

                     • width_transform  (bool)  -- If gdsii_path is True, this flag indicates whether the width of the path should transform when scaling this object.  It has no effect when gdsii_path is
                       False.

                     • layer (integer, list) -- The GDSII layer numbers for the elements of each path.  If the number of layers in the list is less than the number of paths, the list is repeated.

                     • datatype (integer, list) -- The GDSII datatype for the elements of each path (between 0 and 255).  If the number of datatypes in the list is less than the number of paths, the list
                       is repeated.

                 Notes

                        The value of tolerance should not be smaller than precision, otherwise there would be wasted computational effort in calculating the paths.

              grad(u, arm=0, side='-')
                     Calculate the direction vector of each parallel path.

                     Parameters

                            • u (number) -- Position along the RobustPath to compute.  This argument can range from 0 (start of the path) to len(self) (end of the path).

                            • arm (-1, 0, 1) -- Wether to calculate one of the path boundaries (-1 or 1) or its central spine (0).

                            • side ('-' or '+') -- At path joins, whether to calculate the direction using the component before or after the join.

                     Returns
                            out -- Direction vectors for each of the N parallel paths in this object.

                     Return type
                            Numpy array[N, 2]

              width(u)
                     Calculate the width of each parallel path.

                     Parameters
                            u (number) -- Position along the RobustPath to compute.  This argument can range from 0 (start of the path) to len(self) (end of the path).

                     Returns
                            out -- Width for each of the N parallel paths in this object.

                     Return type
                            Numpy array[N]

              get_polygons(by_spec=False)
                     Calculate the polygonal boundaries described by this path.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with the polygons of each individual pair (layer, datatype).

                     Returns
                            out -- List containing the coordinates of the vertices of each polygon, or dictionary with the list of polygons (if by_spec is True).

                     Return type
                            list of array-like[N][2] or dictionary

              to_polygonset()
                     Create a PolygonSet representation of this object.

                     The resulting object will be fractured according to the parameter max_points used when instantiating this object.

                     Returns
                            out -- A PolygonSet that contains all boundaries for this path.  If the path is empty, returns None.

                     Return type
                            PolygonSet or None

              to_gds(multiplier)
                     Convert this object to a series of GDSII elements.

                     If RobustPath.gdsii_path is True, GDSII path elements are created instead of boundaries.  Such paths do not support variable widths, but their memeory footprint is smaller than  full
                     polygonal boundaries.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII elements.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              area(by_spec=False)
                     Calculate the total area of this object.

                     This functions creates a PolgonSet from this object and calculates its area, which means it is computationally expensive.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with {(layer, datatype): area}.

                     Returns
                            out -- Area of this object.

                     Return type
                            number, dictionary

              translate(dx, dy)
                     Translate this path.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction

                            • dy (number) -- Distance to move in the y-direction

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              rotate(angle, center=(0, 0))
                     Rotate this path.

                     Parameters

                            • angle (number) -- The angle of rotation (in radians).

                            • center (array-like[2]) -- Center point for the rotation.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              scale(scale, center=(0, 0))
                     Scale this path.

                     Parameters

                            • scale (number) -- Scaling factor.

                            • center (array-like[2]) -- Center point for the scaling operation.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              transform(translation, rotation, scale, x_reflection, array_trans=None)
                     Apply a transform to this path.

                     Parameters

                            • translation (Numpy array[2]) -- Translation vector.

                            • rotation (number) -- Rotation angle.

                            • scale (number) -- Scaling factor.

                            • x_reflection (bool) -- Reflection around the first axis.

                            • array_trans (Numpy aray[2]) -- Translation vector before rotation and reflection.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

                        Notes

                               Applies the transformations in the same order as a CellReference or a CellArray.  If width_transform is False, the widths are not scaled.

              segment(end_point, width=None, offset=None, relative=False)
                     Add a straight section to the path.

                     Parameters

                            • end_point (array-like[2]) -- End position of the straight segment.

                            • width  (number,  callable,  list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  If this is callable, it must be a function of one
                              argument (that varies from 0 to 1) that returns the width of the path.  A list can be used where each element (number or callable) defines the width for one of the  parallel
                              paths in this object.

                            • offset  (number, callable, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  If this is callable, it must be a
                              function of one argument (that varies from 0 to 1) that returns the offset increase.  A list can be used where each element (number or callable) defines the absolute  offset
                              (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, end_point is used as an offset from the current path position, i.e., if the path is at (1, -2) and the end_point is (10, 25), the segment will be
                              constructed from (1, -2) to (1 + 10, -2 + 25) = (11, 23).  Otherwise, end_point is used as an absolute coordinate.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              arc(radius, initial_angle, final_angle, width=None, offset=None)
                     Add a circular arc section to the path.

                     Parameters

                            • radius (number) -- Radius of the circular arc.

                            • initial_angle (number) -- Initial angle of the arc.

                            • final_angle (number) -- Final angle of the arc.

                            • width  (number,  callable,  list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  If this is callable, it must be a function of one
                              argument (that varies from 0 to 1) that returns the width of the path.  A list can be used where each element (number or callable) defines the width for one of the  parallel
                              paths in this object.

                            • offset  (number, callable, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  If this is callable, it must be a
                              function of one argument (that varies from 0 to 1) that returns the offset increase.  A list can be used where each element (number or callable) defines the absolute  offset
                              (not offset increase) for one of the parallel paths in this object.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              turn(radius, angle, width=None, offset=None)
                     Add a circular turn to the path.

                     The initial angle of the arc is calculated from an average of the current directions of all parallel paths in this object.

                     Parameters

                            • radius (number) -- Radius of the circular arc.

                            • angle  ('r', 'l', 'rr', 'll' or number) -- Angle (in radians) of rotation of the path.  The values 'r' and 'l' represent 90-degree turns cw and ccw, respectively; the values
                              'rr' and 'll' represent analogous 180-degree turns.

                            • width (number, callable, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  If this is callable, it must be a  function  of  one
                              argument  (that varies from 0 to 1) that returns the width of the path.  A list can be used where each element (number or callable) defines the width for one of the parallel
                              paths in this object.

                            • offset (number, callable, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  If this is callable, it must be  a
                              function  of one argument (that varies from 0 to 1) that returns the offset increase.  A list can be used where each element (number or callable) defines the absolute offset
                              (not offset increase) for one of the parallel paths in this object.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              parametric(curve_function, curve_derivative=None, width=None, offset=None, relative=True)
                     Add a parametric curve to the path.

                     Parameters

                            • curve_function (callable) -- Function that defines the curve.  Must be a function of one argument (that varies from 0 to 1) that returns a 2-element Numpy array with the co‐
                              ordinates of the curve.

                            • curve_derivative (callable) -- If set, it should be the derivative of the curve function.  Must be a function of one argument (that varies from 0 to 1) that returns a 2-ele‐
                              ment Numpy array.  If None, the derivative will be calculated numerically.

                            • width (number, callable, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  If this is callable, it must be a  function  of  one
                              argument  (that varies from 0 to 1) that returns the width of the path.  A list can be used where each element (number or callable) defines the width for one of the parallel
                              paths in this object.

                            • offset (number, callable, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  If this is callable, it must be  a
                              function  of one argument (that varies from 0 to 1) that returns the offset increase.  A list can be used where each element (number or callable) defines the absolute offset
                              (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, the return values of curve_function are used as offsets from the current path position, i.e., to ensure a continuous path, curve_function(0) must
                              be (0, 0).  Otherwise, they are used as absolute coordinates.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              bezier(points, width=None, offset=None, relative=True)
                     Add a Bezier curve to the path.

                     A Bezier curve is added to the path starting from its current position and finishing at the last point in the points array.

                     Parameters

                            • points (array-like[N][2]) -- Control points defining the Bezier curve.

                            • width (number, callable, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  If this is callable, it must be a  function  of  one
                              argument  (that varies from 0 to 1) that returns the width of the path.  A list can be used where each element (number or callable) defines the width for one of the parallel
                              paths in this object.

                            • offset (number, callable, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  If this is callable, it must be  a
                              function  of one argument (that varies from 0 to 1) that returns the offset increase.  A list can be used where each element (number or callable) defines the absolute offset
                              (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, all coordinates in the points array are used as offsets from the current path position, i.e., if the path is at (1, -2) and the last point in the
                              array is (10, 25), the constructed Bezier will end at (1 + 10, -2 + 25) = (11, 23).  Otherwise, the points are used as absolute coordinates.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

              smooth(points, angles=None, curl_start=1, curl_end=1, t_in=1, t_out=1, cycle=False, width=None, offset=None, relative=True)
                     Add a smooth interpolating curve through the given points.

                     Uses the Hobby algorithm
                     [1]_
                      to calculate a smooth interpolating curve made of cubic Bezier segments between each pair of points.

                     Parameters

                            • points (array-like[N][2]) -- Vertices in the interpolating curve.

                            • angles (array-like[N + 1] or None) -- Tangent angles at each point (in radians).  Any angles defined as None are automatically calculated.

                            • curl_start (number) -- Ratio between the mock curvatures at the first point and at its neighbor.  A value of 1 renders the first segment a good approximation for a  circular
                              arc.  A value of 0 will better approximate a straight segment.  It has no effect for closed curves or when an angle is defined for the first point.

                            • curl_end  (number)  -- Ratio between the mock curvatures at the last point and at its neighbor.  It has no effect for closed curves or when an angle is defined for the first
                              point.

                            • t_in (number or array-like[N + 1]) -- Tension parameter when arriving at each point.  One value per point or a single value used for all points.

                            • t_out (number or array-like[N + 1]) -- Tension parameter when leaving each point.  One value per point or a single value used for all points.

                            • cycle (bool) -- If True, calculates control points for a closed curve, with an additional segment connecting the first and last points.

                            • width (number, callable, list) -- If a number, all parallel paths are linearly tapered to this width along the segment.  If this is callable, it must be a  function  of  one
                              argument  (that varies from 0 to 1) that returns the width of the path.  A list can be used where each element (number or callable) defines the width for one of the parallel
                              paths in this object.

                            • offset (number, callable, list) -- If a number, all parallel paths offsets are linearly increased by this amount (which can be negative).  If this is callable, it must be  a
                              function  of one argument (that varies from 0 to 1) that returns the offset increase.  A list can be used where each element (number or callable) defines the absolute offset
                              (not offset increase) for one of the parallel paths in this object.

                            • relative (bool) -- If True, all coordinates in the points array are used as offsets from the current path position, i.e., if the path is at (1, -2) and the last point in the
                              array is (10, 25), the constructed curve will end at (1 + 10, -2 + 25) = (11, 23).  Otherwise, the points are used as absolute coordinates.

                     Returns
                            out -- This object.

                     Return type
                            RobustPath

                        Notes

                               Arguments width and offset are repeated for each cubic Bezier that composes this path element.
                     References

              [1]  Hobby, J.D.  Discrete Comput. Geom. (1986) 1: 123.  DOI: 10.1007/BF02187690

   Curve
       class gdspy.Curve(x, y=0, tolerance=0.01)
              Bases: object

              Generation of curves loosely based on SVG paths.

              Short summary of available methods:
                                                                                       ┌────────┬───────────────────────────────┐
                                                                                       │ Method │ Primitive                     │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ L/l    │ Line segments                 │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ H/h    │ Horizontal line segments      │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ V/v    │ Vertical line segments        │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ C/c    │ Cubic Bezier curve            │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ S/s    │ Smooth cubic Bezier curve     │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ Q/q    │ Quadratic Bezier curve        │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ T/t    │ Smooth quadratic Bezier curve │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ B/b    │ General degree Bezier curve   │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ I/i    │ Smooth interpolating curve    │
                                                                                       ├────────┼───────────────────────────────┤
                                                                                       │ arc    │ Elliptical arc                │
                                                                                       └────────┴───────────────────────────────┘

              The uppercase version of the methods considers that all coordinates are absolute, whereas the lowercase considers that they are relative to the current end point of the curve.

              Parameters

                     • x (number) -- X-coordinate of the starting point of the curve.  If this is a complex number, the value of y is ignored and the starting point becomes (x.real, x.imag).

                     • y (number) -- Y-coordinate of the starting point of the curve.

                     • tolerance (number) -- Tolerance used to calculate a polygonal approximation to the curve.

                 Notes

                        In all methods of this class that accept coordinate pairs, a single complex number can be passed to be split into its real and imaginary parts.  This feature can be useful in  ex‐
                        pressing coordinates in polar form.

                        All commands follow the SVG 2 specification, except for elliptical arcs and smooth interpolating curves, which are inspired by the Metapost syntax.
              Examples.sp
              >>> curve = gdspy.Curve(3, 4).H(1).q(0.5, 1, 2j).L(2 + 3j, 2, 2)
              >>> pol = gdspy.Polygon(curve.get_points())

              get_points()
                     Get the polygonal points that approximate this curve.

                     Returns
                            out -- Vertices of the polygon.

                     Return type
                            Numpy array[N, 2]

              L(*xy) Add straight line segments to the curve.

                     Parameters
                            xy (numbers) -- Endpoint coordinates of the line segments.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              l(*xy) Add straight line segments to the curve.

                     Parameters
                            xy (numbers) -- Endpoint coordinates of the line segments relative to the current end point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              H(*x)  Add horizontal line segments to the curve.

                     Parameters
                            x (numbers) -- Endpoint x-coordinates of the line segments.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              h(*x)  Add horizontal line segments to the curve.

                     Parameters
                            x (numbers) -- Endpoint x-coordinates of the line segments relative to the current end point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              V(*y)  Add vertical line segments to the curve.

                     Parameters
                            y (numbers) -- Endpoint y-coordinates of the line segments.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              v(*y)  Add vertical line segments to the curve.

                     Parameters
                            y (numbers) -- Endpoint y-coordinates of the line segments relative to the current end point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              arc(radius, initial_angle, final_angle, rotation=0)
                     Add an elliptical arc to the curve.

                     Parameters

                            • radius (number, array-like[2]) -- Arc radius.  An elliptical arc can be created by passing an array with 2 radii.

                            • initial_angle (number) -- Initial angle of the arc (in radians).

                            • final_angle (number) -- Final angle of the arc (in radians).

                            • rotation (number) -- Rotation of the axis of the ellipse.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              C(*xy) Add cubic Bezier curves to the curve.

                     Parameters
                            xy  (numbers)  --  Coordinate  pairs. Each set of 3 pairs are interpreted as the control point at the beginning of the curve, the control point at the end of the curve and the
                            endpoint of the curve.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              c(*xy) Add cubic Bezier curves to the curve.

                     Parameters
                            xy (numbers) -- Coordinate pairs. Each set of 3 pairs are interpreted as the control point at the beginning of the curve, the control point at the end of  the  curve  and  the
                            endpoint of the curve.  All coordinates are relative to the current end point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              S(*xy) Add smooth cubic Bezier curves to the curve.

                     Parameters
                            xy (numbers) -- Coordinate pairs. Each set of 2 pairs are interpreted as the control point at the end of the curve and the endpoint of the curve.  The control point at the be‐
                            ginning  of  the  curve is assumed to be the reflection of the control point at the end of the last curve relative to the starting point of the curve. If the previous curve is
                            not a cubic Bezier, the control point is coincident with the starting point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              s(*xy) Add smooth cubic Bezier curves to the curve.

                     Parameters
                            xy (numbers) -- Coordinate pairs. Each set of 2 pairs are interpreted as the control point at the end of the curve and the endpoint of the curve.  The control point at the be‐
                            ginning of the curve is assumed to be the reflection of the control point at the end of the last curve relative to the starting point of the curve. If the  previous  curve  is
                            not a cubic Bezier, the control point is coincident with the starting point.  All coordinates are relative to the current end point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              Q(*xy) Add quadratic Bezier curves to the curve.

                     Parameters
                            xy (numbers) -- Coordinate pairs. Each set of 2 pairs are interpreted as the control point and the endpoint of the curve.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              q(*xy) Add quadratic Bezier curves to the curve.

                     Parameters
                            xy  (numbers)  --  Coordinate  pairs.  Each set of 2 pairs are interpreted as the control point and the endpoint of the curve.  All coordinates are relative to the current end
                            point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              T(*xy) Add smooth quadratic Bezier curves to the curve.

                     Parameters
                            xy (numbers) -- Coordinates of the endpoints of the curves.  The control point is assumed to be the reflection of the control point of the last curve relative to the  starting
                            point of the curve. If the previous curve is not a quadratic Bezier, the control point is coincident with the starting point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              t(*xy) Add smooth quadratic Bezier curves to the curve.

                     Parameters
                            xy  (numbers) -- Coordinates of the endpoints of the curves.  The control point is assumed to be the reflection of the control point of the last curve relative to the starting
                            point of the curve. If the previous curve is not a quadratic Bezier, the control point is coincident with the starting point.  All coordinates are relative to the current  end
                            point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              B(*xy) Add a general degree Bezier curve.

                     Parameters
                            xy (numbers) -- Coordinate pairs.  The last coordinate is the endpoint of curve and all other are control points.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              b(*xy) Add a general degree Bezier curve.

                     Parameters
                            xy (numbers) -- Coordinate pairs.  The last coordinate is the endpoint of curve and all other are control points.  All coordinates are relative to the current end point.

                     Returns
                            out -- This curve.

                     Return type
                            Curve

              I(points, angles=None, curl_start=1, curl_end=1, t_in=1, t_out=1, cycle=False)
                     Add a smooth interpolating curve through the given points.

                     Uses the Hobby algorithm
                     [1]_
                      to calculate a smooth interpolating curve made of cubic Bezier segments between each pair of points.

                     Parameters

                            • points (array-like[N][2]) -- Vertices in the interpolating curve.

                            • angles (array-like[N + 1] or None) -- Tangent angles at each point (in radians).  Any angles defined as None are automatically calculated.

                            • curl_start  (number) -- Ratio between the mock curvatures at the first point and at its neighbor.  A value of 1 renders the first segment a good approximation for a circular
                              arc.  A value of 0 will better approximate a straight segment.  It has no effect for closed curves or when an angle is defined for the first point.

                            • curl_end (number) -- Ratio between the mock curvatures at the last point and at its neighbor.  It has no effect for closed curves or when an angle is defined for  the  first
                              point.

                            • t_in (number or array-like[N + 1]) -- Tension parameter when arriving at each point.  One value per point or a single value used for all points.

                            • t_out (number or array-like[N + 1]) -- Tension parameter when leaving each point.  One value per point or a single value used for all points.

                            • cycle (bool) -- If True, calculates control points for a closed curve, with an additional segment connecting the first and last points.

                     Returns
                            out -- This curve.

                     Return type
                            Curve
                     Examples.sp
                     >>> c1 = gdspy.Curve(0, 1).I([(1, 1), (2, 1), (1, 0)])
                     >>> c2 = gdspy.Curve(0, 2).I([(1, 2), (2, 2), (1, 1)],
                     ...                          cycle=True)
                     >>> ps = gdspy.PolygonSet([c1.get_points(), c2.get_points()])
                     References

              [1]  Hobby, J.D.  Discrete Comput. Geom. (1986) 1: 123.  DOI: 10.1007/BF02187690

              i(points, angles=None, curl_start=1, curl_end=1, t_in=1, t_out=1, cycle=False)
                     Add a smooth interpolating curve through the given points.

                     Uses the Hobby algorithm
                     [1]_
                      to calculate a smooth interpolating curve made of cubic Bezier segments between each pair of points.

                     Parameters

                            • points (array-like[N][2]) -- Vertices in the interpolating curve (relative to teh current endpoint).

                            • angles (array-like[N + 1] or None) -- Tangent angles at each point (in radians).  Any angles defined as None are automatically calculated.

                            • curl_start  (number) -- Ratio between the mock curvatures at the first point and at its neighbor.  A value of 1 renders the first segment a good approximation for a circular
                              arc.  A value of 0 will better approximate a straight segment.  It has no effect for closed curves or when an angle is defined for the first point.

                            • curl_end (number) -- Ratio between the mock curvatures at the last point and at its neighbor.  It has no effect for closed curves or when an angle is defined for  the  first
                              point.

                            • t_in (number or array-like[N + 1]) -- Tension parameter when arriving at each point.  One value per point or a single value used for all points.

                            • t_out (number or array-like[N + 1]) -- Tension parameter when leaving each point.  One value per point or a single value used for all points.

                            • cycle (bool) -- If True, calculates control points for a closed curve, with an additional segment connecting the first and last points.

                     Returns
                            out -- This curve.

                     Return type
                            Curve
                     Examples.sp
                     >>> c1 = gdspy.Curve(0, 1).i([(1, 0), (2, 0), (1, -1)])
                     >>> c2 = gdspy.Curve(0, 2).i([(1, 0), (2, 0), (1, -1)],
                     ...                          cycle=True)
                     >>> ps = gdspy.PolygonSet([c1.get_points(), c2.get_points()])
                     References

              [1]  Hobby, J.D.  Discrete Comput. Geom. (1986) 1: 123.  DOI: 10.1007/BF02187690

   Label
       class gdspy.Label(text, position, anchor='o', rotation=None, magnification=None, x_reflection=False, layer=0, texttype=0)
              Bases: object

              Text that can be used to label parts of the geometry or display messages.  The text does not create additional geometry, it's meant for display and labeling purposes only.

              Parameters

                     • text (string) -- The text of this label.

                     • position (array-like[2]) -- Text anchor position.

                     • anchor ('n', 's', 'e', 'w', 'o', 'ne', 'nw'...) -- Position of the anchor relative to the text.

                     • rotation (number) -- Angle of rotation of the label (in degrees).

                     • magnification (number) -- Magnification factor for the label.

                     • x_reflection (bool) -- If True, the label is reflected parallel to the x direction before being rotated (not supported by LayoutViewer).

                     • layer (integer) -- The GDSII layer number for these elements.

                     • texttype (integer) -- The GDSII text type for the label (between 0 and 63).

              Variables

                     • text (string) -- The text of this label.

                     • position (array-like[2]) -- Text anchor position.

                     • anchor (int) -- Position of the anchor relative to the text.

                     • rotation (number) -- Angle of rotation of the label (in degrees).

                     • magnification (number) -- Magnification factor for the label.

                     • x_reflection (bool) -- If True, the label is reflected parallel to the x direction before being rotated (not supported by LayoutViewer).

                     • layer (integer) -- The GDSII layer number for these elements.

                     • texttype (integer) -- The GDSII text type for the label (between 0 and 63).
              Examples.sp
              >>> label = gdspy.Label('Sample label', (10, 0), 'sw')
              >>> myCell.add(label)

              to_gds(multiplier)
                     Convert this label to a GDSII structure.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII structure.

                     Returns
                            out -- The GDSII binary string that represents this label.

                     Return type
                            string

              translate(dx, dy)
                     Translate this label.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction

                            • dy (number) -- Distance to move in the y-direction

                     Returns
                            out -- This object.

                     Return type
                            Label
                     Examples.sp
                     >>> text = gdspy.Label((0, 0), (10, 20))
                     >>> text = text.translate(2, 0)
                     >>> myCell.add(text)

   boolean
       gdspy.boolean(operand1, operand2, operation, precision=0.001, max_points=199, layer=0, datatype=0)
              Execute any boolean operation between 2 polygons or polygon sets.

              Parameters

                     • operand1  (PolygonSet,  CellReference,  CellArray  or  iterable)  --  First operand.  If this is an iterable, each element must be a PolygonSet, CellReference, CellArray, or an ar‐
                       ray-like[N][2] of vertices of a polygon.

                     • operand2 (None, PolygonSet, CellReference, CellArray or iterable) -- Second operand.  If this is an iterable, each element must be a PolygonSet, CellReference, CellArray, or an ar‐
                       ray-like[N][2] of vertices of a polygon.

                     • operation ({'or', 'and', 'xor', 'not'}) -- Boolean operation to be executed.  The 'not' operation returns the difference operand1 - operand2.

                     • precision (float) -- Desired precision for rounding vertice coordinates.

                     • max_points (integer) -- If greater than 4, fracture the resulting polygons to ensure they have at most max_points vertices.  This is not a tessellating  function,  so  this  number
                       should be as high as possible.  For example, it should be set to 199 for polygons being drawn in GDSII files.

                     • layer (integer) -- The GDSII layer number for the resulting element.

                     • datatype (integer) -- The GDSII datatype for the resulting element (between 0 and 255).

              Returns
                     out -- Result of the boolean operation.

              Return type
                     PolygonSet or None

   offset
       gdspy.offset(polygons, distance, join='miter', tolerance=2, precision=0.001, join_first=False, max_points=199, layer=0, datatype=0)
              Shrink or expand a polygon or polygon set.

              Parameters

                     • polygons  (PolygonSet,  CellReference,  CellArray or iterable) -- Polygons to be offset.  If this is an iterable, each element must be a PolygonSet, CellReference, CellArray, or an
                       array-like[N][2] of vertices of a polygon.

                     • distance (number) -- Offset distance.  Positive to expand, negative to shrink.

                     • join ('miter', 'bevel', 'round') -- Type of join used to create the offset polygon.

                     • tolerance (number) -- For miter joints, this number must be at least 2 and it represents the maximal distance in multiples of offset between new vertices and their  original  posi‐
                       tion before beveling to avoid spikes at acute joints.  For round joints, it indicates the curvature resolution in number of points per full circle.

                     • precision (float) -- Desired precision for rounding vertex coordinates.

                     • join_first (bool) -- Join all paths before offsetting to avoid unnecessary joins in adjacent polygon sides.

                     • max_points  (integer)  --  If  greater than 4, fracture the resulting polygons to ensure they have at most max_points vertices.  This is not a tessellating function, so this number
                       should be as high as possible.  For example, it should be set to 199 for polygons being drawn in GDSII files.

                     • layer (integer) -- The GDSII layer number for the resulting element.

                     • datatype (integer) -- The GDSII datatype for the resulting element (between 0 and 255).

              Returns
                     out -- Return the offset shape as a set of polygons.

              Return type
                     PolygonSet or None

   slice
       gdspy.slice(polygons, position, axis, precision=0.001, layer=0, datatype=0)
              Slice polygons and polygon sets at given positions along an axis.

              Parameters

                     • polygons (PolygonSet, CellReference, CellArray or iterable) -- Operand of the slice operation.  If this is an iterable, each element must be a PolygonSet, CellReference, CellArray,
                       or an array-like[N][2] of vertices of a polygon.

                     • position (number or list of numbers) -- Positions to perform the slicing operation along the specified axis.

                     • axis (0 or 1) -- Axis along which the polygon will be sliced.

                     • precision (float) -- Desired precision for rounding vertice coordinates.

                     • layer (integer, list) -- The GDSII layer numbers for the elements between each division.  If the number of layers in the list is less than the number of divided regions,  the  list
                       is repeated.

                     • datatype  (integer,  list)  -- The GDSII datatype for the resulting element (between 0 and 255).  If the number of datatypes in the list is less than the number of divided regions,
                       the list is repeated.

              Returns
                     out -- Result of the slicing operation, with N = len(positions) + 1.  Each PolygonSet comprises all polygons between 2 adjacent slicing positions, in crescent order.

              Return type
                     list[N] of PolygonSet or None
              Examples.sp
              >>> ring = gdspy.Round((0, 0), 10, inner_radius = 5)
              >>> result = gdspy.slice(ring, [-7, 7], 0)
              >>> cell.add(result[1])

   inside
       gdspy.inside(points, polygons, short_circuit='any', precision=0.001)
              Test whether each of the points is within the given set of polygons.

              Parameters

                     • points (array-like[N][2] or sequence of array-like[N][2]) -- Coordinates of the points to be tested or groups of points to be tested together.

                     • polygons (PolygonSet, CellReference, CellArray or iterable) -- Polygons to be tested against.  If this is an iterable, each element must be a PolygonSet, CellReference,  CellArray,
                       or an array-like[N][2] of vertices of a polygon.

                     • short_circuit  ({'any', 'all'}) -- If points is a sequence of point groups, testing within each group will be short-circuited if any of the points in the group is inside ('any') or
                       outside ('all') the polygons.  If points is simply a sequence of points, this parameter has no effect.

                     • precision (float) -- Desired precision for rounding vertice coordinates.

              Returns
                     out -- Tuple of booleans indicating if each of the points or point groups is inside the set of polygons.

              Return type
                     tuple

   copy
       gdspy.copy(obj, dx=0, dy=0)
              Create a copy of obj and translate it by (dx, dy).

              Parameters

                     • obj (translatable object) -- Object to be copied.

                     • dx (number) -- Distance to move in the x-direction.

                     • dy (number) -- Distance to move in the y-direction.

              Returns
                     out -- Translated copy of original obj

              Return type
                     translatable object
              Examples.sp
              >>> rectangle = gdspy.Rectangle((0, 0), (10, 20))
              >>> rectangle2 = gdspy.copy(rectangle, 2,0)
              >>> myCell.add(rectangle)
              >>> myCell.add(rectangle2)

   GDSII Library
   Cell
       class gdspy.Cell(name, exclude_from_current=False)
              Bases: object

              Collection of polygons, paths, labels and raferences to other cells.

              Parameters

                     • name (string) -- The name of the cell.

                     • exclude_from_current (bool) -- If True, the cell will not be automatically included in the current library.

              Variables

                     • name (string) -- The name of this cell.

                     • polygons (list of PolygonSet) -- List of cell polygons.

                     • paths (list of RobustPath or FlexPath) -- List of cell paths.

                     • labels (list of Label) -- List of cell labels.

                     • references (list of CellReference or CellArray) -- List of cell references.

              to_gds(multiplier, timestamp=None)
                     Convert this cell to a GDSII structure.

                     Parameters

                            • multiplier (number) -- A number that multiplies all dimensions written in the GDSII structure.

                            • timestamp (datetime object) -- Sets the GDSII timestamp.  If None, the current time is used.

                     Returns
                            out -- The GDSII binary string that represents this cell.

                     Return type
                            string

              copy(name, exclude_from_current=False, deep_copy=False)
                     Creates a copy of this cell.

                     Parameters

                            • name (string) -- The name of the cell.

                            • exclude_from_current (bool) -- If True, the cell will not be included in the global list of cells maintained by gdspy.

                            • deep_copy (bool) -- If False, the new cell will contain only references to the existing elements.  If True, copies of all elements are also created.

                     Returns
                            out -- The new copy of this cell.

                     Return type
                            Cell

              add(element)
                     Add a new element or list of elements to this cell.

                     Parameters
                            element (PolygonSet, CellReference, CellArray or iterable) -- The element or iterable of elements to be inserted in this cell.

                     Returns
                            out -- This cell.

                     Return type
                            Cell

              remove_polygons(test)
                     Remove polygons from this cell.

                     The function or callable test is called for each polygon in the cell.  If its return value evaluates to True, the corresponding polygon is removed from the cell.

                     Parameters
                            test (callable) -- Test function to query whether a polygon should be removed.  The function is called with arguments: (points, layer, datatype)

                     Returns
                            out -- This cell.

                     Return type
                            Cell
                     Examples

                     Remove polygons in layer 1:

                     >>> cell.remove_polygons(lambda pts, layer, datatype:
                     ...                      layer == 1)

                     Remove polygons with negative x coordinates:

                     >>> cell.remove_polygons(lambda pts, layer, datatype:
                     ...                      any(pts[:, 0] < 0))

              remove_paths(test)
                     Remove paths from this cell.

                     The function or callable test is called for each FlexPath or RobustPath in the cell.  If its return value evaluates to True, the corresponding label is removed from the cell.

                     Parameters
                            test (callable) -- Test function to query whether a path should be removed.  The function is called with the path as the only argument.

                     Returns
                            out -- This cell.

                     Return type
                            Cell

              remove_labels(test)
                     Remove labels from this cell.

                     The function or callable test is called for each label in the cell.  If its return value evaluates to True, the corresponding label is removed from the cell.

                     Parameters
                            test (callable) -- Test function to query whether a label should be removed.  The function is called with the label as the only argument.

                     Returns
                            out -- This cell.

                     Return type
                            Cell
                     Examples

                     Remove labels in layer 1:

                     >>> cell.remove_labels(lambda lbl: lbl.layer == 1)

              area(by_spec=False)
                     Calculate the total area of the elements on this cell, including cell references and arrays.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with the areas of each individual pair (layer, datatype).

                     Returns
                            out -- Area of this cell.

                     Return type
                            number, dictionary

              get_layers()
                     Return the set of layers in this cell.

                     Returns
                            out -- Set of the layers used in this cell.

                     Return type
                            set

              get_datatypes()
                     Return the set of datatypes in this cell.

                     Returns
                            out -- Set of the datatypes used in this cell.

                     Return type
                            set

              get_bounding_box()
                     Calculate the bounding box for this cell.

                     Returns
                            out -- Bounding box of this cell [[x_min, y_min], [x_max, y_max]], or None if the cell is empty.

                     Return type
                            Numpy array[2, 2] or None

              get_polygons(by_spec=False, depth=None)
                     Return a list of polygons in this cell.

                     Parameters

                            • by_spec (bool) -- If True, the return value is a dictionary with the polygons of each individual pair (layer, datatype).

                            • depth (integer or None) -- If not None, defines from how many reference levels to retrieve polygons.  References below this level will result in a bounding box.  If  by_spec
                              is True the key will be the name of this cell.

                     Returns
                            out -- List containing the coordinates of the vertices of each polygon, or dictionary with the list of polygons (if by_spec is True).

                     Return type
                            list of array-like[N][2] or dictionary

                     NOTE:
                        Instances of FlexPath and RobustPath are also included in the result by computing their polygonal boundary.

              get_polygonsets(depth=None)
                     Return a list with a copy of the polygons in this cell.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve polygons from.

                     Returns
                            out -- List containing the polygons in this cell and its references.

                     Return type
                            list of PolygonSet

              get_paths(depth=None)
                     Return a list with a copy of the paths in this cell.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve paths from.

                     Returns
                            out -- List containing the paths in this cell and its references.

                     Return type
                            list of FlexPath or RobustPath

              get_labels(depth=None)
                     Return a list with a copy of the labels in this cell.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve labels from.

                     Returns
                            out -- List containing the labels in this cell and its references.

                     Return type
                            list of Label

              get_dependencies(recursive=False)
                     Return a list of the cells included in this cell as references.

                     Parameters
                            recursive (bool) -- If True returns cascading dependencies.

                     Returns
                            out -- List of the cells referenced by this cell.

                     Return type
                            set of Cell

              flatten(single_layer=None, single_datatype=None, single_texttype=None)
                     Convert all references into polygons, paths and labels.

                     Parameters

                            • single_layer (integer or None) -- If not None, all polygons will be transferred to the layer indicated by this number.

                            • single_datatype (integer or None) -- If not None, all polygons will be transferred to the datatype indicated by this number.

                            • single_datatype -- If not None, all labels will be transferred to the texttype indicated by this number.

                     Returns
                            out -- This cell.

                     Return type
                            Cell

   CellReference
       class gdspy.CellReference(ref_cell, origin=(0, 0), rotation=None, magnification=None, x_reflection=False, ignore_missing=False)
              Bases: object

              Simple reference to an existing cell.

              Parameters

                     • ref_cell (Cell or string) -- The referenced cell or its name.

                     • origin (array-like[2]) -- Position where the reference is inserted.

                     • rotation (number) -- Angle of rotation of the reference (in degrees).

                     • magnification (number) -- Magnification factor for the reference.

                     • x_reflection (bool) -- If True the reference is reflected parallel to the x direction before being rotated.

                     • ignore_missing (bool) -- If False a warning is issued when the referenced cell is not found.

              to_gds(multiplier)
                     Convert this object to a GDSII element.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII element.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              area(by_spec=False)
                     Calculate the total area of the referenced cell with the magnification factor included.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with the areas of each individual pair (layer, datatype).

                     Returns
                            out -- Area of this cell.

                     Return type
                            number, dictionary

              get_polygons(by_spec=False, depth=None)
                     Return the list of polygons created by this reference.

                     Parameters

                            • by_spec (bool) -- If True, the return value is a dictionary with the polygons of each individual pair (layer, datatype).

                            • depth  (integer or None) -- If not None, defines from how many reference levels to retrieve polygons.  References below this level will result in a bounding box.  If by_spec
                              is True the key will be the name of the referenced cell.

                     Returns
                            out -- List containing the coordinates of the vertices of each polygon, or dictionary with the list of polygons (if by_spec is True).

                     Return type
                            list of array-like[N][2] or dictionary

                     NOTE:
                        Instances of FlexPath and RobustPath are also included in the result by computing their polygonal boundary.

              get_polygonsets(depth=None)
                     Return the list of polygons created by this reference.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve polygons from.

                     Returns
                            out -- List containing the polygons in this cell and its references.

                     Return type
                            list of PolygonSet

              get_paths(depth=None)
                     Return the list of paths created by this reference.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve paths from.

                     Returns
                            out -- List containing the paths in this cell and its references.

                     Return type
                            list of FlexPath or RobustPath

              get_labels(depth=None)
                     Return the list of labels created by this reference.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve labels from.

                     Returns
                            out -- List containing the labels in this cell and its references.

                     Return type
                            list of Label

              get_bounding_box()
                     Calculate the bounding box for this reference.

                     Returns
                            out -- Bounding box of this cell [[x_min, y_min], [x_max, y_max]], or None if the cell is empty.

                     Return type
                            Numpy array[2, 2] or None

              translate(dx, dy)
                     Translate this reference.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            CellReference

   CellArray
       class gdspy.CellArray(ref_cell, columns, rows, spacing, origin=(0, 0), rotation=None, magnification=None, x_reflection=False, ignore_missing=False)
              Bases: object

              Multiple references to an existing cell in an array format.

              Parameters

                     • ref_cell (Cell or string) -- The referenced cell or its name.

                     • columns (positive integer) -- Number of columns in the array.

                     • rows (positive integer) -- Number of columns in the array.

                     • spacing (array-like[2]) -- distances between adjacent columns and adjacent rows.

                     • origin (array-like[2]) -- Position where the cell is inserted.

                     • rotation (number) -- Angle of rotation of the reference (in degrees).

                     • magnification (number) -- Magnification factor for the reference.

                     • x_reflection (bool) -- If True, the reference is reflected parallel to the x direction before being rotated.

                     • ignore_missing (bool) -- If False a warning is issued when the referenced cell is not found.

              to_gds(multiplier)
                     Convert this object to a GDSII element.

                     Parameters
                            multiplier (number) -- A number that multiplies all dimensions written in the GDSII element.

                     Returns
                            out -- The GDSII binary string that represents this object.

                     Return type
                            string

              area(by_spec=False)
                     Calculate the total area of the cell array with the magnification factor included.

                     Parameters
                            by_spec (bool) -- If True, the return value is a dictionary with the areas of each individual pair (layer, datatype).

                     Returns
                            out -- Area of this cell.

                     Return type
                            number, dictionary

              get_polygons(by_spec=False, depth=None)
                     Return the list of polygons created by this reference.

                     Parameters

                            • by_spec (bool) -- If True, the return value is a dictionary with the polygons of each individual pair (layer, datatype).

                            • depth (integer or None) -- If not None, defines from how many reference levels to retrieve polygons.  References below this level will result in a bounding box.  If  by_spec
                              is True the key will be name of the referenced cell.

                     Returns
                            out -- List containing the coordinates of the vertices of each polygon, or dictionary with the list of polygons (if by_spec is True).

                     Return type
                            list of array-like[N][2] or dictionary

                     NOTE:
                        Instances of FlexPath and RobustPath are also included in the result by computing their polygonal boundary.

              get_polygonsets(depth=None)
                     Return the list of polygons created by this reference.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve polygons from.

                     Returns
                            out -- List containing the polygons in this cell and its references.

                     Return type
                            list of PolygonSet

              get_paths(depth=None)
                     Return the list of paths created by this reference.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve paths from.

                     Returns
                            out -- List containing the paths in this cell and its references.

                     Return type
                            list of FlexPath or RobustPath

              get_labels(depth=None)
                     Return the list of labels created by this reference.

                     Parameters
                            depth (integer or None) -- If not None, defines from how many reference levels to retrieve labels from.

                     Returns
                            out -- List containing the labels in this cell and its references.

                     Return type
                            list of Label

              get_bounding_box()
                     Calculate the bounding box for this reference.

                     Returns
                            out -- Bounding box of this cell [[x_min, y_min], [x_max, y_max]], or None if the cell is empty.

                     Return type
                            Numpy array[2, 2] or None

              translate(dx, dy)
                     Translate this reference.

                     Parameters

                            • dx (number) -- Distance to move in the x-direction.

                            • dy (number) -- Distance to move in the y-direction.

                     Returns
                            out -- This object.

                     Return type
                            CellArray

   GdsLibrary
       class gdspy.GdsLibrary(name='library', infile=None, unit=1e-06, precision=1e-09, **kwargs)
              Bases: object

              GDSII library (file).

              Represent a GDSII library containing a dictionary of cells.

              Parameters

                     • name (string) -- Name of the GDSII library.  Ignored if a name is defined in infile.

                     • infile (file or string) -- GDSII stream file (or path) to be imported.  It must be opened for reading in binary format.

                     • kwargs (keyword arguments) -- Arguments passed to read_gds.

              Variables

                     • name (string) -- Name of the GDSII library.

                     • cell_dict (dictionary) -- Dictionary of cells in this library, indexed by name.

                     • unit (number) -- Unit size for the objects in the library (in meters).

                     • precision (number) -- Precision for the dimensions of the objects in the library (in meters).

              add(cell, overwrite_duplicate=False)
                     Add one or more cells to the library.

                     Parameters

                            • cell (Cell or iterable) -- Cells to be included in the library.

                            • overwrite_duplicate (bool) -- If True an existing cell with the same name in the library will be overwritten.

                     Returns
                            out -- This object.

                     Return type
                            GdsLibrary

                        Notes

                               CellReference or CellArray instances that referred to an overwritten cell are not automatically updated.

              write_gds(outfile, cells=None, timestamp=None, binary_cells=None)
                     Write the GDSII library to a file.

                     The  dimensions  actually written on the GDSII file will be the dimensions of the objects created times the ratio unit/precision.  For example, if a circle with radius 1.5 is created
                     and we set GdsLibrary.unit to 1.0e-6 (1 um) and GdsLibrary.precision to 1.0e-9` (1 nm), the radius of the circle will be 1.5 um and the GDSII file will contain the dimension 1500 nm.

                     Parameters

                            • outfile (file or string) -- The file (or path) where the GDSII stream will be written.  It must be opened for writing operations in binary format.

                            • cells (iterable) -- The cells or cell names to be included in the library.  If None, all cells are used.

                            • timestamp (datetime object) -- Sets the GDSII timestamp.  If None, the current time is used.

                            • binary_cells (iterable of bytes) -- Iterable with binary data for GDSII cells (from get_binary_cells, for example).

                        Notes

                               Only the specified cells are written.  The user is responsible for ensuring all cell dependencies are satisfied.

              read_gds(infile, units='skip', rename={}, rename_template='{name}', layers={}, datatypes={}, texttypes={})
                     Read a GDSII file into this library.

                     Parameters

                            • infile (file or string) -- GDSII stream file (or path) to be imported.  It must be opened for reading in binary format.

                            • units ({'convert', 'import', 'skip'}) -- Controls how to scale and use the units in the imported file.  'convert': the imported geometry is scaled  to  this  library  units.
                              'import':  the  unit and precision in this library are replaced by those from the imported file.  'skip': the imported geometry is not scaled and units are not replaced; the
                              geometry is imported in the user units of the file.

                            • rename (dictionary) -- Dictionary used to rename the imported cells.  Keys and values must be strings.

                            • rename_template (string) -- Template string used to rename the imported cells. Appiled only if the cell name is not in the  rename  dictionary.   Examples:  'prefix-{name}',
                              '{name}-suffix'

                            • layers (dictionary) -- Dictionary used to convert the layers in the imported cells.  Keys and values must be integers.

                            • datatypes (dictionary) -- Dictionary used to convert the datatypes in the imported cells.  Keys and values must be integers.

                            • texttypes (dictionary) -- Dictionary used to convert the text types in the imported cells.  Keys and values must be integers.

                     Returns
                            out -- This object.

                     Return type
                            GdsLibrary

                        Notes

                               Not all features from the GDSII specification are currently supported.  A warning will be produced if any unsupported features are found in the imported file.

              extract(cell, overwrite_duplicate=False)
                     Extract a cell from the this GDSII file and include it in the current global library, including referenced dependencies.

                     Parameters

                            • cell (Cell or string) -- Cell or name of the cell to be extracted from the imported file.  Referenced cells will be automatically extracted as well.

                            • overwrite_duplicate (bool) -- If True an existing cell with the same name in the current global library will be overwritten.

                     Returns
                            out -- The extracted cell.

                     Return type
                            Cell

                        Notes

                               CellReference or CellArray instances that referred to an overwritten cell are not automatically updated.

              top_level()
                     Output the top level cells from the GDSII data.

                     Top level cells are those that are not referenced by any other cells.

                     Returns
                            out -- List of top level cells.

                     Return type
                            list

   GdsWriter
       class gdspy.GdsWriter(outfile, name='library', unit=1e-06, precision=1e-09, timestamp=None)
              Bases: object

              GDSII strem library writer.

              The  dimensions  actually written on the GDSII file will be the dimensions of the objects created times the ratio unit/precision.  For example, if a circle with radius 1.5 is created and we
              set unit to 1.0e-6 (1 um) and precision to 1.0e-9 (1 nm), the radius of the circle will be 1.5 um and the GDSII file will contain the dimension 1500 nm.

              Parameters

                     • outfile (file or string) -- The file (or path) where the GDSII stream will be written.  It must be opened for writing operations in binary format.

                     • name (string) -- Name of the GDSII library (file).

                     • unit (number) -- Unit size for the objects in the library (in meters).

                     • precision (number) -- Precision for the dimensions of the objects in the library (in meters).

                     • timestamp (datetime object) -- Sets the GDSII timestamp.  If None, the current time is used.

                 Notes

                        This class can be used for incremental output of the geometry in case the complete layout is too large to be kept in memory all at once.
              Examples.sp
              >>> writer = gdspy.GdsWriter('out-file.gds', unit=1.0e-6,
              ...                          precision=1.0e-9)
              >>> for i in range(10):
              ...     cell = gdspy.Cell('C{}'.format(i), True)
              ...     # Add the contents of this cell...
              ...     writer.write_cell(cell)
              ...     # Clear the memory: erase Cell objects and any other objects
              ...     # that won't be needed.
              ...     del cell
              >>> writer.close()

              write_cell(cell, timestamp=None)
                     Write the specified cell to the file.

                     Parameters

                            • cell (Cell) -- Cell to be written.

                            • timestamp (datetime object) -- Sets the GDSII timestamp.  If None, the current time is used.

                        Notes

                               Only the specified cell is written.  Dependencies must be manually included.

                     Returns
                            out -- This object.

                     Return type
                            GdsWriter

              write_binary_cells(binary_cells)
                     Write the specified binary cells to the file.

                     Parameters
                            binary_cells (iterable of bytes) -- Iterable with binary data for GDSII cells (from get_binary_cells, for example).

                     Returns
                            out -- This object.

                     Return type
                            GdsWriter

              close()
                     Finalize the GDSII stream library.

   LayoutViewer
   write_gds
       gdspy.write_gds(outfile, cells=None, name='library', unit=1e-06, precision=1e-09, timestamp=None, binary_cells=None)
              Write the current GDSII library to a file.

              The dimensions actually written on the GDSII file will be the dimensions of the objects created times the ratio unit/precision.  For example, if a circle with radius 1.5 is created  and  we
              set unit to 1.0e-6 (1 um) and precision to 1.0e-9 (1 nm), the radius of the circle will be 1.5 um and the GDSII file will contain the dimension 1500 nm.

              Parameters

                     • outfile (file or string) -- The file (or path) where the GDSII stream will be written.  It must be opened for writing operations in binary format.

                     • cells (array-like) -- The sequence of cells or cell names to be included in the library.  If None, all cells are used.

                     • name (string) -- Name of the GDSII library.

                     • unit (number) -- Unit size for the objects in the library (in meters).

                     • precision (number) -- Precision for the dimensions of the objects in the library (in meters).

                     • timestamp (datetime object) -- Sets the GDSII timestamp.  If None, the current time is used.

                     • binary_cells (iterable of bytes) -- Iterable with binary data for GDSII cells (from get_binary_cells, for example).

   gdsii_hash
       gdspy.gdsii_hash(filename, engine=None)
              Calculate the a hash value for a GDSII file.

              The hash is generated based only on the contents of the cells in the GDSII library, ignoring any timestamp records present in the file structure.

              Parameters

                     • filename (string) -- Full path to the GDSII file.

                     • engine  (hashlib-like  engine)  -- The engine that executes the hashing algorithm.  It must provide the methods update and hexdigest as defined in the hashlib module.  If None, the
                       default hashlib.sha1() is used.

              Returns
                     out -- The hash corresponding to the library contents in hex format.

              Return type
                     string

   get_binary_cells
       gdspy.get_binary_cells(infile)
              Load all cells from a GDSII stream file in binary format.

              Parameters
                     infile (file or string) -- GDSII stream file (or path) to be loaded.  It must be opened for reading in binary format.

              Returns
                     out -- Dictionary of binary cell representations indexed by name.

              Return type
                     dictionary

                 Notes

                        The returned cells inherit the units of the loaded file.  If they are used in a new library, the new library must use compatible units.

   get_gds_units
       gdspy.get_gds_units(infile)
              Return the unit and precision used in the GDS stream file.

              Parameters
                     infile (file or string) -- GDSII stream file to be queried.

              Returns
                     out -- Return (unit, precision) from the file.

              Return type
                     2-tuple

   current_library
       gdspy.current_library = <gdspy.GdsLibrary object>
              Current GdsLibrary instance for automatic creation of GDSII files.

              This variable can be freely overwritten by the user with a new instance of GdsLibrary.  Examples.sp
              >>> gdspy.Cell('MAIN')
              >>> gdspy.current_library = GdsLibrary()  # Reset current library
              >>> gdspy.Cell('MAIN')  # A new MAIN cell is created without error

SUPPORT
       Help support the development of gdspy by donating:

       Click here

AUTHOR
       Lucas H. Gabrielli

COPYRIGHT
       2009-2020, Lucas H. Gabrielli

1.4.2                                                                                           Mar 21, 2020                                                                                       GDSPY(1)
