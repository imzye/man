complexity(1)                                                                                  User Commands                                                                                  complexity(1)

NAME
       complexity - Measure complexity of C source

SYNOPSIS
       complexity [-flags] [-flag [value]] [--option-name[[=| ]value]] [ <file-name> ... ]

       The  operands  that  this  program  operates on may be specified either on the command line or read from standard input, one per line.  In that input, leading and trailing white space is stripped,
       blank lines are ignored.  Standard input may not be a terminal.

       Compute the complexity of source code not just with a path-through-the-code count, but also amplifying line counts by logic level nesting.

       Compute the complexity of code by counting lines of non-comment source and multiplying by a nested logic weight factor.  By default, 1.9.

DESCRIPTION
       The weight of each statement is the number of lines the statement uses.  This value is multiplied by the nested logic weighting (1.9 by default) for each layer of logic.  For example,  this  snip‐
       pet:

           if (foo) {
             if (bar) {
               bumble; baz;
             }
           }

       will  score  11.   This  score is then scaled to approximate pmccabe results by dividing by 20 and rounding.  This scores "1" at the end.  pmccabe scores higher on simple procedures and complexity
       scores higher with more deeply nested logic.

       The scoring can be tweaked by adjusting the --nesting-penalty and --scale-ing factors.  The default values were calibrated by comparing the average results of millions of lines of  code  with  the
       results of pmccabe.

       For the purposes of this program, a procedure is identified by a name followed by a parenthesized expression and then an opening curly brace.  It ends with a closing curly brace in column 1.

       This  program will perform its function for every file named on the command line or every file named in a list read from stdin.  The arguments or input names must be pre-existing files.  The input
       list may contain comments, which are blank lines or lines beginning with a '#' character.

OPTIONS
       -t minimum, --threshold=minimum Reporting threshold.  This option takes an integer number as its argument.  The default minimum for this option is:
            30

       Ignore any procedures with a complexity measure below this threshold.  By default, a complexity score of under 30 is not printed.  However, if a histogram and statistics are to be printed, but not
       individual procedure scores, then the default is set to zero.  Procedures below this limit are not counted in the statistics.

       --horrid-threshold=minimum zero exit threshold.  This option takes an integer number as its argument.  The default minimum for this option is:
            100

       If any procedures score higher than this threshold, then the program will exit non-zero.  (4/COMPLEX_EXIT_HORRID_FUNCTION, if no other problems are encountered.)  By default, this program exits
       zero unless one function exceeds the horrid score of 100.

       -n factor, --nesting-penalty=factor score multiplier for nested code.

       Linguistic constructs weigh more heavily the more deeply nested they are.  By default, each layer penalizes by a factor of 1.9.  The option argument is a floating point number.  The penalty may be
       1, but not less.

       --demi-nesting-penalty=factor score multiplier for nested expressions.

       By default, this value is halfway between 1.0 and the nesting penalty (specifically, the square root of the nesting penalty).  It refers to a parenthesized sub-expression. e.g.
           ((a > b) && (c > d))
       contains two parenthesized sub-expressions.  This would count 3.5 points.  On the other hand, this:
           (a > b && c > d)
       contains two relation operators and a logical operator at the same level.  These nested counts will be multiplied together and yield 2.5 * 2.5, or 6.25.  Don't do that.  It gets even worse if you
       have logical ands and ors at the same level.

       -s factor, --scale=factor complexity scaling factor.  This option takes an integer number as its argument.

       By default, the scaling is 20 which divides the raw score by 20.  This was normalized to roughly correspond to the pmccabe scores:

       0-9 Easily maintained code.

       10-19 Maintained with little trouble.

       20-29 Maintained with some effort.

       30-39 Difficult to maintain code.

       40-49 Hard to maintain code.

       50-99 Unmaintainable code.

       100-199 Crazy making difficult code.

       200+ I only wish I were kidding.
           Score | ln-ct | nc-lns| file-name(line): proc-name
            4707    3815    2838   lib/vasnprintf.c(1747): VASNPRINTF

       -h, --histogram, --no-histogram Display histogram of complexity numbers.  The no-histogram form will disable the option.  This option may not be preset with environment variables or in initializa‐
       tion (rc) files.

       Instead of printing out each function's score, a summary is printed at the end showing how many functions had particular ranges of scores.  Unless --scores is specifically called out, the scores
       will not print with this option specified.  The minimum scoring threshold will also be reduced to zero (0), unless --threshold is specified.

       -c, --scores, --no-scores Display the score for each procedure.  The no-scores form will disable the option.  This option may not be preset with environment variables or in initialization (rc)
       files.

       If you specify --histogram, individual scores will not be displayed, unless this option is specified.

       -I string, --ignore=string procedure name to be ignored.  This option may appear an unlimited number of times.

       Some code has macros defined that confuse the lexical analysis.  This will cause them to be ignored.  Other ways to cause functions to be ignored are:

       Use K&R syntax for a procedure header.

       Use a preprocessing macro to assemble the procedure header.

       Simplify your code.
       Generally speaking, anything you do that alters normal C syntax will confuse the lexical analysis.  If a procedure is not seen, then it will not get counted.  If code within a procedure is incom‐
       prehensible, you will likely get inappropriate results.

       -H, --no-header do not print scoring header.  This option may not be preset with environment variables or in initialization (rc) files.

       If a script is going to process the scoring output, parsing is easier without a header.  The histogram output will always have a header.

       -u unifdef-opt, --unifdef=unifdef-opt Run the source(s) through unifdef(1BSD).  This option may appear an unlimited number of times.

       Strip out sections of code surrounded by #if/#endif directives.  The option argument is passed as an argument to the unifdef(1BSD) program.  For example:
           complexity -u-Dsymbol
       would cause symbol to be defined and remove sections of code preceded by #ifndef symbol directives.

       Please see the unifdef documentation for more information.

       --unif-exe=prog Specify the unifdef program.

       Alternate program to use for unifdef-ing the input.

       -i file-name, --input=file-name file of file list.

       Instead of either a command line list of input files or reading them from standard input, read the list of files from this file.

       --trace=file-name trace output file.

       Print intermediate scores to a trace file.

       -?, --help Display usage information and exit.

       -!, --more-help Pass the extended usage information through a pager.

       -> [cfgfile], --save-opts [=cfgfile] Save the option state to cfgfile.  The default is the last configuration file listed in the OPTION PRESETS section, below.  The command will exit after updat‐
       ing the config file.

       -< cfgfile, --load-opts=cfgfile, --no-load-opts Load options from cfgfile.  The no-load-opts form will disable the loading of earlier config/rc/ini files.  --no-load-opts is handled early, out of
       order.

       -v [{v|c|n --version [{v|c|n}]}] Output version of program and exit.  The default mode is `v', a simple version.  The `c' mode will print copyright information and `n' will print the full copy‐
       right notice.

       OPTION PRESETS
              Any option that is not marked as not presettable may be preset by loading values from configuration ("RC" or ".INI") file(s) and values from environment variables named:
                COMPLEXITY_<option-name> or COMPLEXITY
              The environmental presets take precedence (are processed later than) the configuration files.  The homerc files are "$@/complex.conf", "$HOME", "$PROJECT_ROOT/complex.conf",  and  ".".   If
              any of these are directories, then the file .complexityrc is searched for within those directories.

ENVIRONMENT
       See OPTION PRESETS for configuration environment variables.

FILES
       See OPTION PRESETS for configuration files.

EXIT STATUS
       One of the following exit values will be returned:

       0  (EXIT_SUCCESS) Successful program execution.

       1  (EXIT_FAILURE) The operation failed or the command syntax was not valid.

       3  (EXIT_NOMEM) insufficient memory to run program

       4  (EXIT_HORRID_FUNCTION) One or more functions scored over 100

       5  (EXIT_NO_DATA) No qualifying procedures were found.

       6  (EXIT_ASSERT) Assertion failed

       32  (EXIT_BAD_FILE) one or more input files were unreadable or empty.

       66  (EX_NOINPUT) A specified configuration file could not be loaded.

       70  (EX_SOFTWARE) libopts had an internal operational error.  Please report it to autogen-users@lists.sourceforge.net.  Thank you.

       AUTHORS
              Bruce Korb

COPYRIGHT
       Copyright (C) 2011-2020 Bruce Korb all rights reserved.  This program is released under the terms of the GNU General Public License, version 3 or later.

BUGS
       This program does not recognize K&R procedure headers.

       Some procedures still get missed.  Usually, these are procedures that use the C pre-processor to extend the C language in some way.

       Initialized variable definitions within procedures have the initializing elements counted in the complexity calculation.

       Please send bug reports to: bkorb@gnu.org

NOTES
       This manual page was AutoGen-erated from the complexity option definitions.

GNU Complexity (1.13)                                                                           19 Sep 2022                                                                                   complexity(1)
