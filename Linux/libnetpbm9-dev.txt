libpbm(3)                                                             Library Functions Manual                                                             libpbm(3)

NAME
       libpbm - functions to read and write PBM image files

SYNOPSIS
       #include <pbm.h>

       int pm_keymatch(char * str, char * keyword, int minchars);

       int pm_maxvaltobits(int maxval);

       int pm_bitstomaxval(int bits);

       unsigned int pm_lcm(unsigned int x, unsigned int y, unsigned int z, unsigned int limit);

       void pm_message(char * fmt, ... );

       void pm_error(char * fmt, ... );

       void pm_perror(char * fmt, ... );

       void pm_usage(char * usage);

       FILE *pm_openr(char * name)

       FILE *pm_openw(char * name);

       FILE *pm_openr_seekable(const char * name);

       FILE *pm_close(FILE * fp);

       char *pm_read_unknown_size(FILE * fp, long *nread);

       unsigned int pm_tell(FILE * fileP);

       void pm_seek(FILE * fileP, unsigned long filepos);

       bit **pbm_allocarray(int cols,  int rows);

       bit *pbm_allocrow(int cols);

       pbm_freearray(bit **bits, int rows);

       pbm_freerow(bit *bitrow);

       void pbm_readpbminit(FILE * fp, int *colsP, int *rowsP, int *formatP);

       void pbm_readpbmrow(FILE * fp, bit *bitrow, int cols, int format);

       void pbm_readpbmrow_packed(FILE * fp,
       unsigned char * const packed_bits, const int cols, const int format);

       void bit** pbm_readpbm(FILE * fp, int *colsP, int *rowsP);

       void pbm_writepbminit(FILE * fp, int cols, int rows, int forceplain);

       void pbm_writepbmrow(FILE * fp, bit *bitrow, int cols, int forceplain);

       void pbm_writepbmrow_packed(FILE * fp,
       unsigned char * const packed_bits, const int cols, const int forceplain);

       void pbm_writepbm(FILE * fp, bit **bits, int cols, int rows, int forceplain);

       #define pbm_packed_bytes(cols) ...

       void pbm_nextimage( FILE *file, int * const eofP);

       void pbm_check( FILE * file, const enum pm_check_type check_type, const int format, const int cols, const int rows, enum pm_check_code * const retval);

       int pm_readbigshort(FILE *in, short *sP);

       int pm_writebigshort(FILE *out, short s);

       int pm_readbiglong(FILE *in, long *lP);

       int pm_writebiglong(FILE *out, long l);

       int pm_readlittleshort(FILE *in, short *sP);

       int pm_writelittleshort(FILE *out, short s);

       int pm_readlittlelong(FILE *in, long *lP);

       int pm_writelittlelong(FILE *out, long l);

DESCRIPTION - PACKAGE-WIDE ROUTINES
   KEYWORD MATCHING
       pm_keymatch() does a case-insensitive match of str against keyword.  str can be a leading sunstring of keyword, but at least minchars must be present.

   MAXVAL ARITHMETIC
       pm_maxvaltobits() and pm_bitstomaxval() convert between a maxval and the minimum number of bits required to hold it.

       pm_lcm()  computes  the  least common multiple of 3 integers.  You also specify a limit and if the LCM would be higher than that limit, pm_lcm() just returns
       that limit.

   MESSAGES AND ERRORS
       pm_message() is a printf() style routine to write an informational message to the Standard Error file stream.  pm_message() suppresses the message,  however,
       if the user specified the -quiet option on the command line.  See the initialization functions, e.g.  pbm_init(), for information on the -quiet option.  Note
       that Netpbm programs are often used interactively, but also often used by programs.  In the interactive case, it is nice to issue  messages  about  what  the
       program  is doing, but in the program case, such messages are usually undesirable.  By using pm_message() for all your messages, you make your program usable
       in both cases.  Without any effort on your part, program users of your program can avoid the messages by specifying the -quiet option.

       pm_error() is a printf() style routine that writes an error message to the Standard Error file stream and exits the program with an exit code of 1.

   GENERIC FILE ACCESS
       pm_openr() opens the given file for reading, with appropriate error checking.  A filename of - is taken to mean Standard Input.  pm_openw() opens  the  given
       file for writing, with appropriate error checking.  pm_close() closes the file descriptor, with appropriate error checking.

       pm_openr_seekable()  appears to open the file just like pm_openr(), but the file thus opened is guaranteed to be seekable (you can use ftell() and fseek() on
       it).  pm_openr_seekable() pulls this off by copying the entire file to a temporary file and giving you the handle of the temporary file, if it  has  to.   If
       the  file  you  name  is  a regular file, it's already seekable so pm_openr_seekable() just does the same thing as pm_openr().  But if it is, say, a pipe, it
       isn't seekable.  So pm_openr_seekable() reads the pipe until EOF into a temporary file, then opens that temporary file and returns the handle of  the  tempo‐
       rary file.  The temporary file is seekable.

       The file pm_openr_seekable() creates is one that the operating system recognizes as temporary, so when you close the file, by any means, it gets deleted.

       You  need a seekable file if you intend to make multiple passes through the file.  The only alternative is to read the entire image into memory and work from
       that copy.  That may use too much memory.  Note that the image takes less space in the file cache than in a buffer in memory.   As  much  as  96  times  less
       space!  Each sample is an integer in the buffer, which is usually 96 bits.  In the file, a sample may be as small as 1 bit and rarely more than 8 bits.

       pm_read_unknown_size()  reads  an entire file or input stream of unknown size to a buffer.  Allocate memory more memory as needed. The calling routine has to
       free the allocated buffer with free().

       pm_read_unknown_size() returns a pointer to the allocated buffer. The nread argument returns the number of bytes read.

       pm_tell() returns a handle for the current position of the file, whether it be the header or a row of the raster.  Use the handle as an argument to pm_seek()
       to reposition the file there later.  The file must be seekable (which you can ensure by opening it with pm_openr_seekable())orthismayfail.

   ENDIAN I/O
       pm_readbigshort(),   pm_writebigshort(),   pm_readbiglong(),   pm_writebiglong(),   pm_readlittleshort(),   pm_writelittleshort(),  pm_readlittlelong(),  and
       pm_writelittlelong() are routines to read and write short and long ints in either big- or little-endian byte order.  The return value is 0 upon  success  and
       -1 upon failure (either EOF or I/O error).

DESCRIPTION - PBM-SPECIFIC ROUTINES
   TYPES AND CONSTANTS
       typedef ... bit;

       #define PBM_WHITE ...

       #define PBM_BLACK ...

       Each bit should contain only the values of PBM_WHITE or PBM_BLACK.

       #define PBM_FORMAT ...

       #define RPBM_FORMAT ...

       #define PBM_TYPE PBM_FORMAT

       #define PBM_FORMAT_TYPE(f) ...

       These are for distinguishing different file formats and types.

   INITIALIZATION
       All PBM programs must call pbm_init just after invocation, before processing arguments.

   MEMORY MANAGEMENT
       pbm_allocarray()  allocates  an  array  of bits.  pbm_allocrow() allocates a row of the given number of bits.  pbm_freearray() frees the array allocated with
       pbm_allocarray() containing the given number of rows.  pbm_freerow() frees a row of bits.

   READING PBM IMAGE FILES
       pbm_readpbminit() reads the header from a PBM image in a PBM file, filling in the rows, cols and format variables.  pbm_readpbmrow() reads a row of bits into
       the bitrow array.  Format and cols were filled in by pbm_readpbminit().  pbm_readpbmrow_packed() is like pbm_readrow() except instead of returning a bits ar‐
       ray, it returns an array packed_bits of bytes with the pixels of the image row packed into them.  The pixels are in order from left to right across  the  row
       and  from  the  beginning  of the array to the end.  Within a byte, the bits are in order from the most significant bit to the least significant bit.  If the
       number of pixels in the row is not a multiple of 8, the last byte returned is padded on the least signficant bit side with undefined bits.  White  is  repre‐
       sented by a PBM_WHITE bit; black by PBM_BLACK.

       pbm_readpbm()  reads  an  entire  bitmap  file into memory, returning the allocated array and filling in the rows and cols variables.  This function combines
       pbm_readpbminit(), pbm_allocarray() and pbm_readpbmrow().

   WRITING PBM IMAGE FILES
       pbm_writepbminit() writes the header for a PBM image in a PBM file.  forceplain is a boolean value specifying that a plain format (text) file to be  written,
       as  opposed  to  a  raw format (binary) one.  pbm_writepbmrow() writes a row to a PBM file.  pbm_writepbmrow_packed() is the same as pbm_writepbmrow() except
       that you supply the row to write as an array of bytes packed with bits instead of as a bits array.  The format of packed_bits is the same as that returned by
       pbm_readpbmrow().

       pbm_writepbm() writes the header and all data for a PBM image to a PBM file.  This function combines pbm_writepbminit() and pbm_writepbmrow().

   MISCELLANEOUS
       pbm_nextimage() positions a PBM input file to the next image in it (so that a subsequent pbm_readpbminit() reads its header).

       Immediately  before a call to pbm_nextimage(), the file must be positioned either at its beginning (i.e. nothing has been read from the file yet) or just af‐
       ter an image (i.e. as left by a pbm_readpbmrow() of the last row in the image).

       In effect, then, all pbm_nextimage() does is test whether there is a next image or the file is positioned at end-of-file.

       If pbm_nextimage() successfully positions to the next image, it returns *eofP false (0).  If there is no next image in the file, it returns *eofP  true  (1).
       If it can't position or determine the file status due to a file error, it issues an error message and exits the program with an error exit code.

       pbm_check() checks for the common file integrity error where the file is the wrong size to contain all the image data.  pbm_check() assumes the file is posi‐
       tioned after an image header (as if pbm_readpbminit() was the last operation on the file).  It checks the file size to see if the number of bytes left in the
       file  are  the number required to contain the image raster.  If the file is too short, pbm_check() causes the program to exit with an error message and error
       completion code.  Otherwise, it returns one of the following values (enumerations of the enum pm_check_code type) as *retval:

       PM_CHECK_OK
              The file's size is exactly what is required to hold the image raster.

       PM_CHECK_UNKNOWN_TYPE
              format is not a format whose size pbm_check() can anticipate.  The only format with which pbm_check() can deal is raw PBM format.

       PM_CHECK_TOO_LONG
              The file is longer than it needs to be to contain the image raster.  The extra data might be another image.

       PM_CHECK_UNCHECKABLE
              The file is not a kind that has a predictable size, so there is no simple way for pbm_check() to know if it is the right size.  Only  a  regular  file
              has predictable size.  A pipe is a common example of a file that does not.

       check_type  must  have  the  value PM_CHECK_BASIC (an enumerated value of the pm_check_type enumerated type).  Otherwise, the effect of pbm_check() is unpre‐
       dictable.  This argument exists for future backward compatible expansion of the function of pbm_check().

SEE ALSO
       libpgm(3), libppm(3), libpnm(3), pbm(5)

AUTHOR
       Copyright (C) 1989, 1991 by Tony Hansen and Jef Poskanzer.

                                                                                                                                                           libpbm(3)
