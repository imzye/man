Refactor(3pm)                                                                       User Contributed Perl Documentation                                                                       Refactor(3pm)

NAME
       Devel::Refactor - Perl extension for refactoring Perl code.

VERSION
       $Revision: $  This is the CVS revision number.

SYNOPSIS
         use Devel::Refactor;

         my $refactory = Devel::Refactor->new;

         my ($new_sub_call,$new_sub_code) =
            $refactory->extract_subroutine($sub_name, $code_snippet);

         my $files_to_change = $refactory->rename_subroutine('./path/to/dir',
                                                             'oldSubName','newSubName');
         # $files_to_change is a hashref where keys are file names, and values are
         # arrays of hashes with line_number => new_text

ABSTRACT
       Perl module that facilitates refactoring Perl code.

DESCRIPTION
       The Devel::Refactor module is for code refactoring.

       While Devel::Refactor may be used from Perl programs, it is also designed to be used with the EPIC plug-in for the eclipse integrated development environment.

CLASS METHODS
       Just the constructor for now.

   new
       Returns a new Devel::Refactor object.

PUBLIC OBJECT METHODS
       Call on a object returned by new().

   extract_subroutine($new_name,$old_code [,$syntax_check])
       Pass it a snippet of Perl code that belongs in its own subroutine as well as a name for that sub.  It figures out which variables need to be passed into the sub, and which variables might be
       passed back.  It then produces the sub along with a call to the sub.

       Hashes and arrays within the code snippet are converted to hashrefs and arrayrefs.

       If the syntax_check argument is true then a sytax check is performed on the refactored code.

       Example:

           $new_name = 'newSub';
           $old_code = <<'eos';
             my @results;
             my %hash;
             my $date = localtime;
             $hash{foo} = 'value 1';
             $hash{bar} = 'value 2';
             for my $loopvar (@array) {
                print "Checking $loopvar\n";
                push @results, $hash{$loopvar} || '';
             }
           eos

           ($new_sub_call,$new_code) = $refactory->extract_subroutine($new_name,$old_code);
           # $new_sub_call is 'my ($date, $hash, $results) = newSub (\@array);'
           # $new_code is
           # sub newSub {
           #     my $array = shift;
           #
           #   my @results;
           #   my %hash;
           #   my $date = localtime;
           #   $hash{foo} = 'value 1';
           #   $hash{bar} = 'value 2';
           #   for my $loopvar (@$array) {
           #      print "Checking $loopvar\n";
           #      push @results, $hash{$loopvar} || '';
           #   }
           #
           #
           #     return ($date, \%hash, \@results);
           # }

       Included in the examples directory is a script for use in KDE under Linux.  The script gets its code snippet from the KDE clipboard and returns the transformed code the same way.  The new sub name
       is prompted for via STDIN.

   rename_subroutine($where,$old_name,$new_name,[$max_depth])
       where is one of:
         path-to-file
         path-to-directory

       If where is a directory then all Perl files (default is ".pl", ".pm", and ".pod" See the perl_file_extensions method.) in that directory and its' descendents (to max_depth deep,) are searched.

       Default for max_depth is 0 -- just the directory itself; max_depth of 1 means the specified directory, and it's immeadiate sub-directories; max_depth of 2 means the specified directory, it's sub-
       directories, and their sub-directrories, and so forth.  If you want to scan very deep, use a high number like 99.

       If no matches are found then returns undef, otherwise:

       Returns a hashref that tells you which files you might want to change, and for each file gives you the line numbers and proposed new text for that line.  The hashref looks like this,  where
       old_name was found on two lines in the first file and on one line in the second file:

        {
          ./path/to/file1.pl => [
                                  { 11  => "if (myClass->newName($x)) {\n" },
                                  { 27  => "my $result = myClass->newName($foo);\n"},
                                ],
          ./path/to/file2.pm => [
                                  { 235 => "sub newName {\n"},
                                ],
        }

       The keys are paths to individual files. The values are arraryrefs containing hashrefs where the keys are the line numbers where old_name was found and the values are the proposed new line, with
       old_name changed to new_name.

   is_perlfile($filename)
       Takes a filename or path and returns true if the file has one of the extensions in perl_file_extensions, otherwise returns false.

OBJECT ACCESSORS
       These object methods return various data structures that may be stored in a Devel::Refactor object. In some cases the method also allows setting the property, e.g. perl_file_extensions.

   get_new_code
       Returns the return_snippet object property.

   get_eval_results
       Returns the eval_err object property.

   get_sub_call
       Returns the return_sub_call object property.

   get_scalars
       Returns an array of the keys from scalar_vars object property.

   get_arrays
       Returns an array of the keys from the array_vars object property.

   get_hashes
       Returns an array of the keys from the hash_vars object property.

   get_local_scalars
       Returns an array of the keys from the local_scalars object property.

   get_local_arrays
       Returns an array of the keys from the local_arrays object property.

   get_local_hashes
       Returns an array of the keys from the local_hashes object property.

   perl_file_extensions([$arrayref|$hashref])
       Returns a hashref where the keys are regular expressions that match filename extensions that we think are for Perl files. Default are ".pl", ".pm", and ".pod"

       If passed a hashref then it replaces the current values for this object. The keys should be regular expressions, e.g. "\.cgi$".

       If passed an arrayref then the list of values are added as valid Perl filename extensions. The list should be filename extensions, NOT regular expressions, For example:

         my @additonal_filetypes = qw( .ipl .cgi );
         my $new_hash = $refactory->perl_file_extensions(\@additional_filetypes);
         # $new_hash = {
         #   '\.pl$'   => 1,
         #   '\.pm$'   => 1,
         #   '\.pod$'  => 1,
         #   '\.ipl$'  => 1,
         #   '\.cgi$'  => 1,
         #   '\.t$'    => 1,
         # }

TODO LIST
       Come up with a more uniform approach to ACCESSORS.
       Add more refactoring features, such as add_parameter.
       Add a SEE ALSO section with URLs for eclipse/EPIC, refactoring.com, etc.

AUTHOR
       Scott Sotka, <ssotka@barracudanetworks.com>

COPYRIGHT AND LICENSE
       Copyright 2005 by Scott Sotka

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

perl v5.36.0                                                                                     2022-11-21                                                                                   Refactor(3pm)
