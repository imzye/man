
XS(1)                                                                                       General Commands Manual                                                                                       XS(1)

NAME
       xs - extensible shell

SYNOPSIS
       xs [-silevxnpod] [-c FRAGMENT | SCRIPT [ARGUMENTS]]

DESCRIPTION
       Xs is a command interpreter for Linux.  Xs allows programming in a functional style and has a simple, consistent syntax.

       Xs provides hooks to customize many of its internal operations, including primitives for exception handling and lexical and dynamic control flow.

       A significant portion of xs is implemented in xs.

       Xs is a descendant of rc(1) and es(1); the three implementations are not interoperable.

OPTIONS
       -s            Read commands from standard input; pass the first argument to xs rather than taking the argument as the name of a file to source.
       -i            Force xs to be an interactive shell even if commands do not come from standard input via a terminal.
       -l            Cause xs to be a login shell, as if it had been invoked as -xs.
       -e            Exit if any command (apart from those appearing as tests in conditional forms or as arguments to logical operators) returns a false status.
       -v            Echo input to standard error.
       -x            Print commands to standard error.
       -n            Disable command execution.
       -p            Don't initialize functions from the environment.
       -o            If any of file descriptors 0, 1 or 2 are inherited closed, leave them closed rather than open on /dev/null.
       -d            Don't trap SIGQUIT or SIGTERM.
       -c FRAGMENT   Execute the FRAGMENT.  (See Program fragments, below.)

LANGUAGE
       Lexically, an xs program consists of words and punctuation.  (See FOOTNOTE.)

   Words
       In its simplest form, a word is a sequence of non-special characters.  The special characters are:

              # $ & ' ( ) ; < > \ ^ ` { | } space tab newline

       The empty word is denoted by ''.

       Words are indivisible and immutable.

   Escapes
       A special character may escaped by preceeding it with a backslash (\); this defeats the character's special meaning, allowing the character to be (part of) a word.

       Other escapes denote control characters:

              \a   alert (bell)
              \b   backspace
              \e   escape
              \f   form feed
              \n   newline
              \r   return
              \t   tab

       A character octet may be denoted by its hexadecimal or octal code point:

              \xnn   Character octet nn, for n in {0..0, a..f, A..F}
              \mnn   Character octet mnn, for m in {0..3} and n in {0..7}

       A UTF-8 octet sequence may be denoted using the escape sequence:

              \u'n...'   UTF-8 character having codepoint n..., for one to six n in {0..9, a..f, A..F}

       Xs does not allow scripts to contain a NUL character; thus the following are all invalid:

              \000, \x00 and \u'0'.

       A backslash must not be followed by a sequence of characters other than as described above.

   Quoted words
       A sequence of characters enclosed by apostrophes (') is a word; the bounding ' are not part of the word.  We refer to this form as a quoted word.

       An apostrophe is written within a quoted word by doubling it, e.g.,

              'Sam''s word' .

       All other special characters lose their meaning within a quoted word.

   Commands
       A command is a sequence of words separated by whitespace.  The first word is always the name of an executable program on $path, an xs function, or a lambda (defined below).  Subsequent words are argu‐
       ments; these are subject to evaluation, expansion and substitution.  Because the arguments are passed as a list, any argument that yields () will "disappear" (see Lists).

   Command separator
       A command must occupy one logical line.  Commands are separated by newlines or semicolons (;).

   Program fragments
       A program fragment (henceforth fragment) is a sequence of zero or more commands enclosed in braces:

              {command*} .

       A fragment may span multiple physical lines.

       The value of a fragment is the result code returned by the last command executed.  An empty fragment ({}) has a result of zero.  A fragment containing a pipeline (see Pipes) returns a list of results:
       one for each function or executable in the pipeline; the list is true in the aggregate only if each element is true (see Truth values).

       A fragment appearing as a parameter of a function or executable is treated as a single word.  Fragments are indivisible and immutable.

       The braces may be elided if the command is a single word having no arguments.

   Comments
       The hash mark (#) introduces a comment which ends at newline.

   Line continuation
       Program text may be split across physical lines by ending each logical line with a backslash (\).  The backslash and the immediately following newline are read as a space.

   Lists
       A list is a space-separated sequence of words.  The empty list is denoted by ().  All lists are flat in xs; balanced parentheses may be written for grouping, but they do not create a tree.  Thus

              this is a list of seven words

       and

              this (is a list) ((of) () (seven words)) ()

       are identical.

       A list enclosed in parentheses may span multiple lines without need of line continuation characters.

   Concatenation
       Lists may be joined using the concatenation operator, caret (^).

       A list of length one is a word.  Concatenating two words creates a new word.

       When either list has length greater than one, the result of concatenation is the cross product of the lists.

       When either list is empty, the result of concatenation is the empty list.

   Variable names
       Letters,  digits,  all  UTF-8  characters  encoded as at least two octets (i.e., code points greater than \u'7f') and the characters percent (%), star (*), hyphen (-) and underscore (_) may be used in
       variable names.  These characters may appear in any order or combination.

       The xs special characters (see Words) may also appear in a variable name if quoted or escaped.  Likewise, character escapes (see Escapes) may be part of a variable name.

       Variable names having the prefix fn- or var- have special meaning; see Functions and Settors, respectively.

   Assignment
       A variable is assigned a list value using the notation

              var = list .

       The spaces around = are mandatory.

       A variable becomes undefined by assigning an empty list as its value.  While

              var = ()

       is valid, the preferred form is

              var =    .

       The value of an assignment is its assigned value.

   Variables
       All variables are exported to the environment unless declared within a local, let or for form (described below).

       A variable's value is retrieved by writing $ before its name, like $var .  Indirection (multiple $) is allowed.

       An undefined variable yields the empty list when referenced.

       A variable name may be constructed at runtime.  Parentheses must enclose expressions used to construct a name.

   Subscripted reference
       Specific list elements may be selected via subscripting.  This takes the form

              $var(subscripts) .

       List elements are indexed starting at one.  A subscript less than 1 is an error.  A subscript greater than the number of list elements yields the empty list.

              a = w x y z; echo $a(2 3 4 4 3)
                     prints x y z z y .

       Subscripts may be specified as ranges by separating the range endpoints with ... .  The range operator must be separated from its arguments by spaces.

       Either end of the range may be left unspecified.

              $var(... 7)
                     yields elements 1 through 7 of the list.

              $var(3 ...)
                     yields elements 3 through the end of the list.

       Reversing the endpoints of a range returns the values in reversed order:

              a = s d r a w k c a b; $a(5 ... 2)
                     yeilds the list w a r d .

       If subscripts is an empty list, the result is empty.

   Multiple assignment
       A list of variables may be specified on the left side of an assignment.  Parentheses are mandatory around the list of variables.

       Corresponding list elements on the right side are assigned to variables on the left.  If the right side has more elements than there are variables on the left, the rightmost variable is  assigned  the
       list value of the remaining elements.  If there are more variables than list elements, the excess variables are assigned the empty list.

       Variable names may not be computed or subscripted on the left side of a multiple assignment.

   List length
       The length of a list assigned to a variable is given by

              $#var .

   Flattening
       A  list may be flattened to a single word using the $^ operator.  This yields a word composed of the words of the given list, with a single space between each pair of words.  As with the subscript op‐
       erator, this applies only to a variable (not literal) list.

   Free carets
       Concatenation may be written implicitly (rather than using the ^ operator) in certain situations.  If a word is followed by another word, $ or ` without intervening whitespace, then xs inserts a caret
       between them.

   Wildcard patterns
       A pattern is a word which may contain wildcards.

       *      Matches zero or more characters.

       ?      Matches exactly one character.

       [class]
              Matches any of the characters specified by the class, following the same rules as those for ed(1), except that class negation is denoted by ~ since ^ has another interpretation in xs.

   Pathname expansion
       Where a word may be treated as a pathname, xs expands wildcards.

       The pathname separator, /, is never matched by *.  The ? wildcard never matches a dot at the beginning of a pathname component.

       A tilde (~) alone or followed by a slash (/) is replaced by the value of $home.  A tilde followed by a username is replaced with the home directory path of that user.  (See getpwent(3).)

       A quoted wildcard loses its meaning as a wildcard.

   Pattern matching
       The pattern matching operator (~) returns true when a subject matches any of the given patterns:

              ~ subject pattern ... .

       A subject may be a list.  If composed of individual words or expressions, the subject list must be enclosed by parentheses.

       Pattern wildcards are never expanded with pathnames from the filesystem.

   Pattern extraction
       The pattern extraction operator (~~) returns the parts of each subject that match a wildcard in the patterns:

              ~~ subject pattern ... .

       Subjects and patterns are the same as for the pattern matching operator.

   Arithmetic substitution
       An infix arithmetic expression may be evaluated to produce a single word representing its value:

              `(expression) .

       The expression consists of numeric values and the infix operators +, -, *, /, % (modulus), and ** (exponentiation); these obey the usual precedence and associativity rules and may be otherwise grouped
       using parentheses.

       A value is either a numeric constant or a variable reference yielding a numeric value.  Numbers may be integer or floating-point; the latter are stored with limited precision (usually six  significant
       digits).

       Integer overflow does not signal an exception.

       If an expression involves any floating-point value, the result will be floating-point.

       Division of integers produces an integer result via truncation.  Modulus behaves as fmod(3) if either argument is floating-point.

       An undefined variable (a variable reference yielding value ()) is treated as zero within an arithmetic expression.

       Variables  having subscripted or constructed names may not be used in an arithmetic expression.  Variable names in an expression may not be spelled using the characters which denote the arithmetic op‐
       erators.

   Pipes
       The standard output of one fragment may be piped to the standard input of another:

              fragment1 | fragment2 .

       Other file descriptors may be connected:

              fragment1 |[fd1=fd2] fragment2 .

       The form

              fragment1 |[fd1] fragment2

       is identical to

              fragment2 |[fd1=0] fragment2 .

   Command substitution
       The backquote form creates a list from the standard output of a fragment:

              `fragment .

       Words are parsed from the standard output using the separators defined by $ifs.

       This variant backquote form binds $ifs to the given list of separators:

              `` separators fragment .

   Functions
       Xs has two forms by which a function is defined:

              fn name fragment

       and

              fn-name = fragment .

       The former is normally used for top-level and nested definitions; the latter must be used when binding a function for local use.  Because the latter is an assignment, the spaces around  =  are  manda‐
       tory.

   Lambdas
       A lambda is an unnamed function.  In xs, a lambda is written as a fragment in which the first element may be a lambda list (see below).  A lambda without a lambda list is a lambda with no arguments.

   Lambda list
       A lambda list binds names to function arguments.  Its form is:

              |name ...| .

       Arguments are bound to names left-to-right.  Excess arguments bind in a list to the last name.  Excess names are bound to ().

       A lambda list may only appear as the first element of a fragment.

   Truth values
       The values 0, '' and () are all treated as true; everything else (including 0.0) is false.  A list of true values is true; a list containing an untrue value is false.

       The keywords true and false are equivalent to result 0 and result 1, respectively.

   Return values
       The value of evaluating a fragment is the return value of the last function or executable evaluated before leaving the fragment.

       A specific result may be returned by:

              result list .

   Logical operators
       The following operators apply to truth values:

              value1 && value2
                     True if both value1 and value2 are true.

              value1 || value2
                     True if value1 is true or if value1 is false and value2 is true.

              ! value
                     True if value is false.

       The && and || operators evaluate their arguments from left to right, stopping when the value of the expression is determined.

   Relational operators
       Numbers and strings may be compared using the relational operators:

              value1 :lt value2
                     True if value1 is less than value2.

              value1 :le value2
                     True if value1 is less than or equal to value2.

              value1 :gt value2
                     True if value1 is greater than value2.

              value1 :ge value2
                     True if value1 is greater than or equal to value2.

              value1 :eq value2
                     True if value1 is equal to value2.

              value1 :ne value2
                     True if value1 is not equal to value2.

       If either argument is non-numeric, the arguments are compared according to the current locale's collation order.

   Input and output
       Input may be redirected from a file to standard input:

              <filename fragment

       or

              fragment <filename .

       It is an error if the file does not exist or is not readable.

       Output may be redirected from standard output to a file:

              fragment >filename

       or

              >filename fragment .

       The file is created if it does not exist.  If the file already exists, its contents are replaced.  It is an error for the file to not be writable.

       Other file descriptors may be specified:

              fragment >[ofd]filename

       and

              fragment <[ifd]filename .

       A file descriptor may be duplicated using the form:

              >[fd1=fd2] .

       This causes output to fd1 to be written instead to fd2.  Thus,

              fragment >filename >[2=1]filename

       causes both standard output and standard error to be written to the same file.

       Other redirection operators have their own semantics:

              >>filename
                     Append to an existing file; the file is created if nonexistent.

              <>filename
                     Open a file for reading and writing (on standard input unless otherwise specified).

              <>>filename
                     Open a file for reading and appending (on standard input unless otherwise specified).

              ><filename
                     Truncate a file and open it for reading and writing (on standard output unless otherwise specified).

              >><filename
                     Open a file for reading and appending (on standard output unless otherwise specified).

       Files opened for reading must be readable.  Files opened for writing or appending must be writable.

       An open file descriptor is closed using this form:

              >[fd=] .

       File descriptors must be integer constants.

   Literal input
       Multiple lines of input may be read from a script using a "here document":

              fragment <<eof-marker

       or

              fragment <<'eof-marker' .

       The eof-marker is a word which must appear on a line by itself immediately following the final newline of textual data taken as input.

       The  first  form (with the unquoted eof-marker) replaces variables within the textual data.  (Only simple variables; indirection, subscripts and constructed names are not allowed.)  A $ can be emitted
       literally by writing $$.  To emit the value of a variable followed immediately by a literal word, write: $var^word .  The caret (^) is taken literally elsewhere in a here document.

       The second form (with the quoted eof-marker) copies the textual data without substitution of any kind.

       Text may also provide the content of a readable file via a "here string":

              <<<'text' .

       The text may span lines.  No substitution is performed within a here string.

       A here string may also be created using a variable for the content, like <<<$var .

   Process substitution
       Process substitution allows for the output of a command to be read from a file descriptor or for data written to a file descriptor to be read by a command, using the forms:

              <{command+}

       and

              >{command+} .

       The files created by process substitution are implemented using pipes, which are not seekable.

       Multiple commands may appear within the braces.

       Note that the braces are an essential part of this syntax; these are not >fragment and <fragment .

   Local variables
       Local variables exist only during execution of their binding form:

              local (binding ...) fragment ,

       where binding is either name = value or just name (and value is taken as ()).  Multiple bindings are separated by ;.

       While bound by local, variables are accessible within the environment.

   Lexical variables
       Lexical variables are bound by the form:

              let (binding ...) fragment ,

       where binding is either name = value or just name (and value is taken as ()).  Multiple bindings are separated by ;.

       A lexical variable is accessible only within fragment.  Furthermore, a lexical variable persists across executions of a function which is defined within the let form.  A lexical binding is stored as a
       closure in the environment.  The binding is not accessible as an environment variable.

   Conditionals
       Xs has two main conditional forms:

              if condition fragment else fragment ,

       where condition is a boolean expression and the else branch is optional, and

              switch var cases ,

       where cases is a list of word fragment, each representing the code to be executed for a specific value of var, followed by a fragment to be executed when none of the words match var.

   Loops
       Xs has these looping forms:

              while condition fragment
              until condition fragment
              for vars-and-values fragment
              forever fragment

       The while form executes fragment while condition is true.

       The until form executes fragment until condition is false.

       The  for  form executes fragment with variables bound to consecutive values in vars-and-values, which is a sequence of one or more var list forms separated by ;.  This continues until the longest list
       is exhausted; shorter lists are implicitly padded with () to match the length of the longest list.

       The forever fragment form loops forever, like while true fragment.

   Settors
       A settor function is a variable like set-var.

       When var is assigned, set-var is called as a function, passing the value to be assigned.  $0 is bound to the name of the variable being assigned.  The result of the settor function is used as the  as‐
       signment's value.

       A settor is never invoked on a lexical variable.

   Exceptions
       Exceptions  in  xs  are used for non-lexical control transfer.  An exception is passed up the call chain to the most recently established catcher.  The catcher may handle the exception, retry the code
       which caused the exception or throw the exception to the next catcher.

       An exception is a list.  The first word denotes the exception type, one of:

              eof    Raised by the xs parser at end of input.

              error  The following words are the source (typically a descriptive name such as the name of the function which signalled the error) and a message.  xs provides a last-resort  catcher  to  print
                     the message.

              exit   The next word is an optional numeric return code (default: 0).  This exception, when caught by xs, exits the shell with the given return code.

              retry  When  raised  by a catcher, this causes the body of the catch form to run again.  Note that the catcher must have done something to clear the cause of the exception; otherwise retry will
                     cause an infinite loop.

       The catch form executes its body in the context of a catcher:

              catch catcher body .

       The catcher and body are fragments.

   Upward funargs
       An "upward funarg" is a function returned from another function.  Because a returned function may be executed in a different lexical context, all free variables referenced by the function must be cap‐
       tured in a let binding.  In other words, an upward funarg must be let-bound.

       A  fragment  or lambda may be returned instead of a closure only in the case where the code references no free variables.  This practice is discouraged as it will cause your code to fail should a free
       variable be added later.

BUILTIN VARIABLES
       These dynamic variables form a part of the programming interface to xs.

       *      The arguments passed to xs.  Individual arguments may be referenced via subscripts or as $1, $2, $3, etc.

       0      At the top level, this variable (i.e., $0) is the value of xs's argv[0] or the name of a sourced file.  Within an executing function, the name of the function.

       apid   The ID of the most recently started background process.

       history
              The pathname of the file to which xs appends commands read by the toplevel loop.  This may be left undefined.

       home   The path to the current user's home directory.  $home and $HOME are aliased to each other.

       ifs    The input field separator, used by backquote (`) to split command output into words.  The initial value is the list
              space tab newline .

       max-eval-depth
              Sets an upper bound on the size of the interpreter's evaluation stack.

       noexport
              A list of dynamic variable names which xs will not export to the environment.

       path   A list of directories to be searched for executable programs.  The current directory is denoted by the empty word ('').  $path and $PATH are aliased to each other,  with  appropriate  syntactic
              adjustments.

       pid    The process ID of the running xs.

       prompt $prompt(1)  is  printed  before  reading a command.  $prompt(2) is printed before reading a continuation line.  The default, ';' '', facilitates copy-paste from a terminal session into a script
              file.  $prompt may contain ANSI terminal control characters and sequences.

       signals
              A list of signals trapped by xs.  For each signal name on $signals, xs raises a correspondingly-named exception upon trapping the signal.  A signal's disposition is determined  by  an  optional
              prefix to its name:

              -      Ignore the signal, here and in child processes.

              /      Ignore the signal here, but take its default behavior in child processes.

              . (for sigint and sigwinch)
                     Perform normal processing (i.e., print an extra newline upon receipt of sigint; note the new window size upon receipt of sigwinch).

              none   Default behavior.

              The initial value of $signals is

                     .sigint /sigquit /sigterm -sigxcpu .sigwinch -sigpwr

              plus  any signals ignored (/) when xs started.  xs recognizes that sigxcpu and sigpwr are used by its garbage collector and intentionally ignores them to avoid disrupting the collector's opera‐
              tion.

       Xs maintains $SHLVL for interoperability with other shells.

BUILTIN COMMANDS
       These commands are built into xs, and execute within the xs process.

       . [-einvx] file [args...]
              Sources file.  The options are a subset of those recognized by xs; see Options.

       access [-n name] [-1e] [-rwx] [-fdcblsp] path...
              Tests paths for accessibility.  Without the -1, -e and -n options, access returns true for paths which are accessible as specified.  A printable error message (which  evaluates  as  false;  see
              Truth  values) is returned for paths which are not accessible.  The default test (no options) returns true if a path exists, regardless of mode or type.  These options determine the test to ap‐
              ply to the paths:

              -r   Is the path readable?
              -w   Is the path writable?
              -x   Is the path executable?
              -f   Is the path a plain file?
              -d   Is the path a directory?
              -c   Is the path a character device?
              -b   Is the path a block device?
              -l   Is the path a symbolic link?
              -s   Is the path a socket?
              -p   Is the path a named pipe?

              With the -n name option, the paths are applied to name, producing a list of test results.

              With -1, access returns the first path to satisfy the test.  If no path satisfies the test, return the empty list unless -e was specified, in which case not having a satisfied  test  causes  an
              error to be raised.

       alias name expansion...
              Define a function with expansion as its body.  The first word of expansion is replaced with its whats value to prevent the recursion that would occur if name and the first word of expansion are
              the same.

       catch catcher body
              Run body.  If an exception is raised, run catcher.  The exception is passed as an argument to catcher.

       cd [directory]
              Set the working directory to directory.  With no argument, this is the same as cd $home.

       dirs [-c]
              Show the directory stack (see pushd and popd).  With -c, clear the directory stack.

       echo [-n] [--] args...
              Print args to standard output, separated by spaces.  The output ends with a newline unless suppressed by -n.  Arguments following -- are taken literally.

       escape lambda
              Run lambda, a function of one argument.  The argument names a function (like fn-somename) which, when evaluated within lambda, transfers control to just after the escape form.  Arguments of the
              escape function are returned as the value of the form.

       eval list
              Convert list to a word and pass it to the xs interpreter for parsing and execution.

              Lexical bindings are not available to eval.  The following code prints "dyn":

                      x = dyn
                      let (x = lex) {
                          eval 'echo $x'
                      }

       exec cmd
              Replace xs with cmd.  If cmd has only redirections, then apply the redirections to the current xs.

       exit [status]
              Cause xs to exit with the given status, or with zero if status is not given.

       false  Identical to result 1.

       for vars-and-values... fragment
              See Loops.

       forever fragment
              See Loops.

       fork command
              Run command in a subshell.

       history [#|-c|-d #|-n|-y]
              Without arguments, show command history.  # shows the most recent # history entries.  -c clears the history.  -d # deletes history entry #.  -n and -y disable and enable history recording.

       if condition fragment [else fragment]
              See Conditionals.

       jobs   List background jobs.

       limit [-h] [resource [value]]
              Display  or  alter  process  resource limits.  -h for hard limits.  Value is either unlimited or a number.  Numbers representing size allow the suffixes k (kilobyte), m (megabyte), and g (giga‐
              byte).  Numbers representing time allow the suffixes s (seconds), m (minutes), and h (hours) as well as durations like hh:mm:ss and mm:ss.

       map action list
              Apply action individually to each element of list; collect the results as map's result.

       omap action list
              Like map, but collect a list of the outputs of action.

       popd   Pop the directory stack to set the working directory, and print the new stack.  The command is ignored if the directory stack is empty.

       printf format args...
              Print args on standard output according to format.  Valid format conversions are those of printf(3p), except that there must be a one-to-correspondence between format specs (excluding  %%)  and
              arguments: positional argument specs, variable width and precision, and excess arguments are all disallowed.  Escapes must be unquoted in format.

       pushd [dir]
              Push dir's absolute path onto the directory stack, set the working directory to dir and show the new stack.  If dir is omitted and the stack is at least two deep, then alternate between the two
              top directories.

       read   Read from standard input and return a single word containing a line of text (without the newline).  Return () upon end-of-file.

       result value...
              Return values.

       switch value [case action]... [default-action]
              See Conditionals.

       throw exception arg...
              See Exceptions.

       time command arg...
              Execute command with args.  Print consumed real, user and system time to standard error.

       true   Identical to result 0.

       umask [mask]
              Set or show the umask.

       until test body
              See Loops.

       unwind-protect body cleanup
              Execute body; when it completes or raises an exception, run cleanup.

       var var...
              Print definition of var(s).

       vars [-vfs] [-epi]
              Print definition of all variables which satisfy the given options:

              -v   variables (not functions or settors).  This is the default if none of -v, -f or -s is given.
              -f   functions
              -s   settors
              -e   exported.  This is the default if none of -e, -p or -i is given.
              -p   private (not exported)
              -i   internal (predefined and builtin)
              -a   all of the above

       wait [pid]
              Wait for a child process denoted by its pid to exit.  If no pid is given, wait for any child process.

       whats command...
              Identify command(s) by pathname, primitive, or fragment.

       while test body
              See Loops.

HOOK FUNCTIONS
       The following functions implement specific parts of xs semantics; a hook function can be rewritten to provide special behaviors.  Hook functions are normally called as a result of xs translating  pro‐
       grams into an internal form.  See CANONICAL FORM.

       %and command...
              Execute command(s) from left to right, stopping at the command that first yields a false value.  The false value is returned by %and.

       %append fd file command
              Run command with fd open in append mode on file.

       %background command
              Run command as a background process.  If xs is an interactive shell, print the background process ID.

       %backquote separators command
              Run command as a child process, splitting standard output into words at any character in separators.

       %close fd command
              Run command with the closed file descriptor fd.

       %cmp word1 word2
              Compare  word1  to  word2  and  return -1, 0 or 1 if word1 is respectively less than, equal to or greater than word2.  If either argument is non-numeric, then a lexicographic comparison is done
              based upon the locale's collation order.

       %count list
              Return the number of words in list.

       %create fd file command
              Run command with fd open for writing on file.

       %dup newfd oldfd command
              Run command with oldfd copied to newfd.

       %exit-on-false command
              Run command; exit xs if any part of command (outside of conditional tests and arguments to logical operators) returns a false value.

       %flatten separator list
              Concatenate the words of list, interposing separator.

       %here fd word... command
              Run command with words passed as an input file on fd.

       %not command
              Run command and invert the boolean sense of its result.

       %one list
              Return list if it contains exactly one word; otherwise raise a "too many files in redirection" error.

       %open fd file command
              Run command with file open for reading on fd.

       %open-append fd file command
              Run command with file open for reading and appending on fd.

       %open-create fd file command
              Run command with file open for reading and writing on fd.  If the file exists, truncate it.

       %open-write fd file command
              Run command with file open for reading and writing on fd.

       %openfile mode fd file command
              Run command with file open on fd with the given mode.

       %or command...
              Execute command(s) from left to right, stopping at the command that first yields a true value.  The true value is returned by %or.

       %pathsearch program
              If program exists in a directory on $path, return the full path to program.  Otherwise raise an error.

       %pipe command1 [outfd infd command2] ...
              Run commands with outfd of command1 connected via a pipe to infd of command2.  Additional commands may be added to the pipeline.

       %readfrom var input command
              Run command with var bound to the name of a file containing the standard output produced by the command input.

       %seq command...
              Run commands in order, from left to right.

       %whats program...
              Return the pathname, primitive, or fragment of each program.

       %writeto var output command
              Run command with var bound to the name of a file containing the standard input to be consumed by the command output.

UTILITY FUNCTIONS
       These functions also define xs behavior, but are less useful for customization:

       %apids Return the process IDs of all background processes for which xs has not yet waited.

       %fsplit separators arg...
              Split each arg word at any separators character, producing a list.  Repeated instances of separators in args create empty words ('') in the result.

       %is-interactive
              Return true if the innermost toploop is interactive.

       %is-login
              Return true if this is a login shell.

       %newfd Return a file descriptor that the shell believes is not otherwise used.

       %run program argv0 args...
              Run program, which must be an absolute pathname, passing argv0 as the program's name and args as its arguments.

       %split separators arg...
              Like %fsplit, but repeated instances of a separators character in args are coalesced.

       %var var...
              Return the definition of each var.

PRIMITIVE FUNCTIONS
       Primitives provide the underlying behaviors for many hooks and builtins, and may not be redefined.
                         │
       Primitive         │ Implements
       ──────────────────┼────────────────────────────────────────────────
       $&access          │ access
       $&apids           │ %apids
       $&background      │ used by %background
       $&backquote       │ used by %backquote
       $&batchloop       │ %batch-loop
       $&catch           │ catch
       $&cd              │ used by cd
       $&close           │ %close
       $&cmp             │ %cmp
       $&collect         │ invokes GC
       $&count           │ %count
       $&dot             │ .
       $&dup             │ %dup
       $&echo            │ echo
       $&exec            │ exec
       $&exitonfalse     │ %exit-on-false
       $&flatten         │ %flatten
       $&forever         │ forever
       $&fork            │ fork
       $&fsplit          │ %fsplit
       $&here            │ %here
       $&home            │ %home
       $&if              │ if
       $&internals       │ used by vars
       $&isinteractive   │ %is-interactive
       $&islogin         │ %is-login
       $&len             │ count chars in word(s)
       $&limit           │ limit
       $&newfd           │ %newfd
       $&newpgrp         │ newpgrp
       $&openfile        │ %openfile
       $&parse           │ %parse
       $&pipe            │ %pipe
       $&primitives      │ list xs primitives
       $&printf          │ printf
       $&random          │ random integer
       $&read            │ %read
       $&readfrom        │ %readfrom
       $&resetterminal   │ used to keep readline(3) in sync with terminal
       $&result          │ result
       $&run             │ %run
       $&seq             │ %seq
       $&sethistory      │ set-history
       $&setmaxevaldepth │ set-max-eval-depth
       $&setnoexport     │ set-noexport
       $&setsignals      │ set-signals
       $&split           │ %split
       $&throw           │ throw
       $&time            │ time
       $&umask           │ umask
       $&var             │ %var
       $&vars            │ used by vars
       $&version         │ version info
       $&wait            │ wait
       $&whats           │ %whats
       $&wid             │ count character cells in word(s)
       $&writeto         │ %writeto

TOPLOOPS
       A toploop repeatedly reads and executes a command and prints its result.  Xs has two toploops, one of which is selected depending upon xs options.

       %batch-loop
              This is the toploop for a non-interactive shell and for the dot (.)  and eval commands when their input is non-interactive.  %batch-loop returns upon catching an exception.

       %interactive-loop
              This is the toploop for an interactive shell and for the dot (.)  and eval commands when their input is interactive.  %interactive-loop returns upon catching an eof exception.

              The %interactive-loop has a hook function, %before-interactive-prompt; if defined, this is called — passing the return code of the prior command — after %prompt but before printing the  initial
              prompt.

       Xs binds one of the following functions to fn-%dispatch for use by the toploop.  The choice of function is determined by whether the shell is interactive and by the -n and -x options.

              %eval-noprint command
              %eval-print command
              %noeval-noprint command
              %noeval-print command

       These functions handle command input for the shell:

       %parse prompt1 prompt2
              Read input after printing prompt1 initially and prompt2 for continuation lines.  Return a fragment suitable for execution.  Raise an eof exception at end of input.

       %prompt Xs calls this hook immediately before %parse.  A common use is to update the value of $prompt.

CANONICAL FORM
       Xs rewrites surface syntax in terms of hook functions.

   Control flow
       ! command                    %not {command}
       command &                    %background {command}
       command1 ; command2          %seq {command1} {command2}
       command1 && command2         %and {command1} {command2}
       command1 || command2         %or {command1} {command2}
       fn name {|arg...| command}   fn-^name = {|arg...| command}

   Input/output
       command < file             %open 0 file {command}
       command > file             %create 1 file {command}
       command >[n] file          %create n file {command}
       command >> file            %append 1 file {command}
       command <> file            %open-write 0 file {command}
       command <>> file           %open-append 0 file {command}
       command >< file            %open-create 1 file {command}
       command >>< file           %open-append 1 file {command}
       command >[n=]              %close n {command}
       command >[m=n]             %dup m n {command}
       command << tag input tag   %here 0 input {command}
       command <<< word           %here 0 word {command}
       command1 | command2        %pipe {command1} 1 0 {command2}
       command1 |[m=n] command2   %pipe {command1} m n {command2}
       command1 >{ command2 }     %writeto var {command2} {command1 $var}
       command1 <{ command2 }     %readfrom var {command2} {command1 $var}

   Expressions
       $#var                       <={%count %var}
       $^var                       <={%flatten ' ' $var}
       `{ command arg... }         <={%backquote <={%flatten '' $ifs} {command arg...}}
       `` ifs { command arg... }   <={%backquote <={%flatten '' ifs} {command arg...}}

   Relational operators
       a :lt b   {~ {%cmp a b} -1}
       a :le b   {~ {%cmp a b} -1 0}
       a :gt b   {~ {%cmp a b} 1}
       a :ge b   {~ {%cmp a b} 1 0}
       a :eq b   {~ {%cmp a b} 0}
       a :ne b   {~ {%cmp a b} -1 1}

EDITING
       Input  editing  is  provided by readline(3) and configured by ~/.inputrc.  The ~/.inputrc file may contain definitions specifically for xs, and not other readline(3)-aware programs, through use of the
       conditional construct $if xs.

FILES
       These files are read and interpreted when xs starts:

              ~/.xsrc
                     when xs is a login shell

              ~/.xsin
                     when xs is an interactive shell

       When both ~/.xsrc and ~/.xsin are read, ~/.xsrc is read first.

SEE ALSO
       Additional documentation is installed in prefix/share/doc/xs .  Prefix is typically /usr or /usr/local.

DEPRECATIONS
       The following forms are deprecated and should not be used for new xs code.

                  \unnnn   UTF-8 character having codepoint nnnn, for n in {0..9, a..f, A..F}
              \Unnnnnnnn   UTF-8 character having codepoint nnnnnnnn, for n in {0..9, a..f, A..F}

       NOTICE: Deprecated features, syntax and behaviors are preserved only until the next major release of xs.

BUGS
       The shell does not support job control.

       The interpreter does not implement tail recursion.

       Xs reserves the octets \001 and \002 to annotate variables stored in the environment.  This may present problems for interchange of variables with another program that stores these octets in the envi‐
       ronment.

       Please report issues at <https://github.com/TieDyedDevil/XS>.

SOURCE
       The git(1) source repository is at <https://github.com/TieDyedDevil/XS>.

PACKAGES
       Xs is packaged for Fedora.  The xs 1.1 release first appeared in Fedora 27.

AUTHORS
       Xs 1.1 and later is maintained by David B. Lamkins <david@lamkins.net>.

       Xs 1.0 (self-reporting as 0.1) was maintained by Frederic Koehler <fkfire@gmail.com>.

       Es to 0.9-beta was maintained by Soren Dayton <csdayton@cs.uchicago.edu>.  Es up through 0.84 was maintained by Paul Haar <haahr@adobe.com> and Byron Rakitzis <byron@netapp.com>.

       The rc shell for Plan 9 was written at Bell Labs by Tom Duff.  The Unix port was written by Byron Rakitizis and maintained by Toby Goodwin.  See <http://tobold.org/article/rc>.

       Other contributors may be found in the CHANGES file and in the commit log.

FOOTNOTE
       Yes, and of course whitespace.  Some things should be left unsaid.

                                                                                                  2018 - v1.2                                                                                             XS(1)
