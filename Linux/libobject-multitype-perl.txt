MultiType(3pm)                                                                      User Contributed Perl Documentation                                                                      MultiType(3pm)

NAME
       Object::MultiType - Perl Objects as Hash, Array, Scalar, Code and Glob at the same time.

SYNOPSIS
         use Object::MultiType ;

         my $scalar = 'abc' ;
         my @array  = qw(x y z);
         my %hash   = (A => 1 , B => 2) ;

         my $obj = Object::MultiType->new(
         scalar => \$scalar ,
         array  => \@array ,
         hash   => \%hash ,
         code   => sub{ return("I'm a sub ref!") ; }
         glob   => \*STDOUT ,
         ) ;

         print "Me as scalar: $obj\n" ;

         my $array_1 = $obj->[1] ;
         print "$array_1\n" ;

         my $hash_B = $obj->{B} ;
         print "$hash_B\n" ;

         my $hash = $$obj->hash ;
         foreach my $Key (sort keys %$hash ) {
           print "$Key = $$hash{$Key}\n" ;
         }

         &$obj(args) ;

DESCRIPTION
       This module return an object that works like a Hash, Array, Scalar, Code and Glob object at the same time.

       The usual way is to call it from your module at new():

         package FOO ;

         use Object::MultiType ;
         use vars qw(@ISA) ;
         @ISA = qw(Object::MultiType) ; ## Is good to 'Object::MultiType' be the last in @ISA!

         sub new {
           my $class = shift ;
           my $this = Object::MultiType->new() ;
           bless($this,$class) ;
         }

METHODS
       ** See the methods of the Saver too.

   new
       Arguments:

       bool      The boolean reference. Default: undef

       boolcode|boolsub
                 Set the sub/function (CODE reference) that will return/generate the boolean value.

       scalar    The SCALAR reference. If not sent a null SCALAR will be created.

       scalarcode|scalarsub
                 Set the sub/function (CODE reference) that will return/generate the scalar data of the object.

       array     The ARRAY reference. If not sent a null ARRAY will be created.

       hash      The HASH reference. If not sent a null HASH will be created.

       code      The CODE reference. If not sent a null sub{} will be created.

                 With this your object can be used as a sub reference:

                   my $multi = Object::MultiType->new( code => sub { print "Args: @_\n" ;} ) ;
                   &$multi();

                 Note that the first argument sent to the SUB is the object ($multi).

       glob      The GLOB (HANDLE) reference. If not sent a null GLOB will be created.

                 ** Note that you can't use the default (null) GLOB created when you don't paste this argument!  Since all the objects will share it, and was there just to avoid erros!

       tiearray  Package name to create a TIEARRAY. The argument $$this is sent to tie().

                 tie() is called as:

                   tie(@array,$args{tiearray},$$this) ;

                 Note that is hard to implement the tie methods for PUSH, POP, SHIFT, UNSHIFT, SPLICE...  Unless you make just an alias to another array through the tie methods.

                 ** See tiehash too.

       tiehash   Package name to create a TIEHASH. The argument $$this is sent to tie().

                 tie() is called as:

                   tie(%hash,$args{tiehash},$$this) ;

                 ** $$this (the Saver) is sent, and not $this, to avoid the break of DESTROY (auto reference).

                 ** $$this is a reference to the Saver object that save the SCALAR, ARRAY, HASH, CODE and GLOB.

                   sub TIEHASH {
                     my $class = shift ;
                     my $multi = shift ; ## $$this

                     my $scalarref = $multi->scalar ; ## \${*$multi}
                     my $arrayref  = $multi->array  ; ## \@{*$multi}
                     my $hashref   = $multi->hash   ; ## \%{*$multi}

                     my $this = { s => $scalarref , a => $arrayref , h => $hashref } ;
                     bless($this,$class) ;
                   }

       tiehandle Make the object works like a tied glob (TIEHANDLE).

                 If used with glob will tie() it. If glob is not sent a NULL GLOB is used:

                   my $multi = Object::MultiType->new(
                   glob      => \*MYOUT ,               ## 'glob' is Optional.
                   tiehandle => 'TieHandlePack' ,
                   ) ;

       tieonuse  The reference is only tied when it's used! So, the HASH, ARRAY or GLOB (handle) are only tied if/when they are accessed.

       nodefault If set to true tell to not create the default references inside the Saver, and it will have only the references paste (scalar, array, hash, code, glob).

                 ** This is good to save memory.

   is_saver
       Return 0. Good to see if what you have is the Saver or the MultiType object.

SAVER
       The MultiType object has a Saver object (Object::MultiType::Saver), that save all the different data type (references). This saver can be accessed from the main object:

         my $multi = Object::MultiType->new() ;

         my $saver = $$multi ;
         print $saver->scalar ;

       If you want to save attributes in your Object and you use tiehash, you can't set attributes directly in the MultiType object!:

         sub new {
           my $class = shift ;
           my $this = Object::MultiType->new(tiehash => 'TieHashPack') ;

           ## Dont do that! This will call the STORE() at TIEHASH, and not save it in the object:
           $this->{flagx} = 1 ;

           bless($this,$class) ;
         }

       So, if you use tiehash and want to save attributes (outside tie) use that:

           ## This save the attribute inside the Saver:
           $$this->{flagx} = 1 ;

       Note that this set an attribute in the saver, and it has their own attributes!

         ## $saver = $$this ;

         $saver->{s} ## the sacalar ref.
         $saver->{a} ## the array ref.
         $saver->{h} ## the hash ref.
         $saver->{c} ## the code ref.
         $saver->{g} ## the glob ref.

       ** See "Direct access to the data types".

DESTROY
       When the object is DESTROIED, the Saver inside it is cleanned, so the tied objects can be DESTROIED automatically too.

Direct access to the data types
       To access directly the reference of the different data types (SCALAR, ARRAY, HASH, CODE & GLOB) use:

         my $multi = Object::MultiType->new() ;

         my $saver = $$multi ;

         my $scalarref = $saver->scalar ; ## $saver->{s}
         my $arrayref  = $saver->array  ; ## $saver->{a}
         my $hashref   = $saver->hash   ; ## $saver->{h}
         my $coderef   = $saver->code   ; ## $saver->{c}
         my $globeref  = $saver->glob   ; ## $saver->{g}

         ## You can access the Saver directly from the main object:
         $$multi->hash  ;

       Setting the data:

         $saver->set_bool( 1 ) ;
         $saver->set_scalar( 'xyz' ) ;
         $saver->set_array( [qw(x y z)] ) ;
         $saver->set_hash( {X => 1} ) ;
         $saver->set_code( sub{ print "XYZ\n" ; } ) ;
         $saver->set_glob( \*STDOUT ) ;

As SCALAR
       You can use it as SCALAR when you put it inside quotes or make a copy of it:

         my $multi = Object::MultiType->new( scalar => 'Foo' ) ;

         ## Quote:
         print "Me as scalar: $multi\n" ;

         ## Copy:
         my $str = $multi ;
         $str .= '_x' ; ## Copy made when you change it! Until that $str works like $multi.
         print "$str\n" ;

       using the argument scalarsub you can use a function that will generate the scalar data, in the place of a reference to a SCALAR:

         my $multi = Object::MultiType->new(scalarsub => sub{ return 'generated data' ;} ) ;

         print "My scalar have $multi!\n" ;

As ARRAY
       You can use it as ARRAY directly from the object:

         my $multi = Object::MultiType->new( array => [qw(FOO BAR)] ) ;
         my $array_0 = $multi->[0] ;
         $multi->[1] = 'foo' ;

As HASH
       You can use it as HASH directly from the object:

         my $multi = Object::MultiType->new( hash => {key => 'foo'} ) ;
         my $k = $multi->{key} ;
         $multi->{foo} = 'bar' ;

With TIE
       To use your ARRAY and HASH part tied, you can paste the reference already tied of the HASH or ARRAY, or use the arguments tiehash and tiearray at new():

         ## Using the reference:
         my %hash ;
         tie(%hash,'TieHash') ;
         my $multi = Object::MultiType->new(hash => \%hash) ;

         ## Or using directly the argument:
         my $multi = Object::MultiType->new(tiehash => 'TieHashPack') ;

       Note that using tiehash or tiearray is better, since your tied HASH or ARRAY can see the object Saver and the other data type of it. See the method new() and their arguments.

       Here's an example of a TieHash package that is called from Object::MultiType->new():

         ## The call inside Object::MultiType->new():
         tie(%hash,$args{tiehash},$$this) ;

         ## The package:
         package TieHash ;

         sub TIEHASH {
             my $class = shift ;
             my $Saver = shift ; ## Object::MultiType paste as $$this (only the Saver) to avoid break of DESTROY!
                                 ## $this = Object::MultiType >> $$this = Object::MultiType::Saver

             my $scalarref = $Saver->scalar ;
             my $arrayref  = $Saver->array  ;

             ## Note that $Saver->hash will return the tied hash, and is not needed here!
             ## my $hashref   = $Saver->hash ;

             ## Saving the references inside the TIE object:
             my $this = { scalar => $scalarref , array => $arrayref , hash => {} } ;

             bless($this,$class) ;
         }

         sub FETCH    { my $this = shift ; return( 'key' ) ;}

         sub NEXTKEY  { my $this = shift ; return( 'key' ) ;}

         sub STORE    { my $this = shift ; $this->{hash}{$_[0]} = $_[1] }

         sub DELETE   { my $this = shift ; delete $this->{hash}{$_[0]} }

         sub CLEAR    { my $this = shift ; $this->{hash} = {} ;}

         sub EXISTS   { my $this = shift ; defined $this->{hash}{$_[0]} ;}

         sub FIRSTKEY { my $this = shift ; (sort keys %{$this->{hash}} )[0] }

         sub DESTROY  {}

       Using tiehash, you need to save the attributes in the Saver, or you call the tie().

           $$this->{flagx} = 1 ;

Object::MultiType::Saver
       This is a litte package where the Saver objects are created.  It will save the data types (SCALAR, ARRAY, HASH, CODE & GLOB) of the main objects (Object::MultiType).

       METHODS:

   is_saver
       Return 1. Good to see if what you have is the Saver or the MultiType object.

   bool
       Return the BOOL reference inside the Saver.

   scalar
       Return the SCALAR reference inside the Saver.

   array
       Return the ARRAY reference inside the Saver.

   hash
       Return the HASH reference inside the Saver.

   code
       Return the CODE/sub reference inside the Saver.

   glob
       Return the GLOB/HANDLE reference inside the Saver.

   set_bool
       Set the boolean reference inside the Saver.

   set_scalar
       Set the SCALAR reference inside the Saver.

   set_array
       Set the ARRAY reference inside the Saver.

   set_hash
       Set the HASH reference inside the Saver.

   set_code
       Set the CODE/sub reference inside the Saver.

   set_glob
       Set the GLOB/HANDLE reference inside the Saver.

   clean
       Clean all the references saved in the Saver.

SEE ALSO
       overload, perltie, Scalar::Util.

       This module/class was created for XML::Smart.

AUTHOR
       Graciliano M. P. <gm@virtuasites.com.br>

       I will appreciate any type of feedback (include your opinions and/or suggestions). ;-P

COPYRIGHT
       This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

perl v5.34.0                                                                                     2022-10-13                                                                                  MultiType(3pm)
