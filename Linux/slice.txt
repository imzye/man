SLICE(1)                                                                                          EN Tools                                                                                         SLICE(1)

NAME
       Slice -- Extract pre-defined slices from an ASCII file

SYNOPSIS
       slice [-v] [-y outputpolicy] [-o sliceterm:outputfile[@chmodcmd][#outputpolicy] ..]  [inputfile]

       slice [-V] [-h]

VERSION
       @SLICE_VERSION@

DESCRIPTION
   Input Principle
       The slice program reads inputfile (or from STDIN if inputfile is not given or equal ``"-"'') and divides its already prepared ASCII contents into possibly overlapping areas, called slices.   These
       slices are determined by enclosing blocks defined by begin and end delimiters which have to be already in the file. These block delimiters use the syntax

         [NAME: ... :NAME]

       or alternatively (if there is no misinterpretation possible, i.e. no overlapping or stacked slices)

         [NAME: ... :]

       The NAME identifier has to match against the regular expression ``"[_A-Z0-9]+"'', i.e. NAME is a string consisting only of uppercase letters, digits or underscore characters.

       There can be as many such slice definitions as you like and there can be more than one slice with the same name. The resulting slice is the union of all equal named slices. Actually use this to
       spread a big slice over disjunct peaces of inputfile.

   Output Selection Scheme
       The final output data gets calculated by a slice term consisting of slice names and set theory operators. The following syntax is recognized (in order of LR(1) grammar parsing) for slice terms:

       SLICE_TERM ::= "NAME"
           The  slice  NAME  itself.  This  name has to match against the regex ``"[_A-Z0-9*{}]+"''. Here two cases are possible: "NAME" is either a plain slice name consisting only of uppercase letters,
           digits or an underscore character. Or it is a wildcarded slice name indicated by an asterisk character.

           The first variant just expands to the union of all slices named exactly "NAME".  The second variant expands to the union of all slices which match against the wildcard pattern "NAME". Here the
           asterisk has the semantical meaning of none or any number of characters.  There is one special case, when the asterisk is immediately followed by characters enclosed within  braces,  it  means
           none or any number of characters, but not this sequence of characters.

       SLICE_TERM ::= "!NAME" | "~NAME"
           The complement of slice NAME (i.e. ALL\NAME).

           In formula: {x in ALL: x not in NAME}

       SLICE_TERM ::= "NAME1xNAME2", "NAME1^NAME2"
           The exclusive-or relation between slice NAME1 and slice NAME2. In set theory also called symmetric difference: (NAME1uNAME2)\(NAME1nNAME2) or alternatively (NAME1n!NAME2)u(!NAME1nNAME2).

           In formula: {x in ALL: (x in NAME1 or x in NAME2) and not (x in NAME1 and x in NAME2)}.

       SLICE_TERM ::= "NAME1\NAME2", "NAME1-NAME2"
           The difference of slice NAME1 and slice NAME2, i.e. NAME1 minus NAME2.

           In formula: {x in ALL: x in NAME1 and x not in NAME2}

       SLICE_TERM ::= "NAME1nNAME2" | "NAME1%NAME2"
           The intersection of slice NAME1 and slice NAME2.

           In formula: {x in ALL: x in NAME1 and x in NAME2}

       SLICE_TERM ::= "NAME1uNAME2", "NAME1+NAME2"
           The union of slice NAME1 and slice NAME2.

           In formula: {x in ALL: x in NAME1 or x in NAME2}

       SLICE_TERM ::= "(" SLICE_TERM ")"
           A  grouped  slice  term. Use this to force a different order of evaluation.  By default, all operators are left-associative, except complement which is right-associative.  Operators are listed
           below from lowest to highest precedence:

               -  u  x  n  !

   Advanced Selection: Slice Levels
       Because slices can be overlapping and stacked, a definition level is assigned to each slice while the input is parsed. These levels range from 1 to the maximum encountered  (the  level  0  is  the
       whole  file, i.e. "ALL").  When a slice begins, it is assigned the lowest free level, beginning with level 1. As long as one level is in use, it cannot be assigned again until the end delimiter of
       the corresponding slice is seen.

       An example:

            [A:[B::B]:A][C:[D:[E::C]:D][F::E]:F]

         3                     E-----------E
         2      B--B        D--------D
         1   A--------A  C--------C     F-----F
         0

       Here slice A is assigned level 1. Then B is assigned level 2 because level 1 is still in use by A. Then the end of B is reached, level 2 is freed.  Then the end of A is reached and level 1 is also
       free now, so C is assigned level 1 again. Now only level 1 is in use, so D is assigned level 2. Then E is assigned level 3. Then the end of C is seen and level 1 freed. Then the end of D  is  seen
       and level 2 is freed. Now F begins and because only level 3 is in use, it gets level 1 assigned. Then the end of E frees level 3 and the end of F frees level 1. Finally no levels are still in use.
       This indicates that the slicing is correct.

       If there are any used levels left at the end of this process this indicates an input error and slice responds with an error message displaying the still open slices.

       This  complicated  level mechanism is needed for granular set operations where particular slices should be included or excluded only. So, to make life easier, a few pseudo-slices are automatically
       defined:

       "DEFn"
           The union of all user-defined slices at exactly level n (0 <= n <= oo).

       "UNDEFn"
           The union of all non-user-defined slices at exactly level n (0 <= n <= oo).  This actually is just "!DEFn".

       "DEF"
           The union of all user-defined slices at all levels, beginning at level 1.  This actually is the union of all "DEFn" slices.

       "UNDEF"
           The union of all non-user-defined slices at all levels, beginning with 1. This actually is just "!DEF".

       "ALL"
           The whole file. This actually is just "UNDEF0", because at level 0 there are no user defined slices, so all is undefined.

       NAME"@"
           This is the slice NAME minus the union of all "DEFn" slices with min(NAME) <= n <= oo. Here min(NAME) is the lowest level plus one where NAME ever  occurred.   You  can  read  this  as  ``NAME
           without  all  other  slices at higher levels which overwrite it''. This sounds a little bit crazy, but actually is the most important construct. Try to understand it or your slice terms become
           very complicated.

OPTIONS
       [-y outputpolicy]
           This flag changes output policy depending on events: "u" when an undefined set is encountered, "w" for an unmatched wildcard set, "z" when output is empty  and  "s"  if  it  only  consists  of
           whitespace  characters.   Each  letter  is  followed  by  a  digit telling which action is bound to such events: 0 to ignore such events, 1 to display a warning message and continue, 2 to skip
           concerned file and continue, and 3 to abort with an error message.

           This flag consists of one or more events specifications, and default is "u0w0s0z0".

       [-o sliceterm:outputfile[@chmodcmd][#outputpolicy] ..]
           This redirects the output to a file. Usually the whole file will be send to "STDOUT" (same as "ALL:-"). You can use this option more than once to  output  to  more  than  one  file  while  the
           corresponding sliceterm determines which output data will be included into each output file.

           The  optional  chmodcmd  string  is  intended  for  specifying  options for the chmod command, which is applied to outputfile after writing. For instance use ``"a+r"'' to make sure the file is
           readable by a webserver of ``"u+x"'' to create a file with the execution bit set (usually used for SSI files on a webserver with the "XBitHack" option available).

           The optional outputpolicy string allows changing output policy for only this output file without changing its global meaning.  See above for more information about output policy.

           Be careful here: When you use parenthesis or asterisks inside sliceterm you have to make sure it is really passed to slice this way, i.e. usually you  have  to  escape  these  characters  from
           interpolation by the used shell. Do this either by adding backslashes in front of these characters or just surround the complete option argument with single quotes ('').

       -v  This sets verbose mode where some processing information will be given on the console for debugging purpose.

       -V  Displays the version identification string.

       -h  Displays the usage page.

SPECIAL FEATURE
       Sometimes it can be very useful to be able to provide command line options directly within the input file, for instance to setup one or more -o options. For this slice recognizes lines of the form

          %!slice OPTIONS

       in the input file and automatically adds OPTIONS to the argument line options.  These lines have to start in column 0.

       Example:

          %!slice -oTOC:contents.txt

EXAMPLE
       Assume the following simple multi-language article file article.src, written in HTML:

         <html>
         <head>
         <title>[EN:Titlepage:][DE:Titelseite:]</title>
         </head>
         <body>

         <center>
         <h1>[EN:The Title itself:][DE:Der Titel selbst:]</h1>
         </center>

         <blockquote>
         [EN:...English Abstract...:]
         [DE:...Deutsche Zusammenfassung...:]
         </blockquote>

         [EN:...English Text...:]
         [DE:...Deutscher Text...:]

         </body>
         </html>

       The command

         slice -o ENuUNDEF:article.html.en -o DEuUNDEF:article.html.de

       then creates the following to files:

       article.html.en:
             <html>
             <head>
             <title>Titlepage</title>
             </head>
             <body>

             <center>
             <h1>The Title itself</h1>
             </center>

             <blockquote>
             ...English Abstract...
             </blockquote>

             ...English Text...
             </body>
             </html>

       article.html.de:
             <html>
             <head>
             <title>Titelseite</title>
             </head>
             <body>

             <center>
             <h1>Der Titel selbst</h1>
             </center>

             <blockquote>
             ...Deutsche Zusammenfassung...
             </blockquote>

             ...Deutscher Text...
             </body>
             </html>

RESTRICTION
       The current implementation only handles anonymous end delimiters ``":]"'' correct in clear cases where no mis-interpretation is possible, i.e. when no overlapping occurs. For instance in

          ...[A:...[B:...:A]...:]...

       the end delimiter is not correctly assign to the `B' slice. So, be careful when using anonymous end delimiters in overlapping situations. Pure stacking like

          ...[A:...[B:...:]...:]...

       is allowed and handled correctly, but only when you interpret this as

          ...[A:...[B:...:B]...:A]...

COPYRIGHT
         Copyright (c) 1997-2002 Ralf S. Engelschall.
         Copyright (c) 1999-2002 Denis Barbier.

SEE ALSO
       Slice Home: http://www.engelschall.com/sw/slice/

AUTHORS
         Ralf S. Engelschall
         rse@engelschall.com
         www.engelschall.com

         Denis Barbier
         barbier@engelschall.com

EN Tools                                                                                         2020-11-29                                                                                        SLICE(1)
