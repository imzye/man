BMAKE(1)                                                                                   General Commands Manual                                                                                 BMAKE(1)

NAME
       bmake — maintain program dependencies

SYNOPSIS
       bmake  [-BeikNnqrstWwX]  [-C  directory]  [-D  variable]  [-d  flags]  [-f makefile] [-I directory] [-J private] [-j max_jobs] [-m directory] [-T file] [-V variable] [-v variable] [variable=value]
             [target ...]

DESCRIPTION
       bmake is a program designed to simplify the maintenance of other programs.  Its input is a list of specifications as to the files upon which programs and other files depend.   If  no  -f  makefile
       makefile option is given, bmake will try to open ‘makefile’ then ‘Makefile’ in order to find the specifications.  If the file ‘.depend’ exists, it is read (see mkdep(1)).

       This manual page is intended as a reference document only.  For a more thorough description of bmake and makefiles, please refer to PMake - A Tutorial.

       bmake will prepend the contents of the MAKEFLAGS environment variable to the command line arguments before parsing them.

       The options are as follows:

       -B      Try to be backwards compatible by executing a single shell per command and by executing the commands to make the sources of a dependency line in sequence.

       -C directory
               Change  to directory before reading the makefiles or doing anything else.  If multiple -C options are specified, each is interpreted relative to the previous one: -C / -C etc is equivalent
               to -C /etc.

       -D variable
               Define variable to be 1, in the global context.

       -d [-]flags
               Turn on debugging, and specify which portions of bmake are to print debugging information.  Unless the flags are preceded by ‘-’ they are added to the MAKEFLAGS  environment  variable  and
               will be processed by any child make processes.  By default, debugging information is printed to standard error, but this can be changed using the F debugging flag.  The debugging output is
               always  unbuffered;  in  addition,  if debugging is enabled but debugging output is not directed to standard output, then the standard output is line buffered.  Flags is one or more of the
               following:

               A       Print all possible debugging information; equivalent to specifying all of the debugging flags.

               a       Print debugging information about archive searching and caching.

               C       Print debugging information about current working directory.

               c       Print debugging information about conditional evaluation.

               d       Print debugging information about directory searching and caching.

               e       Print debugging information about failed commands and targets.

               F[+]filename
                       Specify where debugging output is written.  This must be the last flag, because it consumes the remainder of the argument.  If the character immediately after the ‘F’ flag is  ‘+’,
                       then the file will be opened in append mode; otherwise the file will be overwritten.  If the file name is ‘stdout’ or ‘stderr’ then debugging output will be written to the standard
                       output  or  standard error output file descriptors respectively (and the ‘+’ option has no effect).  Otherwise, the output will be written to the named file.  If the file name ends
                       ‘.%d’ then the ‘%d’ is replaced by the pid.

               f       Print debugging information about loop evaluation.

               g1      Print the input graph before making anything.

               g2      Print the input graph after making everything, or before exiting on error.

               g3      Print the input graph before exiting on error.

               j       Print debugging information about running multiple shells.

               l       Print commands in Makefiles regardless of whether or not they are prefixed by ‘@’ or other "quiet" flags.  Also known as "loud" behavior.

               M       Print debugging information about "meta" mode decisions about targets.

               m       Print debugging information about making targets, including modification dates.

               n       Don't delete the temporary command scripts created when running commands.  These temporary scripts are created in the directory referred to by the TMPDIR environment  variable,  or
                       in /tmp if TMPDIR is unset or set to the empty string.  The temporary scripts are created by mkstemp(3), and have names of the form makeXXXXXX.  NOTE: This can create many files in
                       TMPDIR or /tmp, so use with care.

               p       Print debugging information about makefile parsing.

               s       Print debugging information about suffix-transformation rules.

               t       Print debugging information about target list maintenance.

               V       Force the -V option to print raw values of variables, overriding the default behavior set via .MAKE.EXPAND_VARIABLES.

               v       Print debugging information about variable assignment.

               x       Run shell commands with -x so the actual commands are printed as they are executed.

       -e      Specify that environment variables override macro assignments within makefiles.

       -f makefile
               Specify a makefile to read instead of the default ‘makefile’.  If makefile is ‘-’, standard input is read.  Multiple makefiles may be specified, and are read in the order specified.

       -I directory
               Specify  a  directory  in which to search for makefiles and included makefiles.  The system makefile directory (or directories, see the -m option) is automatically included as part of this
               list.

       -i      Ignore non-zero exit of shell commands in the makefile.  Equivalent to specifying ‘-’ before each command line in the makefile.

       -J private
               This option should not be specified by the user.

               When the j option is in use in a recursive build, this option is passed by a make to child makes to allow all the make processes in the build to cooperate to avoid overloading the system.

       -j max_jobs
               Specify the maximum number of jobs that bmake may have running at any one time.  The value is saved in .MAKE.JOBS.  Turns compatibility mode off, unless the B flag is also specified.  When
               compatibility mode is off, all commands associated with a target are executed in a single shell invocation as opposed to the traditional one shell invocation per line.  This can break tra‐
               ditional scripts which change directories on each command invocation and then expect to start with a fresh environment on the next line.  It is more efficient to correct the scripts rather
               than turn backwards compatibility on.

       -k      Continue processing after errors are encountered, but only on those targets that do not depend on the target whose creation caused the error.

       -m directory
               Specify a directory in which to search for sys.mk and makefiles included via the <file>-style include statement.  The -m option can be used multiple times to form a search path.  This path
               will override the default system include path: /usr/share/mk.  Furthermore the system include path will be appended to the search path used for "file"-style include statements (see the  -I
               option).

               If  a  file or directory name in the -m argument (or the MAKESYSPATH environment variable) starts with the string ".../" then bmake will search for the specified file or directory named in
               the remaining part of the argument string.  The search starts with the current directory of the Makefile and then works upward towards the root of the file system.  If the search  is  suc‐
               cessful,  then  the resulting directory replaces the ".../" specification in the -m argument.  If used, this feature allows bmake to easily search in the current source tree for customized
               sys.mk files (e.g., by using ".../mk/sys.mk" as an argument).

       -n      Display the commands that would have been executed, but do not actually execute them unless the target depends on the .MAKE special source (see below).

       -N      Display the commands which would have been executed, but do not actually execute any of them; useful for debugging top-level makefiles without descending into subdirectories.

       -q      Do not execute any commands, but exit 0 if the specified targets are up-to-date and 1, otherwise.

       -r      Do not use the built-in rules specified in the system makefile.

       -s      Do not echo any commands as they are executed.  Equivalent to specifying ‘@’ before each command line in the makefile.

       -T tracefile
               When used with the -j flag, append a trace record to tracefile for each job started and completed.

       -t      Rather than re-building a target as specified in the makefile, create it or update its modification time to make it appear up-to-date.

       -V variable
               Print the value of variable.  Do not build any targets.  Multiple instances of this option may be specified; the variables will be printed one per line, with a blank line for each null  or
               undefined  variable.   The value printed is extracted from the global context after all makefiles have been read.  By default, the raw variable contents (which may include additional unex‐
               panded variable references) are shown.  If variable contains a ‘$’ then the value will be recursively expanded to its complete resultant text before printing.  The expanded value will also
               be printed if .MAKE.EXPAND_VARIABLES is set to true and the -dV option has not been used to override it.  Note that loop-local and target-local variables, as well as values taken temporar‐
               ily by global variables during makefile processing, are not accessible via this option.  The -dv debug mode can be used to see these at the cost of generating substantial  extraneous  out‐
               put.

       -v variable
               Like -V but the variable is always expanded to its complete value.

       -W      Treat any warnings during makefile parsing as errors.

       -w      Print entering and leaving directory messages, pre and post processing.

       -X      Don't  export  variables  passed on the command line to the environment individually.  Variables passed on the command line are still exported via the MAKEFLAGS environment variable.  This
               option may be useful on systems which have a small limit on the size of command arguments.

       variable=value
               Set the value of the variable variable to value.  Normally, all values passed on the command line are also exported to sub-makes in the environment.  The -X flag  disables  this  behavior.
               Variable assignments should follow options for POSIX compatibility but no ordering is enforced.

       There are seven different types of lines in a makefile: file dependency specifications, shell commands, variable assignments, include statements, conditional directives, for loops, and comments.

       In general, lines may be continued from one line to the next by ending them with a backslash (‘\’).  The trailing newline character and initial whitespace on the following line are compressed into
       a single space.

FILE DEPENDENCY SPECIFICATIONS
       Dependency  lines  consist  of one or more targets, an operator, and zero or more sources.  This creates a relationship where the targets “depend” on the sources and are usually created from them.
       The exact relationship between the target and the source is determined by the operator that separates them.  The three operators are as follows:

       :     A target is considered out-of-date if its modification time is less than those of any of its sources.  Sources for a target accumulate over dependency lines when this operator is used.   The
             target is removed if bmake is interrupted.

       !     Targets  are  always  re-created, but not until all sources have been examined and re-created as necessary.  Sources for a target accumulate over dependency lines when this operator is used.
             The target is removed if bmake is interrupted.

       ::    If no sources are specified, the target is always re-created.  Otherwise, a target is considered out-of-date if any of its sources has been modified more recently than the  target.   Sources
             for a target do not accumulate over dependency lines when this operator is used.  The target will not be removed if bmake is interrupted.

       Targets and sources may contain the shell wildcard values ‘?’, ‘*’, ‘[]’, and ‘{}’.  The values ‘?’, ‘*’, and ‘[]’ may only be used as part of the final component of the target or source, and must
       be used to describe existing files.  The value ‘{}’ need not necessarily be used to describe existing files.  Expansion is in directory order, not alphabetically as done in the shell.

SHELL COMMANDS
       Each  target may have associated with it one or more lines of shell commands, normally used to create the target.  Each of the lines in this script must be preceded by a tab.  (For historical rea‐
       sons, spaces are not accepted.)  While targets can appear in many dependency lines if desired, by default only one of these rules may be followed by a creation script.  If  the  ‘::’  operator  is
       used, however, all rules may include scripts and the scripts are executed in the order found.

       Each  line  is treated as a separate shell command, unless the end of line is escaped with a backslash (‘\’) in which case that line and the next are combined.  If the first characters of the com‐
       mand are any combination of ‘@’, ‘+’, or ‘-’, the command is treated specially.  A ‘@’ causes the command not to be echoed before it is executed.  A ‘+’ causes the command to be executed even when
       -n is given.  This is similar to the effect of the .MAKE special source, except that the effect can be limited to a single line of a script.  A ‘-’ in compatibility mode causes any  non-zero  exit
       status of the command line to be ignored.

       When  bmake  is  run  in jobs mode with -j max_jobs, the entire script for the target is fed to a single instance of the shell.  In compatibility (non-jobs) mode, each command is run in a separate
       process.  If the command contains any shell meta characters (‘#=|^(){};&<>*?[]:$`\\n’) it will be passed to the shell; otherwise bmake will attempt direct execution.  If a line starts with ‘-’ and
       the shell has ErrCtl enabled then failure of the command line will be ignored as in compatibility mode.  Otherwise ‘-’ affects the entire job; the script will stop at the first command  line  that
       fails, but the target will not be deemed to have failed.

       Makefiles should be written so that the mode of bmake operation does not change their behavior.  For example, any command which needs to use “cd” or “chdir” without potentially changing the direc‐
       tory  for subsequent commands should be put in parentheses so it executes in a subshell.  To force the use of one shell, escape the line breaks so as to make the whole script one command.  For ex‐
       ample:

             avoid-chdir-side-effects:
                     @echo Building $@ in `pwd`
                     @(cd ${.CURDIR} && ${MAKE} $@)
                     @echo Back in `pwd`

             ensure-one-shell-regardless-of-mode:
                     @echo Building $@ in `pwd`; \
                     (cd ${.CURDIR} && ${MAKE} $@); \
                     echo Back in `pwd`

       Since bmake will chdir(2) to ‘.OBJDIR’ before executing any targets, each child process starts with that as its current working directory.

VARIABLE ASSIGNMENTS
       Variables in make are much like variables in the shell, and, by tradition, consist of all upper-case letters.

   Variable assignment modifiers
       The five operators that can be used to assign values to variables are as follows:

       =       Assign the value to the variable.  Any previous value is overridden.

       +=      Append the value to the current value of the variable.

       ?=      Assign the value to the variable if it is not already defined.

       :=      Assign with expansion, i.e. expand the value before assigning it to the variable.  Normally, expansion is not done until the variable is referenced.  NOTE: References  to  undefined  vari‐
               ables are not expanded.  This can cause problems when variable modifiers are used.

       !=      Expand the value and pass it to the shell for execution and assign the result to the variable.  Any newlines in the result are replaced with spaces.

       Any white-space before the assigned value is removed; if the value is being appended, a single space is inserted between the previous contents of the variable and the appended value.

       Variables  are expanded by surrounding the variable name with either curly braces (‘{}’) or parentheses (‘()’) and preceding it with a dollar sign (‘$’).  If the variable name contains only a sin‐
       gle letter, the surrounding braces or parentheses are not required.  This shorter form is not recommended.

       If the variable name contains a dollar, then the name itself is expanded first.  This allows almost arbitrary variable names, however names containing dollar, braces,  parenthesis,  or  whitespace
       are really best avoided!

       If the result of expanding a variable contains a dollar sign (‘$’) the string is expanded again.

       Variable substitution occurs at three distinct times, depending on where the variable is being used.

       1.   Variables in dependency lines are expanded as the line is read.

       2.   Variables in shell commands are expanded when the shell command is executed.

       3.   “.for” loop index variables are expanded on each loop iteration.  Note that other variables are not expanded inside loops so the following example code:

                  .for i in 1 2 3
                  a+=     ${i}
                  j=      ${i}
                  b+=     ${j}
                  .endfor

                  all:
                          @echo ${a}
                          @echo ${b}

            will print:

                  1 2 3
                  3 3 3

            Because while ${a} contains “1 2 3” after the loop is executed, ${b} contains “${j} ${j} ${j}” which expands to “3 3 3” since after the loop completes ${j} contains “3”.

   Variable classes
       The four different classes of variables (in order of increasing precedence) are:

       Environment variables
               Variables defined as part of bmake's environment.

       Global variables
               Variables defined in the makefile or in included makefiles.

       Command line variables
               Variables defined as part of the command line.

       Local variables
               Variables that are defined specific to a certain target.

       Local variables are all built in and their values vary magically from target to target.  It is not currently possible to define new local variables.  The seven local variables are as follows:

             .ALLSRC   The list of all sources for this target; also known as ‘>’.

             .ARCHIVE  The name of the archive file; also known as ‘!’.

             .IMPSRC   In  suffix-transformation  rules,  the  name/path of the source from which the target is to be transformed (the “implied” source); also known as ‘<’.  It is not defined in explicit
                       rules.

             .MEMBER   The name of the archive member; also known as ‘%’.

             .OODATE   The list of sources for this target that were deemed out-of-date; also known as ‘?’.

             .PREFIX   The file prefix of the target, containing only the file portion, no suffix or preceding directory components; also known as ‘*’.  The suffix must be one of the known  suffixes  de‐
                       clared with .SUFFIXES or it will not be recognized.

             .TARGET   The name of the target; also known as ‘@’.  For compatibility with other makes this is an alias for .ARCHIVE in archive member rules.

       The shorter forms (‘>’, ‘!’, ‘<’, ‘%’, ‘?’, ‘*’, and ‘@’) are permitted for backward compatibility with historical makefiles and legacy POSIX make and are not recommended.

       Variants  of these variables with the punctuation followed immediately by ‘D’ or ‘F’, e.g.  ‘$(@D)’, are legacy forms equivalent to using the ‘:H’ and ‘:T’ modifiers.  These forms are accepted for
       compatibility with AT&T System V UNIX makefiles and POSIX but are not recommended.

       Four of the local variables may be used in sources on dependency lines because they expand to the proper value for each target on the line.  These variables are ‘.TARGET’,  ‘.PREFIX’,  ‘.ARCHIVE’,
       and ‘.MEMBER’.

   Additional built-in variables
       In addition, bmake sets or knows about the following variables:

       $               A single dollar sign ‘$’, i.e.  ‘$$’ expands to a single dollar sign.

       .ALLTARGETS     The list of all targets encountered in the Makefile.  If evaluated during Makefile parsing, lists only those targets encountered thus far.

       .CURDIR         A path to the directory where bmake was executed.  Refer to the description of ‘PWD’ for more details.

       .INCLUDEDFROMDIR
                       The directory of the file this Makefile was included from.

       .INCLUDEDFROMFILE
                       The filename of the file this Makefile was included from.

       MAKE            The  name  that bmake was executed with (argv[0]).  For compatibility bmake also sets .MAKE with the same value.  The preferred variable to use is the environment variable MAKE be‐
                       cause it is more compatible with other versions of bmake and cannot be confused with the special target with the same name.

       .MAKE.DEPENDFILE
                       Names the makefile (default ‘.depend’) from which generated dependencies are read.

       .MAKE.EXPAND_VARIABLES
                       A boolean that controls the default behavior of the -V option.  If true, variable values printed with -V are fully expanded; if false, the raw variable contents (which may  include
                       additional unexpanded variable references) are shown.

       .MAKE.EXPORTED  The list of variables exported by bmake.

       .MAKE.JOBS      The argument to the -j option.

       .MAKE.JOB.PREFIX
                       If bmake is run with j then output for each target is prefixed with a token ‘--- target ---’ the first part of which can be controlled via .MAKE.JOB.PREFIX.  If .MAKE.JOB.PREFIX is
                       empty, no token is printed.
                       For  example: .MAKE.JOB.PREFIX=${.newline}---${.MAKE:T}[${.MAKE.PID}] would produce tokens like ‘---make[1234] target ---’ making it easier to track the degree of parallelism being
                       achieved.

       MAKEFLAGS       The environment variable ‘MAKEFLAGS’ may contain anything that may be specified on bmake's command line.  Anything specified on bmake's command line is appended to the  ‘MAKEFLAGS’
                       variable which is then entered into the environment for all programs which bmake executes.

       .MAKE.LEVEL     The  recursion  depth of bmake.  The initial instance of bmake will be 0, and an incremented value is put into the environment to be seen by the next generation.  This allows tests
                       like: .if ${.MAKE.LEVEL} == 0 to protect things which should only be evaluated in the initial instance of bmake.

       .MAKE.MAKEFILE_PREFERENCE
                       The ordered list of makefile names (default ‘makefile’, ‘Makefile’) that bmake will look for.

       .MAKE.MAKEFILES
                       The list of makefiles read by bmake, which is useful for tracking dependencies.  Each makefile is recorded only once, regardless of the number of times read.

       .MAKE.MODE      Processed after reading all makefiles.  Can affect the mode that bmake runs in.  It can contain a number of keywords:

                       compat               Like -B, puts bmake into "compat" mode.

                       meta                 Puts bmake into "meta" mode, where meta files are created for each target to capture the command run, the output generated and if filemon(4) is available,  the
                                            system calls which are of interest to bmake.  The captured output can be very useful when diagnosing errors.

                       curdirOk= bf         Normally bmake will not create .meta files in ‘.CURDIR’.  This can be overridden by setting bf to a value which represents True.

                       missing-meta= bf     If bf is True, then a missing .meta file makes the target out-of-date.

                       missing-filemon= bf  If bf is True, then missing filemon data makes the target out-of-date.

                       nofilemon            Do not use filemon(4).

                       env                  For debugging, it can be useful to include the environment in the .meta file.

                       verbose              If  in  "meta"  mode, print a clue about the target being built.  This is useful if the build is otherwise running silently.  The message printed the value of:
                                            .MAKE.META.PREFIX.

                       ignore-cmd           Some makefiles have commands which are simply not stable.  This keyword causes them to be ignored for determining whether a target is out  of  date  in  "meta"
                                            mode.  See also .NOMETA_CMP.

                       silent= bf           If bf is True, when a .meta file is created, mark the target .SILENT.

       .MAKE.META.BAILIWICK
                       In  "meta" mode, provides a list of prefixes which match the directories controlled by bmake.  If a file that was generated outside of .OBJDIR but within said bailiwick is missing,
                       the current target is considered out-of-date.

       .MAKE.META.CREATED
                       In "meta" mode, this variable contains a list of all the meta files updated.  If not empty, it can be used to trigger processing of .MAKE.META.FILES.

       .MAKE.META.FILES
                       In "meta" mode, this variable contains a list of all the meta files used (updated or not).  This list can be used to process the meta files to extract dependency information.

       .MAKE.META.IGNORE_PATHS
                       Provides a list of path prefixes that should be ignored; because the contents are expected to change over time.  The default list includes: ‘/dev /etc /proc /tmp /var/run /var/tmp’

       .MAKE.META.IGNORE_PATTERNS
                       Provides a list of patterns to match against pathnames.  Ignore any that match.

       .MAKE.META.IGNORE_FILTER
                       Provides a list of variable modifiers to apply to each pathname.  Ignore if the expansion is an empty string.

       .MAKE.META.PREFIX
                       Defines the message printed for each meta file updated in "meta verbose" mode.  The default value is:
                             Building ${.TARGET:H:tA}/${.TARGET:T}

       .MAKEOVERRIDES  This variable is used to record the names of variables assigned to on the command line, so that they may be exported as part of ‘MAKEFLAGS’.  This behavior can be disabled  by  as‐
                       signing  an empty value to ‘.MAKEOVERRIDES’ within a makefile.  Extra variables can be exported from a makefile by appending their names to ‘.MAKEOVERRIDES’.  ‘MAKEFLAGS’ is re-ex‐
                       ported whenever ‘.MAKEOVERRIDES’ is modified.

       .MAKE.PATH_FILEMON
                       If bmake was built with filemon(4) support, this is set to the path of the device node.  This allows makefiles to test for this support.

       .MAKE.PID       The process-id of bmake.

       .MAKE.PPID      The parent process-id of bmake.

       .MAKE.SAVE_DOLLARS
                       value should be a boolean that controls whether ‘$$’ are preserved when doing ‘:=’ assignments.  The default is false, for backwards compatibility.  Set to true  for  compatability
                       with other makes.  If set to false, ‘$$’ becomes ‘$’ per normal evaluation rules.

       MAKE_PRINT_VAR_ON_ERROR
                       When bmake stops due to an error, it sets ‘.ERROR_TARGET’ to the name of the target that failed, ‘.ERROR_CMD’ to the commands of the failed target, and in "meta" mode, it also sets
                       ‘.ERROR_CWD’  to  the  getcwd(3),  and ‘.ERROR_META_FILE’ to the path of the meta file (if any) describing the failed target.  It then prints its name and the value of ‘.CURDIR’ as
                       well as the value of any variables named in ‘MAKE_PRINT_VAR_ON_ERROR’.

       .newline        This variable is simply assigned a newline character as its value.  This allows expansions using the :@ modifier to put a newline between iterations  of  the  loop  rather  than  a
                       space.  For example, the printing of ‘MAKE_PRINT_VAR_ON_ERROR’ could be done as ${MAKE_PRINT_VAR_ON_ERROR:@v@$v='${$v}'${.newline}@}.

       .OBJDIR         A path to the directory where the targets are built.  Its value is determined by trying to chdir(2) to the following directories in order and using the first match:

                       1.   ${MAKEOBJDIRPREFIX}${.CURDIR}

                            (Only if ‘MAKEOBJDIRPREFIX’ is set in the environment or on the command line.)

                       2.   ${MAKEOBJDIR}

                            (Only if ‘MAKEOBJDIR’ is set in the environment or on the command line.)

                       3.   ${.CURDIR}/obj.${MACHINE}

                       4.   ${.CURDIR}/obj

                       5.   /usr/obj/${.CURDIR}

                       6.   ${.CURDIR}

                       Variable expansion is performed on the value before it's used, so expressions such as
                             ${.CURDIR:S,^/usr/src,/var/obj,}
                       may be used.  This is especially useful with ‘MAKEOBJDIR’.

                       ‘.OBJDIR’  may be modified in the makefile via the special target ‘.OBJDIR’.  In all cases, bmake will chdir(2) to the specified directory if it exists, and set ‘.OBJDIR’ and ‘PWD’
                       to that directory before executing any targets.

       .PARSEDIR       A path to the directory of the current ‘Makefile’ being parsed.

       .PARSEFILE      The basename of the current ‘Makefile’ being parsed.  This variable and ‘.PARSEDIR’ are both set only while the ‘Makefiles’ are being parsed.  If you want to retain  their  current
                       values, assign them to a variable using assignment with expansion: (‘:=’).

       .PATH           A variable that represents the list of directories that bmake will search for files.  The search list should be updated using the target ‘.PATH’ rather than the variable.

       PWD             Alternate  path  to  the  current directory.  bmake normally sets ‘.CURDIR’ to the canonical path given by getcwd(3).  However, if the environment variable ‘PWD’ is set and gives a
                       path to the current directory, then bmake sets ‘.CURDIR’ to the value of ‘PWD’ instead.  This behavior is disabled if ‘MAKEOBJDIRPREFIX’ is set or ‘MAKEOBJDIR’ contains a  variable
                       transform.  ‘PWD’ is set to the value of ‘.OBJDIR’ for all programs which bmake executes.

       .TARGETS        The list of targets explicitly specified on the command line, if any.

       VPATH           Colon-separated (“:”) lists of directories that bmake will search for files.  The variable is supported for compatibility with old make programs only, use ‘.PATH’ instead.

   Variable modifiers
       Variable expansion may be modified to select or modify each word of the variable (where a “word” is white-space delimited sequence of characters).  The general format of a variable expansion is as
       follows:

             ${variable[:modifier[:...]]}

       Each modifier begins with a colon, which may be escaped with a backslash (‘\’).

       A set of modifiers can be specified via a variable, as follows:

             modifier_variable=modifier[:...]
             ${variable:${modifier_variable}[:...]}

       In  this case the first modifier in the modifier_variable does not start with a colon, since that must appear in the referencing variable.  If any of the modifiers in the modifier_variable contain
       a dollar sign (‘$’), these must be doubled to avoid early expansion.

       The supported modifiers are:

       :E   Replaces each word in the variable with its suffix.

       :H   Replaces each word in the variable with everything but the last component.

       :Mpattern
            Select only those words that match pattern.  The standard shell wildcard characters (‘*’, ‘?’, and ‘[]’) may be used.  The wildcard characters may be escaped with a  backslash  (‘\’).   As  a
            consequence of the way values are split into words, matched, and then joined, a construct like
                  ${VAR:M*}
            will normalize the inter-word spacing, removing all leading and trailing space, and converting multiple consecutive spaces to single spaces.

       :Npattern
            This is identical to ‘:M’, but selects all words which do not match pattern.

       :O   Order every word in variable alphabetically.

       :Or  Order every word in variable in reverse alphabetical order.

       :Ox  Randomize words in variable.  The results will be different each time you are referring to the modified variable; use the assignment with expansion (‘:=’) to prevent such behavior.  For exam‐
            ple,

                  LIST=                   uno due tre quattro
                  RANDOM_LIST=            ${LIST:Ox}
                  STATIC_RANDOM_LIST:=    ${LIST:Ox}

                  all:
                          @echo "${RANDOM_LIST}"
                          @echo "${RANDOM_LIST}"
                          @echo "${STATIC_RANDOM_LIST}"
                          @echo "${STATIC_RANDOM_LIST}"
            may produce output similar to:

                  quattro due tre uno
                  tre due quattro uno
                  due uno quattro tre
                  due uno quattro tre

       :Q   Quotes every shell meta-character in the variable, so that it can be passed safely to the shell.

       :q   Quotes  every  shell  meta-character  in  the  variable,  and  also  doubles  ‘$’  characters  so  that it can be passed safely through recursive invocations of bmake.  This is equivalent to:
            ‘:S/\$/&&/g:Q’.

       :R   Replaces each word in the variable with everything but its suffix.

       :range[=count]
            The value is an integer sequence representing the words of the original value, or the supplied count.

       :gmtime[=utc]
            The value is a format string for strftime(3), using gmtime(3).  If a utc value is not provided or is 0, the current time is used.

       :hash
            Compute a 32-bit hash of the value and encode it as hex digits.

       :localtime[=utc]
            The value is a format string for strftime(3), using localtime(3).  If a utc value is not provided or is 0, the current time is used.

       :tA  Attempt to convert variable to an absolute path using realpath(3), if that fails, the value is unchanged.

       :tl  Converts variable to lower-case letters.

       :tsc
            Words in the variable are normally separated by a space on expansion.  This modifier sets the separator to the character c.  If c is omitted, then no separator is used.   The  common  escapes
            (including octal numeric codes), work as expected.

       :tu  Converts variable to upper-case letters.

       :tW  Causes the value to be treated as a single word (possibly containing embedded white space).  See also ‘:[*]’.

       :tw  Causes the value to be treated as a sequence of words delimited by white space.  See also ‘:[@]’.

       :S/old_string/new_string/[1gW]
            Modify  the  first occurrence of old_string in the variable's value, replacing it with new_string.  If a ‘g’ is appended to the last slash of the pattern, all occurrences in each word are re‐
            placed.  If a ‘1’ is appended to the last slash of the pattern, only the first word is affected.  If a ‘W’ is appended to the last slash of the pattern, then the value is treated as a  single
            word  (possibly containing embedded white space).  If old_string begins with a caret (‘^’), old_string is anchored at the beginning of each word.  If old_string ends with a dollar sign (‘$’),
            it is anchored at the end of each word.  Inside new_string, an ampersand (‘&’) is replaced by old_string (without any ‘^’ or ‘$’).  Any character may be used as a delimiter for the  parts  of
            the modifier string.  The anchoring, ampersand and delimiter characters may be escaped with a backslash (‘\’).

            Variable expansion occurs in the normal fashion inside both old_string and new_string with the single exception that a backslash is used to prevent the expansion of a dollar sign (‘$’), not a
            preceding dollar sign as is usual.

       :C/pattern/replacement/[1gW]
            The  :C  modifier  is  just  like the :S modifier except that the old and new strings, instead of being simple strings, are an extended regular expression (see regex(3)) string pattern and an
            ed(1)-style string replacement.  Normally, the first occurrence of the pattern pattern in each word of the value is substituted with replacement.  The ‘1’ modifier causes the substitution  to
            apply  to at most one word; the ‘g’ modifier causes the substitution to apply to as many instances of the search pattern pattern as occur in the word or words it is found in; the ‘W’ modifier
            causes the value to be treated as a single word (possibly containing embedded white space).  Note that ‘1’ and ‘g’ are orthogonal; the former specifies whether multiple words are  potentially
            affected, the latter whether multiple substitutions can potentially occur within each affected word.

            As for the :S modifier, the pattern and replacement are subjected to variable expansion before being parsed as regular expressions.

       :T   Replaces each word in the variable with its last component.

       :u   Remove adjacent duplicate words (like uniq(1)).

       :?true_string:false_string
            If  the variable name (not its value), when parsed as a .if conditional expression, evaluates to true, return as its value the true_string, otherwise return the false_string.  Since the vari‐
            able name is used as the expression, :? must be the first modifier after the variable name itself - which will, of course, usually contain variable expansions.  A common error  is  trying  to
            use expressions like
                  ${NUMBERS:M42:?match:no}
            which actually tests defined(NUMBERS), to determine is any words match "42" you need to use something like:
                  ${"${NUMBERS:M42}" != "":?match:no}.

       :old_string=new_string
            This  is  the  AT&T System V UNIX style variable substitution.  It must be the last modifier specified.  If old_string or new_string do not contain the pattern matching character % then it is
            assumed that they are anchored at the end of each word, so only suffixes or entire words may be replaced.  Otherwise % is the substring of old_string to be replaced in  new_string.   If  only
            old_string  contains the pattern matching character %, and old_string matches, then the result is the new_string.  If only the new_string contains the pattern matching character %, then it is
            not treated specially and it is printed as a literal % on match.  If there is more than one pattern matching character (%) in either the new_string or old_string, only the first  instance  is
            treated specially (as the pattern character); all subsequent instances are treated as regular characters

            Variable expansion occurs in the normal fashion inside both old_string and new_string with the single exception that a backslash is used to prevent the expansion of a dollar sign (‘$’), not a
            preceding dollar sign as is usual.

       :@temp@string@
            This  is  the loop expansion mechanism from the OSF Development Environment (ODE) make.  Unlike .for loops expansion occurs at the time of reference.  Assign temp to each word in the variable
            and evaluate string.  The ODE convention is that temp should start and end with a period.  For example.
                  ${LINKS:@.LINK.@${LN} ${TARGET} ${.LINK.}@}

            However a single character variable is often more readable:
                  ${MAKE_PRINT_VAR_ON_ERROR:@v@$v='${$v}'${.newline}@}

       :_[=var]
            Save the current variable value in ‘$_’ or the named var for later reference.  Example usage:

                  M_cmpv.units = 1 1000 1000000
                  M_cmpv = S,., ,g:_:range:@i@+ $${_:[-$$i]} \
                  \* $${M_cmpv.units:[$$i]}@:S,^,expr 0 ,1:sh

                  .if ${VERSION:${M_cmpv}} < ${3.1.12:L:${M_cmpv}}

            Here ‘$_’ is used to save the result of the ‘:S’ modifier which is later referenced using the index values from ‘:range’.

       :Unewval
            If the variable is undefined newval is the value.  If the variable is defined, the existing value is returned.  This is another ODE make feature.  It is handy for  setting  per-target  CFLAGS
            for instance:
                  ${_${.TARGET:T}_CFLAGS:U${DEF_CFLAGS}}
            If a value is only required if the variable is undefined, use:
                  ${VAR:D:Unewval}

       :Dnewval
            If the variable is defined newval is the value.

       :L   The name of the variable is the value.

       :P   The  path  of the node which has the same name as the variable is the value.  If no such node exists or its path is null, then the name of the variable is used.  In order for this modifier to
            work, the name (node) must at least have appeared on the rhs of a dependency.

       :!cmd!
            The output of running cmd is the value.

       :sh  If the variable is non-empty it is run as a command and the output becomes the new value.

       ::=str
            The variable is assigned the value str after substitution.  This modifier and its variations are useful in obscure situations such as wanting to set a variable when shell commands  are  being
            parsed.  These assignment modifiers always expand to nothing, so if appearing in a rule line by themselves should be preceded with something to keep bmake happy.

            The ‘::’ helps avoid false matches with the AT&T System V UNIX style := modifier and since substitution always occurs the ::= form is vaguely appropriate.

       ::?=str
            As for ::= but only if the variable does not already have a value.

       ::+=str
            Append str to the variable.

       ::!=cmd
            Assign the output of cmd to the variable.

       :[range]
            Selects one or more words from the value, or performs other operations related to the way in which the value is divided into words.

            Ordinarily, a value is treated as a sequence of words delimited by white space.  Some modifiers suppress this behavior, causing a value to be treated as a single word (possibly containing em‐
            bedded  white  space).  An empty value, or a value that consists entirely of white-space, is treated as a single word.  For the purposes of the ‘:[]’ modifier, the words are indexed both for‐
            wards using positive integers (where index 1 represents the first word), and backwards using negative integers (where index -1 represents the last word).

            The range is subjected to variable expansion, and the expanded result is then interpreted as follows:

            index  Selects a single word from the value.

            start..end
                   Selects all words from start to end, inclusive.  For example, ‘:[2..-1]’ selects all words from the second word to the last word.  If start is greater than end, then the words are out‐
                   put in reverse order.  For example, ‘:[-1..1]’ selects all the words from last to first.  If the list is already ordered, then this effectively reverses the list, but it is more  effi‐
                   cient to use ‘:Or’ instead of ‘:O:[-1..1]’.

            *      Causes subsequent modifiers to treat the value as a single word (possibly containing embedded white space).  Analogous to the effect of "$*" in Bourne shell.

            0      Means the same as ‘:[*]’.

            @      Causes subsequent modifiers to treat the value as a sequence of words delimited by white space.  Analogous to the effect of "$@" in Bourne shell.

            #      Returns the number of words in the value.

INCLUDE STATEMENTS, CONDITIONALS AND FOR LOOPS
       Makefile inclusion, conditional structures and for loops  reminiscent of the C programming language are provided in bmake.  All such structures are identified by a line beginning with a single dot
       (‘.’)  character.   Files are included with either .include <file> or .include "file".  Variables between the angle brackets or double quotes are expanded to form the file name.  If angle brackets
       are used, the included makefile is expected to be in the system makefile directory.  If double quotes are used, the including makefile's directory and any directories specified using the -I option
       are searched before the system makefile directory.  For compatibility with other versions of bmake ‘include file ...’ is also accepted.

       If the include statement is written as .-include or as .sinclude then errors locating and/or opening include files are ignored.

       If the include statement is written as .dinclude not only are errors locating and/or opening include files ignored, but stale dependencies within the  included  file  will  be  ignored  just  like
       .MAKE.DEPENDFILE.

       Conditional expressions are also preceded by a single dot as the first character of a line.  The possible conditionals are as follows:

       .error message
               The message is printed along with the name of the makefile and line number, then bmake will exit.

       .export variable ...
               Export  the specified global variable.  If no variable list is provided, all globals are exported except for internal variables (those that start with ‘.’).  This is not affected by the -X
               flag, so should be used with caution.  For compatibility with other bmake programs ‘export variable=value’ is also accepted.

               Appending a variable name to .MAKE.EXPORTED is equivalent to exporting a variable.

       .export-env variable ...
               The same as ‘.export’, except that the variable is not appended to .MAKE.EXPORTED.  This allows exporting a value to the environment which is different from that used by bmake internally.

       .export-literal variable ...
               The same as ‘.export-env’, except that variables in the value are not expanded.

       .info message
               The message is printed along with the name of the makefile and line number.

       .undef variable
               Un-define the specified global variable.  Only global variables may be un-defined.

       .unexport variable ...
               The opposite of ‘.export’.  The specified global variable will be removed from .MAKE.EXPORTED.  If no variable list is provided, all globals are unexported, and .MAKE.EXPORTED deleted.

       .unexport-env
               Unexport all globals previously exported and clear the environment inherited from the parent.  This operation will cause a memory leak of the original environment, so should be used  spar‐
               ingly.  Testing for .MAKE.LEVEL being 0, would make sense.  Also note that any variables which originated in the parent environment should be explicitly preserved if desired.  For example:

                     .if ${.MAKE.LEVEL} == 0
                     PATH := ${PATH}
                     .unexport-env
                     .export PATH
                     .endif

               Would result in an environment containing only ‘PATH’, which is the minimal useful environment.  Actually ‘.MAKE.LEVEL’ will also be pushed into the new environment.

       .warning message
               The message prefixed by ‘warning:’ is printed along with the name of the makefile and line number.

       .if [!]expression [operator expression ...]
               Test the value of an expression.

       .ifdef [!]variable [operator variable ...]
               Test the value of a variable.

       .ifndef [!]variable [operator variable ...]
               Test the value of a variable.

       .ifmake [!]target [operator target ...]
               Test the target being built.

       .ifnmake [!] target [operator target ...]
               Test the target being built.

       .else   Reverse the sense of the last conditional.

       .elif [!] expression [operator expression ...]
               A combination of ‘.else’ followed by ‘.if’.

       .elifdef [!]variable [operator variable ...]
               A combination of ‘.else’ followed by ‘.ifdef’.

       .elifndef [!]variable [operator variable ...]
               A combination of ‘.else’ followed by ‘.ifndef’.

       .elifmake [!]target [operator target ...]
               A combination of ‘.else’ followed by ‘.ifmake’.

       .elifnmake [!]target [operator target ...]
               A combination of ‘.else’ followed by ‘.ifnmake’.

       .endif  End the body of the conditional.

       The operator may be any one of the following:

       ||     Logical OR.

       &&     Logical AND; of higher precedence than “||”.

       As  in C, bmake will only evaluate a conditional as far as is necessary to determine its value.  Parentheses may be used to change the order of evaluation.  The boolean operator ‘!’ may be used to
       logically negate an entire conditional.  It is of higher precedence than ‘&&’.

       The value of expression may be any of the following:

       defined  Takes a variable name as an argument and evaluates to true if the variable has been defined.

       make     Takes a target name as an argument and evaluates to true if the target was specified as part of bmake's command line or was declared the default target (either implicitly  or  explicitly,
                see .MAIN) before the line containing the conditional.

       empty    Takes a variable, with possible modifiers, and evaluates to true if the expansion of the variable would result in an empty string.

       exists   Takes a file name as an argument and evaluates to true if the file exists.  The file is searched for on the system search path (see .PATH).

       target   Takes a target name as an argument and evaluates to true if the target has been defined.

       commands
                Takes a target name as an argument and evaluates to true if the target has been defined and has commands associated with it.

       Expression  may  also be an arithmetic or string comparison.  Variable expansion is performed on both sides of the comparison, after which the integral values are compared.  A value is interpreted
       as hexadecimal if it is preceded by 0x, otherwise it is decimal; octal numbers are not supported.  The standard C relational operators are all supported.  If after variable expansion,  either  the
       left  or right hand side of a ‘==’ or ‘!=’ operator is not an integral value, then string comparison is performed between the expanded variables.  If no relational operator is given, it is assumed
       that the expanded variable is being compared against 0 or an empty string in the case of a string comparison.

       When bmake is evaluating one of these conditional expressions, and it encounters a (white-space separated) word it doesn't recognize, either the “make” or “defined” expression is  applied  to  it,
       depending  on the form of the conditional.  If the form is ‘.ifdef’, ‘.ifndef’, or ‘.if’ the “defined” expression is applied.  Similarly, if the form is ‘.ifmake’ or ‘.ifnmake’, the “make” expres‐
       sion is applied.

       If the conditional evaluates to true the parsing of the makefile continues as before.  If it evaluates to false, the following lines are skipped.  In both cases this continues until a  ‘.else’  or
       ‘.endif’ is found.

       For loops are typically used to apply a set of rules to a list of files.  The syntax of a for loop is:

       .for variable [variable ...] in expression
       ⟨make-rules⟩
       .endfor

       After  the  for expression is evaluated, it is split into words.  On each iteration of the loop, one word is taken and assigned to each variable, in order, and these variables are substituted into
       the make-rules inside the body of the for loop.  The number of words must come out even; that is, if there are three iteration variables, the number of words provided must be a multiple of three.

COMMENTS
       Comments begin with a hash (‘#’) character, anywhere but in a shell command line, and continue to the end of an unescaped new line.

SPECIAL SOURCES (ATTRIBUTES)
       .EXEC     Target is never out of date, but always execute commands anyway.

       .IGNORE   Ignore any errors from the commands associated with this target, exactly as if they all were preceded by a dash (‘-’).

       .MADE     Mark all sources of this target as being up-to-date.

       .MAKE     Execute the commands associated with this target even if the -n or -t options were specified.  Normally used to mark recursive bmakes.

       .META     Create a meta file for the target, even if it is flagged as .PHONY, .MAKE, or .SPECIAL.  Usage in conjunction with .MAKE is the most likely case.  In "meta" mode, the target  is  out-of-
                 date if the meta file is missing.

       .NOMETA   Do not create a meta file for the target.  Meta files are also not created for .PHONY, .MAKE, or .SPECIAL targets.

       .NOMETA_CMP
                 Ignore  differences  in  commands when deciding if target is out of date.  This is useful if the command contains a value which always changes.  If the number of commands change, though,
                 the target will still be out of date.  The same effect applies to any command line that uses the variable .OODATE, which can be used for that purpose even when not  otherwise  needed  or
                 desired:

                       skip-compare-for-some:
                               @echo this will be compared
                               @echo this will not ${.OODATE:M.NOMETA_CMP}
                               @echo this will also be compared

                 The :M pattern suppresses any expansion of the unwanted variable.

       .NOPATH   Do not search for the target in the directories specified by .PATH.

       .NOTMAIN  Normally bmake selects the first target it encounters as the default target to be built if no target was specified.  This source prevents this target from being selected.

       .OPTIONAL
                 If a target is marked with this attribute and bmake can't figure out how to create it, it will ignore this fact and assume the file isn't needed or already exists.

       .PHONY    The  target  does not correspond to an actual file; it is always considered to be out of date, and will not be created with the -t option.  Suffix-transformation rules are not applied to
                 .PHONY targets.

       .PRECIOUS
                 When bmake is interrupted, it normally removes any partially made targets.  This source prevents the target from being removed.

       .RECURSIVE
                 Synonym for .MAKE.

       .SILENT   Do not echo any of the commands associated with this target, exactly as if they all were preceded by an at sign (‘@’).

       .USE      Turn the target into bmake's version of a macro.  When the target is used as a source for another target, the other target acquires the commands,  sources,  and  attributes  (except  for
                 .USE) of the source.  If the target already has commands, the .USE target's commands are appended to them.

       .USEBEFORE
                 Exactly like .USE, but prepend the .USEBEFORE target commands to the target.

       .WAIT     If .WAIT appears in a dependency line, the sources that precede it are made before the sources that succeed it in the line.  Since the dependents of files are not made until the file it‐
                 self could be made, this also stops the dependents being built unless they are needed for another branch of the dependency tree.  So given:

                 x: a .WAIT b
                         echo x
                 a:
                         echo a
                 b: b1
                         echo b
                 b1:
                         echo b1

                 the output is always ‘a’, ‘b1’, ‘b’, ‘x’.
                 The ordering imposed by .WAIT is only relevant for parallel makes.

SPECIAL TARGETS
       Special targets may not be included with other targets, i.e. they must be the only target specified.

       .BEGIN   Any command lines attached to this target are executed before anything else is done.

       .DEFAULT
                This is sort of a .USE rule for any target (that was used only as a source) that bmake can't figure out any other way to create.  Only the shell script is used.  The .IMPSRC variable of a
                target that inherits .DEFAULT's commands is set to the target's own name.

       .DELETE_ON_ERROR
                If  this  target  is present in the makefile, it globally causes make to delete targets whose commands fail.  (By default, only targets whose commands are interrupted during execution are
                deleted.  This is the historical behavior.)  This setting can be used to help prevent half-finished or malformed targets from being left around and corrupting future rebuilds.

       .END     Any command lines attached to this target are executed after everything else is done.

       .ERROR   Any command lines attached to this target are executed when another target fails.  The .ERROR_TARGET variable is set to the target that failed.  See also MAKE_PRINT_VAR_ON_ERROR.

       .IGNORE  Mark each of the sources with the .IGNORE attribute.  If no sources are specified, this is the equivalent of specifying the -i option.

       .INTERRUPT
                If bmake is interrupted, the commands for this target will be executed.

       .MAIN    If no target is specified when bmake is invoked, this target will be built.

       .MAKEFLAGS
                This target provides a way to specify flags for bmake when the makefile is used.  The flags are as if typed to the shell, though the -f option will have no effect.

       .NOPATH  Apply the .NOPATH attribute to any specified sources.

       .NOTPARALLEL
                Disable parallel mode.

       .NO_PARALLEL
                Synonym for .NOTPARALLEL, for compatibility with other pmake variants.

       .OBJDIR  The source is a new value for ‘.OBJDIR’.  If it exists, bmake will chdir(2) to it and update the value of ‘.OBJDIR’.

       .ORDER   The named targets are made in sequence.  This ordering does not add targets to the list of targets to be made.  Since the dependents of a target do not get built until the  target  itself
                could be built, unless ‘a’ is built by another part of the dependency graph, the following is a dependency loop:

                .ORDER: b a
                b: a

                The ordering imposed by .ORDER is only relevant for parallel makes.

       .PATH    The  sources are directories which are to be searched for files not found in the current directory.  If no sources are specified, any previously specified directories are deleted.  If the
                source is the special .DOTLAST target, then the current working directory is searched last.

       .PATH.suffix
                Like .PATH but applies only to files with a particular suffix.  The suffix must have been previously declared with .SUFFIXES.

       .PHONY   Apply the .PHONY attribute to any specified sources.

       .PRECIOUS
                Apply the .PRECIOUS attribute to any specified sources.  If no sources are specified, the .PRECIOUS attribute is applied to every target in the file.

       .SHELL   Sets the shell that bmake will use to execute commands.  The sources are a set of field=value pairs.

                name        This is the minimal specification, used to select one of the built-in shell specs; sh, ksh, and csh.

                path        Specifies the path to the shell.

                hasErrCtl   Indicates whether the shell supports exit on error.

                check       The command to turn on error checking.

                ignore      The command to disable error checking.

                echo        The command to turn on echoing of commands executed.

                quiet       The command to turn off echoing of commands executed.

                filter      The output to filter after issuing the quiet command.  It is typically identical to quiet.

                errFlag     The flag to pass the shell to enable error checking.

                echoFlag    The flag to pass the shell to enable command echoing.

                newline     The string literal to pass the shell that results in a single newline character when used outside of any quoting characters.
                Example:

                .SHELL: name=ksh path=/bin/ksh hasErrCtl=true \
                        check="set -e" ignore="set +e" \
                        echo="set -v" quiet="set +v" filter="set +v" \
                        echoFlag=v errFlag=e newline="'\n'"

       .SILENT  Apply the .SILENT attribute to any specified sources.  If no sources are specified, the .SILENT attribute is applied to every command in the file.

       .STALE   This target gets run when a dependency file contains stale entries, having .ALLSRC set to the name of that dependency file.

       .SUFFIXES
                Each source specifies a suffix to bmake.  If no sources are specified, any previously specified suffixes are deleted.  It allows the creation of suffix-transformation rules.

                Example:

                .SUFFIXES: .o
                .c.o:
                        cc -o ${.TARGET} -c ${.IMPSRC}

ENVIRONMENT
       bmake uses the following environment variables, if they exist: MACHINE, MACHINE_ARCH, MACHINE_MULTIARCH, MAKE, MAKEFLAGS, MAKEOBJDIR, MAKEOBJDIRPREFIX, MAKESYSPATH, PWD, and TMPDIR.

       MAKEOBJDIRPREFIX and MAKEOBJDIR may only be set in the environment or on the command line to bmake and not as makefile variables; see the description of ‘.OBJDIR’ for more details.

FILES
       .depend        list of dependencies
       Makefile       list of dependencies
       makefile       list of dependencies
       sys.mk         system makefile
       /usr/share/mk  system makefile directory

COMPATIBILITY
       The basic make syntax is compatible between different versions of make; however the special variables, variable modifiers and conditionals are not.

   Older versions
       An incomplete list of changes in older versions of bmake:

       The way that .for loop variables are substituted changed after NetBSD 5.0 so that they still appear to be variable expansions.  In particular this stops them being treated as syntax,  and  removes
       some obscure problems using them in .if statements.

       The way that parallel makes are scheduled changed in NetBSD 4.0 so that .ORDER and .WAIT apply recursively to the dependent nodes.  The algorithms used may change again in the future.

   Other make dialects
       Other make dialects (GNU make, SVR4 make, POSIX make, etc.) do not support most of the features of bmake as described in this manual.  Most notably:

             •   The .WAIT and .ORDER declarations and most functionality pertaining to parallelization.  (GNU make supports parallelization but lacks these features needed to control it effectively.)

             •   Directives, including for loops and conditionals and most of the forms of include files.  (GNU make has its own incompatible and less powerful syntax for conditionals.)

             •   All built-in variables that begin with a dot.

             •   Most of the special sources and targets that begin with a dot, with the notable exception of .PHONY, .PRECIOUS, and .SUFFIXES.

             •   Variable modifiers, except for the
                       :old=new
                 string substitution, which does not portably support globbing with ‘%’ and historically only works on declared suffixes.

             •   The $> variable even in its short form; most makes support this functionality but its name varies.

       Some features are somewhat more portable, such as assignment with +=, ?=, and !=.  The .PATH functionality is based on an older feature VPATH found in GNU make and many versions of SVR4 make; how‐
       ever, historically its behavior is too ill-defined (and too buggy) to rely upon.

       The  $@ and $< variables are more or less universally portable, as is the $(MAKE) variable.  Basic use of suffix rules (for files only in the current directory, not trying to chain transformations
       together, etc.) is also reasonably portable.

SEE ALSO
       mkdep(1)

HISTORY
       bmake is derived from NetBSD make(1).  It uses autoconf to facilitate portability to other platforms.

       A make command appeared in Version 7 AT&T UNIX.  This make implementation is based on Adam De Boor's pmake program which was written for Sprite at Berkeley.  It was designed to be a parallel  dis‐
       tributed make running jobs on different machines using a daemon called “customs”.

       Historically the target/dependency “FRC” has been used to FoRCe rebuilding (since the target/dependency does not exist... unless someone creates an “FRC” file).

BUGS
       The  make syntax is difficult to parse without actually acting on the data.  For instance, finding the end of a variable's use should involve scanning each of the modifiers, using the correct ter‐
       minator for each field.  In many places make just counts {} and () in order to find the end of a variable expansion.

       There is no way of escaping a space character in a filename.

Debian                                                                                          June 5, 2020                                                                                       BMAKE(1)
