Sort::Fields(3pm)                                                                   User Contributed Perl Documentation                                                                   Sort::Fields(3pm)

NAME
       Sort::Fields - Sort lines containing delimited fields

SYNOPSIS
         use Sort::Fields;
         @sorted = fieldsort [3, '2n'], @lines;
         @sorted = fieldsort '\+', [-1, -3, 0], @lines;

         $sort_3_2n = make_fieldsort [3, '2n'], @lines;
         @sorted = $sort_3_2n->(@lines);

DESCRIPTION
       Sort::Fields provides a general purpose technique for efficiently sorting lists of lines that contain data separated into fields.

       Sort::Fields automatically imports two subroutines, "fieldsort" and "make_fieldsort", and two variants, "stable_fieldsort" and "make_stable_fieldsort".  "make_fieldsort" generates a sorting
       subroutine and returns a reference to it.  "fieldsort" is a wrapper for the "make_fieldsort" subroutine.

       The first argument to make_fieldsort is a delimiter string, which is used as a regular expression argument for a "split" operator.  The delimiter string is optional.  If it is not supplied,
       make_fieldsort splits each line using "/\s+/".

       The second argument is an array reference containing one or more field specifiers.  The specifiers indicate what fields in the strings will be used to sort the data.  The specifier "1" indicates
       the first field, "2" indicates the second, and so on.  A negative specifier like "-2" means to sort on the second field in reverse (descending) order.  To indicate a numeric rather than alphabetic
       comparison, append "n" to the specifier.  A specifier of "0" means the entire string ("-0" means the entire string, in reverse order).

       The order in which the specifiers appear is the order in which they will be used to sort the data.  The primary key is first, the secondary key is second, and so on.

       "fieldsort [1, 2], @data" is roughly equivalent to "make_fieldsort([1, 2])->(@data)".  Avoid calling fieldsort repeatedly with the same sort specifiers.  If you need to use a particular sort more
       than once, it is more efficient to call "make_fieldsort" once and reuse the subroutine it returns.

       "stable_fieldsort" and "make_stable_fieldsort" are like their "unstable" counterparts, except that the items that compare the same are maintained in their original order.

EXAMPLES
       Some sample data (in array @data):

         123   asd   1.22   asdd
         32    ewq   2.32   asdd
         43    rewq  2.12   ewet
         51    erwt  34.2   ewet
         23    erww  4.21   ewet
         91    fdgs  3.43   ewet
         123   refs  3.22   asdd
         123   refs  4.32   asdd

         # alpha sort on column 1
         print fieldsort [1], @data;

         123   asd   1.22   asdd
         123   refs  3.22   asdd
         123   refs  4.32   asdd
         23    erww  4.21   ewet
         32    ewq   2.32   asdd
         43    rewq  2.12   ewet
         51    erwt  34.2   ewet
         91    fdgs  3.43   ewet

         # numeric sort on column 1
         print fieldsort ['1n'], @data;

         23    erww  4.21   ewet
         32    ewq   2.32   asdd
         43    rewq  2.12   ewet
         51    erwt  34.2   ewet
         91    fdgs  3.43   ewet
         123   asd   1.22   asdd
         123   refs  3.22   asdd
         123   refs  4.32   asdd

         # reverse numeric sort on column 1
         print fieldsort ['-1n'], @data;

         123   asd   1.22   asdd
         123   refs  3.22   asdd
         123   refs  4.32   asdd
         91    fdgs  3.43   ewet
         51    erwt  34.2   ewet
         43    rewq  2.12   ewet
         32    ewq   2.32   asdd
         23    erww  4.21   ewet

         # alpha sort on column 2, then alpha on entire line
         print fieldsort [2, 0], @data;

         123   asd   1.22   asdd
         51    erwt  34.2   ewet
         23    erww  4.21   ewet
         32    ewq   2.32   asdd
         91    fdgs  3.43   ewet
         123   refs  3.22   asdd
         123   refs  4.32   asdd
         43    rewq  2.12   ewet

         # alpha sort on column 4, then numeric on column 1, then reverse
         # numeric on column 3
         print fieldsort [4, '1n', '-3n'], @data;

         32    ewq   2.32   asdd
         123   refs  4.32   asdd
         123   refs  3.22   asdd
         123   asd   1.22   asdd
         23    erww  4.21   ewet
         43    rewq  2.12   ewet
         51    erwt  34.2   ewet
         91    fdgs  3.43   ewet

         # now, splitting on either literal period or whitespace
         # sort numeric on column 4 (fractional part of decimals) then
         # numeric on column 3 (whole part of decimals)
         print fieldsort '(?:\.|\s+)', ['4n', '3n'], @data;

         51    erwt  34.2   ewet
         43    rewq  2.12   ewet
         23    erww  4.21   ewet
         123   asd   1.22   asdd
         123   refs  3.22   asdd
         32    ewq   2.32   asdd
         123   refs  4.32   asdd
         91    fdgs  3.43   ewet

         # alpha sort on column 4, then numeric on the entire line
         # NOTE: produces warnings under -w
         print fieldsort [4, '0n'], @data;

         32    ewq   2.32   asdd
         123   asd   1.22   asdd
         123   refs  3.22   asdd
         123   refs  4.32   asdd
         23    erww  4.21   ewet
         43    rewq  2.12   ewet
         51    erwt  34.2   ewet
         91    fdgs  3.43   ewet

         # stable alpha sort on column 4 (maintains original relative order
         # among items that compare the same)
         print stable_fieldsort [4], @data;

         123   asd   1.22   asdd
         32    ewq   2.32   asdd
         123   refs  3.22   asdd
         123   refs  4.32   asdd
         43    rewq  2.12   ewet
         51    erwt  34.2   ewet
         23    erww  4.21   ewet
         91    fdgs  3.43   ewet

BUGS
       Some rudimentary tests now.

       Perhaps something should be done to catch things like:

         fieldsort '.', [1, 2], @lines;

       '.' translates to "split /./" -- probably not what you want.

       Passing blank lines and/or lines containing the wrong kind of data (alphas instead of numbers) can result in copious warning messages under "-w".

       If the regexp contains memory parentheses ("(...)" rather than "(?:...)"), split will function in "delimiter retention" mode, capturing the contents of the parentheses as well as the stuff between
       the delimiters.  I could imagine how this could be useful, but on the other hand I could also imagine how it could be confusing if encountered unexpectedly.  Caveat sortor.

       Not really a bug, but if you are planning to sort a large text file, consider using sort(1).  Unless, of course, your operating system doesn't have sort(1).

AUTHOR
       Joseph N. Hall, "<joseph@5sigma.com>"

SEE ALSO
       perl(1).

perl v5.40.1                                                                                     2025-04-17                                                                               Sort::Fields(3pm)
