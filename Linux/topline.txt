topline(1)                                                                                General Commands Manual                                                                                topline(1)

NAME
       topline - a disk/per-core CPU grapher/logger

SYNOPSIS
       topline [ -l ] [ -i 1.0 ] [ -o logfile ] [ program arg1 arg2 ...  ]

DESCRIPTION
       While  programs  like htop can show per-core loads, they do so interactively.  There are loggers like dstat but, using numeric data, they have no chance to fit per-CPU information within a line on
       modern many-core processors.  Thus, topline uses Unicode graphing symbols to squash the data into a terse, two-hyperthreads-per-char, form.  This allows eyeballing NUMA  separation,  CPU  hopping,
       etc.

       Once per second, topline plots stats for that interval:

       per every disk,
              one  character with two columns of dots gives that disk's utilization time percentage.  The left column shows reads, the right one shows writes.  Disks are grouped into parenthesised groups
              by interface type (NVMe, SATA, eMMC, ...).

       per every non-hyperthreaded CPU or a pair of hyperthreaded siblings,
              a character with one or two columns is given.  Non-HT CPUS are drawn with bars, HT ones with dots, offline cores are marked with 'o'.  The parentheses group CPUs by their NUMA node.

OPTIONS
       <program> <arg1> <arg2> ...
              Runs a program and terminates the graph once the program exits.  The graph still exhibits the global state of the system rather than just the program you chose and its children.

       If no program is given, topline will keep logging forever (ie, until you press ^C or similar).

       -l, --line-output, --linearize
              Marshalls the program's output line-by-line, avoiding mix-ups with topline's data.  They will be interspersed in separate lines.
              The program will know it is being piped; if you want it to believe it's ran on a terminal (to get colors, etc) you may use a tool like pipetty.

       -i <interval>
              Sets the interval between data samples; the default is 1s.  Floating-point values are allowed; the number may be suffixed by a "s"  (seconds,  default),  "m"  (minutes),  "h"  (hours),  "d"
              (days), "ms" (milliseconds), "us" or "Âµs" (microseconds).

       -o <file>, --output <file>
              Redirects topline's output to the given file.  The program being ran can then use stdout and stderr unimpeded.

       -d, --dump-after, --delay-dump
              Suppresses  the  graph  output until after the program exits, then dumps the logged graph all at once to stderr.  Good for non-interactive builds.  NB. ^C assumes you want to abort both the
              program and topline, please kill the former some other way if that is not the case.

CAVEATS
       If the machine's CPUs are hyperthreaded with more than one or two per core, the graph won't make it obvious which columns share a core.  All siblings are still given consecutively,  unless  forced
       into separate NUMA nodes with fakenuma settings.

       Machines above circa 140 CPUs may not fit on an 80-column terminal.

       All utilization figures are global to the machine even if caused by something else than the program you run.

SEE ALSO
       htop, dstat, VTUNE.

                                                                                                 2019-12-29                                                                                      topline(1)
