Algorithm::Backoff::MIMD(3pm)                                                       User Contributed Perl Documentation                                                       Algorithm::Backoff::MIMD(3pm)

NAME
       Algorithm::Backoff::MIMD - Multiplicative Increment, Multiplicative Decrement (MIMD) backoff

VERSION
       This document describes version 0.010 of Algorithm::Backoff::MIMD (from Perl distribution Algorithm-Backoff), released on 2024-02-24.

SYNOPSIS
        use Algorithm::Backoff::MIMD;

        # 1. instantiate

        my $ab = Algorithm::Backoff::MIMD->new(
            #consider_actual_delay => 1, # optional, default 0
            #max_actual_duration   => 0, # optional, default 0 (retry endlessly)
            #max_attempts          => 0, # optional, default 0 (retry endlessly)
            #jitter_factor         => 0.25, # optional, default 0
            min_delay              => 2, # optional, default 0
            #max_delay             => 100, # optional
            initial_delay              => 3,   # required
            delay_multiple_on_failure  => 2,   # required
            delay_multiple_on_success  => 0.5, # required
        );

        # 2. log success/failure and get a new number of seconds to delay, timestamp is
        # optional but must be monotonically increasing.

        # for example, using the parameters initial_delay=3,
        # delay_multiple_on_failure=2, delay_multiple_on_success=0.5, min_delay=2:

        my $secs;
        $secs = $ab->failure();   # => 3    (= initial_delay)
        $secs = $ab->failure();   # => 6    (3 * 2)
        $secs = $ab->failure();   # => 12   (6 * 2)
        $secs = $ab->success();   # => 6    (12 * 0.5)
        $secs = $ab->success();   # => 3    (6 * 0.5)
        $secs = $ab->success();   # => 2    (max(3*0.5, min_delay=2))
        $secs = $ab->failure();   # => 4    (2 * 2)

       Illustration using CLI show-backoff-delays (4 failures followed by 5 successes, followed by 3 failures):

        % show-backoff-delays -a MIMD --initial-delay 3 --min-delay 2 \
            --delay-multiple-on-failure 2 --delay-multiple-on-success 0.5 \
            0 0 0 0   1 1 1 1 1   0 0 0
        3
        6
        12
        24
        12
        6
        3
        2
        2
        4
        8
        16

DESCRIPTION
       Upon failure, this backoff algorithm calculates the next delay as:

        D1 = initial_delay
        D2 = max(min(D1 * delay_multiple_on_failure, max_delay), min_delay)
        ...

       Upon success, the next delay is calculated as:

        D1 = initial_delay
        D2 = max(min(D1 * delay_multiple_on_success, max_delay), min_delay)
        ...

       "initial_delay", "delay_multiple_on_failure", and "delay_multiple_on_success" are required. "initial_delay" and "min_delay" should be larger than zero; otherwise the next delays will all be zero.

       There are limits on the number of attempts (`max_attempts`) and total duration (`max_actual_duration`).

       It is recommended to add a jitter factor, e.g. 0.25 to add some randomness to avoid "thundering herd problem".

METHODS
   new
       Usage:

        new(%args) -> obj

       This function is not exported.

       Arguments ('*' denotes required arguments):

       •   consider_actual_delay => bool (default: 0)

           Whether to consider actual delay.

           If  set  to  true,  will  take into account the actual delay (timestamp difference).  For example, when using the Constant strategy of delay=2, you log failure() again right after the previous
           failure() (i.e. specify the same timestamp).  failure() will then return ~2+2 = 4 seconds. On the other hand, if you waited 2 seconds before calling failure() again (i.e. specify the timestamp
           that is 2 seconds larger than the previous timestamp), failure() will return 2 seconds.  And if you waited 4 seconds or more, failure() will return 0.

       •   delay_multiple_on_failure* => ufloat

           How much to multiple previous delay, upon failure (e.g. 1.5).

       •   delay_multiple_on_success* => ufloat

           How much to multiple previous delay, upon success (e.g. 0.5).

       •   initial_delay* => ufloat

           Initial delay for the first attempt after failure, in seconds.

       •   jitter_factor => float

           How much to add randomness.

           If you set this to a value larger than 0, the actual delay will be between a random number between original_delay *  (1-jitter_factor)  and  original_delay  *  (1+jitter_factor).  Jitters  are
           usually added to avoid so-called "thundering herd" problem.

           The jitter will be applied to delay on failure as well as on success.

       •   max_actual_duration => ufloat (default: 0)

           Maximum number of seconds for all of the attempts (0 means unlimited).

           If  set  to  a positive number, will limit the number of seconds for all of the attempts. This setting is used to limit the amount of time you are willing to spend on a task. For example, when
           using the Exponential strategy of initial_delay=3 and max_attempts=10, the delays will be 3, 6, 12, 24, ... If failures are logged according to the suggested delays, and max_actual_duration is
           set to 21 seconds, then the third failure() will return -1 instead of 24 because 3+6+12 >= 21, even though max_attempts has not been exceeded.

       •   max_attempts => uint (default: 0)

           Maximum number consecutive failures before giving up.

           0 means to retry endlessly without ever giving up. 1 means to give up after a single failure (i.e. no retry attempts). 2 means to retry once after a failure.  Note that after  a  success,  the
           number of attempts is reset (as expected). So if max_attempts is 3, and if you fail twice then succeed, then on the next failure the algorithm will retry again for a maximum of 3 times.

       •   max_delay => ufloat

           Maximum delay time, in seconds.

       •   min_delay => ufloat (default: 0)

           Maximum delay time, in seconds.

       Return value:  (obj)

HOMEPAGE
       Please visit the project's homepage at <https://metacpan.org/release/Algorithm-Backoff>.

SOURCE
       Source repository is at <https://github.com/perlancar/perl-Algorithm-Backoff>.

SEE ALSO
       Algorithm::Backoff::LILD

       Algorithm::Backoff::LIMD

       Algorithm::Backoff::MILD

       Algorithm::Backoff

       Other "Algorithm::Backoff::*" classes.

AUTHOR
       perlancar <perlancar@cpan.org>

CONTRIBUTING
       To contribute, you can send patches by email/via RT, or send pull requests on GitHub.

       Most of the time, you don't need to build the distribution yourself. You can simply modify the code, then test via:

        % prove -l

       If   you   want   to   build   the   distribution   (e.g.   to   try   to   install  it  locally  on  your  system),  you  can  install  Dist::Zilla,  Dist::Zilla::PluginBundle::Author::PERLANCAR,
       Pod::Weaver::PluginBundle::Author::PERLANCAR, and sometimes one or two other Dist::Zilla- and/or Pod::Weaver plugins. Any additional steps required beyond that are considered  a  bug  and  can  be
       reported to me.

COPYRIGHT AND LICENSE
       This software is copyright (c) 2024, 2019 by perlancar <perlancar@cpan.org>.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.

BUGS
       Please report any bugs or feature requests on the bugtracker website <https://rt.cpan.org/Public/Dist/Display.html?Name=Algorithm-Backoff>

       When submitting a bug or request, please include a test-file or a patch to an existing test-file that illustrates the bug or desired feature.

perl v5.40.1                                                                                     2025-05-04                                                                   Algorithm::Backoff::MIMD(3pm)
