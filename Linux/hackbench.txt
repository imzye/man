hackbench(8)                                                                                                                                                                                       hackbench(8)

NAME
       hackbench - scheduler benchmark/stress test

SYNOPSIS
       hackbench [-f|--fds NUM] [-F|--fifo] [-g|--groups NUM] [-h|--help] [-l|--loops LOOPS] [-p|--pipe] [-s|--datasize SIZE] [-T|--threads] [-P|--process]

DESCRIPTION
       Hackbench is both a benchmark and a stress test for the Linux kernel scheduler. It's main job is to create a specified number of pairs of schedulable entities (either threads or traditional processes)
       which communicate via either sockets or pipes and time how long it takes for each pair to send data back and forth.

OPTIONS
       These programs follow the usual GNU command line syntax, with long options starting with two dashes ("--").
       A summary of options is included below.

       -f, --fds=NUM
              Defines how many file descriptors each child should use.  Note that the effective number will be twice the amount you set here, as the sender and receiver children  will  each  open  the  given
              amount of file descriptors.

       -F,--fifo
              Change the main thread to SCHED_FIFO after creating workers.  This allows the management thread to run after many workers are created.

       -g, --groups=NUM
              Defines how many groups of senders and receivers should be started

       -h, --help

       -l, --loops=LOOPS
              How many messages each sender/receiver pair should send

       -p, --pipe
              Sends the data via a pipe instead of the socket (default)

       -s, --datasize=SIZE
              Sets the amount of data to send in each message

       -T, --threads
              Each sender/receiver child will be a POSIX thread of the parent.

       -P, --process
              Hackbench will use fork() on all children (default behaviour)
              Shows a simple help screen

EXAMPLES
       Running hackbench without any options will give default behaviour, using fork() and sending data between senders and receivers via sockets.

       user@host: ~ $ hackbench
       Running in process mode with 10 groups using 40 file descriptors each (== 400 tasks)
       Each sender will pass 100 messages of 100 bytes
       Time: 0.890

       To use pipes between senders and receivers and using threads instead of fork(), run

       user@host: ~ $ hackbench --pipe --threads   (or hackbench -p -T)
       Running in threaded mode with 10 groups using 40 file descriptors each (== 400 tasks)
       Each sender will pass 100 messages of 100 bytes
       Time: 0.497

       Set the datasize to 512 bytes, do 200 messages per sender/receiver pairs and use 15 groups using 25 file descriptors per child, in process mode.

       user@host: ~ $ hackbench -s 512 -l 200 -g 15 -f 25 -P
       Running in process mode with 15 groups using 50 file descriptors each (== 750 tasks)
       Each sender will pass 200 messages of 512 bytes
       Time: 4.497

AUTHORS
       hackbench was written by Rusty Russell <rusty@rustcorp.com.au> with contributions from Yanmin Zhang <yanmin_zhang@linux.intel.com>, Ingo Molnar <mingo@elte.hu> and David Sommerseth <davids@redhat.com>

       This manual page was written by Clark Williams <williams@redhat.com> and David Sommerseth <davids@redhat.com>

HISTORY
       This version of hackbench is based on the code downloaded from http://people.redhat.com/mingo/cfs-scheduler/tools/hackbench.c.  Yanmin Zhang merged the original hackbench code from
       http://devresources.linuxfoundation.org/craiger/hackbench/src/hackbench.c which uses fork() and a modified version from
       http://www.bullopensource.org/posix/pi-futex/hackbench_pth.c which uses pthread only and gave the possibility to change behaviour at run time.  Hackbench have since then gone through some more rewrit‚Äê
       ing to improve error handling and proper tracking of fork()ed children, to avoid leaving zombies on the system if hackbench stops unexpectedly.

                                                                                              September  19, 2020                                                                                  hackbench(8)
