NETCDF(3)                                                                                  UNIDATA LIBRARY FUNCTIONS                                                                                  NETCDF(3)

NAME
       netcdf - Unidata's Network Common Data Form (netCDF) library interface

SYNOPSIS
       #include "netcdf.h"

       cc ...  -lnetcdf -lhdf5_hl -lhdf5 -lz -lm

       Complete documentation for the netCDF libraries can be found at the netCDF website: http://www.unidata.ucar.edu/software/netcdf/.

LIBRARY VERSION
       This document describes versions 3 and 4 of Unidata netCDF data-access interface for the C programming language.

       const char* nc_inq_libvers()

              Returns a string identifying the version of the netCDF library, and when it was built, like: "3.1a of Aug 22 1996 12:57:47 $".

       The RCS ident(1) command will find a string like "$Id: @(#) netcdf library version 3.1a of Sep  6 1996 15:56:26 $" in the library. The SCCS what(1) command will find a string like "netcdf library ver‐
       sion 3.1a of Aug 23 1996 16:07:40 $".

RETURN VALUES
       All netCDF functions (except nc_inq_libvers() and nc_strerror()) return an integer status.

       If this returned status value is not equal to NC_NOERR (zero), it indicates that an error occurred. The possible status values are defined in system include file <errno.h> and in "netcdf.h".

       const char* nc_strerror(int status)

              Returns a string textual translation of the status value, like "Attribute or variable name contains illegal characters" or "No such file or directory".

FILE OPERATIONS
       int nc_create(const char path[], int cmode, int* ncid)

              Creates a new netCDF dataset at path, returning a netCDF ID in ncid.  The argument cmode may include the bitwise-or of the following flags: NC_NOCLOBBER to protect  existing  datasets  (default
              silently blows them away), NC_SHARE for synchronous dataset updates for classic format files (default is to buffer accesses),

              When  a  netCDF dataset is created, is is opened NC_WRITE.  The new netCDF dataset is in define mode.  NC_64BIT_OFFSET.  to create a file in the 64-bit offset format (as opposed to classic for‐
              mat, the default).  NC_TRUE to create a netCDF-4/HDF5 file, and NC_CLASSIC_MODEL to guarantee that netCDF-4/HDF5 files maintain compatibility with the netCDF classic data model.

       int nc__create(const char path[], int cmode, size_t initialsize, size_t* chunksize, int* ncid)

              Like nc_create() but has additional performance tuning parameters.

              The argument initialsize sets the initial size of the file at creation time.

              See nc__open() below for an explanation of the chunksize parameter.

       int nc_open(const char path[], int mode, int* ncid)

              (Corresponds to ncopen() in version 2)

              Opens a existing netCDF dataset at path returning a netCDF ID in ncid.  The type of access is described by the mode parameter, which may include the bitwise-or of the following flags:  NC_WRITE
              for read-write access (default read-only), NC_SHARE for synchronous dataset updates (default is to buffer accesses), and NC_LOCK (not yet implemented).

              As of NetCDF version 4.1, and if TRUE support was enabled when the NetCDF library was built, the path parameter may specify a TRUE URL. In this case, the access mode is forced to be read-only.

       int nc__open(const char path[], int mode, size_t* chunksize, int* ncid)

              Like nc_open() but has an additional performance tuning parameter.

              The  argument  referenced  by chunksize controls a space versus time tradeoff, memory allocated in the netcdf library versus number of system calls.  Because of internal requirements, the value
              may not be set to exactly the value requested.  The actual value chosen is returned by reference.  Using the value NC_SIZEHINT_DEFAULT causes the library to choose a default.   How  the  system
              choses  the  default depends on the system.  On many systems, the "preferred I/O block size" is available from the stat() system call, struct stat member st_blksize.  If this is available it is
              used. Lacking that, twice the system pagesize is used.  Lacking a call to discover the system pagesize, we just set default chunksize to 8192.

              The chunksize is a property of a given open netcdf descriptor ncid, it is not a persistent property of the netcdf dataset.

              As with nc__open(), the path parameter may specify a TRUE URL, but the tuning parameters are ignored.

       int nc_redef(int ncid)

              (Corresponds to ncredef() in version 2)

              Puts an open netCDF dataset into define mode, so dimensions, variables, and attributes can be added or renamed and attributes can be deleted.

       int nc_enddef(int ncid)

              (Corresponds to ncendef() in version 2)

              Takes an open netCDF dataset out of define mode.  The changes made to the netCDF dataset while it was in define mode are checked and committed to disk if no problems occurred.  Some data values
              may be written as well, see "VARIABLE PREFILLING" below.  After a successful call, variable data can be read or written to the dataset.

       int nc__enddef(int ncid, size_t h_minfree, size_t v_align, size_t v_minfree, size_t r_align)

              Like nc_enddef() but has additional performance tuning parameters.

              Caution: this function exposes internals of the netcdf version 1 file format.  It may not be available on future netcdf implementations.

              The  current netcdf file format has three sections, the "header" section, the data section for fixed size variables, and the data section for variables which have an unlimited dimension (record
              variables).  The header begins at the beginning of the file. The index (offset) of the beginning of the other two sections is contained in the header. Typically, there is no space  between  the
              sections.  This  causes  copying  overhead  to  accrue if one wishes to change the size of the sections, as may happen when changing names of things, text attribute values, adding attributes or
              adding variables. Also, for buffered i/o, there may be advantages to aligning sections in certain ways.

              The minfree parameters allow one to control costs of future calls to nc_redef(), nc_enddef() by requesting that minfree bytes be available at the end of the section.   The  h_minfree  parameter
              sets the pad at the end of the "header" section. The v_minfree parameter sets the pad at the end of the data section for fixed size variables.

              The  align  parameters allow one to set the alignment of the beginning of the corresponding sections. The beginning of the section is rounded up to an index which is a multiple of the align pa‐
              rameter. The flag value NC_ALIGN_CHUNK tells the library to use the chunksize (see above) as the align parameter.  The v_align parameter controls the alignment of the beginning of the data sec‐
              tion for fixed size variables.  The r_align parameter controls the alignment of the beginning of the data section for variables which have an unlimited dimension (record variables).

              The file format requires mod 4 alignment, so the align parameters are silently rounded up to multiples of 4. The usual call, nc_enddef(ncid) is equivalent to nc__enddef(ncid, 0, 4, 0, 4).

              The file format does not contain a "record size" value, this is calculated from the sizes of the record variables. This unfortunate fact prevents us from providing minfree and alignment control
              of the "records" in a netcdf file. If you add a variable which has an unlimited dimension, the third section will always be copied with the new variable added.

       int nc_sync(int ncid)

              (Corresponds to ncsync() in version 2)

              Unless the NC_SHARE bit is set in nc_open() or nc_create(), accesses to the underlying netCDF dataset are buffered by the library. This function synchronizes the state of the underlying dataset
              and the library.  This is done automatically by nc_close() and nc_enddef().

       int nc_abort(int ncid)

              (Corresponds to ncabort() in version 2)

              You  don't  need  to  call  this function.  This function is called automatically by nc_close() if the netCDF was in define mode and something goes wrong with the commit.  If the netCDF dataset
              isn't in define mode, then this function is equivalent to nc_close().  If it is called after nc_redef(), but before nc_enddef(), the new definitions are not committed and the dataset is closed.
              If it is called after nc_create() but before nc_enddef(), the dataset disappears.

       int nc_close(int ncid)

              (Corresponds to ncclose() in version 2)

              Closes an open netCDF dataset.  If the dataset is in define mode, nc_enddef() will be called before closing.  After a dataset is closed, its ID may be reassigned to another dataset.

       int nc_inq(int ncid, int* ndims, int* nvars, int* natts, int* unlimdimid)

       int nc_inq_ndims(int ncid, int* ndims)

       int nc_inq_nvars(int ncid, int* nvars)

       int nc_inq_natts(int ncid, int* natts)

       int nc_inq_unlimdim(int ncid, int* unlimdimid)

       int nc_inq_format(int ncid, int* formatn)

              Use these functions to find out what is in a netCDF dataset.  Upon successful return, ndims will contain  the number of dimensions defined for this netCDF dataset, nvars will contain the number
              of variables, natts will contain the number of attributes, and unlimdimid will contain the dimension ID of the unlimited dimension if one exists, or -1 otherwise.  formatn will contain the ver‐
              sion  number of the dataset <format>, one of NC_FORMAT_CLASSIC, NC_FORMAT_64BIT_OFFSET, NC_FORMAT_NETCDF4, or NC_FORMAT_NETCDF4_CLASSIC.  If any of the return parameters is a NULL pointer, then
              the corresponding information will not be returned; hence, no space need be allocated for it.

       int nc_def_dim(int ncid, const char name[], size_t len, int* dimid)

              (Corresponds to ncdimdef() in version 2)

              Adds a new dimension to an open netCDF dataset, which must be in define mode.  name is the dimension name.  If dimid is not a NULL pointer then upon successful completion dimid will contain the
              dimension ID of the newly created dimension.

USER DEFINED TYPES
       Users  many  define  types  for  a  netCDF-4/HDF5 file (unless the NC_CLASSIC_MODEL was used when the file was creates). Users may define compound types, variable length arrays, enumeration types, and
       opaque types.

       int nc_def_compound(int ncid, size_t size, const char name[], int* typeidp)

              Define a compound type.

       int nc_insert_compound(int ncid, nc_type , const char name[], size_t offset, nc_type field_typeid)

              Insert an element into a compound type. May not be done after type has been used, or after the type has been written by an enddef.

       int nc_insert_array_compound(int ncid, nc_type , const char name[], size_t offset, nc_type field_typeid, int ndims, const int dim_sizes[])

              Insert an array into a compound type.

       int nc_inq_type(int ncid, nc_type , char name[], size_t* sizep)

              Learn about a type.

       int nc_inq_compound(int ncid, nc_type , char name[], size_t* sizep, size_t* nfieldsp)

       int nc_inq_compound_name(int ncid, nc_type , char name[])

       int nc_inq_compound_size(int ncid, nc_type , size_t* sizep)

       int nc_inq_compound_nfields(int ncid, nc_type , size_t* nfieldsp)

       int nc_inq_compound_fieldname(int ncid, nc_type , int fieldid, char name[])

       int nc_inq_compound_fieldindex(int ncid, nc_type , const char name[], int* fieldidp)

       int nc_inq_compound_fieldoffset(int ncid, nc_type , int fieldid, size_t* offsetp)

       int nc_inq_compound_fieldtype(int ncid, nc_type , int fieldid, nc_type* field_typeid)

       int nc_inq_compound_fieldndims(int ncid, nc_type , int fieldid, int* ndims)

       int nc_inq_compound_fielddim_sizes(int ncid, nc_type , int fieldid, int dim_sizes[])

              Learn about a compound type.

       int nc_def_vlen(int ncid, const char name[], nc_type base_typeid, nc_type* xtypep)

              Create a variable length array type.

       int nc_inq_vlen(int ncid, nc_type , char name[], size_t* datum_sizep, nc_type* base_nc_typep)

              Learn about a variable length array type.

       int nc_free_vlen(nc_vlen_t *vl)

              Free memory consumed by reading data of a variable length array type.

       int nc_put_vlen_element(int ncid, nc_type , void * vlen_element, size_t len, void * data)

              Write one VLEN.

       int nc_get_vlen_element(int ncid, nc_type , void ** vlen_element, size_t len, void ** data)

              Read one VLEN.

       int nc_free_string(size_t len, char **data)

              Free memory consumed by reading data of a string type.

       int nc_inq_user_type(int ncid, nc_type , char name[], size_t* , nc_type* , size_t* , int* )

              Learn about a user define type.

       int nc_def_enum(int ncid, nc_type base_typeid, const char name[], nc_type* typeidp)

              Define an enumeration type.

       int nc_insert_enum(int ncid, nc_type base_typeid, const char name[], const void *value)

              Insert a name-value pair into enumeration type.

       int nc_inq_enum_member(int ncid, nc_type xtype, int idx, char name[], void *value)

       int nc_inq_enum_ident(int ncid, nc_type xtype, int idx, long long value, char identifier[])

              Learn about a name-value pair into enumeration type.

       int nc_def_opaque(int ncid, size_t size, const char name[], nc_type* xtypep)

              Create an opaque type.

       int nc_inq_opaque(int ncid, nc_type xtype, char name[], size_t* sizep)

              Learn about opaque type.

GROUPS
       Users may organize data into hierarchical groups in netCDF-4/HDF5 files (unless NC_CLASSIC_MODEL was used when creating the file).

       int nc_inq_grps(int ncid, int* numgrps, int ncids[])

              Learn how many groups (and their ncids) are available from the group represented by ncid.

       int nc_inq_grpname(int ncid, char name[])

       int nc_inq_grpname_full(int ncid, size_t* len, char name[])

       int nc_inq_grpname_len(int ncid, size_t* len)

       int nc_inq_grp_parent(int ncid, int* ncid)

       int nc_inq_grp_ncid(int ncid, char name[], int* ncid)

       int nc_inq_full_ncid(int ncid, char name[], int* ncid)

              Learn about a group.

       int nc_inq_varids(int ncid, int* nvars, int* )

              Get the varids in a group.

       int nc_inq_dimids(int ncid, int* ndims, int* dimids, int include_parents)

              Get the dimids in a group and (potentially) its parents.

       int nc_inq_typeids(int ncid, int* ntypes, int typeids[])

              Get the typeids of user-defined types in a group.

       int nc_def_grp(int ncid, char name[], int* ncid)

              Create a group.

DIMENSIONS
       int nc_inq_dimid(int ncid, const char name[], int* dimid)

              (Corresponds to ncdimid() in version 2)

              Given a dimension name, returns the ID of a netCDF dimension in dimid.

       int nc_inq_dim(int ncid, int dimid, char name[], size_t* len)

       int nc_inq_dimname(int ncid, int dimid, char name[])

       int nc_inq_dimlen(int ncid, int dimid, size_t* len)

              Use these functions to find out about a dimension.  If either the name argument or len argument is a NULL pointer, then the associated information will not be returned.  Otherwise, name  should
              be  big enough (NC_MAX_NAME) to hold the dimension name as the name will be copied into your storage.  The length return parameter, len will contain the size of the dimension.  For the unlimit‐
              ed dimension, the returned length is the current maximum value used for writing into any of the variables which use the dimension.

       int nc_rename_dim(int ncid, int dimid, const char name[])

              (Corresponds to ncdimrename() in version 2)

              Renames an existing dimension in an open netCDF dataset.  If the new name is longer than the old name, the netCDF dataset must be in define mode.  You cannot rename a dimension to have the same
              name as another dimension.

VARIABLES
       int nc_def_var(int ncid, const char name[], nc_type xtype, int ndims, const int dimids[], int* varid)

              (Corresponds to ncvardef() in version 2)

              Adds a new variable to a netCDF dataset. The netCDF must be in define mode.  If not NULL, then varid will be set to the netCDF variable ID.

       int nc_inq_varid(int ncid, const char name[], int* varid)

              (Corresponds to ncvarid() in version 2)

              Returns the ID of a netCDF variable in varid given its name.

       int nc_inq_var(int ncid, int varid, char name[], nc_type* xtype, int* ndims, int dimids[], int* natts)

       int nc_inq_varname(int ncid, int varid, char name[])

       int nc_inq_vartype(int ncid, int varid, nc_type* xtype)

       int nc_inq_varndims(int ncid, int varid, int* ndims)

       int nc_inq_vardimid(int ncid, int varid, int dimids[])

       int nc_inq_varnatts(int ncid, int varid, int* natts)

              Returns information about a netCDF variable, given its ID.  If any of the return parameters (name, xtype, ndims, dimids, or natts) is a NULL pointer, then the corresponding information will not
              be returned; hence, no space need be allocated for it.

       int nc_rename_var(int ncid, int varid, const char name[])

              (Corresponds to ncvarrename() in version 2)

              Changes the name of a netCDF variable.  If the new name is longer than the old name, the netCDF must be in define mode.  You cannot rename a variable to have the name of any existing variable.

VARIABLES in NETCDF-4 FILES
       The following functions may only be used on variables in a netCDF-4/HDF5 data file. These functions must be called after the variable is defined, but before an enddef call.

       int nc_def_var_deflate(int ncid, int varid, int shuffle, int deflate, int deflate_level)

       Turn on compression and/or shuffle filter. (Shuffle filter is only useful for integer data.)

       int nc_inq_var_deflate(int ncid, int varid, int* shufflep, int* deflatep, int* deflate_levelp)

              Learn about a variable's deflate settings.

       int nc_def_var_fletcher32(int ncid, int varid, int fletcher32)

              Turn on checksumming for a variable.

       int nc_inq_var_fletcher32(int ncid, int varid, int* fletcher32)

              Learn about checksumming for a variable.

       int nc_def_var_chunking(int ncid, int varid, int storage, const size_t chunksizesp[])

              Set chunksizes for a variable.

       int nc_inq_var_chunking(int ncid, int varid, int* storagep, size_t chunksizesp[])

              Learn about chunksizes for a variable.

       int nc_def_var_fill(int ncid, int varid, int no_fill, const size_t chunksizesp[])

              Set a fill value for a variable.

       int nc_inq_var_fill(int ncid, int varid, int* storagep, size_t chunksizesp[])

              Learn the fill value for a variable.

       int nc_def_var_endian(int ncid, int varid, int endian)

              Set endianness of variable.

       int nc_inq_var_endian(int ncid, int varid, int* endianp)

              Learn the endianness of a variable.

WRITING AND READING WHOLE VARIABLES
       int nc_put_var_text(int ncid, int varid, const char out[])

       int nc_put_var_uchar(int ncid, int varid, const unsigned char out[])

       int nc_put_var_schar(int ncid, int varid, const signed char out[])

       int nc_put_var_short(int ncid, int varid, const short out[])

       int nc_put_var_int(int ncid, int varid, const int out[])

       int nc_put_var_long(int ncid, int varid, const long out[])

       int nc_put_var_float(int ncid, int varid, const float out[])

       int nc_put_var_double(int ncid, int varid, const double out[])

       int nc_put_var_ubyte(int ncid, int varid, const unsigned char out[])

       int nc_put_var_ushort(int ncid, int varid, const unsigned short out[])

       int nc_put_var_uint(int ncid, int varid, const unsigned int out[])

       int nc_put_var_int64(int ncid, int varid, const long long out[])

       int nc_put_var_uint64(int ncid, int varid, const unsigned long long out[])

       int nc_put_var_string(int ncid, int varid, const char * out[])

              Writes an entire netCDF variable (i.e. all the values).  The netCDF dataset must be open and in data mode.  The type of the data is specified in the function name, and it is  converted  to  the
              external  type  of the specified variable, if possible, otherwise an NC_ERANGE error is returned. Note that rounding is not performed during the conversion. Floating point numbers are truncated
              when converted to integers.

       int nc_get_var_text(int ncid, int varid, char in[])

       int nc_get_var_uchar(int ncid, int varid, unsigned char in[])

       int nc_get_var_schar(int ncid, int varid, signed char in[])

       int nc_get_var_short(int ncid, int varid, short in[])

       int nc_get_var_int(int ncid, int varid, int in[])

       int nc_get_var_long(int ncid, int varid, long in[])

       int nc_get_var_float(int ncid, int varid, float in[])

       int nc_get_var_double(int ncid, int varid, double in[])

       int nc_get_var_ubyte(int ncid, int varid, unsigned char in[])

       int nc_get_var_ushort(int ncid, int varid, unsigned short in[])

       int nc_get_var_uint(int ncid, int varid, unsigned int in[])

       int nc_get_var_int64(int ncid, int varid, long long in[])

       int nc_get_var_uint64(int ncid, int varid, unsigned long long in[])

       int nc_get_var_string(int ncid, int varid, char * in[])

              Reads an entire netCDF variable (i.e. all the values).  The netCDF dataset must be open and in data mode.  The data is converted from the external type of the specified variable, if  necessary,
              to the type specified in the function name.  If conversion is not possible, an NC_ERANGE error is returned.

WRITING AND READING ONE DATUM
       int nc_put_var1_text(int ncid, int varid, const size_t index[], char *out)

       int nc_put_var1_uchar(int ncid, int varid, const size_t index[], unsigned char *out)

       int nc_put_var1_schar(int ncid, int varid, const size_t index[], signed char *out)

       int nc_put_var1_short(int ncid, int varid, const size_t index[], short *out)

       int nc_put_var1_int(int ncid, int varid, const size_t index[], int *out)

       int nc_put_var1_long(int ncid, int varid, const size_t index[], long *out)

       int nc_put_var1_float(int ncid, int varid, const size_t index[], float *out)

       int nc_put_var1_double(int ncid, int varid, const size_t index[], double *out)

       int nc_put_var1_ubyte(int ncid, int varid, const size_t index[], unsigned char *out)

       int nc_put_var1_ushort(int ncid, int varid, const size_t index[], unsigned short *out)

       int nc_put_var1_uint(int ncid, int varid, const size_t index[], unsigned int *out)

       int nc_put_var1_int64(int ncid, int varid, const size_t index[], long long *out)

       int nc_put_var1_uint64(int ncid, int varid, const size_t index[], unsigned long long *out)

       int nc_put_var1_string(int ncid, int varid, const size_t index[], char * *out)

              Puts  a  single  data value into a variable at the position index of an open netCDF dataset that is in data mode.  The type of the data is specified in the function name, and it is converted to
              the external type of the specified variable, if possible, otherwise an NC_ERANGE error is returned.

       int nc_get_var1_text(int ncid, int varid, const size_t index[], char* in)

       int nc_get_var1_uchar(int ncid, int varid, const size_t index[], unsigned char* in)

       int nc_get_var1_schar(int ncid, int varid, const size_t index[], signed char* in)

       int nc_get_var1_short(int ncid, int varid, const size_t index[], short* in)

       int nc_get_var1_int(int ncid, int varid, const size_t index[], int* in)

       int nc_get_var1_long(int ncid, int varid, const size_t index[], long* in)

       int nc_get_var1_float(int ncid, int varid, const size_t index[], float* in)

       int nc_get_var1_double(int ncid, int varid, const size_t index[], double* in)

       int nc_get_var1_ubyte(int ncid, int varid, const size_t index[], unsigned char* in)

       int nc_get_var1_ushort(int ncid, int varid, const size_t index[], unsigned short* in)

       int nc_get_var1_uint(int ncid, int varid, const size_t index[], unsigned int* in)

       int nc_get_var1_int64(int ncid, int varid, const size_t index[], long long* in)

       int nc_get_var1_uint64(int ncid, int varid, const size_t index[], unsigned long long* in)

       int nc_get_var1_string(int ncid, int varid, const size_t index[], char ** in)

              Gets a single data value from a variable at the position index of an open netCDF dataset that is in data mode.  The data is converted from the external type of the specified variable, if neces‐
              sary, to the type specified in the function name.  If conversion is not possible, an NC_ERANGE error is returned.

WRITING AND READING AN ARRAY
       int nc_put_vara_text(int ncid, int varid, const size_t start[], const size_t count[], const char out[])

       int nc_put_vara_uchar(int ncid, int varid, const size_t start[], const size_t count[], const unsigned char out[])

       int nc_put_vara_schar(int ncid, int varid, const size_t start[], const size_t count[], const signed char out[])

       int nc_put_vara_short(int ncid, int varid, const size_t start[], const size_t count[], const short out[])

       int nc_put_vara_int(int ncid, int varid, const size_t start[], const size_t count[], const int out[])

       int nc_put_vara_long(int ncid, int varid, const size_t start[], const size_t count[], const long out[])

       int nc_put_vara_float(int ncid, int varid, const size_t start[], const size_t count[], const float out[])

       int nc_put_vara_double(int ncid, int varid, const size_t start[], const size_t count[], const double out[])

       int nc_put_vara_ubyte(int ncid, int varid, const size_t start[], const size_t count[], const unsigned char out[])

       int nc_put_vara_ushort(int ncid, int varid, const size_t start[], const size_t count[], const unsigned short out[])

       int nc_put_vara_uint(int ncid, int varid, const size_t start[], const size_t count[], const unsigned int out[])

       int nc_put_vara_int64(int ncid, int varid, const size_t start[], const size_t count[], const long long out[])

       int nc_put_vara_uint64(int ncid, int varid, const size_t start[], const size_t count[], const unsigned long long out[])

       int nc_put_vara_string(int ncid, int varid, const size_t start[], const size_t count[], const char * out[])

              Writes  an  array  section of values into a netCDF variable of an open netCDF dataset, which must be in data mode.  The array section is specified by the start and count vectors, which give the
              starting index and count of values along each dimension of the specified variable.  The type of the data is specified in the function name and is converted to the external type of the specified
              variable, if possible, otherwise an NC_ERANGE error is returned.

       int nc_get_vara_text(int ncid, int varid, const size_t start[], const size_t count[], char in[])

       int nc_get_vara_uchar(int ncid, int varid, const size_t start[], const size_t count[], unsigned char in[])

       int nc_get_vara_schar(int ncid, int varid, const size_t start[], const size_t count[], signed char in[])

       int nc_get_vara_short(int ncid, int varid, const size_t start[], const size_t count[], short in[])

       int nc_get_vara_int(int ncid, int varid, const size_t start[], const size_t count[], int in[])

       int nc_get_vara_long(int ncid, int varid, const size_t start[], const size_t count[], long in[])

       int nc_get_vara_float(int ncid, int varid, const size_t start[], const size_t count[], float in[])

       int nc_get_vara_double(int ncid, int varid, const size_t start[], const size_t count[], double in[])

       int nc_get_vara_ubyte(int ncid, int varid, const size_t start[], const size_t count[], unsigned char in[])

       int nc_get_vara_ushort(int ncid, int varid, const size_t start[], const size_t count[], unsigned short in[])

       int nc_get_vara_uint(int ncid, int varid, const size_t start[], const size_t count[], unsigned int in[])

       int nc_get_vara_int64(int ncid, int varid, const size_t start[], const size_t count[], long long in[])

       int nc_get_vara_uint64(int ncid, int varid, const size_t start[], const size_t count[], unsigned long long in[])

       int nc_get_vara_string(int ncid, int varid, const size_t start[], const size_t count[], char * in[])

              Reads  an  array  section  of values from a netCDF variable of an open netCDF dataset, which must be in data mode.  The array section is specified by the start and count vectors, which give the
              starting index and count of values along each dimension of the specified variable.  The data is converted from the external type of the specified variable, if necessary, to the  type  specified
              in the function name.  If conversion is not possible, an NC_ERANGE error is returned.

WRITING AND READING A SLICED ARRAY
       int nc_put_vars_text(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const char out[])

       int nc_put_vars_uchar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const unsigned char out[])

       int nc_put_vars_schar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const signed char out[])

       int nc_put_vars_short(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const short out[])

       int nc_put_vars_int(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const int out[])

       int nc_put_vars_long(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const long out[])

       int nc_put_vars_float(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const float out[])

       int nc_put_vars_double(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const double out[])

       int nc_put_vars_ubyte(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const unsigned char out[])

       int nc_put_vars_ushort(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const unsigned short out[])

       int nc_put_vars_uint(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const unsigned int out[])

       int nc_put_vars_int64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const long long out[])

       int nc_put_vars_uint64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const unsigned long long out[])

       int nc_put_vars_string(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], const char * out[])

              These functions are used for strided output, which is like the array section output described above, except that the sampling stride (the interval between accessed values) is specified for each
              dimension.  For an explanation of the sampling stride vector, see COMMON ARGUMENTS DESCRIPTIONS below.

       int nc_get_vars_text(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], char in[])

       int nc_get_vars_uchar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], unsigned char in[])

       int nc_get_vars_schar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], signed char in[])

       int nc_get_vars_short(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], short in[])

       int nc_get_vars_int(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], int in[])

       int nc_get_vars_long(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], long in[])

       int nc_get_vars_float(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], float in[])

       int nc_get_vars_double(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], double in[])

       int nc_get_vars_ubyte(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], unsigned char in[])

       int nc_get_vars_ushort(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], unsigned short in[])

       int nc_get_vars_uint(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], unsigned int in[])

       int nc_get_vars_int64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], long long in[])

       int nc_get_vars_uint64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], unsigned long long in[])

       int nc_get_vars_string(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], char * in[])

              These functions are used for strided input, which is like the array section input described above, except that the sampling stride (the interval between accessed values) is specified  for  each
              dimension.  For an explanation of the sampling stride vector, see COMMON ARGUMENTS DESCRIPTIONS below.

WRITING AND READING A MAPPED ARRAY
       int nc_put_varm_text(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const char out[])

       int nc_put_varm_uchar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const unsigned char out[])

       int nc_put_varm_schar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const signed char out[])

       int nc_put_varm_short(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const short out[])

       int nc_put_varm_int(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const int out[])

       int nc_put_varm_long(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const long out[])

       int nc_put_varm_float(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const float out[])

       int nc_put_varm_double(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const double out[])

       int nc_put_varm_ubyte(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const unsigned char out[])

       int nc_put_varm_ushort(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const unsigned short out[])

       int nc_put_varm_uint(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const unsigned int out[])

       int nc_put_varm_int64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const long long out[])

       int nc_put_varm_uint64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const unsigned long long out[])

       int nc_put_varm_string(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, const char * out[])

              These  functions are used for mapped output, which is like strided output described above, except that an additional index mapping vector is provided to specify the in-memory arrangement of the
              data values.  For an explanation of the index mapping vector, see COMMON ARGUMENTS DESCRIPTIONS below.

       int nc_get_varm_text(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, char in[])

       int nc_get_varm_uchar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, unsigned char in[])

       int nc_get_varm_schar(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, signed char in[])

       int nc_get_varm_short(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, short in[])

       int nc_get_varm_int(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, int in[])

       int nc_get_varm_long(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, long in[])

       int nc_get_varm_float(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, float in[])

       int nc_get_varm_double(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, double in[])

       int nc_get_varm_ubyte(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, unsigned char in[])

       int nc_get_varm_ushort(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, unsigned short in[])

       int nc_get_varm_uint(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, unsigned int in[])

       int nc_get_varm_int64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, long long in[])

       int nc_get_varm_uint64(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, unsigned long long in[])

       int nc_get_varm_string(int ncid, int varid, const size_t start[], const size_t count[], const size_t stride[], imap, char * in[])

              These functions are used for mapped input, which is like strided input described above, except that an additional index mapping vector is provided to specify the in-memory  arrangement  of  the
              data values.  For an explanation of the index mapping vector, see COMMON ARGUMENTS DESCRIPTIONS below.

ATTRIBUTES
       int nc_put_att_text(int ncid, int varid, const char name[], nc_type xtype, size_t len, const char out[])

       int nc_put_att_uchar(int ncid, int varid, const char name[], nc_type xtype, size_t len, const unsigned char out[])

       int nc_put_att_schar(int ncid, int varid, const char name[], nc_type xtype, size_t len, const signed char out[])

       int nc_put_att_short(int ncid, int varid, const char name[], nc_type xtype, size_t len, const short out[])

       int nc_put_att_int(int ncid, int varid, const char name[], nc_type xtype, size_t len, const int out[])

       int nc_put_att_long(int ncid, int varid, const char name[], nc_type xtype, size_t len, const long out[])

       int nc_put_att_float(int ncid, int varid, const char name[], nc_type xtype, size_t len, const float out[])

       int nc_put_att_double(int ncid, int varid, const char name[], nc_type xtype, size_t len, const double out[])

       int nc_put_att_ubyte(int ncid, int varid, const char name[], nc_type xtype, size_t len, const unsigned char out[])

       int nc_put_att_ushort(int ncid, int varid, const char name[], nc_type xtype, size_t len, const unsigned short out[])

       int nc_put_att_uint(int ncid, int varid, const char name[], nc_type xtype, size_t len, const unsigned int out[])

       int nc_put_att_int64(int ncid, int varid, const char name[], nc_type xtype, size_t len, const long long out[])

       int nc_put_att_uint64(int ncid, int varid, const char name[], nc_type xtype, size_t len, const unsigned long long out[])

       int nc_put_att_string(int ncid, int varid, const char name[], nc_type xtype, size_t len, const char * out[])

       int nc_put_att(int ncid, int varid, const char name[], nc_type xtype, size_t len, void * ip)

       int nc_get_att(int ncid, int varid, const char name[], void ** ip)

              Unlike  variables,  attributes do not have separate functions for defining and writing values.  This family of functions defines a new attribute with a value or changes the value of an existing
              attribute.  If the attribute is new, or if the space required to store the attribute value is greater than before, the netCDF dataset must be in define mode.  The parameter len is the number of
              values from out to transfer.  It is often one, except that for nc_put_att_text() it will usually be strlen(out).

              For  these  functions,  the  type  component  of  the  function name refers to the in-memory type of the value, whereas the xtype argument refers to the external type for storing the value.  An
              NC_ERANGE error results if a conversion between these types is not possible.  In this case the value is represented with the appropriate fill-value for the associated external type.

       int nc_inq_attname(int ncid, int varid, int attnum, char name[])

              Gets the name of an attribute, given its variable ID and attribute number.  This function is useful in generic applications that need to get the names of all the attributes  associated  with  a
              variable,  since  attributes are accessed by name rather than number in all other attribute functions.  The number of an attribute is more volatile than the name, since it can change when other
              attributes of the same variable are deleted.  The attributes for each variable are numbered from 0 (the first attribute) to nvatts-1, where nvatts is the number of attributes for the  variable,
              as returned from a call to nc_inq_varnatts().  If the name parameter is a NULL pointer, no name will be returned and no space need be allocated.

       int nc_inq_att(int ncid, int varid, const char name[], nc_type* xtype, size_t* len)

       int nc_inq_attid(int ncid, int varid, const char name[], int* attnum)

       int nc_inq_atttype(int ncid, int varid, const char name[], nc_type* xtype)

       int nc_inq_attlen(int ncid, int varid, const char name[], size_t* len)

              These  functions return information about a netCDF attribute, given its variable ID and name.  The information returned is the external type in xtype and the number of elements in the attribute
              as len.  If any of the return arguments is a NULL pointer, the specified information will not be returned.

       int nc_copy_att(int ncid, int varid_in, const char name[], int ncid_out, int varid_out)

              Copies an attribute from one netCDF dataset to another.  It can also be used to copy an attribute from one variable to another within the same netCDF.  ncid_in is the  netCDF  ID  of  an  input
              netCDF dataset from which the attribute will be copied.  varid_in is the ID of the variable in the input netCDF dataset from which the attribute will be copied, or NC_GLOBAL for a global attri‐
              bute.  name is the name of the attribute in the input netCDF dataset to be copied.  ncid_out is the netCDF ID of the output netCDF dataset to which the attribute will be copied.  It is  permis‐
              sible  for  the input and output netCDF ID's to be the same.  The output netCDF dataset should be in define mode if the attribute to be copied does not already exist for the target variable, or
              if it would cause an existing target attribute to grow.  varid_out is the ID of the variable in the output netCDF dataset to which the attribute will be copied, or NC_GLOBAL to copy to a global
              attribute.

       int nc_rename_att(int ncid, int varid, const char name[], const char newname[])

              Changes  the  name of an attribute.  If the new name is longer than the original name, the netCDF must be in define mode.  You cannot rename an attribute to have the same name as another attri‐
              bute of the same variable.  name is the original attribute name.  newname is the new name to be assigned to the specified attribute.  If the new name is longer than the  old  name,  the  netCDF
              dataset must be in define mode.

       int nc_del_att(int ncid, int varid, const char name[])

              Deletes an attribute from a netCDF dataset.  The dataset must be in define mode.

       int nc_get_att_text(int ncid, int varid, const char name[], char in[])

       int nc_get_att_uchar(int ncid, int varid, const char name[], unsigned char in[])

       int nc_get_att_schar(int ncid, int varid, const char name[], signed char in[])

       int nc_get_att_short(int ncid, int varid, const char name[], short in[])

       int nc_get_att_int(int ncid, int varid, const char name[], int in[])

       int nc_get_att_long(int ncid, int varid, const char name[], long in[])

       int nc_get_att_float(int ncid, int varid, const char name[], float in[])

       int nc_get_att_double(int ncid, int varid, const char name[], double in[])

       int nc_get_att_ubyte(int ncid, int varid, const char name[], unsigned char in[])

       int nc_get_att_ushort(int ncid, int varid, const char name[], unsigned short in[])

       int nc_get_att_uint(int ncid, int varid, const char name[], unsigned int in[])

       int nc_get_att_int64(int ncid, int varid, const char name[], long long in[])

       int nc_get_att_uint64(int ncid, int varid, const char name[], unsigned long long in[])

       int nc_get_att_string(int ncid, int varid, const char name[], char * in[])

              Gets the value(s) of a netCDF attribute, given its variable ID and name.  Converts from the external type to the type specified in the function name, if possible, otherwise returns an NC_ERANGE
              error.  All elements of the vector of attribute values are returned, so you must allocate enough space to hold them.  If you don't know how much space to reserve, call nc_inq_attlen() first  to
              find out the length of the attribute.

COMMON ARGUMENT DESCRIPTIONS
       In this section we define some common arguments which are used in the "FUNCTION DESCRIPTIONS" section.

       int ncid
              is the netCDF ID returned from a previous, successful call to nc_open() or nc_create()

       char name[]
              is the name of a dimension, variable, or attribute. The names of dimensions, variables and attributes consist of arbitrary sequences of alphanumeric characters (as well as underscore '_', peri‐
              od '.' and hyphen '-'), beginning with a letter or underscore. (However names commencing with underscore are reserved for system use.) Case is significant in netCDF names. A zero-length name is
              not  allowed.   As an input argument, it shall be a pointer to a 0-terminated string; as an output argument, it shall be the address of a buffer in which to hold such a string.  The maximum al‐
              lowable number of characters (excluding the terminating 0) is NC_MAX_NAME.

       nc_type xtype
              specifies the external data type of a netCDF variable or attribute and is one of the following: NC_BYTE, NC_CHAR, NC_SHORT, NC_INT, NC_FLOAT, or NC_DOUBLE.  These are used to specify 8-bit  in‐
              tegers,  characters, 16-bit integers, 32-bit integers, 32-bit IEEE floating point numbers, and 64-bit IEEE floating-point numbers, respectively.  (NC_INT corresponds to NC_LONG in version 2, to
              specify a 32-bit integer).

       int dimids[]
              is a vector of dimension ID's and defines the shape of a netCDF variable.  The size of the vector shall be greater than or equal to the rank (i.e. the number  of  dimensions)  of  the  variable
              (ndims).   The vector shall be ordered by the speed with which a dimension varies: dimids[ndims-1] shall be the dimension ID of the most rapidly varying dimension and dimids[0] shall be the di‐
              mension ID of the most slowly varying dimension.  The maximum possible number of dimensions for a variable is given by the symbolic constant NC_MAX_VAR_DIMS.

       int dimid
              is the ID of a netCDF dimension.  netCDF dimension ID's are allocated sequentially from the non-negative integers beginning with 0.

       int ndims
              is either the total number of dimensions in a netCDF dataset or the rank (i.e. the number of dimensions) of a netCDF variable.  The value shall not be negative or greater than the symbolic con‐
              stant NC_MAX_VAR_DIMS.

       int varid
              is the ID of a netCDF variable or (for the attribute-access functions) the symbolic constant NC_GLOBAL, which is used to reference global attributes.  netCDF variable ID's are allocated sequen‐
              tially from the non-negative integers beginning with 0.

       int* natts
              is the number of global attributes in a netCDF dataset  for the nc_inquire() function or the number of attributes associated with a netCDF variable for the nc_varinq() function.

       const size_t index[]
              specifies the indicial coordinates of the netCDF data value to be accessed.  The indices start at 0; thus, for example, the first data value of a two-dimensional variable is (0,0).  The size of
              the vector shall be at least the rank of the associated netCDF variable and its elements shall correspond, in order, to the variable's dimensions.

       const size_t start[]
              specifies the starting point for accessing a netCDF variable's data values in terms of the indicial coordinates of the corner of the array section.  The indices start at 0; thus, the first data
              value of a variable is (0, 0, ..., 0).  The size of the vector shall be at least the rank of the associated netCDF variable and its elements shall correspond, in order, to the variable's dimen‐
              sions.

       const size_t count[]
              specifies  the  number of indices selected along each dimension of the array section.  Thus, to access a single value, for example, specify count as (1, 1, ..., 1).  Note that, for strided I/O,
              this argument must be adjusted to be compatible with the stride and start arguments so that the interaction of the three does not attempt to access an invalid data co-ordinate.  The elements of
              the count vector correspond, in order, to the variable's dimensions.

       const size_t stride[]
              specifies  the sampling interval along each dimension of the netCDF variable.   The elements of the stride vector correspond, in order, to the netCDF variable's dimensions (stride[0]) gives the
              sampling interval along the most slowly varying dimension of the netCDF variable).  Sampling intervals are specified in type-independent units of elements (a value of 1 selects consecutive ele‐
              ments of the netCDF variable along the corresponding dimension, a value of 2 selects every other element, etc.).  A NULL stride argument is treated as (1, 1, ... , 1).

       imap   specifies  the mapping between the dimensions of a netCDF variable and the in-memory structure of the internal data array.  The elements of the index mapping vector correspond, in order, to the
              netCDF variable's dimensions (imap[0] gives the distance between elements of the internal array corresponding to the most slowly varying dimension of the netCDF  variable).   Distances  between
              elements  are  specified  in type-independent units of elements (the distance between internal elements that occupy adjacent memory locations is 1 and not the element's byte-length as in netCDF
              2).  A NULL pointer means the memory-resident values have the same structure as the associated netCDF variable.

VARIABLE PREFILLING
       By default, the netCDF interface sets the values of all newly-defined variables of finite length (i.e. those that do not have an unlimited, dimension) to the type-dependent fill-value associated  with
       each  variable.   This is done when nc_enddef() is called.  The fill-value for a variable may be changed from the default value by defining the attribute `_FillValue' for the variable.  This attribute
       must have the same type as the variable and be of length one.

       Variables with an unlimited dimension are also prefilled, but on an `as needed' basis.  For example, if the first write of such a variable is to position 5, then positions 0 through 4 (and no  others)
       would be set to the fill-value at the same time.

       This  default  prefilling  of  data values may be disabled by or'ing the NC_NOFILL flag into the mode parameter of nc_open() or nc_create(), or, by calling the function nc_set_fill() with the argument
       NC_NOFILL.  For variables that do not use the unlimited dimension, this call must be made before nc_enddef().  For variables that use the unlimited dimension, this call may be made at any time.

       One can obtain increased performance of the netCDF interface by using this feature, but only at the expense of requiring the application to set every single data value.  The performance enhancing  be‐
       havior of this function is dependent on the particulars of the implementation and dataset format.  The flag value controlled by nc_set_fill() is per netCDF ID, not per variable or per write.  Allowing
       this to change affects the degree to which a program can be effectively parallelized.  Given all of this, we state that the use of this feature may not be available (or even needed) in future  releas‐
       es. Programmers are cautioned against heavy reliance upon this feature.

       int nc_setfill(int ncid, int fillmode, int* old_fillemode)

              (Corresponds to ncsetfill() in version 2)

              Determines  whether  or  not  variable prefilling will be done (see above).  The netCDF dataset shall be writable.  fillmode is either NC_FILL to enable prefilling (the default) or NC_NOFILL to
              disable prefilling.  This function returns the previous setting in old_fillmode.

MPP FUNCTION DESCRIPTIONS
       These functions were used on archaic SGI/Cray MPP machines. These functions are retained for backward compatibility; the PE arguments must all be set to zero.

       int nc__create_mp(const char path[], int cmode, size_t initialsize, int pe, size_t* chunksize, int* ncid)

              Like nc__create().

              The argument pe must be zero.

       int nc__open_mp(const char path[], int mode, int pe, size_t* chunksize, int* ncid)

              Like nc__open().  The argument pe must be zero.

       int nc_inq_base_pe(int ncid, int* pe)

              Always returns pe of zero.

       int nc_set_base_pe(int ncid, int pe)

              This function does nothing.

ENVIRONMENT VARIABLES
       NETCDF_FFIOSPEC
           Specifies the Flexible File I/O buffers for netCDF I/O when executing under the UNICOS operating system (the variable is ignored on other operating  systems).   An  appropriate  specification  can
           greatly  increase the efficiency of netCDF I/O -- to the extent that it can actually surpass FORTRAN binary I/O.  This environment variable has been made a little more generalized, such that other
           FFIO option specifications can now be added.  The default specification is bufa:336:2, unless a current FFIO specification is in operation, which will be honored.  See UNICOS Flexible File I/O for
           more information.

MAILING-LISTS
       Both  a mailing list and a digest are available for discussion of the netCDF interface and announcements about netCDF bugs, fixes, and enhancements.  To begin or change your subscription to either the
       mailing-list or the digest, send one of the following in the body (not the subject line) of an email message to "majordomo@unidata.ucar.edu".  Use your email address in place of jdoe@host.inst.domain.

       To subscribe to the netCDF mailing list:
              subscribe netcdfgroup jdoe@host.inst.domain
       To unsubscribe from the netCDF mailing list:
              unsubscribe netcdfgroup jdoe@host.inst.domain
       To subscribe to the netCDF digest:
              subscribe netcdfdigest jdoe@host.inst.domain
       To unsubscribe from the netCDF digest:
              unsubscribe netcdfdigest jdoe@host.inst.domain
       To retrieve the general introductory information for the mailing list:
              info netcdfgroup
       To get a synopsis of other majordomo commands:
              help

SEE ALSO
       ncdump(1), ncgen(1), netcdf(3).

       netCDF User's Guide, published by the Unidata Program Center, University Corporation for Atmospheric Research, located in Boulder, Colorado.

       NetCDF home page at http:/www.unidata.ucar.edu/netcdf.

Printed: 2022-01-16                                                                                1997-04-18                                                                                         NETCDF(3)
