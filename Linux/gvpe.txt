GVPE.PROTOCOL(7)                                                                        GNU Virtual Private Ethernet                                                                       GVPE.PROTOCOL(7)

The GNU-VPE Protocols
Overview
       GVPE can make use of a number of protocols. One of them is the GNU VPE protocol which is used to authenticate tunnels and send encrypted data packets. This protocol is described in more detail the
       second part of this document.

       The first part of this document describes the transport protocols which are used by GVPE to send its data packets over the network.

PART 1: Transport protocols
       GVPE offers a wide range of transport protocols that can be used to interchange data between nodes. Protocols differ in their overhead, speed, reliability, and robustness.

       The following sections describe each transport protocol in more detail. They are sorted by overhead/efficiency, the most efficient transport is listed first:

   RAW IP
       This protocol is the best choice, performance-wise, as the minimum overhead per packet is only 38 bytes.

       It works by sending the VPN payload using raw IP frames (using the protocol set by ip-proto).

       Using raw IP frames has the drawback that many firewalls block "unknown" protocols, so this transport only works if you have full IP connectivity between nodes.

   ICMP
       This protocol offers very low overhead (minimum 42 bytes), and can sometimes tunnel through firewalls when other protocols can not.

       It works by prepending an ICMP header with type icmp-type and a code of 255. The default icmp-type is echo-reply, so the resulting packets look like echo replies, which looks rather strange to
       network administrators.

       This transport should only be used if other transports (i.e. raw IP) are not available or undesirable (due to their overhead).

   UDP
       This is a good general choice for the transport protocol as UDP packets tunnel well through most firewalls and routers, and the overhead per packet is moderate (minimum 58 bytes).

       It should be used if RAW IP is not available.

   TCP
       This protocol is a very bad choice, as it not only has high overhead (more than 60 bytes), but the transport also retries on its own, which leads to congestion when the link has moderate packet
       loss (as both the TCP transport and the tunneled traffic will retry, increasing congestion more and more). It also has high latency and is quite inefficient.

       It's only useful when tunneling through firewalls that block better protocols. If a node doesn't have direct internet access but a HTTP proxy that supports the CONNECT method it can be used to
       tunnel through a web proxy. For this to work, the tcp-port should be 443 (https), as most proxies do not allow connections to other ports.

       It is an abuse of the usage a proxy was designed for, so make sure you are allowed to use it for GVPE.

       This protocol also has server and client sides. If the tcp-port is set to zero, other nodes cannot connect to this node directly. If the tcp-port is non-zero, the node can act both as a client as
       well as a server.

   DNS
       WARNING: Parsing and generating DNS packets is rather tricky. The code almost certainly contains buffer overflows and other, likely exploitable, bugs. You have been warned.

       This is the worst choice of transport protocol with respect to overhead (overhead can be 2-3 times higher than the transferred data), and latency (which can be many seconds). Some DNS servers
       might not be prepared to handle the traffic and drop or corrupt packets. The client also has to constantly poll the server for data, so the client will constantly create traffic even if it doesn't
       need to transport packets.

       In addition, the same problems as the TCP transport also plague this protocol.

       Its only use is to tunnel through firewalls that do not allow direct internet access. Similar to using a HTTP proxy (as the TCP transport does), it uses a local DNS server/forwarder (given by the
       dns-forw-host configuration value) as a proxy to send and receive data as a client, and an NS record pointing to the GVPE server (as given by the dns-hostname directive).

       The only good side of this protocol is that it can tunnel through most firewalls mostly undetected, iff the local DNS server/forwarder is sane (which is true for most routers, wireless LAN
       gateways and nameservers).

       Fine-tuning needs to be done by editing src/vpn_dns.C directly.

PART 2: The GNU VPE protocol
       This section, unfortunately, is not yet finished, although the protocol is stable (until bugs in the cryptography are found, which will likely completely change the following description).
       Nevertheless, it should give you some overview over the protocol.

   Anatomy of a VPN packet
       The exact layout and field lengths of a VPN packet is determined at compile time and doesn't change. The same structure is used for all transport protocols, be it RAWIP or TCP.

        +------+------+--------+------+
        | HMAC | TYPE | SRCDST | DATA |
        +------+------+--------+------+

       The HMAC field is present in all packets, even if not used (e.g. in auth request packets), in which case it is set to all zeroes. The MAC itself is calculated over the TYPE, SRCDST and DATA fields
       in all cases.

       The TYPE field is a single byte and determines the purpose of the packet (e.g. RESET, COMPRESSED/UNCOMPRESSED DATA, PING, AUTH REQUEST/RESPONSE, CONNECT REQUEST/INFO etc.).

       SRCDST is a three byte field which contains the source and destination node IDs (12 bits each).

       The DATA portion differs between each packet type, naturally, and is the only part that can be encrypted. Data packets contain more fields, as shown:

        +------+------+--------+-------+------+
        | HMAC | TYPE | SRCDST | SEQNO | DATA |
        +------+------+--------+-------+------+

       SEQNO is a 32-bit sequence number. It is negotiated at every connection initialization and starts at some random 31 bit value. GVPE currently uses a sliding window of 512 packets/sequence numbers
       to detect reordering, duplication and replay attacks.

       The encryption is done on SEQNO+DATA in CTR mode with IV generated from the seqno (for AES: seqno || seqno || seqno || (u32)0), which ensures uniqueness for a given key.

   The authentication/key exchange protocol
       Before nodes can exchange packets, they need to establish authenticity of the other side and a key. Every node has a private RSA key and the public RSA keys of all other nodes.

       When a node wants to establish a connection to another node, it sends an RSA-OEAP-encrypted challenge and an ECDH (curve25519) key. The other node replies with its own ECDH key and a HKDF of the
       challenge and both ECDH keys to prove its identity.

       The remote node enganges in exactly the same protocol. When both nodes have exchanged their challenge and verified the response, they calculate a cipher key and a HMAC key and start exchanging
       data packets.

       In detail, the challenge consist of:

         RSA-OAEP (SEQNO MAC CIPHER SALT EXTRA-AUTH) ECDH1

       That is, it encrypts (with the public key of the remote node) an initial sequence number for data packets, key material for the HMAC key, key material for the cipher key, a salt used by the HKDF
       (as shown later) and some extra random bytes that are unused except for authentication. It also sends the public key of a curve25519 exchange.

       The remote node decrypts the RSA data, generates its own ECDH key (ECDH2), and replies with:

         HKDF-Expand (HKDF-Extract (ECDH2, RSA), ECDH1, AUTH_DIGEST_SIZE) ECDH2

       That is, it extracts from the decrypted RSA challenge, using its ECDH key as salt, and then expands using the requesting node's ECDH1 key. The resulting hash is returned as a proof that the node
       could decrypt the RSA challenge data, together with the ECDH key.

       After both nodes have done this to each other, they calculate the shared ECDH secret, cipher and HMAC keys for the session (each node generates two cipher and HMAC keys, one for sending and one
       for receiving).

       The HMAC key for sending is generated as follow:

          HMAC_KEY = HKDF-Expand (HKDF-Extract (REMOTE_SALT, MAC ECDH_SECRET), info, HMAC_MD_SIZE)

       It extracts from MAC and ECDH_SECRET using the remote SALT, then expands using a static info string.

       The cipher key is generated in the same way, except using the CIPHER part of the original challenge.

       The result of this process is to authenticate each node to the other node, while exchanging keys using both RSA and ECDH, the latter providing perfect forward secrecy.

       The protocol has been overdesigned where this was possible without increasing implementation complexity, in an attempt to protect against implementation or protocol failures. For example, if the
       ECDH challenge was found to be flawed, perfect forward secrecy would be lost, but the data would likely still be protected. Likewise, standard algorithms and implementations are used where
       possible.

   Retrying
       When there is no response to an auth request, the node will send auth requests in bursts with an exponential back-off. After some time it will resort to PING packets, which are very small (8 bytes
       + protocol header) and lightweight (no RSA operations required). A node that receives ping requests from an unconnected peer will respond by trying to create a connection.

       In addition to the exponential back-off, there is a global rate-limit on a per-IP base. It allows long bursts but will limit total packet rate to something like one control packet every ten
       seconds, to avoid accidental floods due to protocol problems (like a RSA key file mismatch between two nodes).

       The intervals between retries are limited by the max-retry configuration value. A node with connect = always will always retry, a node with connect = ondemand will only try (and re-try) to connect
       as long as there are packets in the queue, usually this limits the retry period to max-ttl seconds.

       Sending packets over the VPN will reset the retry intervals as well, which means as long as somebody is trying to send packets to a given node, GVPE will try to connect every few seconds.

   Routing and Protocol translation
       The GVPE routing algorithm is easy: there isn't much routing to speak of: When routing packets to another node, GVPE tries the following options, in order:

       If the two nodes should be able to reach each other directly (common protocol, port known), then GVPE will send the packet directly to the other node.
       If this isn't possible (e.g. because the node doesn't have a hostname or known port), but the nodes speak a common protocol and a router is available, then GVPE will ask a router to "mediate"
       between both nodes (see below).
       If a direct connection isn't possible (no common protocols) or forbidden (deny-direct) and there are any routers, then GVPE will try to send packets to the router with the highest priority that is
       connected already and is able (as specified by the config file) to connect directly to the target node.
       If no such router exists, then GVPE will simply send the packet to the node with the highest priority available.
       Failing all that, the packet will be dropped.

       A host can usually declare itself unreachable directly by setting its port number(s) to zero. It can declare other hosts as unreachable by using a config-file that disables all protocols for these
       other hosts. Another option is to disable all protocols on that host in the other config files.

       If  two  hosts  cannot  connect  to  each  other  because  their IP address(es) are not known (such as dial-up hosts), one side will send a mediated connection request to a router (routers must be
       configured to act as routers!), which will send both the originating and the destination host a connection info request with protocol information and IP address of the other host (if known).  Both
       hosts will then try to establish a direct connection to the other peer, which is usually possible even when both hosts are behind a NAT gateway.

       Routing  via  other  nodes  works because the SRCDST field is not encrypted, so the router can just forward the packet to the destination host. Since each host uses its own private key, the router
       will not be able to decrypt or encrypt packets, it will just act as a simple router and protocol translator.

2.25                                                                                             2015-10-31                                                                                GVPE.PROTOCOL(7)
