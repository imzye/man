WagnerFischer(3pm)                                                                  User Contributed Perl Documentation                                                                  WagnerFischer(3pm)

NAME
       Text::WagnerFischer - An implementation of the Wagner-Fischer edit distance

SYNOPSIS
        use Text::WagnerFischer qw(distance);

        print distance("foo","four");# prints "2"

        print distance([0,1,2],"foo","four");# prints "3"

        my @words=("four","foo","bar");

        my @distances=distance("foo",@words);
        print "@distances"; # prints "2 0 3"

        @distances=distance([0,2,1],"foo",@words);
        print "@distances"; # prints "3 0 3"

DESCRIPTION
       This module implements the Wagner-Fischer dynamic programming technique, used here to calculate the edit distance of two strings.  The edit distance is a measure of the degree of proximity between
       two strings, based on "edits": the operations of substitutions, deletions or insertions needed to transform the string into the other one (and vice versa).  A cost (weight) is needed for every of
       the operation defined above:

                   / a if x=y (cost for letter match)
        w(x,y) =  |  b if x=- or y=- (cost for insertion/deletion operation)
                   \ c if x!=y (cost for letter mismatch)

       These costs are given through an array reference as first argument of the distance subroutine: [a,b,c].  If the costs are not given, a default array cost is used: [0,1,1] that is the case of the
       Levenshtein edit distance:

                   / 0 if x=y (cost for letter match)
        w(x,y) =  |  1 if x=- or y=- (cost for insertion/deletion operation)
                   \ 1 if x!=y (cost for letter mismatch)

       This particular distance is the exact number of edit needed to transform the string into the other one (and vice versa).  When two strings have distance 0, they are the same.  Note that the
       distance is calculated to reach the _minimum_ cost, i.e.  choosing the most economic operation for each edit.

EXTENDING (by Daniel Yacob)
       New modules may build upon Text::WagnerFischer as a base class.  This is practical when you would like to apply the algorithm to non-Roman character sets or would like to change some part of the
       algorithm but not another.

       The following example demonstrates how to use the WagnerFisher distance algorithm but apply your own weight function in a new package:

         package Text::WagnerFischer::MyModule;
         use base qw( Text::WagnerFischer );

         #
         # Link to the WagnerFisher "distance" function so that the
         # new module may also export it:
         #
         use vars qw(@EXPORT_OK);

         @EXPORT_OK = qw(&distance);

         *distance = \&Text::WagnerFischer::distance;

         #
         # "override" the _weight function with the a one:
         #
         *Text::WagnerFischer::_weight = \&_my_weight;

         #
         # "override" the default WagnerFischer "costs" table:
         #
         $Text::WagnerFischer::REFC = [0,2,3,1,1];

         sub _my_weight {
           :
           :
           :
         }

AUTHOR
       Copyright 2002,2003 Dree Mistrut <dree@friul.it>

       This package is free software and is provided "as is" without express or implied warranty. You can redistribute it and/or modify it under the same terms as Perl itself.

SEE ALSO
       "Text::Levenshtein", "Text::PhraseDistance"

perl v5.32.0                                                                                     2021-01-01                                                                              WagnerFischer(3pm)
