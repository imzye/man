ECM-FIND-MODULES(7)                                                                         Extra CMake Modules                                                                         ECM-FIND-MODULES(7)

NAME
       ecm-find-modules - ECM Find Modules Reference

INTRODUCTION
       Find  modules are used by the CMake find_package command to search for packages that do not provide their own CMake package config files. CMake provides an extensive set of find modules, and Extra
       CMake Modules (ECM) adds to that.

       To use ECM’s find modules, you need to tell CMake to find the ECM package, and then add either ${ECM_MODULE_PATH} or ${ECM_FIND_MODULE_DIR} to the CMAKE_MODULE_PATH variable:

          find_package(ECM REQUIRED NO_MODULE)
          set(CMAKE_MODULE_PATH ${ECM_FIND_MODULE_DIR})

       Using ${ECM_MODULE_PATH} will also make the modules intended for direct use by CMake scripts available (see ecm-modules(7) and ecm-kde-modules(7)).

       You can also make local copies of find modules using the ecm_use_find_modules function from ECMUseFindModules, which is automatically included when ECM is found:

          find_package(ECM REQUIRED NO_MODULE)
          ecm_use_find_modules(
              DIR "${CMAKE_BINARY_DIR}/cmake"
              MODULES FindEGL.cmake
          )
          set(CMAKE_MODULE_PATH "${CMAKE_BINARY_DIR}/cmake")

       This allows selective use of ECM’s find modules, and the NO_OVERRIDE argument can be used to ensure that if CMake ships its own version of that find module, it will be used instead.

ALL FIND MODULES
   Find7Zip
       Try to find 7-Zip.

       If the 7-Zip executable is not in your PATH, you can provide an alternative name or full path location with the 7Zip_EXECUTABLE variable.

       This will define the following variables:

       7Zip_FOUND
              TRUE if 7-Zip is available

       7Zip_EXECUTABLE
              Path to 7-Zip executable

       If 7Zip_FOUND is TRUE, it will also define the following imported target:

       7Zip::7Zip
              Path to 7-Zip executable

       NOTE:
          It will see to only find the original 7-Zip, not one of the  p7zip forks.

       Since 5.113.0.

   Find7z
       Try to find 7z.

       If the 7z executable is not in your PATH, you can provide an alternative name or full path location with the 7z_EXECUTABLE variable.

       This will define the following variables:

       7z_FOUND
              TRUE if 7z is available

       7z_EXECUTABLE
              Path to 7z executable

       If 7z_FOUND is TRUE, it will also define the following imported target:

       7z::7z Path to 7z executable

       NOTE:
          Only works on Windows.

       Deprecated: since 5.113, use  Find7Zip.

       Since 5.85.0.

   FindCanberra
       Try to find Canberra event sound library.

       This will define the following variables:

       Canberra_FOUND
              True if (the requested version of) Canberra is available

       Canberra_VERSION
              The version of Canberra

       Canberra_LIBRARIES
              The libraries of Canberra for use with target_link_libraries()

       Canberra_INCLUDE_DIRS
              The include dirs of Canberra for use with target_include_directories()

       If Canberra_FOUND is TRUE, it will also define the following imported target:

       Canberra::Canberra
              The Canberra library

       In general we recommend using the imported target, as it is easier to use.  Bear in mind, however, that if the target is in the link interface of an exported library, it must be made available  by
       the package config file.

       Since 5.56.0.

   FindEGL
       Try to find EGL.

       This will define the following variables:

       EGL_FOUND
              True if (the requested version of) EGL is available

       EGL_VERSION
              The version of EGL; note that this is the API version defined in the headers, rather than the version of the implementation (eg: Mesa)

       EGL_LIBRARIES
              This can be passed to target_link_libraries() instead of the EGL::EGL target

       EGL_INCLUDE_DIRS
              This should be passed to target_include_directories() if the target is not used for linking

       EGL_DEFINITIONS
              This should be passed to target_compile_options() if the target is not used for linking

       If EGL_FOUND is TRUE, it will also define the following imported target:

       EGL::EGL
              The EGL library

       In  general we recommend using the imported target, as it is easier to use.  Bear in mind, however, that if the target is in the link interface of an exported library, it must be made available by
       the package config file.

       Since pre-1.0.0.

   FindGLIB2
       Try to locate the GLib2 library.  If found, this will define the following variables:

       GLIB2_FOUND
              True if the GLib2 library is available

       GLIB2_INCLUDE_DIRS
              The GLib2 include directories

       GLIB2_LIBRARIES
              The GLib2 libraries for linking

       GLIB2_INCLUDE_DIR
              Deprecated, use GLIB2_INCLUDE_DIRS

       GLIB2_LIBRARY
              Deprecated, use GLIB2_LIBRARIES

       If GLIB2_FOUND is TRUE, it will also define the following imported target:

       GLIB2::GLIB2
              The GLIB2 library

       GLIB2::GTHREAD2
              The GThread2 library (since 6.7.0)

       GLIB2::GOBJECT
              The GObject library (since 6.7.0)

       GLIB2::GIO
              The GIO library (since 6.7.0)

       Since 5.41.0.

   FindGperf
       Try to find GNU gperf.

       If the gperf executable is not in your PATH, you can provide an alternative name or full path location with the Gperf_EXECUTABLE variable.

       This will define the following variables:

       Gperf_FOUND
              True if gperf is available.

       Gperf_EXECUTABLE
              The gperf executable.

       Gperf_VERSION
              The gperf version. (since 5.85)

       If Gperf_FOUND is TRUE, it will also define the following imported target:

       GPerf::Gperf
              The gperf executable.

       and the following public function:

          ecm_gperf_generate(<GperfInput> <OutputFile> <OutputVariable(|target (since 5.83))>
                             [GENERATION_FLAGS <flags>])

       Run gperf on <GperfInput> to generate <OutputFile>, adding it to the <OutputVariable> variable which contains the source for the target where <OutputFile> is going to be built or, since  KF  5.83,
       if  the  given  argument  is  a target, to the list of private sources of that target. The target must not be an alias. The optional GENERATION_FLAGS argument is needed to pass extra parameters to
       gperf (note you cannot override that way the output file).

       A simple invocation would be:

          ecm_gperf_generate(simple.gperf ${CMAKE_CURRENT_BINARY_DIR}/simple.h MySources)

       Since 5.35.0.

   FindGradle
       Provides the ability to build Android AAR libraries using Gradle.

       This relies on the Qt provided Gradle, so a Qt for Android installation is required.

          gradle_add_aar(<target>
                         BUIDLFILE build.gradle
                         NAME <aar-name>)

       This builds an Android AAR library using the given build.gradle file.

          gradle_install_aar(<target>
                             DESTINATION <dest>)

       Installs a Android AAR library that has been created with gradle_add_aar.

       Since 5.76.0.

   FindIcoTool
       Try to find icotool.

       If the icotool executable is not in your PATH, you can provide an alternative name or full path location with the IcoTool_EXECUTABLE variable.

       This will define the following variables:

       IcoTool_FOUND
              True if icotool is available.

       IcoTool_EXECUTABLE
              The icotool executable.

       If IcoTool_FOUND is TRUE, it will also define the following imported target:

       IcoTool::IcoTool
              The icotool executable.

       Since 5.49.

   FindInotify
       Try to find inotify on this system. This finds:

              • libinotify on Unix like systems, or

              • the kernel’s inotify on Linux systems.

       This will define the following variables:

       Inotify_FOUND
              True if inotify is available

       Inotify_LIBRARIES
              This has to be passed to target_link_libraries()

       Inotify_INCLUDE_DIRS
              This has to be passed to target_include_directories()

       On Linux and SunOS, the libraries and include directories are empty, even though Inotify_FOUND may be set to TRUE. This is because no special includes or libraries are  needed.  On  other  systems
       these may be needed to use inotify.

       Since 5.32.0.

   FindIsoCodes
       Try to find iso-codes data files.  Once done this will define:

       IsoCodes_FOUND
              Whether the system has iso-codes

       IsoCodes_PREFIX
              The location in which the iso-codes data files are found

       IsoCodes_DOMAINS
              The available domains provided by iso-codes

       Since 5.80.0.

   FindKF5
       Find KDE Frameworks 5 with a single find_package() call.

       This  will use the package config files provided by the individual frameworks.  For example, if you wish to find KArchive, which presents itself to CMake as KF5Archive (ie: you would do find_pack‐
       age(KF5Archive) to find it directly), you can do

          find_package(KF5 COMPONENTS Archive)

       If all the required components (those given in the COMPONENTS argument, but not those given in the OPTIONAL_COMPONENTS argument) are found, KF5_FOUND will be set to true. Otherwise, it will be set
       to false.

       Since pre-1.0.0.

   FindLibExiv2
       Try to find the Exiv2 library.

       This will define the following variables:

       LibExiv2_FOUND
              True if (the requested version of) Exiv2 is available

       LibExiv2_VERSION
              The version of Exiv2

       LibExiv2_INCLUDE_DIRS
              The include dirs of Exiv2 for use with target_include_directories()

       LibExiv2_LIBRARIES
              The Exiv2 library for use with target_link_libraries().  This can be passed to target_link_libraries() instead of the LibExiv2::LibExiv2 target

       If LibExiv2_FOUND is TRUE, it will also define the following imported target:

       LibExiv2::LibExiv2
              The Exiv2 library

       In general we recommend using the imported target, as it is easier to use.  Bear in mind, however, that if the target is in the link interface of an exported library, it must be made available  by
       the package config file.

       Since 5.53.0.

   FindLibGit2
       Try to find libgit2 on a Unix system.

       This will define the following variables:

       LIBGIT2_FOUND
              True if (the requested version of) libgit2 is available

       LIBGIT2_VERSION
              The version of libgit2

       LIBGIT2_LIBRARIES
              This can be passed to target_link_libraries() instead of the LibGit2::LibGit2 target

       LIBGIT2_INCLUDE_DIRS
              This should be passed to target_include_directories() if the target is not used for linking

       LIBGIT2_DEFINITIONS
              This should be passed to target_compile_options() if the target is not used for linking

       If LIBGIT2_FOUND is TRUE, it will also define the following imported target:

       LibGit2::LibGit2
              The libgit2 library

       In  general we recommend using the imported target, as it is easier to use.  Bear in mind, however, that if the target is in the link interface of an exported library, it must be made available by
       the package config file.

       Since 1.3.0.

   FindLibMount
       Try to find the libmount library (part of util-linux), once done this will define:

       LibMount_FOUND
              LibMount was found on the system.

       LibMount_INCLUDE_DIRS
              The libmount include directory.

       LibMount_LIBRARIES
              The libmount libraries.

       LibMount_VERSION
              The libmount version.

       If LibMount_FOUND is TRUE, it will also define the following imported target:

       LibMount::LibMount
              The libmount library

       Since 5.83.0

   FindLibcap
       Try to find the setcap binary and cap libraries

       This will define:

       Libcap_FOUND
              system has the cap library and setcap binary

       Libcap_LIBRARIES
              cap libraries to link against

       SETCAP_EXECUTABLE
              path of the setcap binary

       In addition, the following targets are defined:
              Libcap::SetCapabilities

       Since 5.80.0

   FindOpenEXR
       Try to find the OpenEXR libraries.

       This will define the following variables:

       OpenEXR_FOUND
              True if OpenEXR is available

       OpenEXR_LIBRARIES
              Link to these to use OpenEXR

       OpenEXR_INCLUDE_DIRS
              Include directory for OpenEXR

       OpenEXR_DEFINITIONS
              Compiler flags required to link against OpenEXR

       and the following imported targets:

       OpenEXR::IlmImf
              The OpenEXR core library

       In general we recommend using the imported target, as it is easier to use.  Bear in mind, however, that if the target is in the link interface of an exported library, it must be made available  by
       the package config file.

       Since pre-1.0.0.

   FindPhoneNumber
       Try to find PhoneNumber.

       This is a component-based find module, which makes use of the COMPONENTS and OPTIONAL_COMPONENTS arguments to find_module.  The following components are available:

          PhoneNumber  GeoCoding

       If no components are specified, this module will act as though all components were passed to OPTIONAL_COMPONENTS.

       This module will define the following variables, independently of the components searched for or found:

       PhoneNumber_FOUND
              True if (the requestion version of) PhoneNumber is available

       For  each searched-for components, PhoneNumber_<component>_FOUND will be set to TRUE if the corresponding library was found, and FALSE otherwise.  If PhoneNumber_<component>_FOUND is TRUE, the im‐
       ported target PhoneNumber::<component> will be defined.

       Since 5.54.0.

   FindPoppler
       Try to find Poppler.

       This is a component-based find module, which makes use of the COMPONENTS and OPTIONAL_COMPONENTS arguments to find_module.  The following components are available:

          Core  Cpp  Qt5  Qt4  Glib

       If no components are specified, this module will act as though all components were passed to OPTIONAL_COMPONENTS.

       This module will define the following variables, independently of the components searched for or found:

       Poppler_FOUND
              TRUE if (the requested version of) Poppler is available

       Poppler_VERSION
              Found Poppler version

       Poppler_TARGETS
              A list of all targets imported by this module (note that there may be more than the components that were requested)

       Poppler_LIBRARIES
              This can be passed to target_link_libraries() instead of the imported targets

       Poppler_INCLUDE_DIRS
              This should be passed to target_include_directories() if the targets are not used for linking

       Poppler_DEFINITIONS
              This should be passed to target_compile_options() if the targets are not used for linking

       For each searched-for components, Poppler_<component>_FOUND will be set to TRUE if the corresponding Poppler library was found, and FALSE otherwise.  If Poppler_<component>_FOUND is TRUE, the  im‐
       ported  target  Poppler::<component>  will be defined.  This module will also attempt to determine Poppler_*_VERSION variables for each imported target, although Poppler_VERSION should normally be
       sufficient.

       In general we recommend using the imported targets, as they are easier to use and provide more control.  Bear in mind, however, that if any target is in the link interface of an exported  library,
       it must be made available by the package config file.

       Since 5.19

   FindPulseAudio
       Try to locate the PulseAudio library.  If found, this will define the following variables:

       PulseAudio_FOUND
              True if the system has the PulseAudio library of at least the minimum version specified by either the version parameter to find_package() or the variable PulseAudio_MINIMUM_VERSION

       PulseAudio_INCLUDE_DIRS
              The PulseAudio include directory

       PulseAudio_LIBRARIES
              The PulseAudio libraries for linking

       PulseAudio_MAINLOOP_LIBRARY
              The libraries needed to use PulseAudio Mainloop

       PulseAudio_VERSION
              The version of PulseAudio that was found

       PulseAudio_INCLUDE_DIR
              Deprecated, use PulseAudio_INCLUDE_DIRS

       PulseAudio_LIBRARY
              Deprecated, use PulseAudio_LIBRARIES

       If PulseAudio_FOUND is TRUE, it will also define the following imported target:

       PulseAudio::PulseAudio
              The PulseAudio library

       Since 5.41.0.

   FindQtWaylandScanner
       Try to find qtwaylandscanner.

       If the qtwaylandscanner executable is not in your PATH, you can provide an alternative name or full path location with the QtWaylandScanner_EXECUTABLE variable.

       This will define the following variables:

       QtWaylandScanner_FOUND
              True if qtwaylandscanner is available

       QtWaylandScanner_EXECUTABLE
              The qtwaylandscanner executable.

       If QtWaylandScanner_FOUND is TRUE, it will also define the following imported target:

       Wayland::QtScanner
              The qtwaylandscanner executable.

       This module provides the following functions to generate C++ protocol implementations:

          • ecm_add_qtwayland_client_protocol

          • ecm_add_qtwayland_server_protocol

          ecm_add_qtwayland_client_protocol(<target>
                                            PROTOCOL <xmlfile>
                                            BASENAME <basename>
                                            [PREFIX <prefix>]
                                            [PRIVATE_CODE])

          ecm_add_qtwayland_client_protocol(<source_files_var>
                                            PROTOCOL <xmlfile>
                                            BASENAME <basename>
                                            [PREFIX <prefix>]
                                            [PRIVATE_CODE])

       Generate  C++ wrapper to Wayland client protocol files from <xmlfile> XML definition for the <basename> interface and append those files to <source_files_var> or <target>.  Pass the <prefix> argu‐
       ment if the interface names don’t start with qt_ or wl_.  PRIVATE_CODE instructs wayland-scanner to hide marshalling code from the compiled DSO for use in other DSOs. The default is to export this
       code.

       WaylandScanner is required and will be searched for.

          ecm_add_qtwayland_server_protocol(<target>
                                            PROTOCOL <xmlfile>
                                            BASENAME <basename>
                                            [PREFIX <prefix>]
                                            [PRIVATE_CODE])

          ecm_add_qtwayland_server_protocol(<source_files_var>
                                            PROTOCOL <xmlfile>
                                            BASENAME <basename>
                                            [PREFIX <prefix>]
                                            [PRIVATE_CODE])

       Generate C++ wrapper to Wayland server protocol files from <xmlfile> XML definition for the <basename> interface and append those files to <source_files_var> or <target>.  Pass the <prefix>  argu‐
       ment if the interface names don’t start with qt_ or wl_.  PRIVATE_CODE instructs wayland-scanner to hide marshalling code from the compiled DSO for use in other DSOs. The default is to export this
       code.

       WaylandScanner is required and will be searched for.

       Since 1.4.0.

   FindSasl2
       Try to find the SASL2 library.

       This will define the following variables:

       Sasl2_FOUND
              System has SASL2.

       Sasl2_VERSION
              The version of SASL2.

       Sasl2_INCLUDE_DIRS
              This should be passed to target_include_directories() if the target is not used for linking.

       Sasl2_LIBRARIES
              The SASL2 library.  This can be passed to target_link_libraries() instead of the Sasl2::Sasl2 target

       If Sasl2_FOUND is TRUE, the following imported target will be available:

       Sasl2::Sasl2
              The SASL2 library

       Since 5.41.0.

   FindSeccomp
       Try to locate the libseccomp library.

       This will define the following variables:

       Seccomp_FOUND
              True if the seccomp library is available

       Seccomp_INCLUDE_DIRS
              The seccomp include directories

       Seccomp_LIBRARIES
              The seccomp libraries for linking

       If Seccomp_FOUND is TRUE, it will also define the following imported target:

       Seccomp::Seccomp
              The Seccomp library

       Since 5.44.0.

   FindSharedMimeInfo
       Try to find the shared-mime-info package.

       This will define the following variables:

       SharedMimeInfo_FOUND
              True if system has the shared-mime-info package

       UPDATE_MIME_DATABASE_EXECUTABLE
              The update-mime-database executable

       and the following imported targets:

       SharedMimeInfo::UpdateMimeDatabase
              The update-mime-database executable

       The follow macro is available:

          update_xdg_mimetypes(<path>)

       Updates the XDG mime database at install time (unless the $DESTDIR environment variable is set, in which case it is up to package managers to perform this task).

       Since pre-1.0.0.

   FindTaglib
       Try to find the Taglib library.

       This will define the following variables:

       Taglib_FOUND
              True if the system has the taglib library of at least the minimum version specified by the version parameter to find_package()

       Taglib_INCLUDE_DIRS
              The taglib include dirs for use with target_include_directories

       Taglib_LIBRARIES
              The taglib libraries for use with target_link_libraries()

       Taglib_VERSION
              The version of taglib that was found

       If Taglib_FOUND is TRUE, it will also define the following imported target:

       Taglib::Taglib
              The Taglib library

       Since 5.72.0

   FindUDev
       Try to find the UDev library.

       This will define the following variables:

       UDev_FOUND
              System has UDev.

       UDev_INCLUDE_DIRS
              The libudev include directory.

       UDev_LIBRARIES
              The libudev libraries.

       UDev_VERSION
              The libudev version.

       If UDev_FOUND is TRUE, it will also define the following imported target:

       UDev::UDev
              The UDev library

       Since 5.57.0.

   FindWayland
       Try to find Wayland.

       This is a component-based find module, which makes use of the COMPONENTS and OPTIONAL_COMPONENTS arguments to find_module.  The following components are available:

          Client  Server  Cursor  Egl

       If no components are specified, this module will act as though all components were passed to OPTIONAL_COMPONENTS.

       This module will define the following variables, independently of the components searched for or found:

       Wayland_FOUND
              TRUE if (the requested version of) Wayland is available

       Wayland_VERSION
              Found Wayland version

       Wayland_TARGETS
              A list of all targets imported by this module (note that there may be more than the components that were requested)

       Wayland_LIBRARIES
              This can be passed to target_link_libraries() instead of the imported targets

       Wayland_INCLUDE_DIRS
              This should be passed to target_include_directories() if the targets are not used for linking

       Wayland_DEFINITIONS
              This should be passed to target_compile_options() if the targets are not used for linking

       Wayland_DATADIR
              The core wayland protocols data directory Since 5.73.0

       For  each searched-for components, Wayland_<component>_FOUND will be set to TRUE if the corresponding Wayland library was found, and FALSE otherwise.  If Wayland_<component>_FOUND is TRUE, the im‐
       ported target Wayland::<component> will be defined.  This module will also attempt to determine Wayland_*_VERSION variables for each imported target, although Wayland_VERSION  should  normally  be
       sufficient.

       In  general we recommend using the imported targets, as they are easier to use and provide more control.  Bear in mind, however, that if any target is in the link interface of an exported library,
       it must be made available by the package config file.

       Since pre-1.0.0.

   FindWaylandProtocols
       Try to find wayland-protocols on a Unix system.

       This will define the following variables:

       WaylandProtocols_FOUND
              True if (the requested version of) wayland-protocols is available

       WaylandProtocols_VERSION
              The version of wayland-protocols

       WaylandProtocols_DATADIR
              The wayland protocols data directory

   FindWaylandScanner
       Try to find wayland-scanner.

       If the wayland-scanner executable is not in your PATH, you can provide an alternative name or full path location with the WaylandScanner_EXECUTABLE variable.

       This will define the following variables:

       WaylandScanner_FOUND
              True if wayland-scanner is available.

       WaylandScanner_EXECUTABLE
              The wayland-scanner executable.

       If WaylandScanner_FOUND is TRUE, it will also define the following imported target:

       Wayland::Scanner
              The wayland-scanner executable.

       This module provides the following functions to generate C protocol implementations:

          • ecm_add_wayland_client_protocol

          • ecm_add_wayland_server_protocol

          ecm_add_wayland_client_protocol(<target>
                                          PROTOCOL <xmlfile>
                                          BASENAME <basename>
                                          [PRIVATE_CODE])

          ecm_add_wayland_client_protocol(<source_files_var>
                                          PROTOCOL <xmlfile>
                                          BASENAME <basename>
                                          [PRIVATE_CODE])

       Generate Wayland client protocol files from <xmlfile> XML definition for the <basename> interface and append those files to <source_files_var> or <target>.

       PRIVATE_CODE instructs wayland-scanner to hide marshalling code from the compiled DSO for use in other DSOs. The default is to export this code.

          ecm_add_wayland_server_protocol(<target>
                                          PROTOCOL <xmlfile>
                                          BASENAME <basename>
                                          [PRIVATE_CODE])

          ecm_add_wayland_server_protocol(<source_files_var>
                                          PROTOCOL <xmlfile>
                                          BASENAME <basename>
                                          [PRIVATE_CODE])

       Generate Wayland server protocol files from <xmlfile> XML definition for the <basename> interface and append those files to <source_files_var> or <target>.

       PRIVATE_CODE instructs wayland-scanner to hide marshalling code from the compiled DSO for use in other DSOs. The default is to export this code.

       Since 1.4.0.

   FindX11_XCB
       Try to find the X11 XCB compatibility library.

       This will define the following variables:

       X11_XCB_FOUND
              True if (the requested version of) libX11-xcb is available

       X11_XCB_VERSION
              The version of libX11-xcb (this is not guaranteed to be set even when X11_XCB_FOUND is true)

       X11_XCB_LIBRARIES
              This can be passed to target_link_libraries() instead of the EGL::EGL target

       X11_XCB_INCLUDE_DIR
              This should be passed to target_include_directories() if the target is not used for linking

       X11_XCB_DEFINITIONS
              This should be passed to target_compile_options() if the target is not used for linking

       If X11_XCB_FOUND is TRUE, it will also define the following imported target:

       X11::XCB
              The X11 XCB compatibility library

       In general we recommend using the imported target, as it is easier to use.  Bear in mind, however, that if the target is in the link interface of an exported library, it must be made available  by
       the package config file.

       Since pre-1.0.0.

   FindXCB
       Try to find XCB.

       This is a component-based find module, which makes use of the COMPONENTS and OPTIONAL_COMPONENTS arguments to find_module.  The following components are available:

          XCB
          ATOM         AUX          COMPOSITE    CURSOR       DAMAGE
          DPMS         DRI2         DRI3         EVENT        EWMH
          GLX          ICCCM        IMAGE        KEYSYMS      PRESENT
          RANDR        RECORD       RENDER       RENDERUTIL   RES
          SCREENSAVER  SHAPE        SHM          SYNC         UTIL
          XF86DRI      XFIXES       XINERAMA     XINPUT       XKB
          XTEST        XV           XVMC

       If no components are specified, this module will act as though all components were passed to OPTIONAL_COMPONENTS. Before 5.82 this excluded XINPUT. Since 5.82 all components are searched for.

       This module will define the following variables, independently of the components searched for or found:

       XCB_FOUND
              True if (the requestion version of) xcb is available

       XCB_VERSION
              Found xcb version

       XCB_TARGETS
              A list of all targets imported by this module (note that there may be more than the components that were requested)

       XCB_LIBRARIES
              This can be passed to target_link_libraries() instead of the imported targets

       XCB_INCLUDE_DIRS
              This should be passed to target_include_directories() if the targets are not used for linking

       XCB_DEFINITIONS
              This should be passed to target_compile_options() if the targets are not used for linking

       For  each searched-for components, XCB_<component>_FOUND will be set to true if the corresponding xcb library was found, and false otherwise.  If XCB_<component>_FOUND is true, the imported target
       XCB::<component> will be defined.  This module will also attempt to determine XCB_*_VERSION variables for each imported target, although XCB_VERSION should normally be sufficient.

       In general we recommend using the imported targets, as they are easier to use and provide more control.  Bear in mind, however, that if any target is in the link interface of an exported  library,
       it must be made available by the package config file.

       Since pre-1.0.0.

   Findepoxy
       Try to find libepoxy on a Unix system.

       This will define the following variables:

       epoxy_FOUND
              True if (the requested version of) libepoxy is available

       epoxy_VERSION
              The version of libepoxy

       epoxy_LIBRARIES
              This should be passed to target_link_libraries() if the target is not used for linking

       epoxy_INCLUDE_DIRS
              This should be passed to target_include_directories() if the target is not used for linking

       epoxy_DEFINITIONS
              This should be passed to target_compile_options() if the target is not used for linking

       epoxy_HAS_GLX
              True if GLX support is available

       If epoxy_FOUND is TRUE, it will also define the following imported target:

       epoxy::epoxy
              The epoxy library

       In  general we recommend using the imported target, as it is easier to use.  Bear in mind, however, that if the target is in the link interface of an exported library, it must be made available by
       the package config file.

   Findgzip
       Try to find gzip.

       If the gzip executable is not in your PATH, you can provide an alternative name or full path location with the gzip_EXECUTABLE variable.

       This will define the following variables:

       gzip_FOUND
              TRUE if gzip is available

       gzip_EXECUTABLE
              Path to gzip executable

       If gzip_FOUND is TRUE, it will also define the following imported target:

       gzip::gzip
              Path to gzip executable

       Since 5.85.0.

SEE ALSO
       ecm(7), ecm-modules(7), ecm-kde-modules(7)

COPYRIGHT
       KDE Developers

6.18                                                                                            Sep 30, 2025                                                                            ECM-FIND-MODULES(7)
