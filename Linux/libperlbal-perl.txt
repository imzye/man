Perlbal::Manual::Debugging(3pm)                                                     User Contributed Perl Documentation                                                     Perlbal::Manual::Debugging(3pm)

NAME
       Perlbal::Manual::Debugging - Debugging Perlbal

   VERSION
       Perlbal 1.78.

   DESCRIPTION
       Perlbal has two ways of debugging.

       One of them is through a management console; the other is through debugging messages.

   Debugging in a console
       You'll need to set up a management service and use it to dump all the information you require.

       The comprehensive documentation on this process can be found at Perlbal::Manual::Management.

   Debugging messages
       You can control the ammount of debugging messages Perlbal dumps by setting the environment variable "PERLBAL_DEBUG" to a value between 0 and 4:

           PERLBAL_DEBUG = 0 # no debug

           PERLBAL_DEBUG = 4 # debug everything

       Debug level 1

       You can activate basic debug by setting "PERLBAL_DEBUG" to 1:

           PERLBAL_DEBUG = 1

       The following debugging messages are turned on:

       •   When a connection to a backend is closed, Perlbal::BackendHTTP prints "Backend $self is done; closing..."

       •   When a connection to a backend is killed, Perlbal::ClientProxy prints "Client ($self) closing backend ($backend)"

       •   When an HTTP request fails to be parsed, Perlbal::HTTPHeaders prints "HTTP parse failure: $reason"

       •   When the connection is promoted to SSL, Perlbal::TCPListener prints "  .. socket upgraded to SSL!"

       Debug level 2

       By setting the debug level to 2 you'll get all the messages from level 1.

           PERLBAL_DEBUG = 2

       You will also get a few others:

       •   When a connection to a backend is opened and ready to be written to, Perlbal::BackendHTTP prints "Backend $self is writeable!"

       •   When a response is about to be handled, Perlbal::BackendHTTP prints "BackendHTTP: handle_response"

       •   When a backend is ready to be read from, Perlbal::BackendHTTP prints "Backend $self is readable!"

       •   When there's an error with the connection to the backend, Perlbal::BackendHTTP prints "BACKEND event_err"

       •   Whenever we're determining if we should be sending keep-alive header information back to the client, Perlbal::ClientHTTPBase prints "ClientHTTPBase::setup_keepalive($self)"

       •   Whenever the client is ready for more of its file, Perlbal::ClientHTTPBase prints "REPROXY SSL done"

       •   Right after we've read a chunk of a file and when a reproxy request is about to be sent, Perlbal::ClientHTTPBase prints "REPROXY Sent: $sent"

       •   When we've written all data in the queue (and are about to stop waiting for write notifications), Perlbal::ClientHTTPBase prints "All writing done to $self"

       •   Whenever a client proxy is about to be closed, Perlbal::ClientProxy prints "Perlbal::ClientProxy closed", followed by a possible "again" and a possible "saying $reason"

       •   When a client has disconnected, Perlbal::ClientProxy prints "ClientProxy::client_disconnected"

       •   When a backend requests a client of a high priority request and the client is available, "Service" in Perlbal prints "Got from fast queue, in front of $backlog others"

       •   When a backend requests a client of a normal priority request and the client is available, "Service" in Perlbal prints "Backend requesting client, got PRIORITY = $cp-"{fd}.>

       •   When a backend requests a client of a low priority request and the client is available, "Service" in Perlbal prints "Backend requesting client, got low priority = $cp-"{fd}.>

       •   When header are being read, Perlbal::Socket prints "Perlbal::Socket::read_headers($self) is_res=$is_res"

       Debug level 3

           PERLBAL_DEBUG = 3

       By setting the debug level to 3 you'll get all the messages from level 1 and 2 plus the following:

       •   Right before response headers are written to the client, Perlbal::BackendHTTP prints "  writing response headers to client"

       •   As we're writing to the client, Perlbal::BackendHTTP prints "  content_length=VALUE" and "  remain=VALUE", where the values are "undef" if they are not defined

       •   If we're done writing to the client, Perlbal::BackendHTTP prints "  done.  detaching."

       •   Whenever we're determining if we should be sending keep-alive header information back to the client, Perlbal::ClientHTTPBase prints "  service's persist_client = $persist_client"

       •   While  determining  if  we  should  be  sending  keep-alive  header  information  back  to  the  client,  if  we  were sent "content-length" or it's a head request, as we're doing a keep alive
           Perlbal::ClientHTTPBase prints "  doing keep-alive to client"

       •   If we're not sending keep-alive header information back ot the client, Perlbal::ClientHTTPBase prints "  doing connection: close"

       •   Right after we've finished sending all of the results to the user, Perlbal::ClientProxy prints "ClientProxy::backend_finished"

       •   When we've sent a response to a user fully and we need to reset state, Perlbal::ClientProxy prints "ClientProxy::http_response_sent -- resetting state"

       •   When we're writing a response to a client, Perlbal::ClientProxy prints "ClientProxy::event_write"

       •   After writing a response to a client, if it is still connected and we're triggering trigger our backend to keep reading, Perlbal::ClientProxy prints "  unstalling backend"

       •   When reading a request, Perlbal::ClientProxy prints "ClientProxy::event_read"

       •   When reading a request and just before we read the headers, Perlbal::ClientProxy prints "  no headers.  reading."

       •   When reading a request, if we're not buffering to disk or we're no longer reading, as we disable reads, Perlbal::ClientProxy prints "  disabling reads."

       •   As we're reading, Perlbal::ClientProxy prints "  reading $read_size bytes (VALUE bytes remain)", where "VALUE bytes remain" can be <undef>

       •   After each read, Perlbal::ClientProxy prints "  read $len bytes"

       •   After we finished reading the request, Perlbal::ClientProxy prints "  done_reading = $done_reading, backend = BACKEND", where "BACKEND" can be "undef"

       •   When we send the headers to the backend and it responds before we're done reading from the client, further reads from the client are discarded; in this situation Perlbal::ClientProxy prints  "
           already responded.". If the client continues to send data, Perlbal::ClientProxy prints "  already responded [2]." and then gives up on reading

       •   After reading, and having a backend available where we can write to, just before we do, Perlbal::ClientProxy prints "  got a backend.  sending write to it."

       •   After reading, if there's no backend available, Perlbal::ClientProxy prints "  no backend.  read_ahead = $self-"{read_ahead}.>

       •   If we know we've already started spooling a file to disk and we're about to continue doing so, Perlbal::ClientProxy prints "  bureason = $self-"{bureason}>

       •   If a backend wasn't available and we're about to request one, Perlbal::ClientProxy prints "  finally requesting a backend"

       •   When we're trying to read headers and the client has disconnected, Perlbal::Socket prints "  client disconnected"

       •   If we need to remove a trailing "\r\n" from the headers, Perlbal::Socket prints "  throwing away leading \r\n"

       •   If we've read a packet with headers and by the end of it we can't find the end of them, Perlbal::Socket prints "  can't find end of headers"

       •   Once we've read some headers, Perlbal::Socket prints "  pre-parsed headers: [$hstr]"

       •   After reading headers, if there's additional content that we've read, we push it back; when we do so, Perlbal::Socket prints "  pushing back $len bytes after header"

       •   If we got bogus headers, and right before we close the connection due to a parsing failure, Perlbal::Socket prints "  bogus headers"

       •   If we got valid headers, Perlbal::Socket prints "  got valid headers"

       •   If we're reading buffered data from a client, Perlbal::Socket prints "draining readbuf from $self to $dest: [$$bref]"

       Debug level 4

       By setting the debug level to 4 you get all the messages from levels 1 to 3.

       Plus, "write" is redefined so that whenever "write" is called it first prints "write($self, <$clen>"$content") from ($pkg, $filename, $line)".

           PERLBAL_DEBUG = 4

   SEE ALSO
       Perlbal::Manual::Configuration, Perlbal::Manual::Management.

perl v5.34.0                                                                                     2022-06-28                                                                 Perlbal::Manual::Debugging(3pm)
