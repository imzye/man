GIT-REVISE(1)                                                                                    git-revise                                                                                   GIT-REVISE(1)

NAME
       git-revise - Efficiently update, split, and rearrange git commits

SYNOPSIS
       git revise [<options>] [<target>]

DESCRIPTION
       git  revise  is  a  git(1) subcommand to efficiently update, split, and rearrange commits. It is heavily inspired by git-rebase(1), however tries to be more efficient and ergonomic for patch-stack
       oriented workflows.

       By default, git revise will apply staged changes to <target>, updating HEAD to point at the revised history. It also supports splitting commits, rewording commit messages.

       Unlike git-rebase(1), git revise avoids modifying working directory and index state, performing all merges in-memory, and only writing them when necessary.  This  allows  it  to  be  significantly
       faster on large codebases, and avoid invalidating builds.

       If --autosquash or --interactive is specified, the <target> argument may be omitted or given as the special value :option:--root.  If it is omitted, git revise will consider a range of unpublished
       commits on the current branch. If given as :option:--root, all commits including the root commit will be considered.

OPTIONS
   General options
       -a, --all
              Stage changes to tracked files before revising.

       -p, --patch
              Interactively stage hunks from the worktree before revising.

       --no-index
              Ignore staged changes in the index.

       --reauthor
              Reset target commit's author to the current user.

       --ref <gitref>
              Working branch to update; defaults to HEAD.

       -S, --gpg-sign, --no-gpg-sign
              GPG-sign commits.  Overrides both the commit.gpgSign and revise.gpgSign git configurations.

   Main modes of operation
       -i, --interactive
              Rather than applying staged changes to <target>, edit a todo list of actions to perform on commits after <target>. See INTERACTIVE MODE.

       --autosquash, --no-autosquash
              Rather than directly applying staged changes to <target>, automatically perform fixup or squash actions marked with fixup! or squash!  between <target> and the current HEAD. For more infor‐
              mation on what these actions do, see INTERACTIVE MODE.

              These commits are usually created with git commit --fixup=<commit> or git commit --squash=<commit>, and identify the target with the first line of its commit message.

              This option can be combined with --interactive to modify the generated todos before they're executed.

              If the --autosquash option is enabled by default using a configuration variable, the option --no-autosquash can be used to override and disable this setting. See CONFIGURATION.

       -c, --cut
              Interactively select hunks from <target>. The chosen hunks are split into a second commit immediately after the target.

              After splitting is complete, both commits' messages are edited.

              See the "Interactive Mode" section of git-add(1) to learn how to operate this mode.

       -e, --edit
              After applying staged changes, edit <target>'s commit message.

              This option can be combined with --interactive to allow editing of commit messages within the todo list. For more information on, see INTERACTIVE MODE.

       -m <msg>, --message <msg>
              Use the given <msg> as the new commit message for <target>. If multiple -m options are given, their values are concatenated as separate paragraphs.

       --version
              Print version information and exit.

CONFIGURATION
       Configuration is managed by git-config(1).

       revise.autoSquash
              If set to true, imply --autosquash whenever --interactive is specified. Overridden by --no-autosquash. Defaults to false. If not set, the value of rebase.autoSquash is used instead.

       revise.gpgSign
              If  set  to true, GPG-sign new commits; defaults to false.  This setting overrides the original git configuration commit.gpgSign and may be overridden by the command line options --gpg-sign
              and --no-gpg-sign.

CONFLICT RESOLUTION
       When a conflict is encountered, git revise will attempt to resolve it automatically using standard git mechanisms. If automatic resolution fails, the user will be prompted to  resolve  them  manu‐
       ally.

       There is currently no support for using git-mergetool(1) to resolve conflicts.

       No attempt is made to detect renames of files or directories. git revise may produce suboptimal results across renames. Use the interactive mode of git-rebase(1) when rename tracking is important.

NOTES
       A successful git revise will add a single entry to the reflog, allowing it to be undone with git reset @{1}. Unsuccessful git revise commands will leave your repository largely unmodified.

       No merge commits may occur between the target commit and HEAD, as rewriting them is not supported.

       See git-rebase(1) for more information on the implications of modifying history on a repository that you share.

INTERACTIVE MODE
       git revise supports an interactive mode inspired by the interactive mode of git-rebase(1).

       This mode is started with the last commit you want to retain "as-is":

          git revise -i <after-this-commit>

       The special target --root is available to revise everything up to the root commit:

          git revise -i --root

       An editor will be fired up with the commits in your current branch after the given commit. If the index has any staged but uncommitted changes, a <git index> entry will also be present.

          pick 8338dfa88912 Oneline summary of first commit
          pick 735609912343 Summary of second commit
          index 672841329981 <git index>

       These  commits may be re-ordered to change the order they appear in history.  In addition, the pick and index commands may be replaced to modify their behaviour. If present, index commands must be
       at the bottom of the list, i.e. they can not be followed by non-index commands.

       If -e was specified, the full commit message will be included, and each command line will begin with a ++. Any changes made to the commit messages in this file will be applied  to  the  commit  in
       question, allowing for simultaneous editing of commit messages during the todo editing phase.

          ++ pick 8338dfa88912
          Oneline summary of first commit

          Body of first commit

          ++ pick 735609912343
          Summary of second commit

          Body of second commit

          ++ index 672841329981
          <git index>

       The following commands are supported in all interactive modes:

       index  Do not commit these changes, instead leaving them staged in the index.  Index lines must come last in the file.

       pick   Use the given commit as-is in history. When applied to the generated index entry, the commit will have the message <git index>.

       squash Add the commit's changes into the previous commit and open an editor to merge the commits' messages.

       fixup  Like squash, but discard this commit's message rather than editing.

       reword Open an editor to modify the commit message.

       cut    Interactively select hunks from the commit. The chosen hunks are split into a second commit immediately after it.

              After splitting is complete, both commits' messages are edited.

              See the "Interactive Mode" section of git-add(1) to learn how to operate this mode.

REPORTING BUGS
       Please report issues and feature requests to the issue tracker at https://github.com/mystor/git-revise/issues.

       Code, documentation and other contributions are also welcomed.

SEE ALSO
       git(1) git-rebase(1) git-add(1)

COPYRIGHT
       2018-2022, Nika Layzell

0.7.0                                                                                           Jan 05, 2022                                                                                  GIT-REVISE(1)
