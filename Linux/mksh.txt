MKSH(1)                                                                                    General Commands Manual                                                                                  MKSH(1)

NAME
       mksh, sh — MirBSD Korn shell

SYNOPSIS
       mksh [-+abCefhiklmnprUuvXx] [-+o option] [-T [!]tty|-] [file [arg1 ...]]
       mksh [-+abCefhiklmnprUuvXx] [-+o option] [-T [!]tty|-] -c cmd [arg0 ...]
       mksh [-+abCefhiklmnprUuvXx] [-+o option] [-T [!]tty|-] -s [arg1 ...]
       builtin-name [argument ...]

DESCRIPTION
       mksh  is  a command interpreter intended for both interactive and shell script use. Its command language is a superset of both sh(C) and POSIX shell language and largely compatible to the original
       Korn shell. At times, this manual page may give scripting advice; while it sometimes does take portable shell scripting or various standards into account all information is first and foremost pre‐
       sented with mksh in mind and should be taken as such.

   I use Android, OS/2, etc. so what...?
       Please refer to: http://www.mirbsd.org/mksh-faq.htm#sowhatismksh

   Invocation
       Most builtins can be called directly, for example if a link or symlink(7) points to mksh, or if argv[0] is set correspondingly; this does not make sense for, or works properly with,  all  built-in
       utilities though.

       The options are as follows:

       -c  mksh  will execute the command(s) contained in cmd, setting $0 to arg0 (if present), $1 to the next argument, etc. If compiled with -DMKSH_MIDNIGHTBSD01ASH_COMPAT and in -o sh mode, a “--” ar‐
           gument directly following cmd is ignored for compatibility with the legacy FreeBSD sh; this is deprecated and may go away in the future.

       -i  Interactive shell. A shell that reads commands from standard input is “interactive” if this option is used or if both standard input and standard error are attached to a tty(4). An interactive
           shell has job control enabled, ignores the SIGINT, SIGQUIT and SIGTERM signals, and prints prompts before reading input (see the PS1 and PS2 parameters). It also processes the ENV parameter or
           the mkshrc file (see below). For non-interactive shells, the trackall option is on by default (see the set command below).

       -l  Login shell. If the name the shell is called as (i.e. argv[0]) or its basename begins with a dash (hyphen-minus) ‘-’ or if this option is given, the shell is  a  “login  shell”;  see  “Startup
           files” below.

       -p  Privileged  shell. A shell is “privileged” if the real user ID from getuid(2) or group ID from getgid(2) does not match the effective user ID or group ID. Clearing the privileged option causes
           the shell to set its effective user ID and group ID to its initial real user ID and group ID, respectively. For further implications, see set -p and “Startup files”. If the shell is privileged
           and this flag is not set explicitly on invocation, nor during processing the startup files, the “privileged” flag is cleared automatically afterwards.

       -r  Restricted shell. A shell is “restricted” if the basename the shell is called with, after dash removal, begins with ‘r’ or if this option is used. The following restrictions come  into  effect
           after the shell processes any profile and ENV files:

           •   Command  names  cannot  be  specified  with  pathnames, either absolute or relative; the -p flag of the command built-in utility is not usable. The ENV, PATH and SHELL parameters cannot be
               changed.
           •   The current location is fixed: the cd builtin is disabled.
           •   Redirections that create files, i.e. “>”, “>|”, “>>” and “<>”, cannot be used, and the HISTFILE parameter cannot be changed.

       -s  mksh will read and execute commands from standard input; all non-option arguments are assigned to the positional parameters.

       -T -
           Detach from the controlling terminal, return immediately (daemonise).

       -T [!]name
           Spawn mksh on the tty(4) device given. The paths name, /dev/ttyCname and /dev/ttyname are attempted in order. If name is prefixed with an exclamation mark (‘!’), wait for the spawned shell  to
           return, report its exit status or terminating signal visually. Exit 0 if spawned.

       In  addition  to  the  above,  the flags [-+abCefhkmnUuvXx] and [-+o option], respectively for single-letter and long options, as described for the set built-in utility, can be used on the command
       line.

       If neither the -c nor the -s options are specified, mksh will read and execute commands as if the -s flag was passed iff the file argument is absent or “-”; otherwise, it sets $0 to file and reads
       commands from it. Further arguments arg1 ... are assigned to positional parameters.

       The exit status of the shell is 127 if the file specified on the command line could not be opened, or non-zero if a fatal error occurred during execution of the script. Otherwise,  the  errorlevel
       is that of the last command executed, 0 if no command was executed.

   Startup files
       For  the  actual  location of these files, see “FILES”. A login shell processes the system profile first. A privileged shell then processes the suid profile. A non-privileged login shell processes
       the user profile next. A non-privileged interactive shell checks the value of the ENV parameter after subjecting it to parameter, command, arithmetic and tilde  (‘~’)  substitution;  if  unset  or
       empty,  the  user  mkshrc profile is processed; otherwise, if a file whose name is the substitution result exists, it is processed; non-existence is silently ignored. A privileged shell then drops
       privileges if neither was the -p option given on the command line nor set during execution of the startup files.

   Command syntax
       The shell begins parsing its input by removing any backslash-newline combinations, then breaking it into words. Words (which are sequences of characters) are delimited by unquoted whitespace char‐
       acters (space, tab and newline) or meta-characters (‘<’, ‘>’, ‘|’, ‘;’, ‘(’, ‘)’ and ‘&’). Aside from delimiting words, spaces and tabs are ignored, while newlines usually  delimit  commands.  The
       meta-characters  are used in building the following tokens: “<”, “<&”, “<<”, “<<<”, “>”, “>&”, “>>”, “&>”, etc. are used to specify redirections (see “Input/output redirection” below); “|” is used
       to create pipelines; “|&” is used to create co-processes (see “Co-processes” below); “;” is used to separate commands; “&” is used to create asynchronous pipelines; “&&” and “||” are used to spec‐
       ify conditional execution; “;;”, “;&” and “;|” are used in case statements; “(( ... ))” is used in arithmetic expressions; and lastly, “( ... )” is used to create subshells.

       Whitespace and meta-characters can be quoted individually using a backslash (‘\’), or in groups using double (‘"’) or single (“'”) quotes. Note that the following characters are also treated  spe‐
       cially  by the shell and must be quoted if they are to represent themselves: ‘\’, ‘"’, “'”, ‘#’, ‘$’, ‘`’, ‘~’, ‘{’, ‘}’, ‘*’, ‘?’ and ‘[’. The first three of these are the above mentioned quoting
       characters (see “Quoting” below); ‘#’, if used at the beginning of a word, introduces a comment — everything after the ‘#’ up to the nearest newline is ignored; ‘$’ is used to introduce parameter,
       command and arithmetic substitutions (see “Substitution” below); ‘`’ introduces an old-style command substitution  (see  “Substitution”  below);  ‘~’  begins  a  directory  expansion  (see  “Tilde
       expansion” below); ‘{’ and ‘}’ delimit csh(1)-style alternations (see “Brace expansion” below); and finally, ‘*’, ‘?’ and ‘[’ are used in file name generation (see “File name patterns” below).

       As  words  and  tokens are parsed, the shell builds commands, of which there are two basic types: simple-commands, typically programmes that are executed, and compound-commands, such as for and if
       statements, grouping constructs and function definitions.

       A simple-command consists of some combination of parameter assignments (see “Parameters” below), input/output redirections (see “Input/output redirections” below) and command words; the  only  re‐
       striction  is  that parameter assignments come before any command words. The command words, if any, define the command that is to be executed and its arguments. The command may be a shell built-in
       command, a function or an external command (i.e. a separate executable file that is located using the PATH parameter; see “Command execution” below). Note that all command constructs have an  exit
       status:  for  external commands, this is related to the status returned by wait(2) (if the command could not be found, the exit status is 127; if it could not be executed, the exit status is 126);
       the exit status of other command constructs (built-in commands, functions, compound-commands, pipelines, lists, etc.) are all well-defined and are described where the construct is  described.  The
       exit status of a command consisting only of parameter assignments is that of the last command substitution performed during the parameter assignment or 0 if there were no command substitutions.

       Commands can be chained together using the “|” token to form pipelines, in which the standard output of each command but the last is piped (see pipe(2)) to the standard input of the following com‐
       mand.  The  exit  status of a pipeline is that of its last command, unless the pipefail option is set (see there). All commands of a pipeline are executed in separate subshells; this is allowed by
       POSIX but differs from both variants of AT&T UNIX ksh, where all but the last command were executed in subshells; see the read builtin's description for implications and  workarounds.  A  pipeline
       may be prefixed by the “!” reserved word which causes the exit status of the pipeline to be logically complemented: if the original status was 0, the complemented status will be 1; if the original
       status was not 0, the complemented status will be 0.

       Lists  of  commands  can be created by separating pipelines by any of the following tokens: “&&”, “||”, “&”, “|&” and “;”. The first two are for conditional execution: “cmd1 && cmd2” executes cmd2
       only if the exit status of cmd1 is zero; “||” is the opposite — cmd2 is executed only if the exit status of cmd1 is non-zero. “&&” and “||” have equal precedence which is higher than that of  “&”,
       “|&” and “;”, which also have equal precedence. Note that the “&&” and “||” operators are "left-associative". For example, both of these commands will print only "bar":

             $ false && echo foo || echo bar
             $ true || echo foo && echo bar

       The  “&”  token  causes  the preceding command to be executed asynchronously; that is, the shell starts the command but does not wait for it to complete (the shell does keep track of the status of
       asynchronous commands; see “Job control” below). When an asynchronous command is started when job control is disabled (i.e. in most scripts), the command is started with signals SIGINT and SIGQUIT
       ignored and with input redirected from /dev/null (however, redirections specified in the asynchronous command have precedence). The “|&” operator starts a co-process which is  a  special  kind  of
       asynchronous  process  (see  “Co-processes” below). Note that a command must follow the “&&” and “||” operators, while it need not follow “&”, “|&” or “;”. The exit status of a list is that of the
       last command executed, with the exception of asynchronous lists, for which the exit status is 0.

       Compound commands are created using the following reserved words. These words are only recognised if they are unquoted and if they are used as the first word of a command (i.e. they can't be  pre‐
       ceded by parameter assignments or redirections):

             case     else     function     then      ! (
             do       esac     if           time      [[      ((
             done     fi       in           until     {
             elif     for      select       while     }

       In the following compound command descriptions, command lists (denoted as list) that are followed by reserved words must end with a semicolon, a newline or a (syntactically correct) reserved word.
       For example, the following are all valid:

             $ { echo foo; echo bar; }
             $ { echo foo; echo bar<newline>}
             $ { { echo foo; echo bar; } }

       This is not valid:

             $ { echo foo; echo bar }

       case word in [[(] pattern [| pattern] ...) list <terminator>] ... esac
             The  case  statement attempts to match word against a specified pattern; the list associated with the first successfully matched pattern is executed. Patterns used in case statements are the
             same as those used for file name patterns except that the restrictions regarding ‘.’ and ‘/’ are dropped. Note that any unquoted space before and after  a  pattern  is  stripped;  any  space
             within a pattern must be quoted. Both the word and the patterns are subject to parameter, command and arithmetic substitution, as well as tilde substitution.

             For historical reasons, open and close braces may be used instead of in and esac, for example: “case $foo { (ba[rz]|blah) date ;; }”

             The list <terminator>s are:

             “;;”  Terminate after the list.

             “;&”  Fall through into the next list.

             “;|”  Evaluate the remaining pattern-list tuples.

             The exit status of a case statement is that of the executed list; if no list is executed, the exit status is zero.

       for name [in word ...] ; do list; done
             For each word in the specified word list, the parameter name is set to the word and list is executed. The exit status of a for statement is the last exit status of list; if list is never ex‐
             ecuted,  the  exit  status  is zero. If in is not used to specify a word list, the positional parameters ($1, $2, etc.) are used instead; in this case, use a newline instead of the semicolon
             (‘;’) for portability. For historical reasons, open and close braces may be used instead of do and done, as in “for i; { echo $i; }” (not portable).

       function name { list; }
             Defines the function name (see “Functions” below). All redirections specified after a function definition are performed whenever the function is executed, not when the function definition is
             executed.

       name() command
             Mostly the same as function (see above and “Functions” below). Most amounts of space and tab after name will be ignored.

       function name() { list; }
             bashism for name() { list; } (the function keyword is ignored).

       if list; then list; [elif list; then list;] ... [else list;] fi
             If the exit status of the first list is zero, the second list is executed; otherwise, the list following the elif, if any, is executed with similar consequences. If all the  lists  following
             the  if  and elifs fail (i.e. exit with non-zero status), the list following the else is executed. The exit status of an if statement is that of whatever non-conditional (not the first) list
             that is executed; if no non-conditional list is executed, the exit status is zero.

       select name [in word ...]; do list; done
             The select statement provides an automatic method of presenting the user with a menu and selecting from it. An enumerated list of the specified words is printed on standard  error,  followed
             by  a prompt (PS3: normally “#? ”). A number corresponding to one of the enumerated words is then read from standard input, name is set to the selected word (or unset if the selection is not
             valid), REPLY is set to what was read (leading and trailing space is stripped), and list is executed. If a blank line (i.e. zero or more IFS octets) is entered, the menu is reprinted without
             executing list.

             When list completes, the enumerated list is printed if REPLY is empty, the prompt is printed, and so on. This process continues until an end-of-file is read, an interrupt is received,  or  a
             break statement is executed inside the loop. The exit status of a select statement is zero if a break statement is used to exit the loop, non-zero otherwise. If “in word ...” is omitted, the
             positional parameters are used. For historical reasons, open and close braces may be used instead of do and done, as in: “select i; { echo $i; }”

       time [-p] [pipeline]
             The “Command execution” section describes the time reserved word. When not a reserved word, a builtin runs the passed command.

       until list; do list; done
             This works like while (see below), except that the body list is executed only while the exit status of the first list is non-zero.

       while list; do list; done
             A  while  is  a pre-checked loop. Its body list is executed as often as the exit status of the first list is zero. The exit status of a while statement is the last exit status of the list in
             the body of the loop; if the body is not executed, the exit status is zero.

       [[ expression ]]
             Similar to the test and [ ... ] commands (described later), with the following exceptions:

             •   Field splitting and globbing are not performed on arguments.

             •   The -a (AND) and -o (OR) operators are replaced, respectively, with “&&” and “||”.

             •   Operators (e.g. “-f”, “=”, “!”) must be unquoted.

             •   Parameter, command and arithmetic substitutions are performed as expressions are evaluated and lazy expression evaluation is used for the “&&” and “||” operators. This means that in  the
                 following statement, $(<foo) is evaluated if and only if the file foo exists and is readable:

                       $ [[ -r foo && $(<foo) = b*r ]]

             •   The  second  operand  of the “=” and “!=” expressions is a pattern (e.g. the comparison [[ foobar = f*r ]] succeeds). This even works indirectly, while quoting forces literal interpreta‐
                 tion:

                       $ bar=foobar; baz='f*r'         # or: baz='f+(o)b?r'
                       $ [[ $bar = $baz ]]; echo $? # 0
                       $ [[ $bar = "$baz" ]]; echo $? # 1

       { list; }
             Compound construct; list is executed, but not in a subshell.
             Note that “{” and “}” are reserved words, not meta-characters.

       (list)
             Execute list in a subshell, forking. There is no implicit way to pass environment changes from a subshell back to its parent.

       (( expression ))
             The arithmetic expression expression is evaluated; equivalent to ‘let "expression"’ in a compound construct.
             See the let command and “Arithmetic expressions” below.

   Quoting
       Quoting is used to prevent the shell from treating characters or words specially. There are three methods of quoting. First, ‘\’ quotes the following character, unless it is at the end of a  line,
       in  which  case  both the ‘\’ and the newline are stripped. Second, a single quote (“'”) quotes everything up to the next single quote (this may span lines). Third, a double quote (‘"’) quotes all
       characters, except ‘$’, ‘\’ and ‘`’, up to the next unescaped double quote. ‘$’ and ‘`’ inside double quotes have their usual meaning (i.e. parameter, arithmetic or command substitution) except no
       field splitting is carried out on the results of double-quoted substitutions, and the old-style form of command substitution has backslash-quoting for double quotes enabled. If a ‘\’ inside a dou‐
       ble-quoted string is followed by ‘"’, ‘$’, ‘\’ or ‘`’, only the ‘\’ is removed, i.e. the combination is replaced by the second character; if it is followed by a newline, both the ‘\’ and the  new‐
       line are stripped; otherwise, both the ‘\’ and the character following are unchanged.

       If  a  single-quoted  string  is preceded by an unquoted ‘$’, C style backslash expansion (see below) is applied (even single quote characters inside can be escaped and do not terminate the string
       then); the expanded result is treated as any other single-quoted string. If a double-quoted string is preceded by an unquoted ‘$’, the ‘$’ is simply ignored.

   Backslash expansion
       In places where backslashes are expanded, certain C and AT&T UNIX ksh or GNU bash style escapes are translated. These include “\a”, “\b”, “\f”, “\n”, “\r”, “\t”, “\U########”, “\u####”  and  “\v”.
       For  “\U########”  and  “\u####”,  ‘#’ means a hexadecimal digit (up to 4 or 8); these translate a Universal Coded Character Set codepoint to UTF-8 (see “CAVEATS” on UCS limitations). Furthermore,
       “\E” and “\e” expand to the escape character.

       In the print builtin mode, octal sequences must have the optional up to three octal digits ‘#’ prefixed with the digit zero (“\0###”); hexadecimal sequences “\x##” are limited to up to  two  hexa‐
       decimal digits ‘#’; both octal and hexadecimal sequences convert to raw octets; “\%”, where ‘%’ is none of the above, translates to \% (backslashes are retained).

       In  C  style mode, raw octet-yielding octal sequences “\###” must not have the one up to three octal digits prefixed with the digit zero; hexadecimal sequences “\x##” greedily eat up as many hexa‐
       decimal digits ‘#’ as they can and terminate with the first non-xdigit; below \x100 these produce raw octets; above, they are equivalent to “\U#”. The sequence  “\c%”,  where  ‘%’  is  any  octet,
       translates to Ctrl-%, that is, “\c?” becomes DEL, everything else is bitwise ANDed with 0x9F. “\%”, where ‘%’ is none of the above, translates to %: backslashes are trimmed even before newlines.

   Aliases
       There  are  two  types of aliases: normal command aliases and tracked aliases. Command aliases are normally used as a short hand for a long or often used command. The shell expands command aliases
       (i.e. substitutes the alias name for its value) when it reads the first word of a command. An expanded alias is re-processed to check for more aliases. If a command alias ends in a space  or  tab,
       the following word is also checked for alias expansion. The alias expansion process stops when a word that is not an alias is found, when a quoted word is found, or when an alias word that is cur‐
       rently  being expanded is found. Aliases are specifically an interactive feature: while they do happen to work in scripts and on the command line in some cases, aliases are expanded during lexing,
       so their use must be in a separate command tree from their definition; otherwise, the alias will not be found. Noticeably, command lists (separated by semicolon, in command substitutions  also  by
       newline) may be one same parse tree.

       The following command aliases are defined automatically by the shell:

             autoload='\\builtin typeset -fu'
             functions='\\builtin typeset -f'
             hash='\\builtin alias -t'
             history='\\builtin fc -l'
             integer='\\builtin typeset -i'
             local='\\builtin typeset'
             login='\\builtin exec login'
             nameref='\\builtin typeset -n'
             nohup='nohup '
             r='\\builtin fc -e -'
             type='\\builtin whence -v'

       Tracked aliases allow the shell to remember where it found a particular command. The first time the shell does a path search for a command that is marked as a tracked alias, it saves the full path
       of the command. The next time the command is executed, the shell checks the saved path to see that it is still valid, and if so, avoids repeating the path search. Tracked aliases can be listed and
       created  using  alias -t. Note that changing the PATH parameter clears the saved paths for all tracked aliases. If the trackall option is set (i.e. set -o trackall or set -h), the shell tracks all
       commands. This option is set automatically for non-interactive shells. For interactive shells, only the following commands are automatically  tracked:  cat(1),  cc(1),  chmod(1),  cp(1),  date(1),
       ed(1), emacs(1), grep(1), ls(1), make(1), mv(1), pr(1), rm(1), sed(1), sh(1), vi(1) and who(1).

   Substitution
       The  first step the shell takes in executing a simple-command is to perform substitutions on the words of the command. There are three kinds of substitution: parameter, command and arithmetic. Pa‐
       rameter substitutions, which are described in detail in the next section, take the form $name or ${name...}; arithmetic substitutions take the form $((expression)); and command substitutions  take
       the  form  $(command) or (deprecated) `command` or (executed in the current environment) ${ command;} and evaluate to the output of command with any trailing newlines stripped. The latter form re‐
       quires a space, tab or newline after the opening brace and that the closing brace be recognised as a keyword (i.e. is preceded by a newline or semicolon). They are also  called  funsubs  (function
       substitutions)  and behave similar to functions in that shell options are shared and local and return work, though, in contrast to valsubs (see below), exit does not terminate the parent shell for
       compatibility with AT&T UNIX ksh93.

       Another variant of substitution are the valsubs (value substitutions) ${|command;} which are also executed in the current environment, like funsubs, but share their I/O with the  parent;  instead,
       they evaluate to whatever the, initially empty, expression-local variable REPLY is set to within the commands; exit affects the parent like in a function call.

       If  a  substitution  appears outside of double quotes, the results of the substitution are generally subject to word or field splitting according to the current value of the IFS parameter. The IFS
       parameter specifies a list of octets which are used to break a string up into several words; any octets from the set space, tab  and  newline  that  appear  in  the  IFS  octets  are  called  “IFS
       whitespace”.  Sequences  of one or more IFS whitespace octets, in combination with zero or one non-IFS whitespace octets, delimit a field. As a special case, leading and trailing IFS whitespace is
       stripped (i.e. no leading or trailing empty field is created by it); leading or trailing non-IFS whitespace does create an empty field.

       Example: If IFS is set to “<space>:” and VAR is set to “<space>A<space>:<space><space>B::D”, the substitution for $VAR results in four fields: “A”, “B”, “” (an empty field) and “D”. Note  that  if
       the IFS parameter is set to the empty string, no field splitting is done; if it is unset, the default value of space, tab and newline is used.

       Also, note that the field splitting applies only to the immediate result of the substitution. Using the previous example, the substitution for $VAR:E results in the fields: “A”, “B”, “” and “D:E”,
       not “A”, “B”, “”, “D” and “E”. This behaviour is POSIX compliant but incompatible with some other shell implementations which do field splitting on the word which contained the substitution or use
       IFS as a general whitespace delimiter.

       The results of substitution are, unless otherwise specified, also subject to brace expansion and file name expansion (see the relevant sections below).

       A  command substitution of the regular (comsub), deprecated, funsub or valsub form is replaced by the output generated by the specified command which is run in a subshell except for the funsub and
       valsub types which run in the current execution environment. For $(command), ${ command;} and ${|command;} forms, normal quoting rules are used when command is parsed; however, for the  deprecated
       `command`  form, a ‘\’ followed by any of ‘$’, ‘`’ or ‘\’ is stripped (as is ‘"’ when the substitution is part of a double-quoted string); a backslash followed by any other character is unchanged.
       As a special case in command substitutions, a command of the form <file is interpreted to mean substitute the contents of file so that $(<foo) has the same effect, if foo  is  readable,  as  $(cat
       foo) but is much more performant.

       Note  that some shells do not use a recursive parser for command substitutions, leading to failure for certain constructs; to be portable, use as workaround “x=$(cat) <<\EOF” (or the newline-keep‐
       ing “x=<<\EOF” extension) instead to merely slurp the string. IEEE Std 1003.1 (“POSIX.1”) recommends using case statements of the form x=$(case $foo in (bar) echo $bar ;; (*) echo  $baz  ;;  esac)
       instead, which would work but not serve as example for this portability issue.

             x=$(case $foo in bar) echo $bar ;; *) echo $baz ;; esac)
             # above fails to parse on old shells; below is the workaround
             x=$(eval $(cat)) <<\EOF
             case $foo in bar) echo $bar ;; *) echo $baz ;; esac
             EOF

       Arithmetic  substitutions are replaced by the value of the specified expression. For example, the command print $((2+3*4)) displays 14. See “Arithmetic expressions” for a description of an expres‐
       sion.

   Parameters
       Parameters are shell variables; they can be assigned values, and their values can be accessed using a parameter substitution. A parameter name is either one of the special single punctuation char‐
       acter or positional parameters described below, or a letter followed by zero or more letters, digits or underscores. The latter form can be accessed as array appending an index of the form  [expr]
       (in which expr is an arithmetic expression). Array indices range from 0 to 4294967295 (2^32-1), inclusive, in mksh.

       Parameter substitutions take the form $name, ${name} or ${name[expr]} where name is a parameter name. Substitutions of an array in scalar context, i.e. without an expr in the latter form mentioned
       above,  expand the element with the key “0”. Substitution of all array elements with ${name[*]} and ${name[@]} works equivalent to $* and $@ for positional parameters. If substitution is performed
       on a parameter (or an array parameter element) that is not set, an empty string is substituted unless the nounset option (set -u) is set, in which case an error occurs.

       Parameters can be assigned values in a number of ways. First, the shell implicitly sets some parameters like “#”, “PWD” and “$”; this is the only way the special single  character  parameters  are
       set.  Second, parameters are imported from the shell's environment at startup. Third, parameters can be assigned values on the command line: for example, FOO=bar sets the parameter “FOO” to “bar”;
       multiple parameter assignments can be given on a single command line and they can be followed by a simple-command, in which case the assignments are in effect only for the duration of the  command
       (such  assignments are also exported; see below for the implications of this). Note that both the parameter name and the ‘=’ must be unquoted for the shell to recognise a parameter assignment. The
       construct FOO+=baz is also recognised; the old and new values are string-concatenated with no separator. The fourth way of setting a parameter is with the export, readonly  and  typeset  commands;
       see  their  descriptions  in the “Command execution” section. Fifth, for and select loops set parameters as well as the getopts, read and set -A commands. Lastly, parameters can be assigned values
       using assignment operators inside arithmetic expressions (see “Arithmetic expressions” below) or using the ${name=value} form of the parameter substitution (see below).

       Parameters with the export attribute (set using the export or typeset -x commands, or by parameter assignments followed by simple commands) are put in the environment (see environ(7)) of  commands
       run by the shell as name=value pairs. When the shell starts up, it extracts parameters and their values from its environment setting the export attribute for those.

       Modifiers can be applied to the ${name} form of parameter substitution:

       ${name:-word}
               If name is set and not empty, it is substituted; otherwise, word is substituted.

       ${name:+word}
               If name is set and not empty, word is substituted; otherwise, nothing is substituted.

       ${name:=word}
               If name is set and not empty, it is substituted; otherwise, it is assigned word and the resulting value of name is substituted.

       ${name:?word}
               If name is set and not empty, it is substituted; otherwise, word is printed on standard error (preceded by name:) and an error occurs (normally causing termination of a shell script, func‐
               tion, or a script sourced using the “.” built-in). If word is omitted, the string “parameter null or not set” is used instead.

       Note  that, for all of the above, word is actually considered quoted, and special parsing rules apply. The parsing rules also differ on whether the expression is double-quoted: word then uses dou‐
       ble-quoting rules, except for the double quote itself (‘"’) and the closing brace, which, if backslash escaped, gets quote removal applied.

       In the above modifiers, the ‘:’ can be omitted, in which case the conditions only depend on name being set (as opposed to set and not empty). If word is needed, parameter, command, arithmetic  and
       tilde substitution are performed on it; if word is not needed, it is not evaluated.

       The following forms of parameter substitution can also be used:

       ${#name}
               The number of positional parameters if name is “*”, “@” or not specified; otherwise the length (in characters) of the string value of parameter name.

       ${#name[*]}
       ${#name[@]}
               The number of elements in the array name.

       ${%name}
               The width (in screen columns) of the string value of parameter name, or -1 if ${name} contains a control character.

       ${!name}
               The  name  of  the variable referred to by name. This will be name except when name is a name reference (bound variable), created by the nameref command (which is an alias for typeset -n).
               name cannot be one of most special parameters (see below).

       ${!name[*]}
       ${!name[@]}
               The names of indices (keys) in the array name.

       ${name#pattern}
       ${name##pattern}
               If pattern matches the beginning of the value of parameter name, the matched text is deleted from the result of substitution. A single ‘#’ results in the shortest match, and  two  of  them
               result in the longest match.

       ${name%pattern}
       ${name%%pattern}
               Like ${...#...} but deletes from the end of the value.

       ${name/pattern/string}
       ${name/#pattern/string}
       ${name/%pattern/string}
       ${name//pattern/string}
               The longest match of pattern in the value of parameter name is replaced with string (deleted if string is empty; the trailing slash (‘/’) may be omitted in that case). A leading slash fol‐
               lowed by ‘#’ or ‘%’ causes the pattern to be anchored at the beginning or end of the value, respectively; empty unanchored patterns cause no replacement; a single leading slash or use of a
               pattern  that  matches  the  empty  string causes the replacement to happen only once; two leading slashes cause all occurrences of matches in the value to be replaced. May be slow on long
               strings.

       ${name@/pattern/string}
               The same as ${name//pattern/string}, except that both pattern and string are expanded anew for each iteration. Use with KSH_MATCH.

       ${name:pos:len}
               The first len characters of name, starting at position pos, are substituted. Both pos and :len are optional. If pos is negative, counting starts at the end of the string; if it is omitted,
               it defaults to 0. If len is omitted or greater than the length of the remaining string, all of it is substituted. Both pos and len are evaluated as arithmetic expressions.

       ${name@#}
               The hash (using the BAFH1-0 algorithm) of the expansion of name. This is also used internally for the shell's hashtables.

       ${name@Q}
               A quoted expression safe for re-entry, whose value is the value of the name parameter, is substituted.

       ${name@^}
               The value of name in extended caret notation, with both caret (‘^’) and backslash (‘\’) backslash-escaped to avoid ambiguity.

       Note that pattern may need extended globbing pattern (@(...)), single ('...') or double ("...") quote escaping unless -o sh is set.

       The following special parameters are implicitly set by the shell and cannot be set directly using assignments:

       !       Process ID of the last background process started. If no background processes have been started, the parameter is not set.

       #       The number of positional parameters ($1, $2, etc.).

       $       The PID of the shell or, if it is a subshell, the PID of the original shell. Do NOT use this mechanism for generating temporary file names; see mktemp(1) instead.

       -       The concatenation of the current single letter options (see the set command below for a list of options).

       ?       The exit status of the last non-asynchronous command executed. If the last command was killed by a signal, $? is set to 128 plus the signal number, but at most 255.

       0       The name of the shell, determined as follows: the first argument to mksh if it was invoked with the -c option and arguments were given; otherwise the file argument, if it was supplied;  or
               else  the  name the shell was invoked with (i.e. argv[0]). $0 is also set to the name of the current script, or to the name of the current function if it was defined with the function key‐
               word (i.e. a Korn shell style function).

       1 .. 9  The first nine positional parameters that were supplied to the shell, function, or script sourced using the “.” (“dot”)  builtin.  Further  positional  parameters  may  be  accessed  using
               ${number}.

       *       All positional parameters (except 0), i.e. $1, $2, $3, ...
               If  used  outside  of double quotes, parameters are separate words (which are subjected to word splitting); if used within double quotes, parameters are separated by the first character of
               the IFS parameter (or the empty string if IFS is unset.

       @       Same as $*, unless it is used inside double quotes, in which case a separate word is generated for each positional parameter. If there are no positional parameters, no word  is  generated.
               "$@" can be used to access arguments, verbatim, without losing empty arguments or splitting arguments with spaces (IFS, actually).

       The following parameters are set and/or used by the shell:

       _            (underscore)  When  an  external command is executed by the shell, this parameter is set in the environment of the new process to the path of the executed command. In interactive use,
                    this parameter is also set in the parent shell to the last word of the previous command.

       BASHPID      The PID of the shell or subshell.

       CDPATH       Like PATH, but used to resolve the argument to the cd built-in command. Note that if CDPATH is set and does not contain “.” or an empty string element, the current  directory  is  not
                    searched. Also, the cd built-in command will display the resulting directory when a match is found in any search path other than the empty path.

       COLUMNS      Set  to  the  number of columns on the terminal or window. If never unset and not imported, always set dynamically; unless the value as reported by stty(1) is non-zero and sane enough
                    (minimum is 12x3), defaults to 80; similar for LINES. This parameter is used by the interactive line editing modes and by the select, set -o and kill -l commands to format information
                    columns. Importing from the environment or unsetting this parameter removes the binding to the actual terminal size in favour of the provided value.

       ENV          If this parameter is found to be set after any profile files are executed, the expanded value is used as a shell startup file. It typically contains function and alias definitions.

       EPOCHREALTIME
                    Time since the epoch, as returned by gettimeofday(2), formatted as decimal tv_sec followed by a dot (‘.’) and tv_usec padded to exactly six decimal digits.

       EXECSHELL    If set, this parameter is assumed to contain the shell that is to be used to execute commands that execve(2) fails to execute and which do not start with a “#!shell” sequence.

       FCEDIT       The editor used by the fc command (see below).

       FPATH        Like PATH, but used when an undefined function is executed (or when a command cannot be found using PATH) to locate the function definition file. See “Functions” below.

       HISTFILE     The name of the file used to store command history. When assigned to or unset, the file is opened, history is truncated then loaded from the file; subsequent  new  commands  (possibly
                    consisting of several lines) are appended once they successfully compiled. Also, several invocations of the shell will share history if their HISTFILE parameters all point to the same
                    file.

                    Note: If HISTFILE is unset or empty, no history file is used. This is different from AT&T UNIX ksh.

       HISTSIZE     The number of commands normally stored for history. The default is 2047. The maximum is 65535.

       HOME         The default directory for the cd command and the value substituted for an unqualified ~ (see “Tilde expansion” below).

       IFS          Internal  field  separator, used during substitution and by the read command, to split values into distinct arguments; normally set to space, tab and newline. See “Substitution” above
                    for details.

                    Note: This parameter is not imported from the environment when the shell is started.

       KSHEGID      The effective group id of the shell at startup.

       KSHGID       The real group id of the shell at startup.

       KSHUID       The real user id of the shell at startup.

       KSH_MATCH    The last matched string. In a future version, this will be an indexed array, with indexes 1 and up capturing matching groups. Set by string comparisons (= and  !=)  in  double-bracket
                    test  expressions  when  a  match  is  found (when != returns false), by case when a match is encountered, and by the substitution operations ${x#pat}, ${x##pat}, ${x%pat}, ${x%%pat},
                    ${x/pat/rpl}, ${x/#pat/rpl}, ${x/%pat/rpl}, ${x//pat/rpl}, and ${x@/pat/rpl}. See the end of the Emacs editing mode documentation for an example.

       KSH_VERSION  The name (self-identification) and version of the shell (read-only). See also the version commands in “Emacs editing mode” and “Vi editing mode” sections, below.

       LINENO       The line number of the function or shell script that is currently being executed.

       LINES        Set to the number of lines on the terminal or window. Defaults to 24; always set, unless imported or unset. See COLUMNS.

       OLDPWD       The previous working directory. Unset if cd has not successfully changed directories since the shell started or if the shell doesn't know where it is.

       OPTARG       When using getopts, it contains the argument for a parsed option, if it requires one.

       OPTIND       The index of the next argument to be processed when using getopts. Assigning 1 to this parameter causes getopts to process arguments from the beginning the next time it is invoked.

       PATH         A colon (semicolon on OS/2) separated list of directories that are searched when looking for commands and files sourced using the “.” command (see below). An  empty  string  resulting
                    from a leading or trailing (semi)colon, or two adjacent ones, is treated as a “.” (the current directory).

       PATHSEP      A colon (semicolon on OS/2), for the user's convenience.

       PGRP         The process ID of the shell's process group leader.

       PIPESTATUS   An array containing the errorlevel (exit status) codes, one by one, of the last pipeline run in the foreground.

       PPID         The process ID of the shell's parent.

       PS1          The  primary  prompt for interactive shells. Parameter, command and arithmetic substitutions are performed, and ‘!’ is replaced with the current command number (see the fc command be‐
                    low). A literal ‘!’ can be put in the prompt by placing “!!” in PS1.

                    The default prompt is “$ ” for non-root users, “# ” for root. If mksh is invoked by root and PS1 does not contain a ‘#’ character, the default value will be used even if  PS1  already
                    exists in the environment.

                    The  mksh distribution comes with a sample dot.mkshrc containing a sophisticated example, but you might like the following one (note that ${HOSTNAME:=$(hostname)} and the root-vs-user
                    distinguishing clause are (in this example) executed at PS1 assignment time, while the $USER and $PWD are escaped and thus will be evaluated each time a prompt is displayed):

                    PS1='${USER:=$(id -un)}'"@${HOSTNAME:=$(hostname)}:\$PWD $(
                            if (( USER_ID )); then print \$; else print \#; fi) "

                    Note that since the command-line editors try to figure out how long the prompt is (so they know how far it is to the edge of the screen), escape codes  in  the  prompt  tend  to  mess
                    things  up.  You  can tell the shell not to count certain sequences (such as escape codes) by prefixing your prompt with a character (such as Ctrl-A) followed by a carriage return and
                    then delimiting the escape codes with this character. Any occurrences of that character in the prompt are not printed. By the way, don't blame me for this hack; it's derived from  the
                    original ksh88(1), which did print the delimiter character so you were out of luck if you did not have any non-printing characters.

                    Since  backslashes and other special characters may be interpreted by the shell, to set PS1 either escape the backslash itself or use double quotes. The latter is more practical. This
                    is a more complex example, avoiding to directly enter special characters (for example with ^V in the emacs editing mode), which embeds the current working directory, in reverse  video
                    (colour would work, too), in the prompt string:

                          x=$(print \\001) # otherwise unused char
                          PS1="$x$(print \\r)$x$(tput so)$x\$PWD$x$(tput se)$x> "

                    Due to a strong suggestion from David G. Korn, mksh now also supports the following form:

                          PS1=$'\1\r\1\e[7m\1$PWD\1\e[0m\1> '

       PS2          Secondary prompt string, by default “> ”, used when more input is needed to complete a command.

       PS3          Prompt used by the select statement when reading a menu selection. The default is “#? ”.

       PS4          Used  to  prefix commands that are printed during execution tracing (see the set -x command below). Parameter, command and arithmetic substitutions are performed before it is printed.
                    The default is “+ ”. You may want to set it to “[$EPOCHREALTIME] ” instead, to include timestamps.

       PWD          The current working directory. May be unset or empty if the shell doesn't know where it is.

       RANDOM       Each time RANDOM is referenced, it is assigned a number between 0 and 32767 from a Linear Congruential PRNG first.

       REPLY        Default parameter for the read command if no names are given. Also used in select loops to store the value that is read from standard input.

       SECONDS      The number of seconds since the shell started or, if the parameter has been assigned an integer value, the number of seconds since the assignment plus the value that was assigned.

       TMOUT        If set to a positive integer in an interactive shell, it specifies the maximum number of seconds the shell will wait for input after printing the primary prompt (PS1). If the time  is
                    exceeded, the shell exits.

       TMPDIR       The directory temporary shell files are created in. If this parameter is not set or does not contain the absolute path of a writable directory, temporary files are created in /tmp.

       USER_ID      The effective user id of the shell at startup.

   Tilde expansion
       Tilde  expansion,  which  is  done in parallel with parameter substitution, is applied to words starting with an unquoted ‘~’. In parameter assignments (such as those preceding a simple-command or
       those occurring in the arguments of a declaration utility), tilde expansion is done after any assignment (i.e. after the equals sign) or after an unquoted colon (‘:’); login names are also  delim‐
       ited by colons. The Korn shell, except in POSIX mode, always expands tildes after unquoted equals signs, not just in assignment context (see below), and enables tab completion for tildes after all
       unquoted colons during command line editing.

       The  characters  following the tilde, up to the first ‘/’, if any, are assumed to be a login name. If the login name is empty, ‘+’ or ‘-’, the simplified value of the HOME, PWD or OLDPWD parameter
       is substituted, respectively. Otherwise, the password file is searched for the login name, and the tilde expression is substituted with the user's home directory. If the login name is not found in
       the password file or if any quoting or parameter substitution occurs in the login name, no substitution is performed.

       The home directory of previously expanded login names are cached and re-used. The alias -d command may be used to list, change and add to this cache (e.g. alias  -d  fac=/usr/local/facilities;  cd
       ~fac/bin).

   Brace expansion (alternation)
       Brace expressions take the following form:

             prefix{str1,...,strN}suffix

       The  expressions  are expanded to N words, each of which is the concatenation of prefix, stri and suffix (e.g. “a{c,b{X,Y},d}e” expands to four words: “ace”, “abXe”, “abYe” and “ade”). As noted in
       the example, brace expressions can be nested and the resulting words are not sorted. Brace expressions must contain an unquoted comma (‘,’) for expansion to occur (e.g. {} and {foo}  are  not  ex‐
       panded). Brace expansion is carried out after parameter substitution and before file name generation.

   File name patterns
       A  file name pattern is a word containing one or more unquoted ‘?’, ‘*’, ‘+’, ‘@’ or ‘!’ characters or “[...]” sequences. Once brace expansion has been performed, the shell replaces file name pat‐
       terns with the sorted names of all the files that match the pattern (if no files match, the word is left unchanged). The pattern elements have the following meaning:

       ?       Matches any single character.

       *       Matches any sequence of octets.

       [...]   Matches any of the octets inside the brackets. Ranges of octets can be specified by separating two octets by a ‘-’ (e.g. “[a0-9]” matches the letter ‘a’ or any  digit).  Character  classes
               can be specified by wrapping the name of the class between “[:” and “:]” (e.g. “[[:alpha:][:digit:].]” matches any ASCII letter or digit and the full stop).

               In  order  to represent itself, a ‘-’ must either be quoted or the first or last octet in the octet list. Similarly, if it is to represent itself instead of the end of the list, a ‘]’ must
               be quoted or the first octet in the list. Also, an ‘!’ appearing at the start of the list has special meaning (see below), so to represent itself it must be quoted or appear later  in  the
               list. ‘^’ at the beginning of the list must be quoted or appear later.

       [!...]  Like [...], except it matches any octet not inside the brackets.

       *(pattern|...|pattern)
               Matches any string of octets that matches zero or more occurrences of the specified patterns. Example: The pattern *(foo|bar) matches the strings “”, “foo”, “bar”, “foobarfoo”, etc.

       +(pattern|...|pattern)
               Matches any string of octets that matches one or more occurrences of the specified patterns. Example: The pattern +(foo|bar) matches the strings “foo”, “bar”, “foobar”, etc.

       ?(pattern|...|pattern)
               Matches the empty string or a string that matches one of the specified patterns. Example: The pattern ?(foo|bar) only matches the strings “”, “foo” and “bar”.

       @(pattern|...|pattern)
               Matches a string that matches one of the specified patterns. Example: The pattern @(foo|bar) only matches the strings “foo” and “bar”.

       !(pattern|...|pattern)
               Matches  any string that does not match one of the specified patterns. Examples: The pattern !(foo|bar) matches all strings except “foo” and “bar”; the pattern !(*) matches no strings; the
               pattern !(?)* matches all strings (think about it).

       The following character classes are supported (note all POSIX references assume the C locale; EBCDIC systems use the bytes from the codepage  that  map  to  the  named  ASCII  characters  so  e.g.
       “[[:upper:]]” is correct while “[A-Z]” will contain probably-unwanted characters on EBCDIC systems):

             <         (BSD) the null string at the beginning of a word
             >         (BSD) the null string at the end of a word
             alnum     (POSIX) alphanumerical (alpha or digit)
             alpha     (POSIX) alphabetical (upper or lower)
             ascii     (GNU bash) any 7-bit ASCII character except NUL
             blank     (POSIX) space or horizontal tab
             cntrl     (POSIX) ASCII C0 control characters (\x00–\x1F) or \x7F
             digit     (POSIX) ASCII decimal digits (0–9)
             graph     (POSIX) alnum or punct (!–~)
             lower     (POSIX) ASCII lowercase letters (a–z)
             print     (POSIX) space or graph (\x20–~)
             punct     (POSIX) punctuation (graph except alnum): !"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~
             sh_alias  (mksh) valid in alias names: alnum or !%+,-.:@[]_
             sh_edq    (mksh) quoted by tab completion: "#$&'()*:;<=>?[\\`{|}~
             sh_ifs    (mksh) IFS whitespace, IFS non-whitespace, NUL (via $IFS)
             sh_ifsws  (mksh) IFS WS candidates: space, horizontal tab, linefeed
             sh_nl     (mksh) linefeed or (OS/2 TEXTMODE only) carriage return
             sh_quote  (mksh) characters requiring quoting, minus space: \x09\x0A"#$&'()*;<=>?[\\]`{|}~
             space     (POSIX) horizontal tab, line feed, vertical tab, form feed, carriage return, space (\x09–\x0D\x20)
             upper     (POSIX) ASCII uppercase letters (A–Z)
             word      (GNU bash) alphanumerical (alnum) or underscore (“_”)
             xdigit    (POSIX) hexadecimal digits (0–9A–Fa–f) a.k.a. nybbles

       Note that complicated globbing, especially with alternatives, is slow; using separate comparisons may (or may not) be faster.

       Note that mksh (and pdksh) never matches “.” and “..”, but AT&T UNIX ksh, Bourne sh and GNU bash do.

       Note that none of the above pattern elements match either a period (‘.’) at the start of a file name or a slash (‘/’), even if they are explicitly used in a [...] sequence; also, the names “.” and
       “..” are never matched, even by the pattern “.*”.

       If the markdirs option is set, any directories that result from file name generation are marked with a trailing ‘/’.

   Input/output redirection
       When  a  command is executed, its standard input, standard output and standard error (file descriptors 0, 1 and 2, respectively) are normally inherited from the shell. Three exceptions to this are
       commands in pipelines, for which standard input and/or standard output are those set up by the pipeline, asynchronous commands created when job control is disabled, for  which  standard  input  is
       initially set to /dev/null, and commands for which any of the following redirections have been specified:

       >file       Standard output is redirected to file. If file does not exist, it is created; if it does exist, is a regular file, and the noclobber option is set, an error occurs; otherwise, the file
                   is truncated. Note that this means the command cmd <foo >foo will open foo for reading and then truncate it when it opens it for writing, before cmd gets a chance to actually read foo.

       >|file      Same as >, except the file is truncated, even if the noclobber option is set.

       >>file      Same as >, except if file exists it is appended to instead of being truncated. Also, the file is opened in append mode, so writes always go to the end of the file (see open(2)).

       <file       Standard input is redirected from file, which is opened for reading.

       <>file      Same as <, except the file is opened for reading and writing.

       <<marker    After  reading the command line containing this kind of redirection (called a “here document”), the shell copies lines from the command source into a temporary file until a line match‐
                   ing marker is read. When the command is executed, standard input is redirected from the temporary file. If marker contains no quoted characters, the contents of the temporary file  are
                   processed  as  if  enclosed in double quotes each time the command is executed, so parameter, command and arithmetic substitutions are performed, along with backslash (‘\’) escapes for
                   ‘$’, ‘`’, ‘\’ and “\newline”, but not for ‘"’. If multiple here documents are used on the same command line, they are saved in order.

                   If no marker is given, the here document ends at the next << and substitution will be performed. If marker is only a set of either single “''” or double ‘""’ quotes with nothing in be‐
                   tween, the here document ends at the next empty line and substitution will not be performed.

       <<-marker   Same as <<, except leading tabs are stripped from lines in the here document.

       <<<word     Same as <<, except that word is the here document. This is called a here string.

       <&fd        Standard input is duplicated from file descriptor fd. fd can be a single digit, indicating the number of an existing file descriptor; the letter ‘p’, indicating the file descriptor as‐
                   sociated with the output of the current co-process; or the character ‘-’, indicating standard input is to be closed.

       >&fd        Same as <&, except the operation is done on standard output.

       &>file      Same as >file 2>&1. This is a deprecated (legacy) GNU bash extension supported by mksh which also supports the preceding explicit fd digit, for example, 3&>file is the same  as  3>file
                   2>&3 in mksh but a syntax error in GNU bash.

       &>|file, &>>file, &>&fd
                   Same as >|file, >>file or >&fd, followed by 2>&1, as above. These are mksh extensions.

       In  any of the above redirections, the file descriptor that is redirected (i.e. standard input or standard output) can be explicitly given by preceding the redirection with a single digit. Parame‐
       ter, command and arithmetic substitutions, tilde substitutions, and, if the shell is interactive, file name generation are all performed on the file, marker and fd arguments of redirections. Note,
       however, that the results of any file name generation are only used if a single file is matched; if multiple files match, the word with the expanded file name generation characters is  used.  Note
       that in restricted shells, redirections which can create files cannot be used.

       For  simple-commands,  redirections  may  appear  anywhere  in  the  command; for compound-commands (if statements, etc.), any redirections must appear at the end. Redirections are processed after
       pipelines are created and in the order they are given, so the following will print an error with a line number prepended to it:

             $ cat /foo/bar 2>&1 >/dev/null | pr -n -t

       File descriptors created by I/O redirections are private to the shell.

   Arithmetic expressions
       Integer arithmetic expressions can be used with the let command, inside $((...)) expressions, inside array references (e.g. name[expr]), as numeric arguments to the test command, and as the  value
       of  an assignment to an integer parameter. Warning: This also affects implicit conversion to integer, for example as done by the let command. Never use unchecked user input, e.g. from the environ‐
       ment (although the shell tracks import status and refuses to automatically coerce those), in arithmetic context!

       Expressions are calculated using signed arithmetic and the mksh_ari_t type (a 32-bit signed integer), unless they begin with a sole ‘#’ character, in which case  they  use  mksh_uari_t  (a  32-bit
       unsigned integer).

       Expressions  may  contain  alpha-numeric parameter identifiers, array references and integer constants and may be combined with the following C operators (listed and grouped in increasing order of
       precedence):

       Unary operators:

             + - ! ~ ++ --

       Binary operators:

             ,
             = += -= *= /= %= <<= >>= ^<= ^>= &= ^= |=
             ||
             &&
             |
             ^
             &
             == !=
             < <= > >=
             << >> ^< ^>
             + -
             * / %

       Ternary operators:

             ?: (precedence is immediately higher than assignment)

       Grouping operators:

             ( )

       Integer constants and expressions are calculated using an exactly 32-bit wide, signed (two's complement) or unsigned, type with silent wraparound on integer  overflow.  Integer  constants  may  be
       specified  with  arbitrary bases using the notation base#number, where base is a decimal integer specifying the base (up to 36), and number is a number in the specified base. Additionally, base-16
       integers may be specified by prefixing with “0x” (case-insensitive) in all forms of arithmetic expressions, except as numeric arguments to the test built-in utility. Prefixing numbers with a  sole
       digit  zero  (“0”)  does  not  cause interpretation as octal (except in POSIX mode, as required by the standard), as that's unsafe. Prefixing with “10#” forces interpretation as decimal, even with
       leading zeros. An unset or empty parameter evaluates to 0 in integer context.

       As a special mksh extension, numbers to the base of one are treated as either (8-bit transparent) ASCII or Universal Coded Character Set codepoints, depending on the shell's utf8-mode  flag  (cur‐
       rent  setting).  The  AT&T  UNIX  ksh93 syntax of “'x'” instead of “1#x” is also supported. Note that NUL bytes (integral value of zero) cannot be used. If ‘x’ isn't comprised of exactly one valid
       character, the behaviour is undefined (usually, the shell aborts with a parse error, but rarely, it succeeds, e.g. on the sequence C2 20); users of this feature (as opposed to read -a) must  vali‐
       date  the  input first. See “CAVEATS” for UTF-8 mode handling. Base-1 integers don't work well with a number of other shell features, such as reentry-safe output; use print -A or read -a if possi‐
       ble.

       The operators are evaluated as follows:

             unary +
                     Result is the argument (included for completeness).

             unary -
                     Negation.

             !       Logical NOT; the result is 1 if argument is zero, 0 if not.

             ~       Arithmetic (bit-wise) NOT.

             ++      Increment; must be applied to a parameter (not a literal or other expression). The parameter is incremented by 1. When used as a prefix operator, the result is the incremented  value
                     of the parameter; when used as a postfix operator, the result is the original value of the parameter.

             --      Similar to ++, except the parameter is decremented by 1.

             ,       Separates two arithmetic expressions; the left-hand side is evaluated first, then the right. The result is the value of the expression on the right-hand side.

             =       Assignment; the variable on the left is set to the value on the right.

             += -= *= /= %= <<= >>= ^<= ^>= &= ^= |=
                     Assignment  operators. <var><op>=<expr> is the same as <var>=<var><op><expr>, with any operator precedence in <expr> preserved. For example, “var1 *= 5 + 3” is the same as specifying
                     “var1 = var1 * (5 + 3)”.

             ||      Logical OR; the result is 1 if either argument is non-zero, 0 if not. The right argument is evaluated only if the left argument is zero.

             &&      Logical AND; the result is 1 if both arguments are non-zero, 0 if not. The right argument is evaluated only if the left argument is non-zero.

             |       Arithmetic (bit-wise) OR.

             ^       Arithmetic (bit-wise) XOR (exclusive-OR).

             &       Arithmetic (bit-wise) AND.

             ==      Equal; the result is 1 if both arguments are equal, 0 if not.

             !=      Not equal; the result is 0 if both arguments are equal, 1 if not.

             <       Less than; the result is 1 if the left argument is less than the right, 0 if not.

             <= > >=
                     Less than or equal, greater than, greater than or equal. See <.

             << >>   Shift left (right); the result is the left argument with its bits arithmetically (signed operation) or logically (unsigned expression) shifted left (right) by the amount given in the
                     right argument.

             ^< ^>   Rotate left (right); the result is similar to shift, except that the bits shifted out at one end are shifted in at the other end, instead of zero or sign bits.

             + - * /
                     Addition, subtraction, multiplication and division.

             %       Remainder; the result is the symmetric remainder of the division of the left argument by the right. To get the mathematical modulus of “a mod b”, use the formula “(a % b + b) % b”.

             <arg1>?<arg2>:<arg3>
                     If <arg1> is non-zero, the result is <arg2>; otherwise the result is <arg3>. The non-result argument is not evaluated.

   Co-processes
       A co-process (which is a pipeline created with the “|&” operator) is an asynchronous process that the shell can both write to (using print -p) and read from (using read -p). The input  and  output
       of  the  co-process  can also be manipulated using >&p and <&p redirections, respectively. Once a co-process has been started, another can't be started until the co-process exits, or until the co-
       process's input has been redirected using an exec n>&p redirection. If a co-process's input is redirected in this way, the next co-process to be started will share the output with  the  first  co-
       process, unless the output of the initial co-process has been redirected using an exec n<&p redirection.

       Some notes concerning co-processes:

       •   The  only  way  to  close the co-process's input (so the co-process reads an end-of-file) is to redirect the input to a numbered file descriptor and then close that file descriptor: exec 3>&p;
           exec 3>&-

       •   In order for co-processes to share a common output, the shell must keep the write portion of the output pipe open. This means that end-of-file will not be detected until all co-processes shar‐
           ing the co-process's output have exited (when they all exit, the shell closes its copy of the pipe). This can be avoided by redirecting the output to a numbered file descriptor (as  this  also
           causes  the  shell  to close its copy). Note that this behaviour is slightly different from the original Korn shell which closes its copy of the write portion of the co-process output when the
           most recently started co-process (instead of when all sharing co-processes) exits.

       •   print -p will ignore SIGPIPE signals during writes if the signal is not being trapped or ignored; the same is true if the co-process input has been duplicated to another  file  descriptor  and
           print -un is used.

   Functions
       Functions  are  defined  using  either Korn shell function function-name syntax or the Bourne/POSIX shell function-name() syntax (see below for the difference between the two forms). Functions are
       like .‐scripts (i.e. scripts sourced using the “.” built-in) in that they are executed in the current environment. However, unlike .‐scripts, shell arguments (i.e. positional  parameters  $1,  $2,
       etc.) are never visible inside them. When the shell is determining the location of a command, functions are searched after special built-in commands, before builtins and the PATH is searched.

       An  existing  function  may  be deleted using unset -f function-name. A list of functions can be obtained using typeset +f and the function definitions can be listed using typeset -f. The autoload
       command (which is an alias for typeset -fu) may be used to create undefined functions: when an undefined function is executed, the shell searches the path specified in the FPATH  parameter  for  a
       file  with the same name as the function which, if found, is read and executed. If after executing the file the named function is found to be defined, the function is executed; otherwise, the nor‐
       mal command search is continued (i.e. the shell searches the regular built-in command table and PATH). Note that if a command is not found using PATH, an attempt is made to autoload a function us‐
       ing FPATH (this is an undocumented feature of the original Korn shell).

       Functions can have two attributes, “trace” and “export”, which can be set with typeset -ft and typeset -fx, respectively. When a traced function is executed, the shell's xtrace option is turned on
       for the function's duration. The “export” attribute of functions is currently not used.

       Since functions are executed in the current shell environment, parameter assignments made inside functions are visible after the function completes. If this is not the desired effect, the  typeset
       command can be used inside a function to create a local parameter. Note that AT&T UNIX ksh93 uses static scoping (one global scope, one local scope per function) and allows local variables only on
       Korn style functions, whereas mksh uses dynamic scoping (nested scopes of varying locality). Note that special parameters (e.g. $$, $!) can't be scoped in this way.

       The exit status of a function is that of the last command executed in the function. A function can be made to finish immediately using the return command; this may also be used to explicitly spec‐
       ify the exit status. Note that when called in a subshell, return will only exit that subshell and will not cause the original shell to exit a running function (see the while...read loop FAQ).

       Functions defined with the function reserved word are treated differently in the following ways from functions defined with the () notation:

       •   The $0 parameter is set to the name of the function (Bourne-style functions leave $0 untouched).

       •   OPTIND  is  saved/reset and restored on entry and exit from the function so getopts can be used properly both inside and outside the function (Bourne-style functions leave OPTIND untouched, so
           using getopts inside a function interferes with using getopts outside the function).

       •   Shell options (set -o) except -p (-o privileged) have local scope, i.e. changes inside a function are reset upon its exit.

       In the future, the following differences may also be added:

       •   A separate trap/signal environment will be used during the execution of functions. This will mean that traps set inside a function will not affect the shell's traps and signals  that  are  not
           ignored in the shell (but may be trapped) will have their default effect in a function.

       •   The EXIT trap, if set in a function, will be executed after the function returns.

   Command execution
       After  evaluation  of  command-line  arguments, redirections and parameter assignments, the type of command is determined: a special built-in command, a function, a normal builtin or the name of a
       file to execute found using the PATH parameter. The checks are made in the above order. Special built-in commands differ from other commands in that the PATH parameter is not used to find them, an
       error during their execution can cause a non-interactive shell to exit, and parameter assignments that are specified before the command are kept after the command completes. Regular built-in  com‐
       mands are different only in that the PATH parameter is not used to find them.

       POSIX special built-in utilities:

       ., :, break, continue, eval, exec, exit, export, readonly, return, set, shift, times, trap, unset

       Additional mksh commands keeping assignments:

       source, typeset

       All other builtins are not special; these are at least:

       [, alias, bg, bind, builtin, cd, command, echo, false, fc, fg, getopts, jobs, kill, let, print, pwd, read, realpath, rename, suspend, test, true, ulimit, umask, unalias, wait, whence

       Once the type of command has been determined, any command-line parameter assignments are performed and exported for the duration of the command.

       The following describes the special and regular built-in commands and builtin-like reserved words, as well as some optional utilities:

       . file [arg ...]
              (keeps assignments, special) This is called the “dot” command. Execute the commands in file in the current environment. The file is searched for in the directories of PATH. If arguments are
              given,  the  positional  parameters may be used to access them while file is being executed. If no arguments are given, the positional parameters are those of the environment the command is
              used in.

       : [...]
              (keeps assignments, special) The null command.
              Exit status is set to zero.

       Lb64decode [string]
              (dot.mkshrc function) Decode string or standard input to binary.

       Lb64encode [string]
              (dot.mkshrc function) Encode string or standard input as base64.

       Lbafh_init
       Lbafh_add [string]
       Lbafh_finish
              (dot.mkshrc functions) Implement the Better Avalance for Jenkins Hash (IV=1). This is the same hash mksh currently uses internally. After calling Lbafh_init, call Lbafh_add  multiple  times
              until all input is read, then call Lbafh_finish, which writes the result to the unsigned integer Lbafh_v variable for your consumption.

       Lstripcom [file ...]
              (dot.mkshrc function) Same as cat(1) but strips any empty lines and comments (from any ‘#’ character onwards, no escapes) and reduces any amount of whitespace to one space character.

       [ expression ]
              (regular) See test.

       alias [-d | -t [-r] | -+x] [-p] [+] [name[=value] ...]
              (regular)  Without  arguments,  alias  lists  all  aliases.  For  any  name  without  a  value,  the  existing  alias is listed. Any name with a value defines an alias; see “Aliases” above.
              [][A-Za-z0-9_!%+,.@:-] are valid in names, except they may not begin with a plus or hyphen-minus, and [[ is not a valid alias name.

              When listing aliases, one of two formats is used. Normally, aliases are listed as name=value, where value is quoted as necessary. If options were preceded with ‘+’, or a lone ‘+’  is  given
              on the command line, only name is printed.

              The -d option causes directory aliases which are used in tilde expansion to be listed or set (see “Tilde expansion” above).

              With -p, each alias is listed with the string “alias ” prefixed.

              The -t option indicates that tracked aliases are to be listed/set (values given with the command are ignored for tracked aliases).

              The -r option indicates that all tracked aliases are to be reset.

              The -x option sets (+x clears) the export attribute of an alias, or, if no names are given, lists the aliases with the export attribute (exporting an alias has no effect).

       autoload
              (built-in alias) See “Functions” above.

       bg [job ...]
              (regular, needs job control) Resume the specified stopped job(s) in the background. If no jobs are specified, %+ is assumed. See “Job control” below for more information.

       bind -l
              (regular) The names of editing commands strings can be bound to are listed. See “Emacs editing mode” for more information.

       bind [string ...]
              The current bindings, for string, if given, else all, are listed. Note: Default prefix bindings (1=Esc, 2=^X, 3=NUL) assumed.

       bind string=[editing-command] [...]
       bind -m string=substitute [...]
              To  string, which should consist of a control character optionally preceded by one of the three prefix characters and optionally succeeded by a tilde character, the editing-command is bound
              so that future input of the string will immediately invoke that editing command. If a tilde postfix is given, a tilde trailing the control character is ignored. If -m (macro) is given,  fu‐
              ture  input  of  the string will be replaced by the given NUL-terminated substitute string, wherein prefix/control/tilde characters mapped to editing commands (but not those mapped to other
              macros) will be processed.

              The entire argument may be written using extended caret notation: ^Z represents Ctrl-Z; ^+Z represents UTF-8 Meta-Ctrl-Z, and both ^!Z and \x9A represent  ASCII  Meta-Ctrl-Z.  Otherwise,  a
              backslash  escapes  the  next  character,  removing  the special meaning from backslashes, carets and (for the string part) equals signs. (These backslashes obviously must be quoted for the
              shell.) Note that, although only three prefix characters (usually Esc, ^X and NUL) are usable, some multi-character sequences can be supported.

       break [level]
              (keeps assignments, special) Exit the levelth inner-most for, select, until or while loop. level defaults to 1.

       builtin [--] command [arg ...]
              (regular) Execute the built-in command command.

       \builtin command [arg ...]
              (regular, decl-forwarder) Same as builtin. Additionally acts as declaration utility forwarder, i.e. this is a declaration utility (see “Tilde expansion”) iff command is a declaration  util‐
              ity.

       cd [-L] [dir]
       cd -P [-e] [dir]
       chdir [-eLP] [dir]
              (regular) Set the working directory to dir. If the parameter CDPATH is set, it lists the search path for the directory containing dir. An unset or empty path means the current directory. If
              dir  is  found in any component of the CDPATH search path other than an unset or empty path, the name of the new working directory will be written to standard output. If dir is missing, the
              home directory HOME is used. If dir is “-”, the previous working directory is used (see the OLDPWD parameter).

              If the -L option (logical path) is used or if the physical option isn't set (see the set command below), references to “..” in dir are relative to the path used to get to the directory.  If
              the  -P  option (physical path) is used or if the physical option is set, “..” is relative to the filesystem directory tree. The PWD and OLDPWD parameters are updated to reflect the current
              and old working directory, respectively. If the -e option is set for physical filesystem traversal and PWD could not be set, the exit code is 1; greater than 1 if an error occurred, 0  oth‐
              erwise.

       cd [-eLP] old new
       chdir [-eLP] old new
              (regular) The string new is substituted for old in the current directory, and the shell attempts to change to the new directory.

       cls    (dot.mkshrc alias) Reinitialise the display (hard reset).

       command [-pVv] cmd [arg ...]
              (regular,  decl-forwarder)  If neither the -v nor -V option is given, cmd is executed exactly as if command had not been specified, with two exceptions: firstly, cmd cannot be a shell func‐
              tion; and secondly, special built-in commands lose their specialness (i.e. redirection and utility errors do not cause the shell to exit, and command assignments are not permanent).

              If the -p option is given, a default search path, whose actual value is system-dependent, is used instead of the current PATH.

              If the -v option is given, instead of executing cmd, information about what would be executed is given for each argument. For builtins,  functions  and  keywords,  their  names  are  simply
              printed;  for aliases, a command that defines them is printed; for utilities found by searching the PATH parameter, the full path of the command is printed. If no command is found (i.e. the
              path search fails), nothing is printed and command exits with a non-zero status. The -V option is like the -v option, but more verbose.

       continue [level]
              (keeps assignments, special) Jumps to the beginning of the levelth inner-most for, select, until or while loop. level defaults to 1.

       dirs [-lnv]
              (dot.mkshrc function) Print the directory stack. -l causes tilde expansion to occur in the output. -n causes line wrapping before 80 columns, whereas -v causes numbered vertical output.

       doch   (dot.mkshrc alias) Execute the last command with sudo(8).

       echo [-Een] [arg ...]
              (regular) Warning: this utility is not portable; use the standard Korn shell built-in utility print in new code instead.

              Print arguments, separated by spaces, followed by a newline, to standard output. The newline is suppressed if any of the arguments contain the backslash sequence “\c”. See the print command
              below for a list of other backslash sequences that are recognised.

              The options are provided for compatibility with BSD shell scripts. The -E option suppresses backslash interpretation, -e enables it (normally default), -n suppresses the  trailing  newline,
              and anything else causes the word to be printed as argument instead.

              If  the  posix or sh option is set or this is a direct builtin call or print -R, only the first argument is treated as an option, and only if it is exactly “-n”. Backslash interpretation is
              disabled.

       enable [-anps] [name ...]
              (dot.mkshrc function) Hide and unhide built-in utilities, aliases and functions and those defined in dot.mkshrc.

              If no name is given or the -p option is used, builtins are printed (behind the string “enable ”, followed by “-n ” if the builtin is currently disabled), otherwise, they are disabled (if -n
              is given) or re-enabled.

              When printing, only enabled builtins are printed by default; the -a options prints all builtins, while -n prints only disabled  builtins  instead;  -s  limits  the  list  to  POSIX  special
              builtins.

       eval command ...
              (keeps  assignments,  special)  The arguments are concatenated, with a space between each, to form a single string which the shell then parses and executes in the current execution environ‐
              ment.

       exec [-a argv0] [-c] [command [arg ...]]
              (keeps assignments, special) The command (with arguments) is executed without forking, fully replacing the shell process; this is absolute, i.e. exec never returns, even if the  command  is
              not found. The -a option permits setting a different argv[0] value, and -c clears the environment before executing the child process, except for the _ parameter and direct assignments.

              If  no  command is given except for I/O redirection, the I/O redirection is permanent and the shell is not replaced. Any file descriptors greater than 2 which are opened or dup(2)'d in this
              way are not made available to other executed commands (i.e. commands that are not built-in to the shell). Note that the Bourne shell differs here; it does pass these file descriptors on.

       exit [status]
              (keeps assignments, special) The shell or subshell exits with the specified errorlevel (or the current value of the $? parameter).

       export [-p] [parameter[=value]]
              (keeps assignments, special, decl-util) Sets the export attribute of the named parameters. Exported parameters are passed in the environment to executed commands. If values  are  specified,
              the named parameters are also assigned. This is a declaration utility.

              If no parameters are specified, all parameters with the export attribute set are printed one per line: either their names, or, if a “-” with no option letter is specified, name=value pairs,
              or, with the -p option, export commands suitable for re-entry.

       extproc
              (OS/2) Null command required for shebang-like functionality.

       false  (regular) A command that exits with a non-zero status.

       fc [-e editor | -l [-n]] [-r] [first [last]]
              (regular)  first and last select commands from the history. Commands can be selected by history number (negative numbers go backwards from the current, most recent, line) or a string speci‐
              fying the most recent command starting with that string. The -l option lists the command on standard output, and -n inhibits the default command numbers. The -r option reverses the order of
              the list. Without -l, the selected commands are edited by the editor specified with the -e option or, if no -e is specified, the editor specified by the FCEDIT parameter (if this  parameter
              is not set, /bin/ed is used), and the result is executed by the shell.

       fc -e - | -s [-g] [old=new] [prefix]
              (regular)  Re-execute  the  selected command (the previous command by default) after performing the optional substitution of old with new. If -g is specified, all occurrences of old are re‐
              placed with new. The meaning of -e - and -s is identical: re-execute the selected command without invoking an editor. This command is usually accessed with the predefined: alias r='fc -e -'

       fg [job ...]
              (regular, needs job control) Resume the specified job(s) in the foreground. If no jobs are specified, %+ is assumed.
              See “Job control” below for more information.

       functions [name ...]
              (built-in alias) Display the function definition commands corresponding to the listed, or all defined, functions.

       getopts optstring name [arg ...]
              (regular) Used by shell procedures to parse the specified arguments (or positional parameters, if no arguments are given) and to check for legal options. Options that do not take  arguments
              may  be  grouped in a single argument. If an option takes an argument and the option character is not the last character of the word it is found in, the remainder of the word is taken to be
              the option's argument; otherwise, the next word is the option's argument.

              optstring contains the option letters to be recognised. If a letter is followed by a colon, the option takes an argument.

              Each time getopts is invoked, it places the next option in the shell parameter name. If the option was introduced with a ‘+’, the character placed in name is prefixed with a ‘+’. If the op‐
              tion takes an argument, it is placed in the shell parameter OPTARG.

              When an illegal option or a missing option argument is encountered, a question mark or a colon is placed in name (indicating an illegal option or missing argument, respectively) and  OPTARG
              is set to the option letter that caused the problem. Furthermore, unless optstring begins with a colon, a question mark is placed in name, OPTARG is unset and a diagnostic is shown on stan‐
              dard error.

              getopts  records the index of the argument to be processed by the next call in OPTIND. When the end of the options is encountered, getopts returns a non-zero exit status. Options end at the
              first argument that does not start with a ‘-’ (non-option argument) or when a “--” argument is encountered.

              Option parsing can be reset by setting OPTIND to 1 (this is done automatically whenever the shell or a shell procedure is invoked).

              Warning: Changing the value of the shell parameter OPTIND to a value other than 1 or parsing different sets of arguments without resetting OPTIND may lead to unexpected results.

       hash [-r] [name ...]
              (built-in alias) Without arguments, any hashed executable command paths are listed. The -r option causes all hashed commands to be removed from the cache. Each name is  searched  as  if  it
              were a command name and added to the cache if it is an executable command.

       hd [file ...]
              (dot.mkshrc alias or function) Hexdump stdin or arguments legibly.

       history [-nr] [first [last]]
              (built-in alias) Same as fc -l (see above).

       integer [flags] [name[=value] ...]
              (built-in alias) Same as typeset -i (see below).

       jobs [-lnp] [job ...]
              (regular)  Display information about the specified job(s); if no jobs are specified, all jobs are displayed. The -n option causes information to be displayed only for jobs that have changed
              state since the last notification. If the -l option is used, the process ID of each process in a job is also listed. The -p option causes only the process group of each job to  be  printed.
              See “Job control” below for the format of job and the displayed job.

       kill [-s signame | -signum | -signame] { job | pid | pgrp } ...
              (regular)  Send  the  specified signal to the specified jobs, process IDs or process groups. If no signal is specified, the TERM signal is sent. If a job is specified, the signal is sent to
              the job's process group. See “Job control” below for the format of job.

       kill -l [exit-status ...]
              (regular) Print the signal name corresponding to exit-status. If no arguments are specified, a list of all the signals with their numbers and a short description of each are printed.

       let [expression ...]
              (regular) Each expression is evaluated (see “Arithmetic expressions” above). If all expressions evaluate successfully, the exit status is 0 (1) if the last expression evaluated to  non-zero
              (zero). If an error occurs during the parsing or evaluation of an expression, the exit status is greater than 1. Since expressions may need to be quoted, (( expr )) is syntactic sugar for:
                    { \\builtin let 'expr'; }

       local [flags] [name[=value] ...]
              (built-in alias) Same as typeset (see below).

       mknod [-m mode] name b|c major minor
       mknod [-m mode] name p
              (optional)  Create a device special file. The file type may be one of b (block type device), c (character type device) or p (named pipe, FIFO). The file created may be modified according to
              its mode (via the -m option), major (major device number), and minor (minor device number). This is not normally part of mksh; however, distributors may have added  this  as  builtin  as  a
              speed hack.

       nameref [flags] [name[=value] ...]
              (built-in alias) Same as typeset -n (see below).

       popd [-lnv] [+n]
              (dot.mkshrc function) Pops the directory stack and returns to the new top directory. The flags are as in dirs (see above). A numeric argument +n selects the entry in the stack to discard.

       print [-AcelNnprsu[n] | -R [-n]] [argument ...]
              (regular)  Print  the  specified  argument(s)  on the standard output, separated by spaces, terminated with a newline. The escapes mentioned in “Backslash expansion” above, as well as “\c”,
              which is equivalent to using the -n option, are interpreted.

              The options are as follows:

              -A     Each argument is arithmetically evaluated; the character corresponding to the resulting value is printed. Empty arguments separate input words. No backslash expansion.

              -c     The output is printed columnised, top to bottom then left to right, similar to how tab completion (control character escaping excepted), the kill  -l  built-in  utility,  the  select
                     statement and the rs(1) utility do.

              -e     Restore backslash expansion after a previous -r.

              -l     Change the output word separator to newline.

              -N     Change the output word and line separator to ASCII NUL.

              -n     Do not print the trailing line separator.

              -p     Print to the co-process (see “Co-processes” above).

              -r     Inhibit backslash expansion.

              -s     Print to the history file instead of standard output.

              -u[n]  Print to the file descriptor n (defaults to 1 if omitted) instead of standard output.

              The  -R  option  mostly  emulates  the BSD echo(1) command which does not expand backslashes and interprets its first argument as option only if it is exactly “-n” (to suppress the trailing
              newline).

       printf format [arguments ...]
              (optional, defer always) If compiled in, format and print the arguments, supporting the bare POSIX-mandated minimum. If an external utility of the same name is found, it is deferred to, un‐
              less run as direct builtin call or from the builtin utility.

       pushd [-lnv]
              (dot.mkshrc function) Rotate the top two elements of the directory stack. The options are the same as for dirs (see above), and pushd changes to the topmost directory stack entry after act‐
              ing.

       pushd [-lnv] +n
              (dot.mkshrc function) Rotate the element number n to the top.

       pushd [-lnv] name
              (dot.mkshrc function) Push name on top of the stack.

       pwd [-LP]
              (regular) Print the present working directory. If no options are given, pwd behaves as if the -P option (print physical path) was used if the physical shell option is  set,  the  -L  option
              (print  logical  path) otherwise. The logical path is the path used to cd to the current directory; the physical path is determined from the filesystem (by following “..” directories to the
              root directory).

       r [-g] [old=new] [prefix]
              (built-in alias) Same as fc -e - (see above).

       read [-A | -a] [-d x] [-N z | -n z] [-p | -u[n]] [-t n] [-rs] [p ...]
              (regular) Reads a line of input, separates the input into fields using the IFS parameter (see “Substitution” above) or other specified means, and assigns each field to the specified parame‐
              ters p. If no parameters are specified, the REPLY parameter is used to store the result. If there are more parameters than fields, the extra parameters are set to the empty string or 0;  if
              there are more fields than parameters, the last parameter is assigned the remaining fields (including the word separators).

              The options are as follows:

              -A     Store the result into the parameter p (or REPLY) as array of words. Only no or one parameter is accepted.

              -a     Store  the result, without applying IFS word splitting, into the parameter p (or REPLY) as array of characters (wide characters if the utf8-mode option is enacted, octets otherwise);
                     the codepoints are encoded as decimal numbers by default. Only no or one parameter is accepted.

              -d x   Use the first byte of x, NUL if empty, instead of the ASCII newline character to delimit input lines.

              -N z   Instead of reading till end-of-line, read exactly z bytes. Upon EOF, a partial read is returned with exit status 1. After timeout, a partial read is returned with an exit  status  as
                     if SIGALRM were caught.

              -n z   Instead of reading till end-of-line, read up to z bytes but return as soon as any bytes are read, e.g. from a slow terminal device, or if EOF or a timeout occurs.

              -p     Read from the currently active co-process (see “Co-processes” above for details) instead of from a file descriptor.

              -u[n]  Read from the file descriptor number n (defaults to 0, i.e. standard input).
                     The argument must immediately follow the option character.

              -t n   Interrupt reading after n seconds (specified as positive decimal value with an optional fractional part). The exit status of read is the same as if SIGALRM were caught if the timeout
                     occurred, but partial reads may still be returned.

              -r     Normally, read strips backslash-newline sequences and any remaining backslashes from input. This option enables raw mode, in which backslashes are retained and ignored.

              -s     The input line is saved to the history.

              If the input is a terminal, both the -N and -n options set it into raw mode; they read an entire file if -1 is passed as z argument.

              The first parameter may have a question mark and a string appended to it, in which case the string is used as a prompt (printed to standard error before any input is read) if the input is a
              tty(4) (e.g. read nfoo?'number of foos: ').

              If no input is read or a timeout occurred, read exits with a non-zero status.

       readonly [-p] [parameter[=value] ...]
              (keeps  assignments, special, decl-util) Sets the read-only attribute of the named parameters. If values are given, parameters are assigned these before disallowing writes. Once a parameter
              is made read-only, it cannot be unset and its value cannot be changed.

              If no parameters are specified, the names of all parameters with the read-only attribute are printed one per line, unless the -p option is used, in which case readonly commands defining all
              read-only parameters, including their values, are printed.

       realpath [--] name
              (defer with flags) Resolves an absolute pathname corresponding to name. If the resolved pathname either exists or can be created immediately, realpath returns  0  and  prints  the  resolved
              pathname, otherwise or if an error occurs, it issues a diagnostic and returns nonzero. If name ends with a slash (‘/’), resolving to an extant non-directory is also treated as error.

       rename [--] from to
              (defer  always,  needs  rename(2))  Renames  the file from to to. Both pathnames must be on the same device. Intended for emergency situations (where /bin/mv becomes unusable); thin syscall
              wrapper.

       return [status]
              (keeps assignments, special) Returns from a function or . script with errorlevel status. If no status is given, the exit status of the last executed command is used. If used  outside  of  a
              function or . script, it has the same effect as exit. Note that mksh treats both profile and ENV files as . scripts, while the original Korn shell only treated profiles as . scripts.

       rot13  (dot.mkshrc alias) ROT13-encrypts/-decrypts stdin to stdout.

       set [-+abCefhkmnpsUuvXx] [-+o option] [-+A name] [--] [argument ...]
       set -- [argument ...]
       set -+o
              (keeps  assignments, special) The set command can be used to show all shell parameters (like typeset -), set (-) or clear (+) shell options, set an array parameter or the positional parame‐
              ters.

              Options can be changed using the -+o option syntax, where option is the long name of an option, or using the -+letter syntax, where letter is the option's single letter name  (not  all  op‐
              tions have both names). The following table lists short and long names (if extant) along with a description of what each option does:

              -A name
                   Sets the elements of the array parameter name to argument ...

                   If -A is used, the array is reset (i.e. emptied) first; if +A is used, the first N elements are set (where N is the number of arguments); the rest are left untouched. If name ends with
                   a ‘+’, the array is appended to instead.

                   An alternative syntax for the command set -A foo -- a b c; set -A foo+ -- d e which is compatible to GNU bash and also supported by AT&T UNIX ksh93 is: foo=(a b c); foo+=(d e)

              -a | -o allexport
                   Make all variables assigned to while enabled as exported.

              -b | -o notify
                   Print job notification messages asynchronously instead of just before the prompt. Only used with job control (-m).

              -C | -o noclobber
                   Prevent > redirection from overwriting existing files; ‘>|’ must be used to force overwriting instead. Note: This is not safe to use for creation of temporary files or lockfiles due to
                   a TOCTOU in a check allowing one to redirect output to /dev/null or other device files even in noclobber mode.

              -c   Commands are read from an argument string. Can only be used when the shell is invoked.

              -e | -o errexit
                   Exit  (after  executing the ERR trap) as soon as an error occurs or a command fails (i.e. exits with a non-zero status). This does not apply to commands whose exit status is explicitly
                   tested by a shell construct such as !, if, until or while statements. For &&, || and pipelines (but mind -o pipefail), only the status of the last command is tested.

              -f | -o noglob
                   Do not expand file name patterns.

              -h | -o trackall
                   Create tracked aliases for all executed commands (see “Aliases” above). Enabled by default for non-interactive shells.

              -i | -o interactive
                   The shell is an interactive shell. This option can only be used when the shell is invoked. See above for details.

              -k | -o keyword
                   Parameter assignments are recognised anywhere in a command.

              -l | -o login
                   The shell is a login shell. This option can only be used when the shell is invoked. See above for what this means.

              -m | -o monitor
                   Enable job control (default for interactive shells).

              -n | -o noexec
                   Do not execute any commands. Useful for checking the syntax of scripts. Ignored if reading commands from a tty.

              -p | -o privileged
                   The shell is a privileged shell. It is set automatically if, when the shell starts, the real UID or GID does not match the effective UID (EUID) or GID (EGID), respectively.  See  above
                   for a description of what this means.

                   If  the  shell is privileged, setting this flag after startup file processing let it go full setuid and/or setgid. Clearing the flag makes the shell drop privileges. Changing this flag
                   resets the supplementary groups vector.

              -r | -o restricted
                   The shell is a restricted shell. This option can only be used when the shell is invoked. See above for what this means.

              -s | -o stdin
                   If used when the shell is invoked, commands are read from standard input. Set automatically if the shell is invoked with no arguments.

                   When -s is used with the set command it causes the specified arguments to be sorted ASCIIbetically before assigning them to the positional parameters (or to array name, with -A).

              -U | -o utf8-mode
                   Enable UTF-8 support in the “Emacs editing mode” and internal string handling functions. This flag is disabled by default, but can be enabled by setting it on the shell  command  line;
                   is enabled automatically for interactive shells if the POSIX locale uses the UTF-8 codeset or, lacking POSIX locales, the LC_ALL, LC_CTYPE or LANG environment variables either case-in‐
                   sensitively equal “UTF-8” or “utf8” or have that as codeset modifier.

                   This build of the shell implements baroque locale tracking, that is, set -+U is changed whenever one of the POSIX locale-related environment variables changes.

              -u | -o nounset
                   Referencing of an unset parameter, other than “$@” or “$*”, is treated as an error, unless one of the ‘-’, ‘+’ or ‘=’ modifiers is used.

              -v | -o verbose
                   Write shell input to standard error as it is read.

              -X | -o markdirs
                   Mark directories with a trailing ‘/’ during globbing.

              -x | -o xtrace
                   Print commands when they are executed, preceded by PS4.

              -o asis
                   When  quoting  output,  if  not in EBCDIC mode and utf8-mode is disabled, show C1 control characters “as is”, that is, do not escape them. Use with codepages where the range 0x80..0x9F
                   contains printable characters (such as 437, 850, 1252, etc. but not the ISO 8859 series, for example).

              -o bgnice
                   Background jobs are run with lower priority.

              -o braceexpand
                   Enable brace expansion. This is enabled by default.

              -o emacs
                   Enable BRL emacs-like command-line editing (interactive shells only); see “Emacs editing mode”. Enabled by default.

              -o gmacs
                   Enable gmacs-like command-line editing (interactive shells only). Currently identical to emacs editing except that transpose-chars (^T) acts slightly differently.

              -o ignoreeof
                   The shell will not (easily) exit when end-of-file is read; exit must be used. To avoid infinite loops, the shell will exit if EOF is read 13 times in a row.

              -o inherit-xtrace
                   Do not reset -o xtrace upon entering functions (default).

              -o nohup
                   Do not kill running jobs with a SIGHUP signal when a login shell exits. Currently enabled by default.

              -o nolog
                   No effect. In the original Korn shell, this prevented function definitions from being stored in the history file.

              -o physical
                   Causes the cd and pwd commands to use “physical” (i.e. the filesystem's) “..” directories instead of “logical” directories (i.e. the shell handles “..”, which allows  the  user  to  be
                   oblivious  of  symbolic  links to directories). Clear by default. Note that setting this option does not affect the current value of the PWD parameter; only the cd command changes PWD.
                   See cd and pwd above for more details.

              -o pipefail
                   Make the exit status of a pipeline the rightmost non-zero errorlevel, or zero if all commands exited with zero.

              -o posix
                   Behave closer to the standards (see “POSIX mode” for details). Automatically enabled if the shell invocation basename, after ‘-’ and ‘r’ processing, begins with “sh”  and  (often  used
                   for  the  lksh  binary) this autodetection feature is compiled in. As a side effect, setting this flag turns off the braceexpand flag, which can be turned back on manually, and (unless
                   both are set in the same command) sh mode.

              -o sh
                   Enable kludge /bin/sh compatibility mode (see “SH mode” below for details). Automatically enabled if the basename of the shell invocation, after ‘-’ and  ‘r’  processing,  begins  with
                   “sh”  and  this  autodetection  feature  is compiled in (rather uncommon). As a side effect, setting this flag turns off the braceexpand flag, which can be turned back on manually, and
                   posix mode (unless both are set in the same command).

              -o vi
                   Enable vi(1)-like command-line editing (interactive shells only). See “Vi editing mode” for documentation and limitations.

              -o vi-esccomplete
                   In vi command-line editing, do command and file name completion when Esc (^[) is entered in command mode.

              -o vi-tabcomplete
                   In vi command-line editing, do command and file name completion when Tab (^I) is entered in insert mode (default).

              -o viraw
                   No effect. In the original Korn shell, unless viraw was set, the vi command-line mode would let the tty(4) driver do the work until Esc was entered. mksh is always in viraw mode.

              These options can also be used upon invocation of the shell. The current set of options with single letter names can be found in the parameter “$-”. set -o with no option name will list all
              the options and whether each is on or off; set +o prints a command to restore the current option set, using the internal set -o .reset construct, which is an  implementation  detail;  these
              commands are transient (only valid within the current shell session).

              A lone “-” clears both the -v and -x options (obsolete); it (or a lone “+”) terminates option processing and is otherwise ignored.

              Remaining arguments, if any, are assigned (in order, unless -s is given) to name (with -A) or the positional parameters (i.e., $1, $2, etc). Use -- if the first argument begins with plus or
              dash.  If  options  end with “--” and there are no remaining arguments, all positional parameters are cleared. If no options or arguments are given, the values of all parameters are printed
              (suitably quoted).

       setenv [name [value]]
              (dot.mkshrc function) Without arguments, display the names and values of all exported parameters. Otherwise, set name's export attribute, and its  value  to  value  (empty  string  if  none
              given).

       shift [number]
              (keeps assignments, special) The positional parameters number+1, number+2, etc. (number defaults to 1) are renamed to 1, 2, etc.

       smores [file ...]
              (dot.mkshrc function) Simple pager: <Enter> next; ‘q’+<Enter> quit

       source file [arg ...]
              (keeps assignments) Like . (“dot”), except that the current working directory is appended to the search path. (GNU bash extension)

       suspend
              (needs job control and getsid(2)) Stops the shell as if it had received the suspend character from the terminal.

              It  is not possible to suspend a login shell unless the parent process is a member of the same terminal session but is a member of a different process group. As a general rule, if the shell
              was started by another shell or via su(1), it can be suspended.

       test expression
       [ expression ]
              (regular) test evaluates the expression and exits with status code 0 if true, 1 if false, or greater than 1 if there was an error. It is often used as the condition command of if and  while
              statements. All file expressions, except -h and -L, follow symbolic links.

              The following basic expressions are available:

              -a file            file exists.

              -b file            file is a block special device.

              -c file            file is a character special device.

              -d file            file is a directory.

              -e file            file exists.

              -f file            file is a regular file.

              -G file            file's group is the shell's effective group ID.

              -g file            file's mode has the setgid bit set.

              -H file            file is a context dependent directory (only useful on HP-UX).

              -h file            file is a symbolic link.

              -k file            file's mode has the sticky(7) bit set.

              -L file            file is a symbolic link.

              -O file            file's owner is the shell's effective user ID.

              -p file            file is a named pipe (FIFO).

              -r file            file exists and is readable.

              -S file            file is a unix(4)-domain socket.

              -s file            file is not empty.

              -t fd              File descriptor fd is a tty(4) device.

              -u file            file's mode has the setuid bit set.

              -w file            file exists and is writable.

              -x file            file exists and is executable.

              file1 -nt file2    file1 is newer than file2 or file1 exists and file2 does not.

              file1 -ot file2    file1 is older than file2 or file2 exists and file1 does not.

              file1 -ef file2    file1 is the same file as file2.

              string             string has non-zero length.

              -n string          string is not empty.

              -z string          string is empty.

              -v name            The shell parameter name is set.

              -o option          Shell  option is set (see the set command above for a list of options). As a non-standard extension, if the option starts with a ‘!’, the test is negated; the test always
                                 fails if option doesn't exist (so [ -o foo -o -o !foo ] returns true if and only if option foo exists). The same can be achieved with [ -o ?foo ] like in AT&T UNIX ksh93.
                                 option can also be the short flag prefixed with either ‘-’ or ‘+’ (no logical negation), for example “-x” or “+x” instead of “xtrace”.

              string = string    Strings are equal. In double brackets, pattern matching (R59+ using extglobs) occurs if the right-hand string isn't quoted.

              string == string   Same as ‘=’ (deprecated).

              string != string   Strings are not equal. See ‘=’ regarding pattern matching.

              string > string    First string operand is greater than second string operand.

              string < string    First string operand is less than second string operand.

              number -eq number  Numbers compare equal.

              number -ne number  Numbers compare not equal.

              number -ge number  Numbers compare greater than or equal.

              number -gt number  Numbers compare greater than.

              number -le number  Numbers compare less than or equal.

              number -lt number  Numbers compare less than.

              The above basic expressions, in which unary operators have precedence over binary operators, may be combined with the following operators (listed in increasing order of precedence):

                    expr -o expr            Logical OR.
                    expr -a expr            Logical AND.
                    ! expr                  Logical NOT.
                    ( expr )                Grouping.

              Note that a number actually may be an arithmetic expression, such as a mathematical term or the name of an integer variable:

                    x=1; [ "x" -eq 1 ]      evaluates to true

              Note that some special rules are applied (courtesy of POSIX) if the number of arguments to test or inside the brackets [ ... ] is less than five: if leading “!” arguments  can  be  stripped
              such  that  only  one to three arguments remain, then the lowered comparison is executed; (thanks to XSI) parentheses \( ... \) lower four- and three-argument forms to two- and one-argument
              forms, respectively; three-argument forms ultimately prefer binary operations, followed by negation and parenthesis lowering; two- and four-argument forms prefer negation followed by paren‐
              thesis; the one-argument form always implies -n. To assume this is not necessarily portable.

              Note: A common mistake is to use “if [ $foo = bar ]” which fails if parameter “foo” is empty or unset, if it has embedded spaces (i.e. IFS octets) or if it is a unary operator like  “!”  or
              “-n”. Use tests like “if [ x"$foo" = x"bar" ]” instead, or the double-bracket construct (see [[ above): “if [[ $foo = bar ]]” or, to avoid pattern matching, “if [[ $foo = "$bar" ]]”; the [[
              ... ]] construct is not only more secure to use but also often faster. Similarly, operators need to be quoted as usual for test / [.

       time [-p] [pipeline]
              (reserved  word)  If  a  pipeline is given, the times used to execute the pipeline are reported. If no pipeline is given, then the user and system time used by the shell itself, and all the
              commands it has run since it was started, are reported.

              The times reported are the real time (elapsed time from start to finish), the user CPU time (time spent running in user mode), and the system CPU time (time spent running in kernel mode).

              Times are reported to standard error; the format of the output is:

                    0m0.03s real     0m0.02s user     0m0.01s system

              If the -p option is given (which is only permitted if pipeline is a simple command), the output is slightly longer:

                    real     0.03
                    user     0.02
                    sys      0.01

              Simple redirections of standard error do not affect time's output:

                    $ time sleep 1 2>afile
                    $ { time sleep 1; } 2>afile

              Times for the first command do not go to “afile”, but those of the second command do.

       times  (keeps assignments, special) Print the accumulated user and system times (see above) used both by the shell and by processes that the shell started which have exited. The format of the out‐
              put is:

                    0m0.01s 0m0.00s
                    0m0.04s 0m0.02s

       trap n [signal ...]
              (keeps assignments, special) If the first operand is a decimal unsigned integer, this resets all specified signals to the default action, i.e. is the same as calling trap with a dash  (“-”)
              as handler, followed by the arguments (interpreted as signals).

       trap [handler signal ...]
              (keeps  assignments,  special) Sets a trap handler that is to be executed when any of the specified signals are received. handler is either an empty string, indicating the signals are to be
              ignored, a dash (“-”), indicating that the default action is to be taken for the signals (see signal(3)), or a string comprised of shell commands to be executed  at  the  first  opportunity
              (i.e.  when  the  current  command completes or before printing the next PS1 prompt) after receipt of one of the signals. signal is the name, possibly prefixed with “SIG”, of a signal (e.g.
              PIPE, ALRM or SIGINT) or the number of the signal (see the kill -l command above).

              There are two special signals: EXIT (also known as 0), which is executed when the shell is about to exit, and ERR, which is executed after an error occurs; an error is something that  would
              cause the shell to exit if the set -e or set -o errexit option were set. EXIT handlers are executed in the environment of the last executed command. The original Korn shell's DEBUG trap and
              handling of ERR and EXIT in functions are not yet implemented.

              Note that, for non-interactive shells, the trap handler cannot be changed for signals that were ignored when the shell started.

              With  no arguments, the current state of the traps that have been set since the shell started is shown as a series of trap commands. Note that the output of trap cannot be usefully captured
              or piped to another process (an artifact of the fact that traps are cleared when subprocesses are created).

       true   (regular) A command that exits with a zero status.

       type name ...
              (built-in alias) Reveal how name would be interpreted as command.

       typeset [-+aglpnrtUux] [-L[n] | -R[n] | -Z[n]] [-i[n]] [name[=value] ...]
       typeset -f [-tux] [name ...]
              (keeps assignments, decl-util) Display or set attributes of shell parameters or functions. With no name arguments, parameter attributes are shown; if no options are used,  the  current  at‐
              tributes  of all parameters are printed as typeset commands; if an option is given (or “-” with no option letter), all parameters and their values with the specified attributes are printed;
              if options are introduced with ‘+’ (or “+” alone), only names are printed.

              If any name arguments are given, the attributes of the so named parameters are set (-) or cleared (+); inside a function, this will cause the parameters to be created (and set to “”  if  no
              value  is given) in the local scope (except if -g is used). Values for parameters may optionally be specified. For name[*], the change affects all elements of the array, and no value may be
              specified.

              When -f is used, typeset operates on the attributes of functions. As with parameters, if no name arguments are given, functions are listed with their values (i.e.  definitions)  unless  op‐
              tions are introduced with ‘+’, in which case only the names are displayed.

              -a      Indexed array attribute.

              -f      Function mode. Display or set shell functions and their attributes, instead of shell parameters.

              -g      “global” mode. Do not cause named parameters to be created in the local scope when called inside a function.

              -i[n]   Integer  attribute.  n specifies the base to use when stringifying the integer (if not specified, the base given in the first assignment is used). Parameters with this attribute may
                      be assigned arithmetic expressions for values.

              -L[n]   Left justify attribute. n specifies the field width. If n is not specified, the current width of the parameter (or the width of its first assigned value) is used. Leading whitespace
                      (and digit zeros, if used with the -Z option) is stripped. If necessary, values are either truncated or padded with space to fit the field width.

              -l      Lower case attribute. All upper case ASCII characters in values are converted to lower case. (In the original Korn shell, this parameter meant “long integer” when used with  the  -i
                      option.)

              -n      Create a bound variable (name reference): any access to the variable name will access the variable value in the current scope (this is different from AT&T UNIX ksh93!) instead. Also
                      different  from  AT&T  UNIX ksh93 is that value is lazily evaluated at the time name is accessed. This can be used by functions to access variables whose names are passed as parame‐
                      ters, instead of resorting to eval.

              -p      Print complete typeset commands that can be used to re-create the attributes and values of parameters.

              -R[n]   Right justify attribute. n specifies the field width. If n is not specified, the current width of the parameter (or the width of its first assigned value) is used.  Trailing  white‐
                      space is stripped. If necessary, values are either stripped of leading characters or padded with space to fit the field width.

              -r      Read-only attribute. Parameters with this attribute may not be assigned to or unset. Once this attribute is set, it cannot be turned off.

              -t      Tag attribute. This attribute has no meaning to the shell for parameters and is provided for application use.

                      For functions, -t is the trace attribute. When functions with the trace attribute are executed, the -o xtrace (-x) shell option is temporarily turned on.

              -U      Unsigned integer attribute. Integers are printed as unsigned values (combined with the -i option).

              -u      Upper  case attribute. All lower case ASCII characters in values are converted to upper case. (In the original Korn shell, this parameter meant “unsigned integer” when used with the
                      -i option which meant upper case letters would never be used for bases greater than 10. See -U above.)

                      For functions, -u is the undefined attribute, used with FPATH. See “Functions” above for the implications of this.

              -x      Export attribute. Parameters are placed in the environment of any executed commands. Functions cannot be exported for security reasons (“shellshock”).

              -Z[n]   Zero fill attribute. If not combined with -L, this is the same as -R, except zero padding is used instead of space padding. For integers, the number is padded, not the base.

              If any of the -i, -L, -l, -R, -U, -u or -Z options are changed, all others from this set are cleared, unless they are also given on the same command line.

       ulimit [-aBCcdefHilMmnOPpqrSsTtVvwx] [value]
              (regular) Display or set process limits. If no options are used, the file size limit (-f) is assumed. value, if specified, may be either an arithmetic expression or  the  word  “unlimited”.
              The  limits  affect  the shell and any processes created by the shell after a limit is imposed. Note that systems may not allow some limits to be increased once they are set. Also note that
              the types of limits available are system dependent — some systems have only the -f limit, or not even that, or can set only the soft limits, etc.

              -a     Display all limits (soft limits unless -H is used).

              -B n   Set the socket buffer size to n kibibytes.

              -C n   Set the number of cached threads to n.

              -c n   Impose a size limit of n blocks on the size of core dumps. Silently ignored if the system does not support this limit.

              -d n   Limit the size of the data area to n kibibytes.
                     On some systems, read-only maximum brk(2) size minus etext.

              -e n   Set the maximum niceness to n.

              -f n   Impose a size limit of n blocks on files written by the shell and its child processes (any size may be read).

              -H     Set the hard limit only (the default is to set both hard and soft limits). With -a, display all hard limits.

              -i n   Set the number of pending signals to n.

              -l n   Impose a limit of n kibibytes on the amount of locked (wired) physical memory.

              -M n   Set the AIO locked memory to n kibibytes.

              -m n   Impose a limit of n kibibytes on the amount of physical memory used.

              -n n   Impose a limit of n file descriptors that can be open at once. On some systems attempts to set are silently ignored.

              -O n   Set the number of AIO operations to n.

              -P n   Limit the number of threads per process to n.

                     This option mostly matches AT&T UNIX ksh93's -T;
                     on AIX, see -r as used by its ksh though.

              -p n   Impose a limit of n processes that can be run by the user (uid) at any one time.

              -q n   Limit the size of POSIX message queues to n bytes.

              -R n   (Linux) Limit the CPU time slice a real-time process can use before performing a blocking syscall to n milliseconds.

              -r n   (AIX) Limit the number of threads per process to n.
                     (Linux) Set the maximum real-time priority to n.

              -S     Set the soft limit only (the default is to set both hard and soft limits). With -a, display soft limits (default).

              -s n   Limit the size of the stack area to n kibibytes.

              -T n   Impose a time limit of n real seconds (“humantime”) to be used by each process.

              -t n   Impose a time limit of n CPU seconds spent in user mode to be used by each process.

              -V n   Set the number of vnode monitors on Haiku to n.

              -v n   Impose a limit of n kibibytes on the amount of virtual memory (address space) used.

              -w n   Limit the amount of swap space used to at most n kibibytes.

              -x n   Set the maximum number of file locks to n.

              As far as ulimit is concerned, a block is 512 bytes.

       umask [-S] [mask]
              (regular) Display or set the file permission creation mask or umask (see umask(2)). If the -S option is used, the mask displayed or set is symbolic; otherwise, it is an octal number.

              Symbolic masks are like those used by chmod(1). When used, they describe what permissions may be made available (as opposed to octal masks in which a set bit means the corresponding bit  is
              to be cleared). For example, “ug=rwx,o=” sets the mask so files will not be readable, writable or executable by “others”, and is equivalent (on most systems) to the octal mask “007”.

       unalias [-adt] [name ...]
              (regular)  The  aliases  for  the  given  names are removed. If the -a option is used, all aliases are removed. If the -t or -d options are used, the indicated operations are carried out on
              tracked or directory aliases, respectively.

       unset [-fv] parameter ...
              (keeps assignments, special) Unset the named parameters (-v, the default) or functions (-f). With parameter[*], attributes are retained, only values are unset. The exit status  is  non-zero
              if any of the parameters are read-only, zero otherwise (not portable).

       wait [job ...]
              (regular) Wait for the specified job(s) to finish. The exit status of wait is that of the last specified job; if the last job is killed by a signal, the exit status is 128 + the signal num‐
              ber  (see  kill  -l exit-status above); if the last specified job cannot be found (because it never existed or had already finished), the exit status is 127. See “Job control” below for the
              format of job. wait will return if a signal for which a trap has been set is received or if a SIGHUP, SIGINT or SIGQUIT signal is received.

              If no jobs are specified, wait waits for all currently running jobs (if any) to finish and exits with a zero status. If job monitoring is enabled, the completion status of jobs  is  printed
              (this is not the case when jobs are explicitly specified).

       whence [-pv] [name ...]
              (regular)  Without  the  -v  option,  it is the same as command -v, except aliases are printed as their definition only. With the -v option, it is exactly identical to command -V. In either
              case, with the -p option the search is restricted to the (current) PATH.

       which [-a] [name ...]
              (dot.mkshrc function) Without -a, behaves like whence -p (does a PATH search for each name printing the resulting pathname if found); with -a, matches in all PATH  components  are  printed,
              i.e.  the search is not stopped after a match. If no name was matched, the exit status is 2; if every name was matched, it is zero, otherwise it is 1. No diagnostics are produced on failure
              to match.

   Job control
       Job control refers to the shell's ability to monitor and control jobs which are processes or groups of processes created for commands or pipelines. At a minimum, the shell keeps track of the  sta‐
       tus of the background (i.e. asynchronous) jobs that currently exist; this information can be displayed using the jobs commands. If job control is fully enabled (using set -m or set -o monitor), as
       it is for interactive shells, the processes of a job are placed in their own process group. Foreground jobs can be stopped by typing the suspend character from the terminal (normally ^Z); jobs can
       be restarted in either the foreground or background using the commands fg and bg.

       Note that only commands that create processes (e.g. asynchronous commands, subshell commands and non-built-in, non-function commands) can be stopped; commands like read cannot be.

       When a job is created, it is assigned a job number. For interactive shells, this number is printed inside “[...]”, followed by the process IDs of the processes in the job when an asynchronous com‐
       mand is run. A job may be referred to in the bg, fg, jobs, kill and wait commands either by the process ID of the last process in the command pipeline (as stored in the $! parameter) or by prefix‐
       ing the job number with a percent sign (‘%’). Other percent sequences can also be used to refer to jobs:

       %+ | %% | %    The most recently stopped job or, if there are no stopped jobs, the oldest running job.

       %-             The job that would be the %+ job if the latter did not exist.

       %n             The job with job number n.

       %?string       The job with its command containing the string string (an error occurs if multiple jobs are matched).

       %string        The job with its command starting with the string string (an error occurs if multiple jobs are matched).

       When a job changes state (e.g. a background job finishes or foreground job is stopped), the shell prints the following status information:

             [number] flag status command

       where...

       number   is the job number of the job;

       flag     is the ‘+’ or ‘-’ character if the job is the %+ or %- job, respectively, or space if it is neither;

       status   indicates the current state of the job and can be:

                Done [number]
                           The job exited. number is the exit status of the job which is omitted if the status is zero.

                Running    The job has neither stopped nor exited (note that running does not necessarily mean consuming CPU time — the process could be blocked waiting for some event).

                Stopped [signal]
                           The job was stopped by the indicated signal (if no signal is given, the job was stopped by SIGTSTP).

                signal-description [“core dumped”]
                           The job was killed by a signal (e.g. memory fault, hangup); use kill -l for a list of signal descriptions. The “core dumped” message indicates the process created a core file.

       command  is the command that created the process. If there are multiple processes in the job, each process will have a line showing its command and possibly its status, if it is different from the
                status of the previous process.

       When  an attempt is made to exit the shell while there are jobs in the stopped state, the shell warns the user that there are stopped jobs and does not exit. If another attempt is immediately made
       to exit the shell, the stopped jobs are sent a SIGHUP signal and the shell exits. Similarly, if the nohup option is not set and there are running jobs when an attempt  is  made  to  exit  a  login
       shell, the shell warns the user and does not exit. If another attempt is immediately made to exit the shell, the running jobs are sent a SIGHUP signal and the shell exits.

   Terminal state
       The  state  of  the controlling terminal can be modified by a command executed in the foreground, whether or not job control is enabled, but the modified terminal state is only kept past the job's
       lifetime and used for later command invocations if the command exits successfully (i.e. with an exit status of 0). When such a job is momentarily stopped or restarted, the terminal state is  saved
       and  restored,  respectively, but it will not be kept afterwards. In interactive mode, when line editing is enabled, the terminal state is saved before being reconfigured by the shell for the line
       editor, then restored before running a command.

   POSIX mode
       Entering set -o posix mode will cause mksh to behave even more POSIX compliant in places where the defaults or opinions differ. Note that mksh will still operate with unsigned  32-bit  arithmetic;
       use lksh if arithmetic on the host long data type, complete with ISO C Undefined Behaviour, is required; refer to the lksh(1) manual page for details. Most other historic, AT&T UNIX ksh-compatible
       or opinionated differences can be disabled by using this mode; these are:

       •   The incompatible GNU bash I/O redirection &>file is not supported.

       •   File descriptors created by I/O redirections are inherited by child processes.

       •   Numbers with a leading digit zero are interpreted as octal.

       •   The echo builtin does not interpret backslashes and only supports the exact option -n.

       •   Alias expansion with a trailing space only reruns on command words.

       •   Tilde expansion follows POSIX instead of Korn shell rules.

       •   The exit status of fg is always 0.

       •   kill -l only lists signal names, all in one line.

       •   getopts does not accept options with a leading ‘+’.

       •   exec skips builtins, functions and other commands and uses a PATH search to determine the utility to execute.

   SH mode
       Compatibility mode; intended for use with legacy scripts that cannot easily be fixed; the changes are as follows:

       •   The incompatible GNU bash I/O redirection &>file is not supported.

       •   File descriptors created by I/O redirections are inherited by child processes.

       •   The echo builtin does not interpret backslashes and only supports the exact option -n, unless built with -DMKSH_MIDNIGHTBSD01ASH_COMPAT.

       •   The substitution operations ${x#pat}, ${x##pat}, ${x%pat}, and ${x%%pat} wrongly do not require a parenthesis to be escaped and do not parse extglobs.

       •   The getopt construct from lksh(1) passes through the errorlevel.

       •   sh -c eats a leading -- if built with -DMKSH_MIDNIGHTBSD01ASH_COMPAT.

   Interactive input line editing
       The  shell  supports  three modes of reading command lines from a tty(4) in an interactive session, controlled by the emacs, gmacs and vi options (at most one of these can be set at once). The de‐
       fault is emacs. Editing modes can be set explicitly using the set built-in. If none of these options are enabled, the shell simply reads lines using the normal tty(4) driver. If the emacs or gmacs
       option is set, the shell allows emacs-like editing of the command; similarly, if the vi option is set, the shell allows vi-like editing of the command. These modes are described in detail  in  the
       following sections.

       In these editing modes, if a line is longer than the screen width (see the COLUMNS parameter), a ‘>’, ‘+’ or ‘<’ character is displayed in the last column indicating that there are more characters
       after, before and after, or before the current position, respectively. The line is scrolled horizontally as necessary.

       Completed lines are pushed into the history, unless they begin with an IFS octet or IFS white space or are the same as the previous line.

   Emacs editing mode
       When the emacs option is set, interactive input line editing is enabled. Warning: This mode is slightly different from the emacs mode in the original Korn shell. In this mode, various editing com‐
       mands  (typically bound to one or more control characters) cause immediate actions without waiting for a newline. Several editing commands are bound to particular control characters when the shell
       is invoked; these bindings can be changed using the bind command.

       The following is a list of available editing commands. Each description starts with the name of the command, suffixed with a colon; a [n] (if the command can be prefixed with  a  count);  and  any
       keys  the command is bound to by default, written using caret notation (e.g. the ASCII Esc character is written as ^[) or terminal-specific indications. A count prefix for a command is entered us‐
       ing the sequence ^[n, where n is one or more digits. Unless otherwise specified, if a count is omitted, it defaults to 1.

       Bigwords, as used below, are separated by spaces or tabs; words consist of alphanumerics, underscore (‘_’) or dollar sign (‘$’) characters.

       Note that editing command names are used only with the bind command. Furthermore, many editing commands are useful only on terminals with a visible  cursor.  The  user's  tty(4)  characters  (e.g.
       ERASE)  are  bound  to  reasonable  substitutes and override the default bindings; their customary values are shown in parentheses below. The default bindings were chosen to resemble corresponding
       Emacs key bindings:

       abort: INTR (^C), ^G
               Abort the current command, save it to the history, empty the line buffer and set the exit state to interrupted.

       auto-insert: [n]
               (Most ordinary characters are bound to this command.) Simply causes the character to appear as literal input.

       backward-bigword: [n] ^[B
               Moves the cursor backward to the beginning of the bigword.

       backward-char: [n] ^B, ^XD, ANSI-CurLeft, PC-CurLeft
               Moves the cursor backward n characters.

       backward-word: [n] ^[b, ANSI-Ctrl-CurLeft, ANSI-Alt-CurLeft
               Moves the cursor backward to the beginning of the word.

       beginning-of-history: ^[<
               Moves to the beginning of the history.

       beginning-of-line: ^A, ANSI-Home, PC-Home
               Moves the cursor to the beginning of the edited input line.

       capitalise-bigword: [n] ^[C
               Uppercase the first character in the next n bigwords as below.

       capitalise-word: [n] ^[c
               Uppercase the first ASCII character in the next n words, leaving the cursor past the end of the last word.

       clear-screen: ^[^L
               Prints a compile-time configurable sequence to clear the screen and home the cursor, redraws the last line of the prompt string and the currently edited input line.  The  default  sequence
               works for almost all standard terminals.

       comment: ^[#
               If the current line does not begin with a comment character, one is added at the beginning of the line and the line is entered (as if return had been pressed); otherwise, the existing com‐
               ment characters are removed and the cursor is placed at the beginning of the line.

       complete: ^[^[
               Automatically  completes  as  much as is unique of the command name or the file name containing the cursor. If the entire remaining command or file name is unique, a space is printed after
               its completion, unless it is a directory name in which case ‘/’ is appended. If there is no command or file name with the current partial word as its prefix, a  bell  character  is  output
               (usually causing a beep to be sounded).

       complete-command: ^X^[
               Automatically completes as much as is unique of the command name having the partial word up to the cursor as its prefix, as in the complete command above.

       complete-file: ^[^X
               Automatically completes as much as is unique of the file name having the partial word up to the cursor as its prefix, as in the complete command described above.

       complete-list: ^I, ^[=
               Complete  as  much  as is possible of the current word and list the possible completions for it. If only one completion is possible, match as in the complete command above. Note that ^I is
               usually generated by the Tab (tabulator) key.

       delete-bigword-backward: [n] ^[H
               Deletes n bigwords before the cursor.

       delete-bigword-forward: [n] ^[D
               Deletes characters after the cursor up to the end of n bigwords.

       delete-char-backward: [n] ERASE (^H), ^?, ^H
               Deletes n characters before the cursor.

       delete-char-forward: [n] ANSI-Del, PC-Del
               Deletes n characters after the cursor.

       delete-word-backward: [n] Pfx1+ERASE (^[^H), WERASE (^W), ^[^?, ^[^H, ^[h
               Deletes n words before the cursor.

       delete-word-forward: [n] ^[d
               Deletes characters after the cursor up to the end of n words.

       down-history: [n] ^N, ^XB, ANSI-CurDown, PC-CurDown
               Scrolls the history buffer forward n lines (later). Each input line originally starts just after the last entry  in  the  history  buffer,  so  down-history  is  not  useful  until  either
               search-history, search-history-up or up-history has been performed.

       downcase-bigword: [n] ^[L
               Lowercases the next n bigwords.

       downcase-word: [n] ^[l
               Lowercases the next n words.

       edit-line: [n] ^Xe
               Internally run the command fc -e "${VISUAL:-${EDITOR:-vi}}" -- n
               on a temporary script file to interactively edit line n (if n is not specified, the current line); then, unless the editor invoked exits nonzero but even if the script was not changed, ex‐
               ecute the resulting script as if typed on the command line; both the edited (resulting) and original lines are added onto history.

       end-of-history: ^[>
               Moves to the end of the history.

       end-of-line: ^E, ANSI-End, PC-End
               Moves the cursor to the end of the input line.

       eot: ^_
               Acts as an end-of-file; this is useful because edit-mode input disables normal terminal input canonicalisation.

       eot-or-delete: [n] EOF (^D)
               If alone on a line, same as eot, otherwise, delete-char-forward.

       error: (not bound)
               Error (ring the bell).

       evaluate-region: ^[^E
               Evaluates  the  text  between  the mark and the cursor position (the entire line if no mark is set) as function substitution (if it cannot be parsed, the editing state is unchanged and the
               bell is rung to signal an error); $? is updated accordingly.

       exchange-point-and-mark: ^X^X
               Places the cursor where the mark is and sets the mark to where the cursor was.

       expand-file: ^[*
               Appends a ‘*’ to the current word and replaces the word with the result of performing file globbing on the word. If no files match the pattern, the bell is rung.

       forward-bigword: [n] ^[F
               Moves the cursor forward to the end of the nth bigword.

       forward-char: [n] ^F, ^XC, ANSI-CurRight, PC-CurRight
               Moves the cursor forward n characters.

       forward-word: [n] ^[f, ANSI-Ctrl-CurRight, ANSI-Alt-CurRight
               Moves the cursor forward to the end of the nth word.

       goto-history: [n] ^[g
               Goes to history number n.

       kill-line: KILL (^U)
               Deletes the entire input line.

       kill-region: ^[^W
               Deletes the input between the cursor and the mark. Note: this used to be bound to ^W like in Emacs, which is usually taken by WERASE though, so it was moved.

       kill-to-eol: [n] ^K
               Deletes the input from the cursor to the end of the line if n is not specified; otherwise deletes characters between the cursor and column n.

       list: ^[?
               Prints a sorted, columnated list of command names or file names (if any) that can complete the partial word containing the cursor. Directory names have ‘/’ appended to them.

       list-command: ^X?
               Prints a sorted, columnated list of command names (if any) that can complete the partial word containing the cursor.

       list-file: ^X^Y
               Prints a sorted, columnated list of file names (if any) that can complete the partial word containing the cursor. File type indicators are appended as described under list above.

       newline: ^J, ^M
               Causes the current input line to be processed by the shell. The current cursor position may be anywhere on the line.

       newline-and-next: ^O
               Causes the current input line to be processed by the shell, and the next line from history  becomes  the  current  line.  This  is  only  useful  after  an  up-history,  search-history  or
               search-history-up.

       no-op: QUIT (^\)
               This does nothing.

       prefix-1: ^[
               Introduces a 2-character command sequence.

       prefix-2: ^X, ^[[, ^[O
               Introduces a multi-character command sequence.

       prefix-3: ^@
               Introduces a PC keyboard scancode.

       prev-hist-bigword: [n] ^[., ^[_
               If  no  count  is given, the last bigword, otherwise the (n+1)th bigword of the previous line is inserted at the cursor, and the mark is set to the beginning of the inserted word. When in‐
               voked repeatedly, the inserted text is replaced by the corresponding bigword from the second-last, third-last, etc. line.

       quote: ^^, ^V
               The following character is taken literally rather than as an editing command.

       quote-region: ^[Q
               Escapes the text between the mark and the cursor position (the entire line if no mark is set) into a shell command argument.

       redraw: ^L
               Reprints the last line of the prompt string and the current input line on a new line.

       search-character-backward: [n] ^[^]
               Search backward in the current line for the nth occurrence of the next character typed.

       search-character-forward: [n] ^]
               Search forward in the current line for the nth occurrence of the next character typed.

       search-history: ^R
               Enter incremental search mode. The internal history list is searched backwards for commands matching the input. An initial ‘^’ in the search string anchors the search at the  beginning  of
               the  line.  The  escape  key will leave search mode. Other commands, including sequences of escape as prefix-1 followed by a prefix-1 or prefix-2 key, will be executed after leaving search
               mode. The abort (^G) command will restore the input line from before search started. Successive search-history commands continue searching backward to the following previous occurrence  of
               the pattern. The history buffer retains only a finite number of lines; the oldest are discarded as necessary.

       search-history-down: ANSI-PgDn, PC-PgDn
               Search  forwards  (this  command is only useful after an up-history, search-history-up or search-history) through the history buffer for commands whose beginning matches the portion of the
               input line before the cursor. When used on an empty line, this has the same effect as down-history.

       search-history-up: ANSI-PgUp, PC-PgUp
               Search backwards through the history buffer for commands whose beginning matches the portion of the input line before the cursor. When used on an empty line, this has the  same  effect  as
               up-history.

       set-arg: ^[0 .. ^[9
               Mapped to begin prefixing a count to a command.

       set-mark-command: ^[<space>
               Set the mark at the cursor position.

       transpose-chars: ^T
               If at the end of line or, if the gmacs option is set, this exchanges the two previous characters; otherwise, it exchanges the previous and current characters and moves the cursor one char‐
               acter to the right.

       up-history: [n] ^P, ^XA, ANSI-CurUp, PC-CurUp
               Scrolls the history buffer backward n lines (earlier).

       upcase-bigword: [n] ^[U
               Uppercase the next n bigwords.

       upcase-word: [n] ^[u
               Uppercase the next n words.

       version: ^[^V
               Display the version of mksh. The current edit buffer is restored as soon as a key is pressed. The restoring keypress is processed, unless it is a space.

       vt100-hack: ^[[1
               Mapped to internally represent some longer key sequences.

       yank: ^Y
               Inserts the most recently killed text string at the current cursor position.

       yank-pop: ^[y
               Immediately after a yank, replaces the inserted text string with the next previously killed text string.

       The tab completion escapes characters the same way as the following code:

       print -nr -- "${x@/[\"-\$\&-*:-?[\\\`\{-\~${IFS-$' \t\n'}]/\\$KSH_MATCH}"

   Vi editing mode
       Note: The vi command-line editing mode has not yet been brought up to the same quality and feature set as the emacs mode. It is 8-bit clean but specifically does not support UTF-8 or MBCS.

       The vi command-line editor in mksh has basically the same commands as the vi(1) editor with the following exceptions:

       •   You start out in insert mode.

       •   There are file name and command completion commands: =, \, *, ^X, ^E, ^F and, optionally, <Tab> and <Esc>.

       •   The _ command is different (in mksh, it is the last argument command; in vi(1) it goes to the start of the current line).

       •   The / and G commands move in the opposite direction to the j command.

       •   Commands which don't make sense in a single line editor are not available (e.g. screen movement commands and ex(1)-style colon (:) commands).

       Like  vi(1),  there  are  two  modes: “insert” mode and “command” mode. In insert mode, most characters are simply put in the buffer at the current cursor position as they are typed; however, some
       characters are treated specially. In particular, the following characters are taken from current tty(4) settings (see stty(1)) and have their usual meaning (normal values are in parentheses): kill
       (^U), erase (^?), werase (^W), eof (^D), intr (^C) and quit (^\). In addition to the above, the following characters are also treated specially in insert mode:

       ^E       Command and file name enumeration (see below).

       ^F       Command and file name completion (see below). If used twice in a row, the list of possible completions is displayed; if used a third time, the completion is undone.

       ^H       Erases previous character.

       ^J | ^M  End of line. The current line is read, parsed and executed by the shell.

       ^V       Literal next. The next character typed is not treated specially (can be used to insert the characters being described here).

       ^X       Command and file name expansion (see below).

       <Esc>    Puts the editor in command mode (see below).

       <Tab>    Optional file name and command completion (see ^F above), enabled with set -o vi-tabcomplete.

       In command mode, each character is interpreted as a command. Characters that don't correspond to commands, are illegal combinations of commands, or are commands that  can't  be  carried  out,  all
       cause beeps. In the following command descriptions, an [n] indicates the command may be prefixed by a number (e.g. 10l moves right 10 characters); if no number prefix is used, n is assumed to be 1
       unless  otherwise  specified. The term “current position” refers to the position between the cursor and the character preceding the cursor. A “word” is a sequence of letters, digits and underscore
       characters or a sequence of non-letter, non-digit, non-underscore and non-whitespace characters (e.g. “ab2*&^” contains two words) and a “big-word” is a sequence of non-whitespace characters.

       Special mksh vi commands:

       The following commands are not in, or are different from, the normal vi file editor:

       [n]_        Insert a space followed by the nth big-word from the last command in the history at the current position and enter insert mode; if n is not specified, the last word is inserted.

       #           Insert the comment character (‘#’) at the start of the current line and return the line to the shell (equivalent to I#^J).

       [n]g        Like G, except if n is not specified, it goes to the most recent remembered line.

       [n]v        Internally run the command fc -e "${VISUAL:-${EDITOR:-vi}}" -- n
                   on a temporary script file to interactively edit line n (if n is not specified, the current line); then, unless the editor invoked exits nonzero but even if the script was not changed,
                   execute the resulting script as if typed on the command line; both the edited (resulting) and original lines are added onto history.

       * and ^X    Command or file name expansion is applied to the current big-word (with an appended ‘*’ if the word contains no file globbing characters) — the big-word is replaced with the  resulting
                   words.  If  the current big-word is the first on the line or follows one of the characters ‘;’, ‘|’, ‘&’, ‘(’ or ‘)’ and does not contain a slash (‘/’), then command expansion is done;
                   otherwise file name expansion is done. Command expansion will match the big-word against all aliases, functions and built-in commands as well as any executable files found by searching
                   the directories in the PATH parameter. File name expansion matches the big-word against the files in the current directory. After expansion, the cursor is placed  just  past  the  last
                   word and the editor is in insert mode.

       [n]\, [n]^F, [n]<Tab>, and [n]<Esc>
                   Command/file  name  completion.  Replace  the  current big-word with the longest unique match obtained after performing command and file name expansion. <Tab> is only recognised if the
                   vi-tabcomplete option is set, while <Esc> is only recognised if the vi-esccomplete option is set (see set -o). If n is specified, the nth possible completion is selected  (as  reported
                   by the command/file name enumeration command).

       = and ^E    Command/file name enumeration. List all the commands or files that match the current big-word.

       ^V          Display the version of mksh. The current edit buffer is restored as soon as a key is pressed. The restoring keypress is ignored.

       @c          Macro expansion. Execute the commands found in the alias _c.

       Intra-line movement commands:

       [n]h and [n]^H
               Move left n characters.

       [n]l and [n]<space>
               Move right n characters.

       0       Move to column 0.

       ^       Move to the first non-whitespace character.

       [n]|    Move to column n.

       $       Move to the last character.

       [n]b    Move back n words.

       [n]B    Move back n big-words.

       [n]e    Move forward to the end of the word, n times.

       [n]E    Move forward to the end of the big-word, n times.

       [n]w    Move forward n words.

       [n]W    Move forward n big-words.

       %       Find match. The editor looks forward for the nearest parenthesis, bracket or brace and then moves the cursor to the matching parenthesis, bracket or brace.

       [n]fc   Move forward to the nth occurrence of the character c.

       [n]Fc   Move backward to the nth occurrence of the character c.

       [n]tc   Move forward to just before the nth occurrence of the character c.

       [n]Tc   Move backward to just before the nth occurrence of the character c.

       [n];    Repeats the last f, F, t or T command.

       [n],    Repeats the last f, F, t or T command, but moves in the opposite direction.

       Inter-line movement commands:

       [n]j, [n]+, and [n]^N
               Move to the nth next line in the history.

       [n]k, [n]-, and [n]^P
               Move to the nth previous line in the history.

       [n]G    Move to line n in the history; if n is not specified, the number of the first remembered line is used.

       [n]g    Like G, except if n is not specified, it goes to the most recent remembered line.

       [n]/string
               Search backward through the history for the nth line containing string; if string starts with ‘^’, the remainder of the string must appear at the start of the history line for it to match.

       [n]?string
               Same as /, except it searches forward through the history.

       [n]n    Search for the nth occurrence of the last search string; the direction of the search is the same as the last search.

       [n]N    Search for the nth occurrence of the last search string; the direction of the search is the opposite of the last search.

       ANSI-CurUp, PC-PgUp
               Take the characters from the beginning of the line to the current cursor position as search string and do a history search, backwards, for lines beginning with this string; keep the cursor
               position. This works only in insert mode and keeps it enabled.

       ANSI-CurDown, PC-PgDn
               Take  the characters from the beginning of the line to the current cursor position as search string and do a history search, forwards, for lines beginning with this string; keep the cursor
               position. This works only in insert mode and keeps it enabled.

       Edit commands

       [n]a    Append text n times; goes into insert mode just after the current position. The append is only replicated if command mode is re-entered i.e. <Esc> is used.

       [n]A    Same as a, except it appends at the end of the line.

       [n]i    Insert text n times; goes into insert mode at the current position. The insertion is only replicated if command mode is re-entered i.e. <Esc> is used.

       [n]I    Same as i, except the insertion is done just before the first non-blank character.

       [n]s    Substitute the next n characters (i.e. delete the characters and go into insert mode).

       S       Substitute whole line. All characters from the first non-blank character to the end of the line are deleted and insert mode is entered.

       [n]cmove-cmd
               Change from the current position to the position resulting from n move-cmds (i.e. delete the indicated region and go into insert mode); if move-cmd is c, the line starting from  the  first
               non-blank character is changed.

       C       Change from the current position to the end of the line (i.e. delete to the end of the line and go into insert mode).

       [n]x    Delete the next n characters.

       [n]X    Delete the previous n characters.

       D       Delete to the end of the line.

       [n]dmove-cmd
               Delete from the current position to the position resulting from n move-cmds; move-cmd is a movement command (see above) or d, in which case the current line is deleted.

       [n]rc   Replace the next n characters with the character c.

       [n]R    Replace. Enter insert mode but overwrite existing characters instead of inserting before existing characters. The replacement is repeated n times.

       [n]~    Change the case of the next n characters.

       [n]ymove-cmd
               Yank from the current position to the position resulting from n move-cmds into the yank buffer; if move-cmd is y, the whole line is yanked.

       Y       Yank from the current position to the end of the line.

       [n]p    Paste the contents of the yank buffer just after the current position, n times.

       [n]P    Same as p, except the buffer is pasted at the current position.

       Miscellaneous vi commands

       ^J and ^M
               The current line is read, parsed and executed by the shell.

       ^L and ^R
               Redraw the current line.

       [n].    Redo the last edit command n times.

       u       Undo the last edit command.

       U       Undo all changes that have been made to the current line.

       PC Home, End, Del and cursor keys
               They move as expected, both in insert and command mode.

       intr and quit
               The interrupt and quit terminal characters cause the current line to be removed to the history and a new prompt to be printed.

FILES
       ~/.mkshrc          User  mkshrc  profile  (non-privileged interactive shells); see “Startup files.” The location can be changed at compile time (e.g. for embedded systems); AOSP Android builds use
                          /system/etc/mkshrc.
       ~/.profile         User profile (non-privileged login shells); see “Startup files” near the top of this manual.
       /etc/profile       System profile (login shells); see “Startup files.”
       /etc/shells        Shell database.
       /etc/suid_profile  Privileged shells' profile (sugid); see “Startup files.”

       Note: On Android, /system/etc/ contains the system and suid profile.

SEE ALSO
       awk(1), cat(1), ed(1), getopt(1), lksh(1), sed(1), sh(1), stty(1), dup(2), execve(2), getgid(2), getuid(2), mknod(2), mkfifo(2), open(2), pipe(2), rename(2),  wait(2),  getopt(3),  nl_langinfo(3),
       setlocale(3), signal(3), system(3), tty(4), shells(5), environ(7), script(7), utf-8(7), mknod(8)

       The FAQ at http://www.mirbsd.org/mksh-faq.htm or in the /usr/share/doc/mksh/FAQ.htm file.

       http://www.mirbsd.org/ksh-chan.htm

       Morris Bolsky, The KornShell Command and Programming Language, Prentice Hall PTR, xvi + 356 pages, 1989, ISBN 978-0-13-516972-8 (0-13-516972-0).

       Morris I. Bolsky and David G. Korn, The New KornShell Command and Programming Language (2nd Edition), Prentice Hall PTR, xvi + 400 pages, 1995, ISBN 978-0-13-182700-4 (0-13-182700-6).

       Stephen G. Kochan and Patrick H. Wood, UNIX Shell Programming, Sams, 3rd Edition, xiii + 437 pages, 2003, ISBN 978-0-672-32490-1 (0-672-32490-3).

       IEEE  Inc.,  IEEE  Standard  for  Information  Technology — Portable  Operating  System  Interface (POSIX), IEEE Press, Part 2: Shell and Utilities, xvii + 1195 pages, 1993, ISBN 978-1-55937-255-8
       (1-55937-255-9).

       Bill Rosenblatt, Learning the Korn Shell, O'Reilly, 360 pages, 1993, ISBN 978-1-56592-054-5 (1-56592-054-6).

       Bill Rosenblatt and Arnold Robbins, Learning the Korn Shell, Second Edition, O'Reilly, 432 pages, 2002, ISBN 978-0-596-00195-7 (0-596-00195-9).

       Barry Rosenberg, KornShell Programming Tutorial, Addison-Wesley Professional, xxi + 324 pages, 1991, ISBN 978-0-201-56324-5 (0-201-56324-X).

AUTHORS
       The MirBSD Korn Shell is developed by mirabilos (formerly The MirOS Project.) This shell is based on the public domain 7th edition Bourne shell clone by Charles Forsyth, who kindly agreed  to,  in
       countries  where the Public Domain status of the work may not be valid, grant a copyright licence to the general public to deal in the work without restriction and permission to sublicence deriva‐
       tives under the terms of any OSI-approved Open Source licence, and parts of the BRL shell by Doug A. Gwyn, Doug Kingston, Ron Natalie, Arnold Robbins, Lou Salkind and others. The first release  of
       pdksh  was created by Eric Gisin, and it was subsequently maintained by John R. MacMillan, Simon J. Gerraty and Michael Rendell. The effort by Debian, OpenBSD, and other contributors including our
       users, to improve the shell is appreciated. See the documentation, website and the CVS repository (source code) for details.

       mksh-os2 is developed by KO Myung-Hun <komh@chollian.net>.

       mksh-w32 is developed by Michael Langguth <mail@michael-langguth.de>.

       mksh/z/OS is contributed by Daniel Richard G. <skunk@iSKUNK.ORG>.

       The BSD daemon is Copyright © Marshall Kirk McKusick. The complete legalese is at: http://www.mirbsd.org/TaC-mksh.txt

CAVEATS
       mksh provides a consistent, clear interface normally. This may deviate from POSIX in historic or opinionated places. set -o posix (see “POSIX mode” for details) will make the  shell  more  confor‐
       mant,  but  mind  the FAQ (see “SEE ALSO”), especially regarding locales. mksh (but not lksh) provides a consistent 32-bit integer arithmetic implementation, both signed and unsigned, with sign of
       the result of a remainder operation and wraparound defined, even (defying POSIX) on 36-bit and 64-bit systems.

       mksh currently uses OPTU-16 internally, which is the same as UTF-8 and CESU-8 with 0000..FFFD being valid codepoints; raw octets map to U+EF80..U+EFFF. Future compatibility note: mksh R60 will use
       full 21-bit UTF-8 and map raw octets to U-001BBB80..U-001BBBFF instead.

BUGS
       Suspending (using ^Z) pipelines like the one below will only suspend the currently running part of the pipeline; in this example, “fubar” is immediately printed on suspension (but not later  after
       an fg).

             $ /bin/sleep 666 && echo fubar

       The  truncation  process  involved  when  changing HISTFILE does not free old history entries (leaks memory) and leaks old entries into the new history if their line numbers are not overwritten by
       same-number entries from the persistent history file; truncating the on-disc file to HISTSIZE lines has always been broken and prone to history file corruption when multiple shells  are  accessing
       the file; the rollover process for the in-memory portion of the history is slow, should use memmove(3).

       This  document  attempts  to describe mksh R59-CURRENT and up, with vendor patches from Debian, compiled without any options impacting functionality, such as MKSH_SMALL, when not called as /bin/sh
       which, on some systems only, enables set -o posix or set -o sh automatically (whose behaviour differs across targets), for an operating environment supporting all of its advanced needs.

       Please report bugs in mksh in the #!/bin/mksh channel, on IRC; note the information at: http://www.mirbsd.org/mksh-faq.htm#contact

MirBSD                                                                                         April 25, 2025                                                                                       MKSH(1)
