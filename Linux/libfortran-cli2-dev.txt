set_args(3m_cli2)                                                                                                                                                                         set_args(3m_cli2)

NAME
  set_args(3f) - [ARGUMENTS:M_CLI2] command line argument parsing (LICENSE:PD)

SYNOPSIS
  subroutine set_args(prototype,help_text,version_text,ierr,errmsg)

       character(len=*),intent(in),optional              :: prototype
       character(len=*),intent(in),optional              :: help_text(:)
       character(len=*),intent(in),optional              :: version_text(:)
       integer,intent(out),optional                      :: ierr
       character(len=:),intent(out),allocatable,optional :: errmsg

DESCRIPTION
  SET_ARGS(3f) requires a unix-like command prototype which defines the command-line options and their default values. When the program is executed this and the command-line options are applied and the
  resulting values are placed in an internal table for retrieval via GET_ARGS(3f).

  The built-in --help and --version options require optional help_text and version_text values to be provided to be particularly useful.

OPTIONS
  PROTOTYPE
    composed of all command arguments concatenated into a Unix-like command prototype string. For example:

                  call set_args('-L F --ints 1,2,3 --title "my title" -R 10.3')

  The following options are predefined for all commands:

    see "DEFINING THE PROTOTYPE" in the next section for further details.

  HELP_TEXT
    if present, will be displayed when the program is called with a --help switch, and then the program will terminate. If help text is not supplied the command line initialization string will be echoed.

  VERSION_TEXT
    if present, any version text defined will be displayed when the program is called with a --version switch, and then the program will terminate.

  IERR
    if present a non-zero option is returned when an error occurs instead of the program terminating.

  ERRMSG
    a description of the error if ierr is present.

DEFINING THE PROTOTYPE
  •  Keywords start with a single dash for short single-character keywords, and with two dashes for longer keywords.

  •  all keywords on the prototype MUST get a value.

     •  logicals must be set to an unquoted F.

     •  strings must be delimited with double-quotes.  Since internal double-quotes are represented with two double-quotes the string must be at least one space.

  •  numeric keywords are not allowed; but this allows negative numbers to be used as values.

  •  lists of values should be comma-delimited unless a user-specified delimiter is used. The prototype must use the same array delimiters as the call to get the value.

  •  to define a zero-length allocatable array make the value a delimiter (usually a comma) or an empty set of braces ("[]").

   LONG AND SHORT NAMES
  Long keywords start with two dashes followed by more than one letter.  Short keywords are a dash followed by a single letter.

  •  It is recommended long names (--keyword) should be all lowercase but are case-sensitive by default, unless "set_mode('ignorecase')" is in effect.

  •  Long names should always be more than one character.

  •  The recommended way to have short names is to suffix the long name with :LETTER in the definition.

     If this syntax is used then logical shorts may be combined on the command line when "set_mode('strict')" is in effect.

   SPECIAL BEHAVIORS
  •  A  special  behavior occurs if a keyword name ends in ::.  When the program is called the next parameter is taken as a value even if it starts with -. This is not generally recommended but is useful
     in rare cases where non-numeric values starting with a dash are desired.

  •  If the prototype ends with "--" a special mode is turned on where anything after "--" on input goes into the variable REMAINING with values double-quoted and also into  the  array  ARGS  instead  of
     becoming elements in the UNNAMED array. This is not needed for normal processing, but was needed for a program that needed this behavior for its subcommands.

     That is, for a normal call all unnamed values go into UNNAMED and ARGS and REMAINING are ignored. So for

              call set_args('-x 10 -y 20 ')

     A program invocation such as

              xx a b c -- A B C " dd "

     results in

           UNNAMED= ['a','b','c','A','B','C',' dd']
           REMAINING= ''
           ARGS= [character(len=0) :: ] ! ie, an empty character array

     Whereas

           call set_args('-x 10 -y 20 --')

     generates the following output from the same program execution:

           UNNAMED= ['a','b','c']
           REMAINING= '"A" "B" "C" " dd "'
           ARGS= ['A','B','C,' dd']

USAGE NOTES
  When invoking the program line note the (subject to change) following restrictions (which often differ between various command-line parsers):

  •  values for duplicate keywords are appended together with a space separator when a command line is executed by default.

  •  shuffling is not supported. Values immediately follow their keywords.

  •  Only short Boolean keywords can be bundled together.  If allowing bundling is desired call "set_mode('strict')".  This will require prefixing long names with "--" and short names with "-". Otherwise
     M_CLI2  relaxes  that  requirement and mostly does not care what prefix is used for a keyword.  But this would make it unclear what was meant by "-ox" if allowed options were "-o F -x F --ox F " for
     example, so "strict" mode is required to remove the ambiguity.

  •  if a parameter value of just "-" is supplied it is converted to the string "stdin".

  •  values not needed for a keyword value go into the character array "UNNAMED".

     In addition if the keyword "--" is encountered on the command line the rest of the command line goes into the character array "UNNAMED".

EXAMPLE
  Sample program:

      program demo_set_args
      use M_CLI2,  only : filenames=>unnamed, set_args, get_args
      use M_CLI2,  only : get_args_fixed_size
      implicit none
      integer                      :: i
      ! DEFINE ARGS
      real                         :: x, y, z
      real                         :: p(3)
      character(len=:),allocatable :: title
      logical                      :: l, lbig
      integer,allocatable          :: ints(:)
      !
      !  DEFINE COMMAND (TO SET INITIAL VALUES AND ALLOWED KEYWORDS)
      !  AND READ COMMAND LINE
      call set_args(' &
         ! reals
         & -x 1 -y 2.3 -z 3.4e2 &
         ! integer array
         & -p -1,-2,-3 &
         ! always double-quote strings
         & --title "my title" &
         ! string should be a single character at a minimum
         & --label " ", &
         ! set all logical values to F
         & -l F -L F &
         ! set allocatable size to zero if you like by using a delimiter
         & --ints , &
         & ')
      ! ASSIGN VALUES TO ELEMENTS
      !     SCALARS
      call get_args('x',x)
      call get_args('y',y)
      call get_args('z',z)
      call get_args('l',l)
      call get_args('L',lbig)
      call get_args('ints',ints)      ! ALLOCATABLE ARRAY
      call get_args('title',title)    ! ALLOCATABLE STRING
      call get_args_fixed_size('p',p) ! NON-ALLOCATABLE ARRAY
      ! USE VALUES
      write(*,*)'x=',x
      write(*,*)'y=',y
      write(*,*)'z=',z
      write(*,*)'p=',p
      write(*,*)'title=',title
      write(*,*)'ints=',ints
      write(*,*)'l=',l
      write(*,*)'L=',lbig
      ! UNNAMED VALUES
      if(size(filenames) > 0)then
         write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
      endif
      end program demo_set_args

RESPONSE FILES
  If you have no interest in using external files as abbreviations you can ignore this section. Otherwise, before calling set_args(3f) add:

      use M_CLI2, only : set_mode
      call set_mode('response_file')

  M_CLI2 Response files are small files containing CLI (Command Line Interface) arguments that end with ".rsp" that can be used when command lines are so long that they would exceed line length limits or
  so complex that it is useful to have a platform-independent method of creating an abbreviation.

  Shell aliases and scripts are often used for similar purposes (and allow for much more complex conditional execution, of course), but they generally cannot be used to overcome line  length  limits  and
  are typically platform-specific.

  Examples of commands that support similar response files are the Clang and Intel compilers, although there is no standard format for the files.

  They  are  read  if you add options of the syntax "@NAME" as the FIRST parameters on your program command line calls. They are not recursive -- that is, an option in a response file cannot be given the
  value "@NAME2" to call another response file.

  More than one response name may appear on a command line.

  They are case-sensitive names.

  Note "@" s a special character in Powershell, and requires being escaped with a grave character.

   LOCATING RESPONSE FILES
  A search for the response file always starts with the current directory.  The search then proceeds to look in  any  additional  directories  specified  with  the  colon-delimited  environment  variable
  CLI_RESPONSE_PATH.

  The first resource file found that results in lines being processed will be used and processing stops after that first match is found. If no match is found an error occurs and the program is stopped.

   RESPONSE FILE SECTIONS
  A  simple  response  file  just has options for calling the program in it prefixed with the word "options".  But they can also contain section headers to denote selections that are only executed when a
  specific OS is being used, print messages, and execute system commands.

   SEARCHING FOR OSTYPE IN REGULAR FILES
  So assuming the name @NAME was specified on the command line a file named NAME.rsp will be searched for in all the search directories and then in that file a string that starts with the string  @OSTYPE
  (if the environment variables $OS and $OSTYPE are not blank. $OSTYPE takes precedence over $OS).

   SEARCHING FOR UNLABELED DIRECTIVES IN REGULAR FILES
  Then, the same files will be searched for lines above any line starting with "@". That is, if there is no special section for the current OS it just looks at the top of the file for unlabeled options.

   SEARCHING FOR OSTYPE AND NAME IN THE COMPOUND FILE
  In addition or instead of files with the same name as the @NAME option on the command line, you can have one file named after the executable name that contains multiple abbreviation names.

  So  if  your  program  executable  is named EXEC you create a single file called EXEC.rsp and can append all the simple files described above separating them with lines of the form @OSTYPE@NAME or just
  @NAME.

  So if no specific file for the abbreviation is found a file called "EXEC.rsp" is searched for where "EXEC" is the name of the executable.  This file is always a "compound" response file that  uses  the
  following format:

  Any compound EXEC.rsp file found in the current or searched directories will be searched for the string @OSTYPE@NAME first.

  Then if nothing is found, the less specific line @NAME is searched for.

   THE SEARCH IS OVER
  Sounds  complicated  but  actually  works  quite  intuitively. Make a file in the current directory and put options in it and it will be used. If that file ends up needing different cases for different
  platforms add a line like "@Linux" to the file and some more lines and that will only be executed if the environment variable OSTYPE or OS is "Linux". If no match is found for named sections the  lines
  at the top before any "@" lines will be used as a default if no match is found.

  If  you  end  up  using  a  lot of files like this you can combine them all together and put them into a file called "program_name".rsp and just put lines like @NAME or @OSTYPE@NAME at that top of each
  selection.

  Now, back to the details on just what you can put in the files.

SPECIFICATION FOR RESPONSE FILES
   SIMPLE RESPONSE FILES
  The first word of a line is special and has the following meanings:

     options|-  Command options following the rules of the SET_ARGS(3f)
                prototype. So
                 o It is preferred to specify a value for all options.
                 o double-quote strings.
                 o give a blank string value as " ".
                 o use F|T for lists of logicals,
                 o lists of numbers should be comma-delimited.
                 o --usage, --help, --version, --verbose, and unknown
                   options are ignored.

     comment|#  Line is a comment line
     system|!   System command.
                System commands are executed as a simple call to
                system (so a cd(1) or setting a shell variable
                would not effect subsequent lines, for example)
                BEFORE the command being processed.
     print|>    Message to screen
     stop       display message and stop program.

  NOTE: system commands are executed when encountered, but options are gathered from multiple option lines and passed together at the end of processing of the block; so  all  commands  will  be  executed
  BEFORE the command for which options are being supplied no matter where they occur.

  So if a program that does nothing but echos its parameters

     program testit
     use M_CLI2, only : set_args, rget, sget, lget, set_mode
     implicit none
        real :: x,y                           ; namelist/args/ x,y
        character(len=:),allocatable :: title ; namelist/args/ title
        logical :: big                        ; namelist/args/ big
        call set_mode('response_file')
        call set_args('-x 10.0 -y 20.0 --title "my title" --big F')
        x=rget('x')
        y=rget('y')
        title=sget('title')
        big=lget('big')
        write(*,nml=args)
     end program testit

  And a file in the current directory called "a.rsp" contains

      # defaults for project A
      options -x 1000 -y 9999
      options --title " "
      options --big T

  The program could be called with

      $myprog     # normal call
       X=10.0 Y=20.0 TITLE="my title"

      $myprog @a  # change defaults as specified in "a.rsp"
      X=1000.0 Y=9999.0 TITLE=" "

      # change defaults but use any option as normal to override defaults
      $myprog @a -y 1234
       X=1000.0 Y=1234.0 TITLE=" "

   COMPOUND RESPONSE FILES
  A compound response file has the same basename as the executable with a ".rsp" suffix added. So if your program is named "myprg" the filename must be "myprg.rsp".

     Note that here `basename` means the last leaf of the
     name of the program as returned by the Fortran intrinsic
     GET_COMMAND_ARGUMENT(0,...) trimmed of anything after a period ("."),
     so it is a good idea not to use hidden files.

  Unlike simple response files compound response files can contain multiple setting names.

  Specifically in a compound file if the environment variable $OSTYPE (first) or $OS is set the first search will be for a line of the form (no leading spaces should be used):

     @OSTYPE@alias_name

  If no match or if the environment variables $OSTYPE and $OS were not set or a match is not found then a line of the form

     @alias_name

  is  searched for in simple or compound files. If found subsequent lines will be ignored that start with "@" until a line not starting with "@" is encountered. Lines will then be processed until another
  line starting with "@" is found or end-of-file is encountered.

   COMPOUND RESPONSE FILE EXAMPLE
  An example compound file

     #################
     @if
     > RUNNING TESTS USING RELEASE VERSION AND ifort
     options test --release --compiler ifort
     #################
     @gf
     > RUNNING TESTS USING RELEASE VERSION AND gfortran
     options test --release --compiler gfortran
     #################
     @nv
     > RUNNING TESTS USING RELEASE VERSION AND nvfortran
     options test --release --compiler nvfortran
     #################
     @nag
     > RUNNING TESTS USING RELEASE VERSION AND nagfor
     options test --release --compiler nagfor
     #
     #################
     # OS-specific example:
     @Linux@install
     #
     # install executables in directory (assuming install(1) exists)
     #
     system mkdir -p ~/.local/bin
     options run --release T --runner "install -vbp -m 0711 -t ~/.local/bin"
     @install
     STOP INSTALL NOT SUPPORTED ON THIS PLATFORM OR $OSTYPE NOT SET
     #
     #################
     @fpm@testall
     #
     !fpm test --compiler nvfortran
     !fpm test --compiler ifort
     !fpm test --compiler gfortran
     !fpm test --compiler nagfor
     STOP tests complete. Any additional parameters were ignored
     #################

  Would be used like

     fpm @install
     fpm @nag --
     fpm @testall

   NOTES
  The intel Fortran compiler now calls the response files "indirect files" and does not add the implied suffix ".rsp" to the files anymore. It also allows the @NAME syntax anywhere on the  command  line,
  not just at the beginning. -- 20201212

AUTHOR
  John S. Urban, 2019

LICENSE
  Public Domain

                                                                                             February 10, 2023                                                                            set_args(3m_cli2)
