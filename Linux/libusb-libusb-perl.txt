USB::LibUSB::XS(3pm)                                                                User Contributed Perl Documentation                                                                USB::LibUSB::XS(3pm)

NAME
       USB::LibUSB::XS - Raw XS bindings to the libusb-1.0 <http://libusb.info/> API.

SYNOPSIS
         # import all the constants and non-method subroutines
         use USB::LibUSB::XS;

         my ($rv, $ctx) = USB::LibUSB::XS->init();
         $ctx->set_debug(LIBUSB_LOG_LEVEL_WARNING);

         my ($vendor_id, $product_id) = (0x1234, 0x5678);
         my $handle = $ctx->open_device_with_vid_pid($vendor_id, $product_id);

         $rv = $handle->set_auto_detach_kernel_driver(1);
         $rv = $handle->claim_interface($interface);

         $rv = $handle->bulk_transfer_write($endpoint, "some data", $timeout);

         ($rv, my $data) = $handle->bulk_transfer_read($endpoint, $length, $timeout);

DESCRIPTION
       USB::LibUSB::XS provides the raw XS access to the libusb-1.0 API, which can then be used by modules like USB::LibUSB, which is a more user frienly interface.

METHODS/FUNCTIONS
       The following API is documented in the excellent libusb documentation <http://libusb.sourceforge.net/api-1.0/>.

   Library initialization/deinitialization
       Implementation status: complete.

       set_debug

        $ctx->set_debug(LIBUSB_LOG_LEVEL_DEBUG);

       init

        my ($rv, $ctx) = USB::LibUSB::XS->init();

       exit

        $ctx->exit();

   Device handling and enumeration
       Implementation status: complete.

       get_device_list

        my ($rv, @device_list) = $ctx->get_device_list();

       @device_list contains USB::LibUSB::XS::Device objects.

       get_bus_number

        my $bus_number = $dev->get_bus_number();

       get_port_number

        my $port_number = $dev->get_port_number();

       get_port_numbers

        my ($rv, @port_numbers) = $dev->get_port_numbers();

       get_parent

        my $parent_dev = $dev->get_parent();

       get_device_address

        my $address = $dev->get_device_address();

       get_device_speed

        my $speed = $dev->get_device_speed();

       get_max_packet_size

        my $size = $dev->get_max_packet_size($endpoint);

       get_max_iso_packet_size

        my $size = $dev->get_max_iso_packet_size($endpoint);

       ref_device

        $dev = $dev->ref_device();

       unref_device

        $dev->unref_device();

       open

        my ($rv, $handle) = $dev->open();

       Return a USB::LibUSB::XS::Device::Handle object in $handle if $rv is 0.

       open_device_with_vid_pid

        my $handle = $ctx->open_device_with_vid_pid(0x1111, 0x2222);

       Return undef on error.

       close

        $handle->close();

       get_device

        my $dev = $hanlde->get_device();

       get_configuration

        my $config = $handle->get_configuration();

       set_configuration

        my $rv = $handle->set_configuration($config);

       claim_interface

        my $rv = $handle->claim_interface($interface_number);

       release_interface

        my $rv = $handle->release_interface($interface_number);

       set_interface_alt_setting

        my $rv = $handle->set_interface_alt_setting($interface_number, $alternate_setting);

       clear_halt

        my $rv = $handle->clear_halt($endpoint);

       reset_device

        my $rv = $handle->reset_device();

       kernel_driver_active

        my $is_active = $handle->kernelt_driver_active($interface_number);

       detach_kernel_driver

        my $rv = $handle->detach_kernel_driver($interface_number);

       attach_kernel_driver

        my $rv = $handle->attach_kernel_driver($interface_number);

       set_auto_detach_kernel_driver

        my $rv = $handle->set_auto_detach_kernel_driver($enable);

   Miscellaneous
       Implementation status: complete.

       libusb_has_capability

        my $has_cap = libusb_has_capability($capability);

       libusb_error_name

        my $error_name = libusb_error_name($error_code);

       libusb_get_version

        my $version_hash = libusb_get_version();
        my $major = $version_hash->{major};

       libusb_setlocale

        my $rv = libusb_setlocale($locale);

       libusb_strerror

        my $strerror = libusb_strerror($error_code);

   USB descriptors
       Implementation status: complete.

       All descriptors are returned as hash references.

       get_device_descriptor

        my ($rv, $desc) = $dev->get_device_descriptor();
        my $iSerialNumber = $desc->{iSerialNumber};

       get_active_config_descriptor

        my ($rv, $config) = $dev->get_active_config_descriptor($ctx);
        my $iConfiguration = $config->{iConfiguration};

       get_config_descriptor

        my ($rv, $config) = $dev->get_config_descriptor($ctx, $config_index);

       get_config_descriptor_by_value

        my ($rv, $config) = $dev->get_config_descriptor_by_value($ctx, $bConfigurationValue);

       get_bos_descriptor

        my ($rv, $bos) = $handle->get_bos_descriptor($ctx);

       get_string_descriptor_ascii

        my ($rv, $data) = $handle->get_string_descriptor_ascii($desc_index, $length);

       get_descriptor

        my ($rv, $data) = $handle->get_descriptor($desc_type, $desc_index, $length);

       get_string_descriptor

        my ($rv, $data) = $handle->get_string_descriptor($desc_index, $langid, $length);

   Device hotplug event notification
       Implementation status: To be implemented.

   Asynchronous device I/O
       Implementation status: To be implemented.

   Polling and timing
       Implementation status: To be implemented.

   Synchronous device I/O
       Implementation status: complete.

       Timeouts are given in milliseconds.

       control_transfer_write

        my $rv = $handle->control_transfer_write($bmRequestType, $bRequest, $wValue, $wIndex, $data, $timeout);

       control_transfer_read

        my ($rv, $data) = $handle->control_transfer_read($bmRequestType, $bRequest, $wValue, $wIndex, $length, $timeout);

       bulk_tranfer_write

        my $rv = $handle->bulk_transfer_write($endpoint, $data, $timeout);

       bulk_transfer_read

        my ($rv, $data) = $handle->bulk_transfer_read($endpoint, $length, $timeout);

       interrupt_transfer_write

        my $rv = $handle->interrupt_transfer_write($endpoint, $data, $timeout);

       interrupt_transfer_read

        my ($rv, $data) = $handle->interrupt_transfer_read($endpoint, $length, $timeout);

REPORTING BUGS
       Please report bugs at <https://github.com/lab-measurement/USB-LibUSB/issues>.

CONTACT
       Feel free to contact us at the #labmeasurement channel on Freenode IRC.

AUTHOR
       Simon Reinhardt, <simon.reinhardt@physik.uni-r.de>

COPYRIGHT AND LICENSE
       Copyright (C) 2017 by Simon Reinhardt

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.24.0 or, at your option, any later version of Perl 5 you may have
       available.

perl v5.40.0                                                                                     2024-10-15                                                                            USB::LibUSB::XS(3pm)
