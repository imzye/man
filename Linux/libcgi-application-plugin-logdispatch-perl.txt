CGI::Application::Plugin::LogDispatch(3pm)                                          User Contributed Perl Documentation                                          CGI::Application::Plugin::LogDispatch(3pm)

NAME
       CGI::Application::Plugin::LogDispatch - Add Log::Dispatch support to CGI::Application

SYNOPSIS
        package My::App;

        use CGI::Application::Plugin::LogDispatch;

        sub cgiapp_init {
          my $self = shift;

          # calling log_config is optional as
          # some simple defaults will be used
          $self->log_config(
            LOG_DISPATCH_MODULES => [
              {    module => 'Log::Dispatch::File',
                     name => 'debug',
                 filename => '/tmp/debug.log',
                min_level => 'debug',
              },
            ]
          );
        }

        sub myrunmode {
          my $self = shift;

          $self->log->info('Information message');
          $self->log->debug('Debug message');
        }

        - or as a class based singleton -

        package My::App;

        use CGI::Application::Plugin::LogDispatch (
          LOG_DISPATCH_MODULES => [
            {    module => 'Log::Dispatch::File',
                   name => 'debug',
               filename => '/tmp/debug.log',
              min_level => 'debug',
            },
          ]
        );

        My::App->log->info('Information message');

        sub myrunmode {
          my $self = shift;

          $self->log->info('This also works');
        }

DESCRIPTION
       CGI::Application::Plugin::LogDispatch adds logging support to your CGI::Application modules by providing a Log::Dispatch dispatcher object that is accessible from anywhere in the application.

       If you have CGI::Application::Plugin::DevPopup installed, a "Log Entries" report is added to the popup window, containing all of the entries that were logged during the execution of the runmode.

METHODS
   log
       This method will return the current Log::Dispatch dispatcher object.  The Log::Dispatch object is created on the first call to this method, and any subsequent calls will return the same object.
       This effectively creates a singleton log dispatcher for the duration of the request.  If "log_config" has not been called before the first call to "log", then it will choose some sane defaults to
       create the dispatcher object (the exact default values are defined below).

         # retrieve the log object
         my $log = $self->log;
         $log->warning("something's not right!");
         $log->emergency("It's all gone pear shaped!");

         - or -

         # use the log object directly
         $self->log->debug(Data::Dumper::Dumper(\%hash));

         - or -

         # if you configured it as a singleton
         My::App->log->debug('This works too');

   log_config
       This method can be used to customize the functionality of the CGI::Application::Plugin::LogDispatch module.  Calling this method does not mean that a new Log::Dispatch object will be immediately
       created.  The log object will not be created until the first call to $self->log.

       The recommended place to call "log_config" is in the "cgiapp_init" stage of CGI::Application.  If this method is called after the log object has already been accessed, then it will die with an
       error message.

       If this method is not called at all then a reasonable set of defaults will be used (the exact default values are defined below).

       The following parameters are accepted:

       LOG_DISPATCH_OPTIONS
           This  allows  you  to  customize  how the Log::Dispatch object is created by providing a hash of options that will be passed to the Log::Dispatch constructor.  Please see the documentation for
           Log::Dispatch for the exact syntax of the parameters.  Surprisingly enough you will usually not need to use this option, instead look at the LOG_DISPATCH_MODULES option.

            LOG_DISPATCH_OPTIONS => {
                 callbacks => sub { my %h = @_; return time().': '.$h{message}; },
            }

       LOG_DISPATCH_MODULES
           This option allows you to specify the Log::Dispatch::* modules that you wish to use to log messages.  You can list multiple dispatch modules, each with their own set of  options.   Format  the
           options in an array of hashes, where each hash contains the options for the Log::Dispatch:: module you are configuring and also include a 'module' parameter containing the name of the dispatch
           module.   See  below for an example.  You can also add an 'append_newline' option to automatically append a newline to each log entry for this dispatch module (this option is not needed if you
           already specified the APPEND_NEWLINE option listed below which will add a newline for all dispatch modules).

            LOG_DISPATCH_MODULES => [
              {         module => 'Log::Dispatch::File',
                          name => 'messages',
                      filename => '/tmp/messages.log',
                     min_level => 'info',
                append_newline => 1
              },
              {         module => 'Log::Dispatch::Email::MailSend',
                          name => 'email',
                            to => [ qw(foo@bar.com bar@baz.org ) ],
                        subject => 'Oh No!!!!!!!!!!',
                     min_level => 'emerg'
              }
            ]

       APPEND_NEWLINE
           By default Log::Dispatch does not append a newline to the end of the log messages.  By setting this option to a true value, a newline character will automatically be added to the  end  of  the
           log message.

            APPEND_NEWLINE => 1

       LOG_METHOD_EXECUTION (EXPERIMENTAL)
           This  option  will  allow  you  to  log  the execution path of your program.  Set LOG_METHOD_EXECUTION to a list of all the modules you want to be logged.  This will automatically send a debug
           message at the start and end of each method/function that is called in the modules you listed.  The parameters passed, and the return value will also be logged.  This can be useful by  tracing
           the program flow in the logfile without having to resort to the debugger.

            LOG_METHOD_EXECUTION => [qw(__PACKAGE__ CGI::Application CGI)],

           WARNING:   This  hasn't  been  heavily  tested, although it seems to work fine for me.  Also, a closure is created around the log object, so some care may need to be taken when using this in a
           persistent environment like mod_perl.  This feature depends on the Sub::WrapPackages module.

   DEFAULT OPTIONS
       The following example shows what options are set by default (ie this is what you would get if you do not call log_config).  A single Log::Dispatch::Screen module  that  writes  error  messages  to
       STDERR with a minimum log level of debug.

        $self->log_config(
          LOG_DISPATCH_MODULES => [
            {        module => 'Log::Dispatch::Screen',
                       name => 'screen',
                     stderr => 1,
                  min_level => 'debug',
             append_newline => 1
            }
          ],
        );

       Here  is  a  more  customized example that uses two file appenders, and an email gateway.  Here all debug messages are sent to /tmp/debug.log, and all messages above are sent to /tmp/messages.log.
       Also, any emergency messages are emailed to foo@bar.com and bar@baz.org.

        $self->log_config(
          LOG_DISPATCH_MODULES => [
            {    module => 'Log::Dispatch::File',
                   name => 'debug',
               filename => '/tmp/debug.log',
              min_level => 'debug',
              max_level => 'debug'
            },
            {    module => 'Log::Dispatch::File',
                   name => 'messages',
               filename => '/tmp/messages.log',
              min_level => 'info'
            },
            {    module => 'Log::Dispatch::Email::MailSend',
                   name => 'email',
                     to => [ qw(foo@bar.com bar@baz.org ) ],
                 subject => 'Oh No!!!!!!!!!!',
              min_level => 'emerg'
            }
          ],
          APPEND_NEWLINE => 1,
        );

EXAMPLE
       In a CGI::Application module:

         # configure the log modules once during the init stage
         sub cgiapp_init {
           my $self = shift;

           # Configure the session
           $self->log_config(
             LOG_DISPATCH_MODULES => [
               {    module => 'Log::Dispatch::File',
                      name => 'messages',
                  filename => '/tmp/messages.log',
                 min_level => 'error'
               },
               {    module => 'Log::Dispatch::Email::MailSend',
                      name => 'email',
                        to => [ qw(foo@bar.com bar@baz.org ) ],
                    subject => 'Oh No!!!!!!!!!!',
                 min_level => 'emerg'
               }
             ],
             APPEND_NEWLINE => 1,
           );

         }

         sub cgiapp_prerun {
           my $self = shift;

           $self->log->debug("Current runmode:  ".$self->get_current_runmode);
         }

         sub my_runmode {
           my $self = shift;
           my $log  = $self->log;

           if ($ENV{'REMOTE_USER'}) {
             $log->info("user ".$ENV{'REMOTE_USER'});
           }

           # etc...
         }

SINGLETON SUPPORT
       This module can be used as a singleton object.  This means that when the object is created, it will remain accessible  for  the  duration  of  the  process.   This  can  be  useful  in  persistent
       environments  like  mod_perl and PersistentPerl, since the object only has to be created one time, and will remain in memory across multiple requests.  It can also be useful if you want to setup a
       DIE handler, or WARN handler, since you will not have access to the $self object.

       To use this module as a singleton you need to provide all configuration parameters as options to the use statement.  The use statement will accept all  the  same  parameters  that  the  log_config
       method accepts, so see the documentation above for more details.

       When creating the singleton, the log object will be saved in the namespace of the module that created it.  The singleton will also be inherited by any subclasses of this module.

       NOTE:  Singleton support requires the Class::ISA module which is not installed automatically by this module.

SINGLETON EXAMPLE
         package My::App;

         use base qw(CGI::Application);
         use CGI::Application::Plugin::LogDispatch(
             LOG_DISPATCH_MODULES => [
               {    module => 'Log::Dispatch::File',
                      name => 'messages',
                  filename => '/tmp/messages.log',
                 min_level => 'error'
               },
             ],
             APPEND_NEWLINE => 1,
           );

         }

         sub cgiapp_prerun {
           my $self = shift;

           $self->log->debug("Current runmode:  ".$self->get_current_runmode);
         }

         sub my_runmode {
           my $self = shift;
           my $log  = $self->log;

           if ($ENV{'REMOTE_USER'}) {
             $log->info("user ".$ENV{'REMOTE_USER'});
           }

           # etc...
         }

         package My::App::Subclass;

         use base qw(My::App);

         # Setup a die handler that uses the logger
         $SIG{__DIE__} = sub { My::App::Subclass->log->emerg(@_); CORE::die(@_); };

         sub my_other_runmode {
           my $self = shift;

           $self->log->info("This will log to the logger configured in My::App");
         }

BUGS
       Please  report  any  bugs  or  feature  requests to "bug-cgi-application-plugin-logdispatch@rt.cpan.org", or through the web interface at <http://rt.cpan.org>.  I will be notified, and then you'll
       automatically be notified of progress on your bug as I make changes.

SEE ALSO
       CGI::Application, Log::Dispatch, Log::Dispatch::Screen, Sub::WrapPackages, perl(1)

AUTHOR
       Cees Hek <ceeshek@gmail.com>

LICENSE
       Copyright (C) 2004 Cees Hek <ceeshek@gmail.com>

       This library is free software. You can modify and or distribute it under the same terms as Perl itself.

perl v5.34.0                                                                                     2022-06-09                                                      CGI::Application::Plugin::LogDispatch(3pm)
