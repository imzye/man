FENICSFORMCOMPILERX(1)                                                                     FEniCS Form Compiler X                                                                    FENICSFORMCOMPILERX(1)

NAME
       fenicsformcompilerx - FEniCS Form Compiler X Documentation

       The is an experimental version of the FEniCS Form Compiler.  It is developed at https://github.com/FEniCS/ffcx.
                                                        ┌─────────────────────────────┬─────────────────────────────────────────────────────────────────┐
                                                        │ ffcx                        │ FEniCS Form Compiler (FFCx).                                    │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.__main__               │ Run ffcx on a UFL file.                                         │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.analysis               │ Compiler stage 1: Analysis.                                     │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.compiler               │ Main interface for compilation of forms.                        │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.element_interface      │ Finite element interface.                                       │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.formatting             │ Compiler stage 5: Code formatting.                              │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.main                   │ Command-line interface to FFCx.                                 │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.naming                 │ Naming.                                                         │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.codegeneration         │ FFCx code generation.                                           │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.options                │ Options.                                                        │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.ir.representation      │ Compiler stage 2: Code representation.                          │
                                                        ├─────────────────────────────┼─────────────────────────────────────────────────────────────────┤
                                                        │ ffcx.ir.representationutils │ Utility functions for some code shared between representations. │
                                                        └─────────────────────────────┴─────────────────────────────────────────────────────────────────┘

FFCX
       FEniCS Form Compiler (FFCx).

       FFCx compiles finite element variational forms into C code.

       ffcx.get_options(priority_options: dict[str, type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None | int | float] | None = None) -> dict[str,
       int | float | type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None]
              Return (a copy of) the merged option values for FFCX.

              Parameters
                     priority_options – take priority over all other option values (see notes)

              Returns
                     merged option values

              NOTE:
                 This function sets the log level from the merged option values prior to returning.

                 The ffcx_options.json files are cached on the first call. Subsequent calls to this function use this cache.

                 Priority ordering of options from highest to lowest is:

                 • priority_options (API and command line options)

                 • $PWD/ffcx_options.json (local options)

                 • $XDG_CONFIG_HOME/ffcx/ffcx_options.json (user options)

                 • FFCX_DEFAULT_OPTIONS in ffcx.options

                 XDG_CONFIG_HOME is ~/.config/ if the environment variable is not set.

                 Example ffcx_options.json file:
                     { “epsilon”: 1e-7 }

FFCX.__MAIN__
       Run ffcx on a UFL file.

       ffcx.__main__.main(args=None)
              Run ffcx on a UFL file.

FFCX.ANALYSIS
       Compiler stage 1: Analysis.

       This module implements the analysis/preprocessing of variational forms, including automatic selection of elements, degrees and form representation type.

       Functions
                                                                   ┌───────────────────────────────────────────────┬────────────────────────┐
                                                                   │ analyze_ufl_objects(ufl_objects, scalar_type) │ Analyze ufl object(s). │
                                                                   └───────────────────────────────────────────────┴────────────────────────┘

       Classes
                                                                            ┌──────────────────────────────────────────┬───────────┐
                                                                            │ UFLData(form_data, unique_elements, ...) │ UFL data. │
                                                                            └──────────────────────────────────────────┴───────────┘

       class ffcx.analysis.UFLData(form_data: tuple[ufl.algorithms.formdata.FormData, ...], unique_elements: list[basix.ufl._ElementBase], element_numbers: dict[basix.ufl._ElementBase, int], unique_coor‐
       dinate_elements: list[basix.ufl._ElementBase], expressions: list[tuple[ufl.core.expr.Expr, npt.NDArray[np.float64], ufl.core.expr.Expr]])
              Bases: NamedTuple

              UFL data.

              Create new instance of UFLData(form_data, unique_elements, element_numbers, unique_coordinate_elements, expressions)

              element_numbers: dict[_ElementBase, int]
                     Alias for field number 2

              expressions: list[tuple[Expr, ndarray[tuple[Any, ...], dtype[float64]], Expr]]
                     Alias for field number 4

              form_data: tuple[FormData, ...]
                     Alias for field number 0

              unique_coordinate_elements: list[_ElementBase]
                     Alias for field number 3

              unique_elements: list[_ElementBase]
                     Alias for field number 1

       ffcx.analysis.analyze_ufl_objects(ufl_objects: list[Form | AbstractFiniteElement | Mesh | tuple[Expr, ndarray[tuple[Any, ...], dtype[floating]]]], scalar_type: type[Any] | dtype[Any] | _SupportsD‐
       Type[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None) -> UFLData
              Analyze ufl object(s).

              Parameters

                     • ufl_objects – UFL objects

                     • scalar_type – Scalar type that should be used for the analysis

              Returns
                     form_datas:  Form_data  objects  unique_elements:  Unique elements across all forms and expressions element_numbers: Mapping to unique numbers for all elements unique_coordinate_ele‐
                     ments: Unique coordinate elements across all forms and expressions expressions: List of all expressions after post-processing, with its evaluation points
                        and the original expression

              Return type
                     A data structure holding

FFCX.COMPILER
       Main interface for compilation of forms.

       Breaks the compilation into several sequential stages.  The output of each stage is the input of the next stage.

   Compiler stages
       0.  Language, parsing

           • Input:  Python code or .ufl file

           • Output: UFL form

           This stage consists of parsing and expressing a form in the UFL form language. This stage is handled by UFL.

       1.  Analysis

           • Input:  UFL form

           • Output: Preprocessed UFL form and FormData (metadata)

           This stage preprocesses the UFL form and extracts form metadata. It may also perform simplifications on the form.

       2.  Code representation

           • Input:  Preprocessed UFL form and FormData (metadata)

           • Output: Intermediate Representation (IR)

           This stage examines the input and generates all data needed for code generation. This includes generation of finite element basis functions, extraction of data for mapping of degrees of  free‐
           dom and possible precomputation of integrals. Most of the complexity of compilation is handled in this stage.

           The IR is stored as a dictionary, mapping names of UFC functions to data needed for generation of the corresponding code.

       3.  Code generation

           • Input:  Intermediate Representation (IR)

           • Output: C code

           This stage examines the IR and generates the actual C code for the body of each UFC function.

           The code is stored as a dictionary, mapping names of UFC functions to strings containing the C code of the body of each function.

       4.  Code formatting

           • Input:  C code

           • Output: C code files

           This stage examines the generated C++ code and formats it according to the UFC format, generating as output one or more .h/.c files conforming to the UFC format.

       Functions
                                                        ┌──────────────────────────────────────────────────┬────────────────────────────────────────────┐
                                                        │ compile_ufl_objects(ufl_objects, options[, ...]) │ Generate UFC code for a given UFL objects. │
                                                        └──────────────────────────────────────────────────┴────────────────────────────────────────────┘

       ffcx.compiler.analyze_ufl_objects(ufl_objects: list[Form | AbstractFiniteElement | Mesh | tuple[Expr, ndarray[tuple[Any, ...], dtype[floating]]]], scalar_type: type[Any] | dtype[Any] | _SupportsD‐
       Type[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None) -> UFLData
              Analyze ufl object(s).

              Parameters

                     • ufl_objects – UFL objects

                     • scalar_type – Scalar type that should be used for the analysis

              Returns
                     form_datas:  Form_data  objects  unique_elements:  Unique elements across all forms and expressions element_numbers: Mapping to unique numbers for all elements unique_coordinate_ele‐
                     ments: Unique coordinate elements across all forms and expressions expressions: List of all expressions after post-processing, with its evaluation points
                        and the original expression

              Return type
                     A data structure holding

       ffcx.compiler.compile_ufl_objects(ufl_objects: list[Any], options: dict[str, int | float | type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str |
       None], object_names: dict[int, str] | None = None, prefix: str | None = None, visualise: bool = False) -> tuple[str, str]
              Generate UFC code for a given UFL objects.

              Parameters

                     • ufl_objects – Objects to be compiled. Accepts elements, forms, integrals or coordinate mappings.

                     • object_names – Map from object Python id to object name

                     • prefix – Prefix

                     • options – Options

                     • visualise – Toggle visualisation

       ffcx.compiler.compute_ir(analysis: UFLData, object_names: dict[int, str], prefix: str, options: dict[str, type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] |
       _DTypeDict | str | None | int | float], visualise: bool) -> DataIR
              Compute intermediate representation.

       ffcx.compiler.format_code(code: CodeBlocks) -> tuple[str, str]
              Format given code in UFC format. Returns two strings with header and source file contents.

       ffcx.compiler.generate_code(ir: DataIR, options: dict[str, int | float | type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None]) -> CodeBlocks
              Generate code blocks from intermediate representation.

       ffcx.compiler.time() -> floating-point number
              Return the current time in seconds since the Epoch.  Fractions of a second may be present if the system clock provides them.

FFCX.ELEMENT_INTERFACE
       Finite element interface.

       Functions
                                                   ┌────────────────────────────────────────────────┬────────────────────────────────────────────────────────┐
                                                   │ basix_index(indices)                           │ Get the Basix index of a derivative.                   │
                                                   ├────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
                                                   │ create_quadrature(cellname, degree, rule, ...) │ Create a quadrature rule.                              │
                                                   ├────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
                                                   │ map_facet_points(points, facet, cellname)      │ Map points from a reference facet to a physical facet. │
                                                   ├────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
                                                   │ reference_cell_vertices(cellname)              │ Get the vertices of a reference cell.                  │
                                                   └────────────────────────────────────────────────┴────────────────────────────────────────────────────────┘

       ffcx.element_interface.basix_index(indices: tuple[int]) -> int
              Get the Basix index of a derivative.

       ffcx.element_interface.create_quadrature(cellname: str, degree: int, rule: str, elements: list[_ElementBase]) -> tuple[Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsAr‐
       ray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str |
       _NestedSequence[complex | bytes | str]]
              Create a quadrature rule.

       ffcx.element_interface.map_facet_points(points: ndarray[tuple[Any, ...], dtype[float64]], facet: int, cellname: str) -> ndarray[tuple[Any, ...], dtype[float64]]
              Map points from a reference facet to a physical facet.

       ffcx.element_interface.reference_cell_vertices(cellname: str) -> ndarray[tuple[Any, ...], dtype[float64]]
              Get the vertices of a reference cell.

FFCX.FORMATTING
       Compiler stage 5: Code formatting.

       This module implements the formatting of UFC code from a given dictionary of generated C++ code for the body of each UFC function.

       It relies on templates for UFC code available as part of the module ufcx_utils.

       Functions
                                                              ┌────────────────────────────────────────────────┬──────────────────────────────────┐
                                                              │ format_code(code)                              │ Format given code in UFC format. │
                                                              ├────────────────────────────────────────────────┼──────────────────────────────────┤
                                                              │ write_code(code_h, code_c, prefix, output_dir) │ Write code to files.             │
                                                              └────────────────────────────────────────────────┴──────────────────────────────────┘

       class ffcx.formatting.CodeBlocks(file_pre: list[tuple[str, str]], integrals: list[tuple[str, str]], forms: list[tuple[str, str]], expressions: list[tuple[str, str]], file_post: list[tuple[str,
       str]])
              Bases: NamedTuple

              Storage of code blocks of the form (declaration, implementation).

              Blocks for integrals, forms and expressions, and start and end of file output

              Create new instance of CodeBlocks(file_pre, integrals, forms, expressions, file_post)

              expressions: list[tuple[str, str]]
                     Alias for field number 3

              file_post: list[tuple[str, str]]
                     Alias for field number 4

              file_pre: list[tuple[str, str]]
                     Alias for field number 0

              forms: list[tuple[str, str]]
                     Alias for field number 2

              integrals: list[tuple[str, str]]
                     Alias for field number 1

       ffcx.formatting.format_code(code: CodeBlocks) -> tuple[str, str]
              Format given code in UFC format. Returns two strings with header and source file contents.

       ffcx.formatting.write_code(code_h, code_c, prefix, output_dir)
              Write code to files.

FFCX.MAIN
       Command-line interface to FFCx.

       Parse command-line arguments and generate code from input UFL form files.

       Functions
                                                                                   ┌──────────────┬─────────────────────────┐
                                                                                   │ main([args]) │ Run ffcx on a UFL file. │
                                                                                   └──────────────┴─────────────────────────┘

       ffcx.main.arg_type
              alias of int

       ffcx.main.get_options(priority_options: dict[str, type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None | int | float] | None = None) ->
       dict[str, int | float | type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None]
              Return (a copy of) the merged option values for FFCX.

              Parameters
                     priority_options – take priority over all other option values (see notes)

              Returns
                     merged option values

              NOTE:
                 This function sets the log level from the merged option values prior to returning.

                 The ffcx_options.json files are cached on the first call. Subsequent calls to this function use this cache.

                 Priority ordering of options from highest to lowest is:

                 • priority_options (API and command line options)

                 • $PWD/ffcx_options.json (local options)

                 • $XDG_CONFIG_HOME/ffcx/ffcx_options.json (user options)

                 • FFCX_DEFAULT_OPTIONS in ffcx.options

                 XDG_CONFIG_HOME is ~/.config/ if the environment variable is not set.

                 Example ffcx_options.json file:
                     { “epsilon”: 1e-7 }

       ffcx.main.main(args=None)
              Run ffcx on a UFL file.

FFCX.NAMING
       Naming.

       Functions
                                                               ┌──────────────────────────────────────────────────┬─────────────────────────────┐
                                                               │ compute_signature(ufl_objects, tag)              │ Compute the signature hash. │
                                                               ├──────────────────────────────────────────────────┼─────────────────────────────┤
                                                               │ expression_name(expression, prefix)              │ Get expression name.        │
                                                               ├──────────────────────────────────────────────────┼─────────────────────────────┤
                                                               │ form_name(original_form, form_id, prefix)        │ Get form name.              │
                                                               ├──────────────────────────────────────────────────┼─────────────────────────────┤
                                                               │ integral_name(original_form, integral_type, ...) │ Get integral name.          │
                                                               └──────────────────────────────────────────────────┴─────────────────────────────┘

       ffcx.naming.compute_signature(ufl_objects: list[Form | tuple[Expr, ndarray[tuple[Any, ...], dtype[float64]]]], tag: str) -> str
              Compute the signature hash.

              Based on the UFL type of the objects and an additional optional ‘tag’.

       ffcx.naming.expression_name(expression: tuple[Expr, ndarray[tuple[Any, ...], dtype[floating]]], prefix: str) -> str
              Get expression name.

       ffcx.naming.form_name(original_form: Form, form_id: int, prefix: str) -> str
              Get form name.

       ffcx.naming.integral_name(original_form: Form, integral_type: str, form_id: int, subdomain_id: tuple[int, ...] | tuple[str], prefix: str) -> str
              Get integral name.

FFCX.CODEGENERATION
       FFCx code generation.

       Functions
                                                                      ┌────────────────────┬──────────────────────────────────────────────┐
                                                                      │ get_include_path() │ Return location of UFCx header files.        │
                                                                      ├────────────────────┼──────────────────────────────────────────────┤
                                                                      │ get_signature()    │ Return SHA-1 hash of the contents of ufcx.h. │
                                                                      └────────────────────┴──────────────────────────────────────────────┘

       ffcx.codegeneration.get_include_path()
              Return location of UFCx header files.

       ffcx.codegeneration.get_signature()
              Return SHA-1 hash of the contents of ufcx.h.

              In this implementation, the value is computed on import.

FFCX.OPTIONS
       Options.

       Functions
                                                           ┌─────────────────────────────────┬───────────────────────────────────────────────────────┐
                                                           │ get_options([priority_options]) │ Return (a copy of) the merged option values for FFCX. │
                                                           └─────────────────────────────────┴───────────────────────────────────────────────────────┘

       class ffcx.options.Path(*args, **kwargs)
              Bases: PathBase, PurePath

              PurePath subclass that can make system calls.

              Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a  PosixPath
              or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.

              absolute()
                     Return an absolute version of this path No normalization or symlink resolution is performed.

                     Use resolve() to resolve symlinks and remove ‘..’ segments.

              as_uri()
                     Return the path as a URI.

              chmod(mode, *, follow_symlinks=True)
                     Change the permissions of the path, like os.chmod().

              expanduser()
                     Return a new path with expanded ~ and ~user constructs (as returned by os.path.expanduser)

              classmethod from_uri(uri)
                     Return a new path from the given ‘file’ URI.

              glob(pattern, *, case_sensitive=None, recurse_symlinks=False)
                     Iterate over this subtree and yield all existing files (of any kind, including directories) matching the given relative pattern.

              group(*, follow_symlinks=True)
                     Return the group name of the file gid.

              hardlink_to(target)
                     Make this path a hard link pointing to the same file as target.

                     Note the order of arguments (self, target) is the reverse of os.link’s.

              is_junction()
                     Whether this path is a junction.

              is_mount()
                     Check if this path is a mount point

              iterdir()
                     Yield path objects of the directory contents.

                     The children are yielded in arbitrary order, and the special entries ‘.’ and ‘..’ are not included.

              mkdir(mode=511, parents=False, exist_ok=False)
                     Create a new directory at this given path.

              open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)
                     Open the file pointed to by this path and return a file object, as the built-in open() function does.

              owner(*, follow_symlinks=True)
                     Return the login name of the file owner.

              read_text(encoding=None, errors=None, newline=None)
                     Open the file in text mode, read it, and close the file.

              readlink()
                     Return the path to which the symbolic link points.

              rename(target)
                     Rename this path to the target path.

                     The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.

                     Returns the new Path instance pointing to the target path.

              replace(target)
                     Rename this path to the target path, overwriting if that path exists.

                     The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.

                     Returns the new Path instance pointing to the target path.

              resolve(strict=False)
                     Make the path absolute, resolving all symlinks on the way and also normalizing it.

              rglob(pattern, *, case_sensitive=None, recurse_symlinks=False)
                     Recursively yield all existing files (of any kind, including directories) matching the given relative pattern, anywhere in this subtree.

              rmdir()
                     Remove this directory.  The directory must be empty.

              stat(*, follow_symlinks=True)
                     Return the result of the stat() system call on this path, like os.stat() does.

              symlink_to(target, target_is_directory=False)
                     Make this path a symlink pointing to the target path.  Note the order of arguments (link, target) is the reverse of os.symlink.

              touch(mode=438, exist_ok=True)
                     Create this file with the given access mode, if it doesn’t exist.

              unlink(missing_ok=False)
                     Remove this file or link.  If the path is a directory, use rmdir() instead.

              walk(top_down=True, on_error=None, follow_symlinks=False)
                     Walk the directory tree from this directory, similar to os.walk().

              write_text(data, encoding=None, errors=None, newline=None)
                     Open the file in text mode, write to it, and close the file.

       ffcx.options.get_options(priority_options: dict[str, type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None | int | float] | None = None) ->
       dict[str, int | float | type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None]
              Return (a copy of) the merged option values for FFCX.

              Parameters
                     priority_options – take priority over all other option values (see notes)

              Returns
                     merged option values

              NOTE:
                 This function sets the log level from the merged option values prior to returning.

                 The ffcx_options.json files are cached on the first call. Subsequent calls to this function use this cache.

                 Priority ordering of options from highest to lowest is:

                 • priority_options (API and command line options)

                 • $PWD/ffcx_options.json (local options)

                 • $XDG_CONFIG_HOME/ffcx/ffcx_options.json (user options)

                 • FFCX_DEFAULT_OPTIONS in ffcx.options

                 XDG_CONFIG_HOME is ~/.config/ if the environment variable is not set.

                 Example ffcx_options.json file:
                     { “epsilon”: 1e-7 }

FFCX.IR.REPRESENTATION
       Compiler stage 2: Code representation.

       Module computes intermediate representations of forms. For each UFC function, we extract the data needed for code generation at a later stage.

       The representation should conform strictly to the naming and order of functions in UFC. Thus, for code generation of the function “foo”, one should only need to use the data stored in the interme‐
       diate representation under the key “foo”.

       Functions
                                                           ┌─────────────────────────────────────────────────┬──────────────────────────────────────┐
                                                           │ compute_ir(analysis, object_names, prefix, ...) │ Compute intermediate representation. │
                                                           └─────────────────────────────────────────────────┴──────────────────────────────────────┘

       Classes
                                                      ┌───────────────────────────────────────────┬──────────────────────────────────────────────────────┐
                                                      │ CommonExpressionIR(integral_type, ...)    │ Common-ground for IntegralIR and ExpressionIR.       │
                                                      ├───────────────────────────────────────────┼──────────────────────────────────────────────────────┤
                                                      │ DataIR(integrals, forms, expressions)     │ Intermediate representation of data.                 │
                                                      ├───────────────────────────────────────────┼──────────────────────────────────────────────────────┤
                                                      │ ExpressionIR(expression, ...)             │ Intermediate representation of a DOLFINx Expression. │
                                                      ├───────────────────────────────────────────┼──────────────────────────────────────────────────────┤
                                                      │ FormIR(id, name, signature, rank, ...)    │ Intermediate representation of a form.               │
                                                      ├───────────────────────────────────────────┼──────────────────────────────────────────────────────┤
                                                      │ IntegralIR(expression, rank, ...)         │ Intermediate representation of an integral.          │
                                                      ├───────────────────────────────────────────┼──────────────────────────────────────────────────────┤
                                                      │ QuadratureIR(cell_shape, points, weights) │ Intermediate representation of a quadrature rule.    │
                                                      └───────────────────────────────────────────┴──────────────────────────────────────────────────────┘

       class ffcx.ir.representation.CommonExpressionIR(integral_type: str, entity_type: str, tensor_shape: list[int], coefficient_numbering: dict[ufl.Coefficient, int], coefficient_offsets: dict[ufl.Co‐
       efficient, int], original_constant_offsets: dict[ufl.Constant, int], unique_tables: dict[str, npt.NDArray[np.float64]], unique_table_types: dict[str, str], integrand: dict[QuadratureRule, dict],
       name: str, needs_facet_permutations: bool, shape: list[int])
              Bases: NamedTuple

              Common-ground for IntegralIR and ExpressionIR.

              Create new instance of CommonExpressionIR(integral_type, entity_type, tensor_shape, coefficient_numbering, coefficient_offsets, original_constant_offsets, unique_tables, unique_table_types,
              integrand, name, needs_facet_permutations, shape)

              coefficient_numbering: dict[Coefficient, int]
                     Alias for field number 3

              coefficient_offsets: dict[Coefficient, int]
                     Alias for field number 4

              entity_type: str
                     Alias for field number 1

              integral_type: str
                     Alias for field number 0

              integrand: dict[QuadratureRule, dict]
                     Alias for field number 8

              name: str
                     Alias for field number 9

              needs_facet_permutations: bool
                     Alias for field number 10

              original_constant_offsets: dict[Constant, int]
                     Alias for field number 5

              shape: list[int]
                     Alias for field number 11

              tensor_shape: list[int]
                     Alias for field number 2

              unique_table_types: dict[str, str]
                     Alias for field number 7

              unique_tables: dict[str, ndarray[tuple[Any, ...], dtype[float64]]]
                     Alias for field number 6

       class ffcx.ir.representation.DataIR(integrals: list[IntegralIR], forms: list[FormIR], expressions: list[ExpressionIR])
              Bases: NamedTuple

              Intermediate representation of data.

              Create new instance of DataIR(integrals, forms, expressions)

              expressions: list[ExpressionIR]
                     Alias for field number 2

              forms: list[FormIR]
                     Alias for field number 1

              integrals: list[IntegralIR]
                     Alias for field number 0

       class ffcx.ir.representation.ExpressionIR(expression: CommonExpressionIR, original_coefficient_positions: list[int], coefficient_names: list[str], constant_names: list[str], name_from_uflfile:
       str)
              Bases: NamedTuple

              Intermediate representation of a DOLFINx Expression.

              Create new instance of ExpressionIR(expression, original_coefficient_positions, coefficient_names, constant_names, name_from_uflfile)

              coefficient_names: list[str]
                     Alias for field number 2

              constant_names: list[str]
                     Alias for field number 3

              expression: CommonExpressionIR
                     Alias for field number 0

              name_from_uflfile: str
                     Alias for field number 4

              original_coefficient_positions: list[int]
                     Alias for field number 1

       class ffcx.ir.representation.FormIR(id: int, name: str, signature: str, rank: int, num_coefficients: int, num_constants: int, name_from_uflfile: str, original_coefficient_positions: list[int], co‐
       efficient_names: list[str], constant_names: list[str], finite_element_hashes: list[int], integral_names: dict[str, list[str]], subdomain_ids: dict[str, list[int]])
              Bases: NamedTuple

              Intermediate representation of a form.

              Create  new  instance of FormIR(id, name, signature, rank, num_coefficients, num_constants, name_from_uflfile, original_coefficient_positions, coefficient_names, constant_names, finite_ele‐
              ment_hashes, integral_names, subdomain_ids)

              coefficient_names: list[str]
                     Alias for field number 8

              constant_names: list[str]
                     Alias for field number 9

              finite_element_hashes: list[int]
                     Alias for field number 10

              id: int
                     Alias for field number 0

              integral_names: dict[str, list[str]]
                     Alias for field number 11

              name: str
                     Alias for field number 1

              name_from_uflfile: str
                     Alias for field number 6

              num_coefficients: int
                     Alias for field number 4

              num_constants: int
                     Alias for field number 5

              original_coefficient_positions: list[int]
                     Alias for field number 7

              rank: int
                     Alias for field number 3

              signature: str
                     Alias for field number 2

              subdomain_ids: dict[str, list[int]]
                     Alias for field number 12

       class ffcx.ir.representation.Integral(integrand, integral_type, domain, subdomain_id, metadata, subdomain_data)
              Bases: object

              An integral over a single domain.

              Initialise.

              integral_type()
                     Return the domain type of this integral.

              integrand()
                     Return the integrand expression, which is an Expr instance.

              metadata()
                     Return the compiler metadata this integral has been annotated with.

              reconstruct(integrand=None, integral_type=None, domain=None, subdomain_id=None, metadata=None, subdomain_data=None)
                     Construct a new Integral object with some properties replaced with new values.

                     Example

                     <a = Integral instance> b = a.reconstruct(expand_compounds(a.integrand())) c = a.reconstruct(metadata={‘quadrature_degree’:2})

              subdomain_data()
                     Return the domain data of this integral.

              subdomain_id()
                     Return the subdomain id of this integral.

              ufl_domain()
                     Return the integration domain of this integral.

       class ffcx.ir.representation.IntegralIR(expression: CommonExpressionIR, rank: int, enabled_coefficients: list[bool], coordinate_element_hash: str)
              Bases: NamedTuple

              Intermediate representation of an integral.

              Create new instance of IntegralIR(expression, rank, enabled_coefficients, coordinate_element_hash)

              coordinate_element_hash: str
                     Alias for field number 3

              enabled_coefficients: list[bool]
                     Alias for field number 2

              expression: CommonExpressionIR
                     Alias for field number 0

              rank: int
                     Alias for field number 1

       class ffcx.ir.representation.QuadratureIR(cell_shape: str, points: npt.NDArray[np.float64], weights: npt.NDArray[np.float64])
              Bases: NamedTuple

              Intermediate representation of a quadrature rule.

              Create new instance of QuadratureIR(cell_shape, points, weights)

              cell_shape: str
                     Alias for field number 0

              points: ndarray[tuple[Any, ...], dtype[float64]]
                     Alias for field number 1

              weights: ndarray[tuple[Any, ...], dtype[float64]]
                     Alias for field number 2

       class ffcx.ir.representation.QuadratureRule(points, weights, tensor_factors=None)
              Bases: object

              A quadrature rule.

              Initialise.

              id()   Return unique deterministic identifier.

                     NOTE:
                        This identifier is used to provide unique names to tables and symbols in generated code.

       class ffcx.ir.representation.UFLData(form_data: tuple[ufl.algorithms.formdata.FormData, ...], unique_elements: list[basix.ufl._ElementBase], element_numbers: dict[basix.ufl._ElementBase, int],
       unique_coordinate_elements: list[basix.ufl._ElementBase], expressions: list[tuple[ufl.core.expr.Expr, npt.NDArray[np.float64], ufl.core.expr.Expr]])
              Bases: NamedTuple

              UFL data.

              Create new instance of UFLData(form_data, unique_elements, element_numbers, unique_coordinate_elements, expressions)

              element_numbers: dict[_ElementBase, int]
                     Alias for field number 2

              expressions: list[tuple[Expr, ndarray[tuple[Any, ...], dtype[float64]], Expr]]
                     Alias for field number 4

              form_data: tuple[FormData, ...]
                     Alias for field number 0

              unique_coordinate_elements: list[_ElementBase]
                     Alias for field number 3

              unique_elements: list[_ElementBase]
                     Alias for field number 1

       ffcx.ir.representation.compute_integral_ir(cell, integral_type, entity_type, integrands, argument_shape, p, visualise)
              Compute intermediate representation for an integral.

       ffcx.ir.representation.compute_ir(analysis: UFLData, object_names: dict[int, str], prefix: str, options: dict[str, type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any]
       | _DTypeDict | str | None | int | float], visualise: bool) -> DataIR
              Compute intermediate representation.

       ffcx.ir.representation.create_quadrature_points_and_weights(integral_type, cell, degree, rule, elements, use_tensor_product=False)
              Create quadrature rule and return points and weights.

       ffcx.ir.representation.sorted_expr_sum(seq)
              Sorted expr sum.

FFCX.IR.REPRESENTATIONUTILS
       Utility functions for some code shared between representations.

       Functions
                                           ┌──────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────┐
                                           │ create_quadrature_points_and_weights(...[, ...]) │ Create quadrature rule and return points and weights.                │
                                           ├──────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
                                           │ integral_type_to_entity_dim(integral_type, tdim) │ Given integral_type and domain tdim, return the tdim of the integra‐ │
                                           │                                                  │ tion entity.                                                         │
                                           ├──────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
                                           │ map_integral_points(points, integral_type, ...)  │ Map points from reference entity to its parent reference cell.       │
                                           └──────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────┘

       Classes
                                                                   ┌───────────────────────────────────────────────────┬────────────────────┐
                                                                   │ QuadratureRule(points, weights[, tensor_factors]) │ A quadrature rule. │
                                                                   └───────────────────────────────────────────────────┴────────────────────┘

       class ffcx.ir.representationutils.QuadratureRule(points, weights, tensor_factors=None)
              Bases: object

              A quadrature rule.

              Initialise.

              id()   Return unique deterministic identifier.

                     NOTE:
                        This identifier is used to provide unique names to tables and symbols in generated code.

       ffcx.ir.representationutils.create_quadrature(cellname: str, degree: int, rule: str, elements: list[_ElementBase]) -> tuple[Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsAr‐
       ray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str |
       _NestedSequence[complex | bytes | str]]
              Create a quadrature rule.

       ffcx.ir.representationutils.create_quadrature_points_and_weights(integral_type, cell, degree, rule, elements, use_tensor_product=False)
              Create quadrature rule and return points and weights.

       ffcx.ir.representationutils.integral_type_to_entity_dim(integral_type, tdim)
              Given integral_type and domain tdim, return the tdim of the integration entity.

       ffcx.ir.representationutils.map_facet_points(points: ndarray[tuple[Any, ...], dtype[float64]], facet: int, cellname: str) -> ndarray[tuple[Any, ...], dtype[float64]]
              Map points from a reference facet to a physical facet.

       ffcx.ir.representationutils.map_integral_points(points, integral_type, cell, entity)
              Map points from reference entity to its parent reference cell.

       ffcx.ir.representationutils.reference_cell_vertices(cellname: str) -> ndarray[tuple[Any, ...], dtype[float64]]
              Get the vertices of a reference cell.

       • Index

       • Module Index

       • Search Page

AUTHOR
       FEniCS Project

COPYRIGHT
       2025, FEniCS Project

0.9.0                                                                                           Oct 12, 2025                                                                         FENICSFORMCOMPILERX(1)
