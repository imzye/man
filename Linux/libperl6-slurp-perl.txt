Perl6::Slurp(3pm)                                                                   User Contributed Perl Documentation                                                                   Perl6::Slurp(3pm)

NAME
       Perl6::Slurp - Implements the Perl 6 'slurp' built-in

SYNOPSIS
           use Perl6::Slurp;

           # Slurp a file by name...

           $file_contents = slurp 'filename';
           $file_contents = slurp '<filename';
           $file_contents = slurp '<', 'filename';
           $file_contents = slurp '+<', 'filename';

           # Slurp a file via an (already open!) handle...

           $file_contents = slurp \*STDIN;
           $file_contents = slurp $filehandle;
           $file_contents = slurp IO::File->new('filename');

           # Slurp a string...

           $str_contents = slurp \$string;
           $str_contents = slurp '<', \$string;

           # Slurp a pipe (not on Windows, alas)...

           $str_contents = slurp 'tail -20 $filename |';
           $str_contents = slurp '-|', 'tail', -20, $filename;

           # Slurp with no source slurps from whatever $_ indicates...

           for (@files) {
               $contents .= slurp;
           }

           # ...or from the entire ARGV list, if $_ is undefined...

           $_ = undef;
           $ARGV_contents = slurp;

           # Specify I/O layers as part of mode...

           $file_contents = slurp '<:raw', $file;
           $file_contents = slurp '<:utf8', $file;
           $file_contents = slurp '<:raw :utf8', $file;

           # Specify I/O layers as separate options...

           $file_contents = slurp $file, {raw=>1};
           $file_contents = slurp $file, {utf8=>1};
           $file_contents = slurp $file, {raw=>1}, {utf8=>1};
           $file_contents = slurp $file, [raw=>1, utf8=>1];

           # Specify input record separator...

           $file_contents = slurp $file, {irs=>"\n\n"};
           $file_contents = slurp '<', $file, {irs=>"\n\n"};
           $file_contents = slurp {irs=>"\n\n"}, $file;

           # Input record separator can be regex...

           $file_contents = slurp $file, {irs=>qr/\n+/};
           $file_contents = slurp '<', $file, {irs=>qr/\n+|\t{2,}};

           # Specify autochomping...

           $file_contents = slurp $file, {chomp=>1};
           $file_contents = slurp {chomp=>1}, $file;
           $file_contents = slurp $file, {chomp=>1, irs=>"\n\n"};
           $file_contents = slurp $file, {chomp=>1, irs=>qr/\n+/};

           # Specify autochomping that replaces irs
           # with another string...

           $file_contents = slurp $file, {irs=>"\n\n", chomp=>"\n"};
           $file_contents = slurp $file, {chomp=>"\n\n"}, {irs=>qr/\n+/};

           # Specify autochomping that replaces
           # irs with a dynamically computed string...

           my $n = 1;
           $file_contents = slurp $file, {chomp=>sub{ "\n#line ".$n++."\n"};

           # Slurp in a list context...

           @lines = slurp 'filename';
           @lines = slurp $filehandle;
           @lines = slurp \$string;
           @lines = slurp '<:utf8', 'filename', {irs=>"\x{2020}", chomp=>"\n"};

DESCRIPTION
       "slurp" takes:

       •   a filename,

       •   a filehandle,

       •   a typeglob reference,

       •   an IO::File object, or

       •   a scalar reference,

       converts it to an input stream (using "open()" if necessary), and reads in the entire stream. If "slurp" fails to set up or read the stream, it throws an exception.

       If  no  data  source is specified "slurp" uses the value of $_ as the source. If $_ is undefined, "slurp" uses the @ARGV list, and magically slurps the contents of all the sources listed in @ARGV.
       Note that the same magic is also applied if you explicitly slurp <*ARGV>, so the following three input operations:

           $contents = join "", <ARGV>;

           $contents = slurp \*ARGV;

           $/ = undef;
           $contents = slurp;

       are identical in effect.

       In a scalar context "slurp" returns the stream contents as a single string.  If the stream is at EOF, it returns an empty string.  In a list context, it splits the contents after  the  appropriate
       input record separator and returns the resulting list of strings.

       You can set the input record separator ("{ irs => $your_irs_here}") for the input operation. The separator can be specified as a string or a regex. Note that an explicit input record separator has
       no input-terminating effect in a scalar context; "slurp" always reads in the entire input stream, whatever the 'irs' value.

       In a list context, changing the separator can change how the input is broken up within the list that is returned.

       If an input record separator is not explicitly specified, "slurp" defaults to "\n" (not to the current value of $/ – since Perl 6 doesn't have a $/);

       You can also tell "slurp" to automagically "chomp" the input as it is read in, by specifying: ("{ chomp => 1 }")

       Better still, you can tell "slurp" to automagically "chomp" the input and replace what it chomps with another string, by specifying: ("{ chomp => "another string" }")

       You  can  also  tell  "slurp"  to  compute  the replacement string on-the-fly by specifying a subroutine as the "chomp" value: ("{ chomp => sub{...} }"). This subroutine is passed the string being
       chomped off, so for example you could squeeze single newlines to a single space and multiple consecutive newlines to a two newlines with:

           sub squeeze {
               my ($removed) = @_;
               if ($removed =~ tr/\n/\n/ == 1) { return " " }
               else                            { return "\n\n"; }
           }

           print slurp(\*DATA, {irs=>qr/[ \t]*\n+/, chomp=>\&squeeze}), "\n";

       Which would transform:

           This is the
           first paragraph

           This is the
           second
           paragraph

           This, the
           third

           This one is
           the
           very
           last

       to:

           This is the first paragraph

           This is the second paragraph

           This, the third

           This one is the very last

       Autochomping works in both scalar and list contexts. In scalar contexts every instance of the input record separator will be removed (or replaced) within the returned string. In list context, each
       list item returned with its terminating separator removed (or replaced).

       You can specify I/O layers, either using the Perl 5 notation:

           slurp "<:layer1 :layer2 :etc", $filename;

       or as an array of options:

           slurp $filename, [layer1=>1, layer2=>1, etc=>1];
           slurp [layer1=>1, layer2=>1, etc=>1], $filename;

       or as individual options (each of which must be in a separate hash):

           slurp $filename, {layer1=>1}, {layer2=>1}, {etc=>1};
           slurp {layer1=>1}, {layer2=>1}, {etc=>1}, $filename;

       (...which, of course, would look much cooler in Perl 6:

           # Perl 6 only :-(

           slurp $filename, :layer1 :layer2 :etc;
           slurp :layer1 :layer2 :etc, $filename;

       )

       A common mistake is to put all the options together in one hash:

           slurp $filename, {layer1=>1, layer2=>1, etc=>1};

       This is almost always a disaster, since the order of I/O layers is usually critical, and placing them all in one hash effectively randomizes that order.  Use an array instead:

           slurp $filename, [layer1=>1, layer2=>1, etc=>1];

WARNINGS
       The syntax and semantics of Perl 6 is still being finalized and consequently is at any time subject to change. That means the same caveat applies to this module.

       When called with a filename or piped shell command, "slurp()" uses Perl's built- in "open()" to access the file. This means that  it  is  subject  to  the  same  platform-specific  limitations  as
       "open()".  For example, slurping from piped shell commands may not work under Windows.

DEPENDENCIES
       Requires: Perl 5.8.0

AUTHOR
       Damian Conway (damian@conway.org)

COPYRIGHT
        Copyright (c) 2003-2012, Damian Conway. All Rights Reserved.
        This module is free software. It may be used, redistributed
           and/or modified under the same terms as Perl itself.

perl v5.36.0                                                                                     2022-11-19                                                                               Perl6::Slurp(3pm)
