BLAKE2(3)                                                                                 Library Functions Manual                                                                                BLAKE2(3)

NAME
       blake2s,  blake2b,  blake2sp,  blake2bp,  blake2s_init,  blake2s_init_key,  blake2s_init_param,  blake2s_update,  blake2s_final, blake2b_init, blake2b_init_key, blake2b_init_param, blake2b_update,
       blake2b_final, blake2sp_init, blake2sp_init_key, blake2sp_update, blake2sp_final, blake2bp_init, blake2bp_init_key, blake2bp_update, blake2bp_final — BLAKE2 cryptographic hash functions

SYNOPSIS
       #include <blake2.h>

       int
       blake2s(uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen);

       int
       blake2b(uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen);

       int
       blake2sp(uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen);

       int
       blake2bp(uint8_t *out, const void *in, const void *key, size_t outlen, size_t inlen, size_t keylen);

       int
       blake2s_init(blake2s_state *S, size_t outlen);

       int
       blake2s_init_key(blake2s_state *S, size_t outlen, const void *key, size_t keylen);

       int
       blake2s_init_param(blake2s_state *S, const blake2s_param *P);

       int
       blake2s_update(blake2s_state *S, const uint8_t *in, size_t inlen);

       int
       blake2s_final(blake2s_state *S, uint8_t *out, size_t outlen);

       int
       blake2b_init(blake2b_state *S, size_t outlen);

       int
       blake2b_init_key(blake2b_state *S, size_t outlen, const void *key, size_t keylen);

       int
       blake2b_init_param(blake2b_state *S, const blake2b_param *P);

       int
       blake2b_update(blake2b_state *S, const uint8_t *in, size_t inlen);

       int
       blake2b_final(blake2b_state *S, uint8_t *out, size_t outlen);

       int
       blake2sp_init(blake2sp_state *S, size_t outlen);

       int
       blake2sp_init_key(blake2sp_state *S, size_t outlen, const void *key, size_t keylen);

       int
       blake2sp_update(blake2sp_state *S, const uint8_t *in, size_t inlen);

       int
       blake2sp_final(blake2sp_state *S, uint8_t *out, size_t outlen);

       int
       blake2bp_init(blake2bp_state *S, size_t outlen);

       int
       blake2bp_init_key(blake2bp_state *S, size_t outlen, const void *key, size_t keylen);

       int
       blake2bp_update(blake2bp_state *S, const uint8_t *in, size_t inlen);

       int
       blake2bp_final(blake2bp_state *S, uint8_t *out, size_t outlen);

DESCRIPTION
       The BLAKE2 family of cryptographic hash functions is an improved version of the SHA-3 finalist BLAKE.

       BLAKE2b is optimized for 64-bit platforms and produces up to 64 bytes of output; BLAKE2s is optimized for 32-bit platforms and produces up to 32 bytes of output.

       BLAKE2bp and BLAKE2sp are parallel versions of BLAKE2b and BLAKE2s designed for increased performance on multicore and large-vector SIMD processors.

       The blake2s_init(), blake2b_init(), blake2sp_init(), and blake2bp_init() functions initialize a hash state S to hash a message to an output of outlen bytes, without using a key.

       S must be allocated by the caller.

       The blake2s_init_key(), blake2b_init_key(), blake2sp_init_key(), and blake2bp_init_key() functions initialize a hash state S to hash a message to an output of outlen bytes, using the  key  key  of
       length keylen.

       The blake2s_init_param() and blake2b_init_param() initialize a hash state S using a custom parameter block P, which must have been filled in completely by the caller.  See the BLAKE2 paper and the
       <blake2.h> header file for details.

       The blake2s_update(), blake2b_update(), blake2sp_update(), and blake2bp_update() functions hash the input buffer in of length inlen bytes into the hash state S.

       The  blake2s_final(),  blake2b_final(),  blake2sp_final(),  and  blake2bp_final() functions compute the hash value accumulated in S and store it into out.  outlen must have the same value that was
       passed to the corresponding init function.

       The blake2s(), blake2b(), blake2sp(), and blake2bp() functions hash a single-buffer input in one function call, optionally using a key.

       To use the latter functions without a key, set keylen to 0 and key to NULL.

       For all functions, the lengths outlen, inlen, and keylen are specified in bytes.

       outlen must be positive and no greater than BLAKE2S_OUTBYTES (32) for the blake2s and blake2sp functions, or positive and no greater than BLAKE2B_OUTBYTES (64) for the blake2b and  blake2bp  func‐
       tions.

       keylen  must  be positive and no greater than BLAKE2S_KEYBYTES (32) for the blake2s and blake2sp functions, or positive and no greater than BLAKE2B_KEYBYTES (64) for the blake2b and blake2bp func‐
       tions.

RETURN VALUES
       All of these functions return 0 if successful, or -1 if they detect an error.

       All detected, reported errors are caused by invalid pointer arguments or out-of-bounds length arguments.

       Not all invalid arguments are detected.

       These functions do not set errno themselves, but do call standard C library functions which might set errno.

BUGS
       The library does not include a self-test function.

       The library does not attempt to detect or report an error if the caller exceeds the input length limits specified for the BLAKE2 functions, even for  BLAKE2s  and  BLAKE2sp,  whose  length  limits
       (2**64-1 bytes and 2**67-1 bytes respectively) could theoretically be reached.

       blake2s_final(), blake2b_final(), blake2sp_final(), and blake2bp_final() do not erase the state S, and do not treat the hash value as sensitive, even if they are used to compute a keyed hash.

       blake2s_final(),  blake2b_final(), blake2sp_final(), and blake2bp_final() alter the state such that further calls to the _update or _final functions will produce poorly-behaved results, and do not
       mark the state as no longer valid in order to detect and prevent such programmer errors.

Debian                                                                                        October 17, 2015                                                                                    BLAKE2(3)
