POSIX::2008(3pm)                                                                    User Contributed Perl Documentation                                                                    POSIX::2008(3pm)

NAME
       POSIX::2008 - Perl interface to POSIX.1-2008

SYNOPSIS
         use POSIX::2008 qw(:fcntl openat pwrite);

         sysopen my $dh, '/tmp', O_RDONLY|O_DIRECTORY|O_NOFOLLOW
           or die 'Dafuq?';
         my $fh = openat($dh, 'foobar', O_RDWR|O_CREAT);
         pwrite($fh, 'fuckyounsa', 10, 0);

DESCRIPTION
       POSIX::2008 contains many of the interfaces specified by POSIX.1-2008 <https://pubs.opengroup.org/onlinepubs/9699919799/> that the core POSIX module withholds, implements in Perl or fucked up.

       It also contains a few nonstandard interfaces present in Linux, BSD and Solaris that are extensions of the POSIX interfaces.

       This module is provided "as is" unless someone volunteers to maintain it.  Use at your own risk.

FILE DESCRIPTORS AND HANDLES
       Since version 0.05, all I/O functions that take numeric file descriptors also accept Perl file or directory handles, except for fdopen() and fdopendir().

       Since version 0.22, returned handles support IO::Handle methods.

SYSTEM CALL RETURN VALUES
       A system call return value of -1 meaning "error" is mapped to undef except for poll() which returns -1 to be consistent with select().

       A system call return value of 0 meaning "success" is mapped to "0 but true".

       For system calls where 0 does not just mean "success", 0 is returned unchanged. These are creat(), open(), read(), write(), readv(), writev(), pread(), pwrite(), preadv(), pwritev(), preadv2(),
       pwritev2(), getpriority(), nice(). openat() gets a special treatment in this regard, see below.

FUNCTIONS
       "a64l"
           l = a64l(s);

       "abort"
           abort();

       "abs"
           ui = abs(i);

           Calls llabs(), labs(), or abs(), whichever is the maximum supported by your system.

           Note that the library functions use signed integers, so abs(~0) is 1.  If you don't want that, use CORE::abs().

       "access"
           ret = access(path, mode);

           New in version 0.08.

       "acos"
           y = acos(x);

       "acosh"
           y = acosh(x);

       "alarm"
           remaining_sec = alarm(sec);

       "asin"
           y = asin(x);

       "asinh"
           y = asinh(x);

       "atan2"
           z = atan2(y, x);

       "atan"
           y = atan(x);

       "atanh"
           y = atanh(x);

       "atof"
           f = atof(s);

       "atoi"
           i = atoi(s);

           Calls atoll(), atol(), or atoi(), whichever is the maximum supported by your system. This is of course silly because you could just use int().

           Changed in version 0.19: Deprecated atol and atoll now covered by atoi.

       "basename"
           s = basename(path);

       "cabs"
           r = cabs(re, im);

       "cacos"
           (re, im) = cacos(re, im);

       "cacosh"
           (re, im) = cacosh(re, im);

       "carg"
           phi = carg(re, im);

       "casin"
           y = casin(x);

       "casinh"
           (re, im) = casinh(re, im);

       "catan"
           (re, im) = catan(re, im);

       "catanh"
           (re, im) = catanh(re, im);

       "catclose"
           ret = catclose(catd);

       "catgets"
           s = catgets(catd, set_id, msg_id, dflt_string);

       "catopen"
           catd = catopen(name, flag);

       "cbrt"
           y = cbrt(x);

       "ccos"
           (re, im) = ccos(re, im);

       "ccosh"
           (re, im) = ccosh(re, im);

       "ceil"
           y = ceil(x);

       "cexp"
           (re, im) = cexp(re, im);

           New in version 0.19.

       "chdir"
           ret = chdir(dir);

           "dir" can be a path, a Perl file or directory handle, or a file descriptor.

           Changed in version 0.19: Deprecated fchdir now covered by chdir.

       "chmod"
           ret = chmod(what, mode);

           "what" can be a path, a Perl file or directory handle (see "NOTES"), or a file descriptor.

           Changed in version 0.19: Deprecated fchmod now covered by chmod.

       "chown"
           ret = chown(what, uid, gid);

           "what" can be a path, a Perl file or directory handle (see "NOTES"), or a file descriptor.

           Changed in version 0.19: Deprecated fchown now covered by chown.

       "cimag"
           im = cimag(re, im);

       "clock"
           t = clock()

           New in version 0.08.

       "clock_getcpuclockid"
           clock_id = clock_getcpuclockid(pid);

           pid defaults to 0. Returns undef on error.

       "clock_getres"
            (sec, nsec) = clock_getres(clock_id);
            floating_sec = clock_getres(clock_id);

           clock_id defaults to "CLOCK_REALTIME". Returns empty list or undef on error.

           Changed in version 0.25: Return floating seconds in scalar context.

       "clock_gettime"
            (sec, nsec) = clock_gettime(clock_id);
            floating_sec = clock_gettime(clock_id);

           clock_id defaults to "CLOCK_REALTIME". Returns empty list or undef on error.

           Changed in version 0.25: Return floating seconds in scalar context.

       "clock_nanosleep"
            (rem_sec, rem_nsec) = clock_nanosleep(clock_id, flags, floating_sec);
            floating_rem_sec = clock_nanosleep(clock_id, flags, floating_sec);

            (rem_sec, rem_nsec) = clock_nanosleep(clock_id, flags, sec, nsec);
            floating_rem_sec = clock_nanosleep(clock_id, flags, sec, nsec);

           Returns zero(es) on success, the remaining time on EINTR, the empty list or undef otherwise. The remaining time is zero if the flag "TIMER_ABSTIME" is set.

           Changed in version 0.25: Sleep time can be floating seconds only or seconds and nanoseconds.

       "clock_settime"
            ret = clock_settime(clock_id, sec, nsec);
            ret = clock_settime(clock_id, floating_sec);

           Changed in version 0.25: Time can be floating seconds only or seconds and nanoseconds.

       "clog"
           (re, im) = clog(re, im);

       "close"
           ret = close(fd);

       "confstr"
           s = confstr(name);

           name is one of the "_CS_*" integer constants.

           Returns undef on error.

       "conj"
           (re, im) = conj(re, im);

       "copysign"
           xs = copysign(x, y);

       "cos"
           y = cos(x);

       "cosh"
           y = cosh(x);

       "cpow"
           (re, im) = cpow(re_x, im_x, re_y, im_y);

       "cproj"
           (re, im) = cproj(re, im);

       "creal"
           re = creal(re, im);

       "creat"
           ret = creat(path, mode=0666);

           New in version 0.22.

       "csin"
           (re, im) = csin(re, im);

       "csinh"
           (re, im) = csinh(re, im);

       "csqrt"
           (re, im) = csqrt(re, im);

       "ctan"
           (re, im) = ctan(re, im);

       "ctanh"
           (re, im) = ctanh(re, im);

       "dirname"
           name = dirname(path);

       "div"
           (quot, rem) = div(numer, denom);

           Calls lldiv(), ldiv(), or div(), whichever is the maximum supported by your system.

           Note that the library functions use signed integers, so "div(~0, 1)" is "(-1, 0)". If you don't want that, use Perls int(), "/" and "%".

           Changed in version 0.19: Deprecated ldiv and lldiv now covered by div.

       "dlclose"
           dlclose(dlhandle);

       "dlerror"
           dlerror();

       "dlopen"
           dlhandle = dlopen(file, mode);

       "dlsym"
           addr = dlsym(dlhandle, name);

       "drand48"
           r = drand48();

       "endutxent"
           endutxent();

       "erand48"
           (r, X0, X1, X2) = erand48(X0, X1, X2);

       "erf"
           y = erf(x);

       "erfc"
           y = erfc(x);

       "execveat"
           execveat(dirfd, path, args, env=undef, flags=0);

           The execveat() system call is a nonstandard extension present in Linux.  See also fexecve().

           It  executes  the  program  referred  to  by  path, which is interpreted relative to dirfd as with the other *at functions, passing args as its command-line arguments and optionally env as its
           environment.

           args must be an array reference and, by convention, args->[0] should be the name of the program being executed.

           env must be a hash reference. If omitted or undef, the environment of the calling proces is used (which you can manipulate via %ENV).

           flags is a bit mask that can include zero or more of the flags "AT_EMPTY_PATH", "AT_SYMLINK_NOFOLLOW".

           path is executed "as is", i.e. no "PATH" search or interpretation of shell metacharacters takes place as opposed to Perl's built-in "exec".

           Returns undef on error, otherwise it doesn't return.

           Usage example:

             sysopen my $dh, '/usr', O_DIRECTORY|O_PATH;
             execveat($dh, 'bin/date', [qw(date +%T)], {TZ => 'UTC'}, AT_SYMLINK_NOFOLLOW);

           New in version 0.22.

       "exp"
           y = exp(x);

       "exp2"
           y = exp2(x);

       "expm1"
           y = expm1(x);

       "faccessat"
           ret = faccessat(dirfd, path, amode, flags=0);

           flags is the bitwise OR of zero or more of "AT_EACCESS", "AT_SYMLINK_NOFOLLOW".

       "fchmodat"
           ret = fchmodat(dirfd, path, mode, flags=0);

           flags can be 0 or "AT_SYMLINK_NOFOLLOW". Your system might support a different set of flags.

       "fchownat"
           ret = fchownat(dirfd, path, uid, gid, flags=0);

           flags can be 0 or "AT_SYMLINK_NOFOLLOW". Your system might support a different set of flags.

       "fdatasync"
           ret = fdatasync(fd);

       "fdopen"
           ret = fdopen(fd, mode);

           Returns a file handle associated with the numeric file descriptor fd or undef on error. mode is one of the values "r", "w", "a" with an optional "+" and/or "b".

           The file descriptor is not dup'ed and will be closed when the handle is closed.

           It's similar to IO::Handle::new_from_fd() with the following improvements:

           •   It really calls fdopen(3).

           •   It expects POSIX mode strings (e.g. "r", not "<").

           •   It fails if mode is not compatible with the flags of fd.

           Usage example:

             my $fh = do {
               opendir my $dh, '.';
               fdopen(POSIX::dup(fileno $dh), 'r');
             };
             chmod 0700, $fh;  # this would fail with $dh from opendir

           New in version 0.05.

           Changed in version 0.22: fd can no longer be a handle (that was a wrong turn).

       "fdopendir"
           ret = fdopendir(fd);

           Returns a directory handle associated with the numeric file descriptor fd or undef on error.

           The file descriptor is not dup'ed and will be closed when the handle is closed.

           Usage example:

             my $dh = do {
               sysopen my $fh, '/tmp', O_RDONLY|O_DIRECTORY|O_NOFOLLOW;
               fdopendir(POSIX::dup(fileno $fh));
             };
             my @dents = readdir $dh;  # this would fail with $fh from sysopen

           New in version 0.05.

           Changed in version 0.22: fd can no longer be a handle (that was a wrong turn).

       "fdim"
           d = fdim(double x, double y);

       "feclearexcept"
           ret = feclearexcept(excepts);

           Returns "0 but true" on success, undef on error.

           New in version 0.20.

       "fegetround"
           rounding_mode = fegetround();

       "feraiseexcept"
           ret = feraiseexcept(excepts);

           Returns "0 but true" on success, undef on error.

           New in version 0.20.

       "fesetround"
           ret = fesetround(round);

           Returns "0 but true" on success, undef on error.

       "fetestexcept"
           excepts_currently_set = fetestexcept(excepts);

           New in version 0.20.

       "fexecve"
           fexecve(fd, args, env=undef);

           Executes the program referred to by the file descriptor fd, passing args as its command-line arguments and optionally env as its environment.

           args must be an array reference and, by convention, args->[0] should be the name of the program being executed.

           env must be a hash reference. If omitted or undef, the environment of the calling proces is used (which you can manipulate via %ENV).

           See the manpage for issues regarding the close-on-exec flag and the /proc filesystem.

           Returns undef on error, otherwise it doesn't return.

           Usage example:

             sysopen my $fh, '/usr/bin/date', O_PATH;
             fexecve($fh, [qw(date +%T)], {TZ => 'UTC'});

           See also execveat().

           New in version 0.22.

       "ffs"
           pos = ffs(i);

           Calls ffsll(), ffsl(), or ffs(), whichever is the maximum available on your system.

       "floor"
           y = floor(x);

       "fma"
           r = fma(x, y, z);

       "fmax"
           m = fmax(x, y);

       "fmin"
           m = fmin(x, y);

       "fmod"
           m = fmod(x, y);

       "fnmatch"
           ret = fnmatch(pattern, string, flags);

           Returns 0 if string matches pattern, "FNM_NOMATCH" if there is no match, undef if there is an error.

           flags is the bitwise OR of zero or more of "FNM_NOESCAPE", "FNM_PATHNAME", "FNM_PERIOD", "FNM_FILE_NAME", "FNM_LEADING_DIR", "FNM_CASEFOLD".

       "fpclassify"
           fpclassify(x);

           Returns one of "FP_NAN", "FP_INFINITE", "FP_ZERO", "FP_SUBNORMAL", "FP_NORMAL".

       "fstatat"
           (dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec, blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = fstatat(dirfd, path, flags = 0);

           flags is the bitwise OR of zero or more of "AT_SYMLINK_NOFOLLOW", "AT_NO_AUTOMOUNT". Your system might support a different set of flags.

           See stat() for notes on the return values and bugs in CORE::stat().

           Returns the empty list on error.

       "fsync"
           ret = fsync(fd);

       "futimens"
           ret = futimens(fd, atime_sec, atime_nsec, mtime_sec, mtime_nsec);

           atime_sec and mtime_sec default to 0, atime_nsec and mtime_nsec default to "UTIME_NOW".

       "getdate"
           (sec, min, hour, mday, mon, year, wday, yday, isdst) = getdate(string);

       "getdate_err"
           getdate_err() returns the value of the getdate_err variable.

       "getegid"
           egid = getegid();

       "geteuid"
           euid = geteuid();

       "getgid"
           gid = getgid();

       "gethostid"
           hostid = gethostid();

       "gethostname"
           hostname = gethostname();

       "getitimer"
           (int_sec, int_usec, val_sec, val_usec) = getitimer(which);

           which can be one of "ITIMER_REAL", "ITIMER_VIRTUAL", "ITIMER_PROF".

           POSIX.1-2008 marks getitimer() and setitimer() obsolete, recommending the use of the POSIX timers API (timer_gettime(), timer_settime(), etc.)  instead.

           POSIX.1-2024 removed getitimer() and setitimer().

       "getpriority"
           prio = getpriority(which=PRIO_PROCESS, who=0);

           which can be one of "PRIO_PROCESS", "PRIO_PGRP", "PRIO_USER", defaults to "PRIO_PROCESS". who defaults to 0.

           Returns undef on error.

       "getsid"
           sid = getsid(pid);

           pid defaults to 0.

       "getuid"
           uid = getuid();

       "getutxent"
           (user, id, line, pid, type, sec, usec) = getutxent();

           getutxent() reads a line from the current file position in the utmp file.

       "getutxid"
           (user, id, line, pid, type, sec, usec) = getutxid(ut_type, ut_id);

           getutxid() searches forward from the current file position in the utmp file based upon ut_type and ut_id. If ut_type is one of "RUN_LVL", "BOOT_TIME",  "NEW_TIME",  or  "OLD_TIME",  getutxid()
           will  find  the  first  entry whose ut_type field matches ut_type. If ut_type is one of "INIT_PROCESS", "LOGIN_PROCESS", "USER_PROCESS", or "DEAD_PROCESS", getutxid() will find the first entry
           whose ut_id field matches ut_id.

       "getutxline"
           (user, id, line, pid, type, sec, usec) = getutxline(ut_line);

           getutxline() searches forward from the current file position in the utmp file. It scans entries whose ut_type is "USER_PROCESS" or "LOGIN_PROCESS" and returns the first one whose ut_line field
           matches ut_line.

       "hypot"
           r = hypot(x, y);

       "ilogb"
           y = ilogb(x);

       "isalnum"
           ret = isalnum(charstring);

           Like POSIX::isalnum() but returns 0 for the empty string.

       "isalpha"
           ret = isalpha(charstring);

           Like POSIX::isalpha() but returns 0 for the empty string.

       "isascii"
           ret = isascii(charstring);

           POSIX.1-2008 marks it as obsolete and it was removed in POSIX.1-2024, but I include it anyway.

           New in version 0.19.

       "isatty"
           ret = isatty(fd);

       "isblank"
           ret = isblank(charstring);

           Like POSIX::isblank() but returns 0 for the empty string.

       "iscntrl"
           ret = iscntrl(charstring);

           Like POSIX::iscntrl() but returns 0 for the empty string.

       "isdigit"
           ret = isdigit(charstring);

           Like POSIX::isdigit() but returns 0 for the empty string.

       "isfinite"
           ret = isfinite(x);

       "isgraph"
           ret = isgraph(charstring);

           Like POSIX::isgraph() but returns 0 for the empty string.

       "isgreaterequal"
           ret = isgreaterequal(x, y);

           New in version 0.20.

       "isinf"
           ret = isinf(x);

       "isless"
           ret = isless(x, y);

           New in version 0.20.

       "islessequal"
           ret = islessequal(x, y);

           New in version 0.20.

       "islessgreater"
           ret = islessgreater(x, y);

           New in version 0.20.

       "islower"
           ret = islower(charstring);

           Like POSIX::islower() but returns 0 for the empty string.

       "isnan"
           ret = isnan(x);

       "isnormal"
           ret = isnormal(x);

       "isprint"
           ret = isprint(charstring);

           Like POSIX::isprint() but returns 0 for the empty string.

       "ispunct"
           ret = ispunct(charstring);

           Like POSIX::ispunct() but returns 0 for the empty string.

       "isspace"
           ret = isspace(charstring);

           Like POSIX::isspace() but returns 0 for the empty string.

       "isunordered"
           ret = isunordered(x, y);

           New in version 0.20.

       "isupper"
           ret = isupper(charstring);

           Like POSIX::isupper() but returns 0 for the empty string.

       "isxdigit"
           ret = isxdigit(charstring);

           Like POSIX::isxdigit() but returns 0 for the empty string.

       "j0"
           y = j0(x);

           j0() is the Bessel function of the first kind of order 0.

       "j1"
           y = j1(x);

           j1() is the Bessel function of the first kind of order 1.

       "jn"
           y = jn(n, x);

           jn() is the Bessel function of the first kind of order n.

       "jrand48"
           (r, X0, X1, X2) = jrand48(X0, X1, X2);

       "killpg"
           ret = killpg(pgrp, sig);

       "l64a"
           s = l64a(n);

       "lchown"
           ret = lchown(path, uid, gid);

           New in version 0.08.

       "ldexp"
           y = ldexp(x, exp);

       "lgamma"
           y = lgamma(x);

       "link"
           ret = link(path1, path2);

       "linkat"
           ret = linkat(fd1, path1, fd2, path2, flags=0);

           flags can be 0 or "AT_SYMLINK_FOLLOW". Your system might support a different set of flags.

       "log"
           y = log(x);

       "log10"
           y = log10(x);

       "log1p"
           y = log1p(x);

       "log2"
           y = log2(x);

       "logb"
           y = logb(x);

       "lrand48"
           r = lrand48();

       "lround"
           l = lround(x);

           Calls llround() or lround() whichever is the maximum available on your system. If the rounded value is outside Perl's internal signed integer range, it is returned as a string. If the  rounded
           value is too large to be stored in a long long or long, undef is returned.

       "lstat"
           (dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec, blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = lstat(path);

           "path" is assumed to be a string (or will be converted to a string).

           See stat() for notes on the return values and bugs in CORE::stat().

           Returns the empty list on error.

       "mkdir"
           ret = mkdir(path, [mode = 0777]);

       "mkdirat"
           ret = mkdirat(fd, path, mode);

       "mkdtemp"
           name = mkdtemp(template);

       "mkfifo"
           ret = mkfifo(path, mode);

       "mkfifoat"
           ret = mkfifoat(fd, path, mode);

       "mknod"
           ret = mknod(path, mode, dev);

       "mknodat"
           ret = mknodat(fd, path, mode, dev);

       "mkstemp"
           (fd, name) = mkstemp(template);

       "mrand48"
           mrand48();

       "nanosleep"
            (rem_sec, rem_nsec) = nanosleep(floating_sec);
            floating_rem_sec = nanosleep(floating_sec);

            (rem_sec, rem_nsec) = nanosleep(sec, nsec);
            floating_rem_sec = nanosleep(sec, nsec);

           Returns zero(es) on success, the remaining time on EINTR, the empty list or undef otherwise.

           Changed in version 0.25: Sleep time can be floating seconds only or seconds and nanoseconds.

       "nearbyint"
           y = nearbyint(x);

       "nextafter"
           z = nextafter(x, y);

       "nexttoward"
           z = nexttoward(x, y);

       "nice"
           ret = nice(incr);

           Returns undef on error.

       "nrand48"
           r = nrand48()

       "open"
           ret = open(path, flags=O_RDONLY, mode=0666);

       "openat"
           ret = openat(dirfd, path, flags=O_RDONLY, mode=0666);

           If  dirfd is numeric (i.e. a file descriptor), openat() returns a file descriptor. If dirfd is a file or directory handle, the return value is also a handle whose type depends on the file type
           of path: If path is a directory, the return value is a directory handle, otherwise it's a file handle.

           To get a handle even for the special numeric dirfd value "AT_FDCWD", you can pass a reference to that value instead, i.e. "openat(\AT_FDCWD, ...)".

           Returns undef on error.

           Changed in version 0.18: Support added for "\AT_FDCWD" reference.

       "openat2"
           ret = openat2(dirfd, path, how);

           The openat2() system call is a Linux-specific extension of openat() and provides a superset of its functionality.

           The how parameter is a hash reference corresponding to the struct open_how. It currently supports the keys flags, mode and resolve. Missing keys are treated as having a zero value.

           Example:

             my $fh = openat2(
               \AT_FDCWD, '/foobar',
               {flags => O_RDWR|O_CREAT, mode => 0600, resolve => RESOLVE_IN_ROOT}
             );

           Note that, unlike open() or openat(), openat2() is very picky about flags and mode. See the manpage for details.

           Returns undef on error.

           New in version 0.18.

       "pathconf"
           ret = pathconf(what, name);

           what can be a path or, if your system supports fpathconf(), a Perl file or directory handle or a file descriptor.

           name is one of the "_PC_*" integer constants.

           Returns undef on error.

           New in version 0.22.

       "poll"
           ret = poll(pollfds, timeout=-1);

           timeout specifies the number of milliseconds that poll() should block waiting for a file descriptor to become ready. A negative timeout value means an  infinite  timeout.  A  timeout  of  zero
           causes poll() to return immediately.

           pollfds  is  an  array  reference  holding  array  references  of the form [fd, events, revents] where fd is an integer file descriptor or a file handle, events is a bit mask of events you are
           interested in for fd, and revents is a bit mask of events that actually occurred.

           revents is changed by the call (unless a timeout or error occurs), everything else remains unchanged.

           If fd is negative or anything sv_2io() doesn't consider a file handle then the corresponding events field is ignored and the revents field returns zero.

           Returns the number of elements in pollfds whose revents have been set to a non-zero value, zero if the call timed out, -1 on error.

           Usage example:

             open my $pipe, '-|', qw(tail -f /var/log/messages);
             my $pollfds = [[\*STDIN, POLLIN, 0], [2, POLLOUT, 0], [$pipe, POLLIN, 0]];
             my $rv = poll($pollfds, -1);

             # Skip events for fd 2 this time:
             my $pollfds = [[\*STDIN, POLLIN, 0], [-2, POLLOUT, 0], [$pipe, POLLIN, 0]];
             my $rv = poll($pollfds, -1);

           New in version 0.25.

       "posix_fadvise"
           ret = posix_fadvise(fd, offset, len, advice);

           advice is one of the "POSIX_FADV_" constants.

           New in version 0.14.

       "posix_fallocate"
           ret = posix_fallocate(fd, offset, len);

           New in version 0.14.

       "pread"
           bytes_read = pread(fd, buf, count, offset=0, buf_offset=0);

           pread() reads count bytes (not characters) of data from the file descriptor fd at file offset offset into the scalar buf without changing the file offset. buf will be enlarged automatically if
           necessary.

           offset and buf_offset are set to 0 if omitted or undef.

           pread() treats buf just like sysread() does: buf_offset may be specified to place the read data at that position in buf. If buf_offset is past the end of buf, buf will  be  padded  with  zeros
           before  appending  the  data. If buf_offset is negative, it is counted from the end of the string. buf will be grown or shrunk so that the last byte actually read is the last byte of buf after
           the read.

           Returns the number of bytes read, 0 at EOF, undef on error.

           Croaks if buf is read-only and count is non-zero.

           Changed in version 0.13: Argument order is now (count, offset) instead of (offset, count).

           Changed in version 0.22: Croak with read-only buf and non-zero count.

       "preadv"
           bytes_read = preadv(fd, buffers, sizes, offset=0);

           preadv() behaves like readv() but adds an optional offset argument, which specifies the file position at which the data is to be read. offset is set to 0 if omitted or undef.

           The file offset is not changed by this system call. The file referred to by fd must be capable of seeking.

           This syscall is present in Linux and BSD.

           New in version 0.13.

       "preadv2"
           bytes_read = preadv2(fd, buffers, sizes, offset=0, flags=0);

           preadv2() is similar to preadv() but adds an optional flags argument, which is a bitwise OR of zero or more of the "RWF_*" flags (see the manpage for details). flags is set to 0 if omitted  or
           undef.

           This syscall is Linux-specific.

           New in version 0.20.

       "psignal"
           psignal(sig, msg);

           New in version 0.25.

       "ptsname"
           name = ptsname(fd);

           Changed in version 0.19: Calls ptsname_r() if available.

           Changed in version 0.22: fd may also be a file handle.

       "pwrite"
           bytes_written = pwrite(fd, buf, count=undef, offset=0, buf_offset=0);

           pwrite() writes count bytes of data from the scalar buf to the file descriptor fd at file offset offset without changing the file offset. The file referenced by fd must be capable of seeking.

           If count is omitted or undef, everything from buf_offset up to the end of buf is written.

           buf_offset may be specified to write data from that position in buf. If buf_offset is negative it is counted from the end of the string.

           offset and buf_offset are set to 0 if omitted or undef.

           Returns the number of bytes written, undef on error.

           On Linux, if a file is opened with "O_APPEND", pwrite() appends data to the end of the file, regardless of the value of offset (in violation of POSIX).

           Changed in version 0.13: Argument order is now (count, offset) instead of (offset, count).

       "pwritev"
           bytes_written = pwritev(fd, buffers, offset=0);

           pwritev() behaves like writev() but adds an optional offset argument, which specifies the file position at which the data is to be written. offset is set to 0 if omitted or undef.

           The file offset is not changed by this system call. The file referred to by fd must be capable of seeking.

           On Linux, if a file is opened with "O_APPEND", pwritev() appends data to the end of the file, regardless of the value of offset (in violation of POSIX).

           This syscall is present in Linux and BSD.

           New in version 0.08.

       "pwritev2"
           bytes_written = pwritev2(fd, buffers, offset=0, flags=0);

           pwritev2()  is  similar to pwritev() but adds an optional flags argument, which is a bitwise OR of zero or more of the "RWF_*" flags (see the manpage for details). flags is set to 0 if omitted
           or undef.

           This syscall is Linux-specific.

           New in version 0.20.

       "random"
           r = random();

       "raise"
           ret = raise(sig);

       "read"
           bytes_read = read(fd, buf, count);

           Like POSIX::read() but returns 0 at EOF instead of "0 but true". Croaks if buf is read-only and count is non-zero.

           Changed in version 0.22: Croak with read-only buf and non-zero count.

       "readv"
           bytes_read = readv(fd, buffers, sizes);

           readv() reads from the file descriptor fd into buffers as many strings as there are elements in sizes.

           buffers must be a variable holding an array (@buf), an array reference or undef ($buf). If it is undef it will be upgraded to an array reference.

           sizes must be an array reference, i.e. "\@sizes", $sizes, or "[...]".

           sizes is expected to hold unsigned integers that specify how many bytes are to be read into each buffer. A byte count of 0 or undef creates an empty string. sizes is processed in array order.

           buffers will be extended if necessary, but it will never be shrunk. If buffers is not empty, any existing elements are replaced as long as sufficient data was read from fd.

           readv() returns the number of bytes read, undef on error.

           Note that it is not an error for a successful call to transfer fewer bytes than requested. In this case there may be one "partially" filled buffer, i.e.   it  contains  fewer  bytes  than  the
           corresponding size. Surplus size entries lead to corresponding empty buffers.

           Usage example:

             my $fh = openat(\AT_FDCWD, '/tmp/foobar', O_RDWR|O_CREAT|O_TRUNC);
             pwrite($fh, 'foobar', 6, 0);
             readv($fh, my $buf1, [3, 0, 8]); # $buf1: ['foo', '', 'bar']
             sysseek $fh, 0, 0;
             readv($fh, my @buf2, [1, 3, 2]); # @buf2: ('f', 'oob', 'ar')

           New in version 0.13.

           Changed in version 0.22: buffers may be an undef variable, buffers beyond EOF are created as empty strings instead of being skipped.

       "readlink"
           name = readlink(path);

           Returns undef on error.

       "readlinkat"
           name = readlinkat(dirfd, path);

           Returns undef on error.

       "realpath"
           resolved_path = realpath(path);

           Calls the actual C library fuction realpath() and relies on it to be able to allocate memory for the resolved path automatically (as required by POSIX-2008).

           Returns undef on error.

           New in version 0.18.

       "remainder"
           rem = remainder(x, y);

           Returns  undef on error.

       "remove"
           ret = remove(path);

           Calls the actual C library function remove().

           Note  that  core  POSIX::remove()  fails  if  path  is  a  symlink to a directory because someone "couldn't read the plans right and did a piss-poor job of putting it together" as (-d $_[0]) ?
           CORE::rmdir($_[0]) : CORE::unlink($_[0]). Quote from Armageddon.

           This could be fixed like this: "unlink $_[0] or ($!{EISDIR} or $!{EPERM}) and rmdir $_[0]" (correct errno check depends on OS), or by using the library call right away.

       "removeat"
           ret = removeat(dirfd, path);

           The removeat() function works exactly like remove() but path is interpreted relative to dirfd as with the other *at functions.

           This function is a home-grown non-standard extension only available in this module (to my knowledge).

           New in version 0.22.

       "remquo"
           (rem, quo) = remquo(x, y);

           Returns the empty list on error.

           New in version 0.20.

       "rename"
           ret = rename(old, new);

       "renameat"
           ret = renameat(olddirfd, oldpath, newdirfd, newpath);

       "renameat2"
           ret = renameat(olddirfd, oldpath, newdirfd, newpath, flags=0);

           The renameat2() system call is a Linux-specific extension of renameat() and provides a superset of its functionality.

           flags is the bitwise OR of zero or more of "RENAME_EXCHANGE", "RENAME_NOREPLACE", "RENAME_WHITEOUT".

           New in version 0.21.

       "rmdir"
           ret = rmdir(path);

           New in version 0.19.

       "round"
           r = round(x);

       "scalbn"
           y = scalbn(x, n);

           Calls scalbln() or scalbn(), whichever is the maximum supported by your system.

       "seed48"
           (old_seed1, old_seed2, old_seed3) = seed48(seed1, seed2, seed3);

       "setegid"
           ret = setegid(gid);

       "seteuid"
           ret = seteuid(uid);

       "setgid"
           ret = setgid(gid);

       "setitimer"
           (old_int_sec, old_int_usec, old_val_sec, old_val_usec) = setitimer(which, int_sec, int_usec, val_sec, val_usec);

           which is one of "ITIMER_REAL", "ITIMER_VIRTUAL", "ITIMER_PROF".

           POSIX.1-2008 marks getitimer() and setitimer() obsolete, recommending the use of the POSIX timers API (timer_gettime(), timer_settime(), etc.)  instead.

           POSIX.1-2024 removed getitimer() and setitimer().

       "setpriority"
           ret = setpriority(prio, which=PRIO_PROCESS, who=0);

           which can be one of "PRIO_PROCESS", "PRIO_PGRP", "PRIO_USER", defaults to "PRIO_PROCESS". who defaults to 0.

           Note that due to the support of default values for which and who, prio is the first call parameter, whereas in the actual syscall it is the last.

           Returns true on success, undef on error.

       "setregid"
           ret = setregid(rgid, egid);

       "setreuid"
           ret = setreuid(ruid, euid);

       "setsid"
           sid = setsid();

           New in version 0.19.

       "setuid"
           ret = setuid(uid);

       "setutxent"
           setutxent();

       "sighold"
           ret = sighold(sig);

           POSIX.1-2008 marks this function as obsolete, recommending the use of "sigprocmask" in POSIX instead.

       "sigignore"
           ret = sigignore(sig);

           POSIX.1-2008 marks this function as obsolete, recommending the use of "sigaction" in POSIX instead. Or use "$SIG{SIG} = 'IGNORE';".

       "signbit"
           b = signbit(x);

       "sigpause"
           sigpause(sig);

           POSIX.1-2008 marks this function as obsolete, recommending the use of "sigsuspend" in POSIX instead.

       "sigrelse"
           ret = sigrelse(sig);

           POSIX.1-2008 marks this function as obsolete, recommending the use of "sigprocmask" in POSIX instead.

       "sin"
           y = sin(x);

           New in version 0.19.

       "sinh"
           y = sinh(x);

       "srand48"
           srand48(seedval);

       "srandom"
           srandom(seed);

       "stat"
           (dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec, blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = stat(what);

           what can be a path, a Perl file handle or a file descriptor.

           ctim_sec, blksize, blocks and nanoseconds may not be available on your system.

           Values outside Perl's internal integer range are returned as strings, i.e. if you need the exact values you should, for example, use "eq" instead of "==" for comparisons.

           Note that CORE::stat() lies to you in some cases: It returns rdev as a signed integer even if your OS's "dev_t" is unsigned. It returns size as a floating point number if your OS's "off_t"  is
           bigger than Perl's integer size. It returns the times as floating point numbers if your OS's "time_t" is unsigned.

           POSIX::2008::stat() doesn't mimic these bugs and uses the correct data types for all values.

           Returns the empty list on error.

       "statvfs"
           (f_bsize, f_frsize, f_blocks, f_bfree, f_bavail, f_files, f_ffree, f_favail, f_fsid, f_flag, f_namemax) = statvfs(what);

           what can be a path, a Perl file handle or a file descriptor.

           Values  outside  Perl's internal integer range are returned as strings as with stat(). Note that Filesys::Statvfs returns only floating point numbers which may give wrong results, and it lacks
           f_fsid.

           Only the ST_NOSUID and ST_RDONLY flags of the f_flag field are specified in POSIX but this module provides additional ST_ flags if available.

           Returns the empty list on error.

           New in version 0.25.

       "strptime"
             (sec, min, hour, mday, mon, year, wday, yday, isdst) =
               strptime(s, format[, sec, min, hour, mday, mon, year, wday, yday, isdst]);

             ... = strptime(s, format, \@tm);

           strptime() converts the string s into a broken-down time according to the format string format.

           The time fields may optionally be initialized in whole or in part either with up to 9 separate arguments or with a single array reference after the format.  Omitted arguments  are  treated  as
           undef. In case of an array reference the array is updated according to the fields affected by the format string. If an error occurred the array is not udpated.

           In list context returns the broken-down time or the empty list on error.  Fields not affected by the format string are returned as initialized.

           In scalar context returns the index of the first byte in s that was not processed or the byte length of s if the whole string was consumed or undef on error.

           As strptime() acts on null-terminated strings, strings containing NUL bytes will only be processed up to the first NUL byte.

           New in version 0.02.

           Changed in version 0.24: Accept an array reference as the third argument (<https://rt.cpan.org/Public/Bug/Display.html?id=66519>).

       "strsignal"
           str = strsignal(sig);

           New in version 0.25.

       "symlink"
           ret = symlink(target, linkpath);

       "symlinkat"
           ret = symlinkat(target, dirfd, linkpath);

       "sync"
           sync();

           This function doesn't return any value.

       "sysconf"
           ret = sysconf(name);

           name is one of the "_SC_*" integer constants.

           Returns undef on error.

           New in version 0.22.

       "tan"
           y = tan(x);

       "tanh"
           y = tanh(x);

       "tgamma"
           y = tgamma(x);

       "timer_create"
           timerid = timer_create(clockid, signal=undef);

           Creates  a  new  per-process  interval  timer  using the clock given by clock_id as the timing base. signal is the signal number to be delivered when the timer expires. If signal is omitted or
           undef, no signal is delivered and the progress of the timer can be monitored using timer_gettime().

           Calling a notification function on timer expiration is currently not supported.

           Returns undef on error.

           New in version 0.16.

           Changed in version 0.22: signal is optional.

       "timer_delete"
           ret = timer_delete(timerid);

           Returns "0 but true" on success, undef on error.

           New in version 0.16.

       "timer_getoverrun"
           count = timer_getoverrun(timerid);

           Returns undef on error.

           New in version 0.16.

       "timer_gettime"
           (interval_sec, interval_nsec, initial_sec, initial_nsec) = timer_gettime(timerid);

           Returns the empty list on error.

           New in version 0.16.

       "timer_settime"
           (old_int_sec, old_int_nsec, old_init_sec, old_init_nsec) = timer_settime(timerid, flags, int_sec, int_nsec, [init_sec, init_nsec]);

           flags may be 0 or "TIMER_ABSTIME". If the init values are omitted, they are set to the int values.

           New in version 0.16.

       "truncate"
           ret = truncate(what, length);

           what can be a path, a Perl file handle, or a file descriptor.

           Note that it does not flush the file handle before truncating. Perl's built-in truncate() does (this is undocumented, probably because it's silly).

           Changed in version 0.19: Deprecated ftruncate now covered by truncate.

       "trunc"
           y = trunc(x);

       "ttyname"
           name = ttyname(fd);

           Calls ttyname_r() if available.

           New in version 0.19.

           Changed in version 0.22: fd may also be a file handle.

       "unlink"
           ret = unlink(path);

           Calls the actual C library function unlink().

           Note that core POSIX::unlink() calls CORE::unlink(), which, unless you start Perl with "-U", a) is prone to time-of-check/time-of-use race conditions due  to  an  additional  lstat(),  and  b)
           blindly fails with "EISDIR" for directories (due to said lstat()), ignoring that some OSes use "EPERM" in this case (as required by POSIX).

       "unlinkat"
           ret = unlinkat(dirfd, path, flags=0);

           flags can be 0 or "AT_REMOVEDIR".

       "utimensat"
           ret = utimensat(dirfd, path, flags, atime_sec, atime_nsec, mtime_sec, mtime_nsec);

           flags can be 0 or "AT_SYMLINK_NOFOLLOW", defaults to 0. Your system might support a different set of flags.

           atime_sec and mtime_sec default to 0. atime_nsec and mtime_nsec default to "UTIME_NOW".

       "write"
           bytes_written = write(fd, buf, count=undef);

           Like POSIX::write() but returns 0 instead of "0 but true" if 0 bytes were written, and never writes more bytes than buf contains even if count exceeds the length of buf.

           If count is omitted or undef, it defaults to the length of buf.

       "writev"
           bytes_written = writev(fd, buffers);

           writev() writes multiple buffers of data to the file associated with the file descriptor fd.

           buffers must be an array reference, i.e. "\@buf", $buf or "[...]". The buffers are processed in array order.

           Note  that  "writev($fh,  $buf);"  is  not  the  same  as "print $fh, @$buf;" or "syswrite $fh, $_ for @$buf;" because writev() transfers data atomically as a single block. See the manpage for
           details.

           Returns the number of bytes written or undef on error.

           New in version 0.08.

       "y0"
           y = y0(x);

           y0() is the Bessel function of the second kind of order 0.

       "y1"
           y = y1(x);

           y1() is the Bessel function of the second kind of order 1.

       "yn"
           y = yn(n, x);

           yn() is the Bessel function of the second kind of order n.

EXPORTS
       This module does not export anything by default. The following export tags are available:

        :at      All *at() functions like openat(), all AT_/RENAME_/RESOLVE_ constants
        :id      All get/set*id() functions like getuid() etc.
        :is      All is* functions like isdigit() etc.
        :rw      read(), readv(), write(), writev()
        :prw     pread(), preadv(), preadv2(), pwrite(), pwritev(), pwritev2()
        :clock   All clock* functions and CLOCK_ constants and TIMER_ABSTIME
        :fcntl   All F_, FD_, O_, POSIX_FADV_, SEEK_, _OK constants (for AT_ use :at)
        :fenv_h  All FE_ constants and fe* functions
        :fnm     fnmatch() and all FNM_ constants
        :poll    poll() and all POLL constants
        :stat_h  All S_I* and UTIME_ constants
        :time_h  All CLOCK_ and TIMER_ constants
        :timer   All timer_ functions and TIMER_ constants
        :utmpx_h   All *utx* functions and utmpx.h constants
        :confstr   confstr() and all _CS_ constants
        :pathconf  pathconf() and all _PC_ constants
        :sysconf   sysconf() and all _SC_ constants

       New in version 0.19: :stat_h export tag.

       New in version 0.20: :fenv_h export tag.

       New in version 0.22: :confstr, :pathconf, :sysconf export tags.

       New in version 0.25: :poll export tag.

CONSTANTS
       "AT_EACCESS" "AT_EMPTY_PATH" "AT_FDCWD" "AT_NO_AUTOMOUNT" "AT_REMOVEDIR"  "AT_RESOLVE_BENEATH"  "AT_SYMLINK_FOLLOW"  "AT_SYMLINK_NOFOLLOW"  "RENAME_EXCHANGE"  "RENAME_NOREPLACE"  "RENAME_WHITEOUT"
       "RESOLVE_BENEATH" "RESOLVE_CACHED" "RESOLVE_IN_ROOT" "RESOLVE_NO_MAGICLINKS" "RESOLVE_NO_SYMLINKS" "RESOLVE_NO_XDEV"

       "ACCOUNTING" "EMPTY" "BOOT_TIME" "NEW_TIME" "OLD_TIME" "DEAD_PROCESS" "INIT_PROCESS" "LOGIN_PROCESS" "USER_PROCESS" "RUN_LVL"

       "CLOCK_BOOTTIME" "CLOCK_BOOTTIME_ALARM" "CLOCK_HIGHRES" "CLOCK_MONOTONIC" "CLOCK_MONOTONIC_COARSE" "CLOCK_MONOTONIC_FAST" "CLOCK_MONOTONIC_PRECISE" "CLOCK_MONOTONIC_RAW" "CLOCK_PROCESS_CPUTIME_ID"
       "CLOCK_REALTIME"   "CLOCK_REALTIME_ALARM"   "CLOCK_REALTIME_COARSE"   "CLOCK_REALTIME_FAST"   "CLOCK_REALTIME_PRECISE"   "CLOCK_SOFTTIME"   "CLOCK_TAI"   "CLOCK_THREAD_CPUTIME_ID"   "CLOCK_UPTIME"
       "CLOCK_UPTIME_FAST" "CLOCK_UPTIME_PRECISE"

       "F_DUPFD" "F_DUPFD_CLOEXEC" "F_GETFD" "F_SETFD" "F_GETFL" "F_SETFL" "F_GETLK" "F_SETLK" "F_SETLKW" "F_GETOWN" "F_SETOWN" "F_RDLCK" "F_UNLCK" "F_WRLCK"

       "FD_CLOEXEC"

       "FE_ALL_EXCEPT" "FE_DIVBYZERO" "FE_INEXACT" "FE_INVALID" "FE_OVERFLOW" "FE_UNDERFLOW" "FE_TONEAREST" "FE_TOWARDZERO" "FE_UPWARD" "FE_DOWNWARD"

       "FNM_CASEFOLD" "FNM_FILE_NAME" "FNM_LEADING_DIR" "FNM_NOESCAPE" "FNM_NOMATCH" "FNM_PATHNAME" "FNM_PERIOD"

       "FP_INFINITE" "FP_NAN" "FP_NORMAL" "FP_SUBNORMAL" "FP_ZERO"

       "TIMER_ABSTIME" "ITIMER_PROF" "ITIMER_REAL" "ITIMER_VIRTUAL"

       "O_ACCMODE" "O_APPEND" "O_ASYNC" "O_CLOEXEC" "O_CREAT" "O_DIRECT" "O_DIRECTORY" "O_DSYNC" "O_EMPTY_PATH" "O_EXCL" "O_EXEC" "O_EXLOCK" "O_LARGEFILE" "O_NDELAY" "O_NOATIME"  "O_NOCTTY"  "O_NOFOLLOW"
       "O_NONBLOCK" "O_NOSIGPIPE" "O_PATH" "O_RDONLY" "O_REGULAR" "O_RESOLVE_BENEATH" "O_RDWR" "O_RSYNC" "O_SEARCH" "O_SHLOCK" "O_SYNC" "O_TMPFILE" "O_TRUNC" "O_TTY_INIT" "O_WRONLY" "FASYNC"

       "POLLIN" "POLLRDNORM" "POLLRDBAND" "POLLPRI" "POLLOUT" "POLLWRNORM" "POLLWRBAND" "POLLERR" "POLLHUP" "POLLNVAL"

       "INFTIM" "POLLFREE" "POLLINIGNEOF" "POLLMSG" "POLLNORM" "POLLRDHUP" "POLLREMOVE" "POLLSTANDARD" "POLL_BUSY_LOOP"

       "POSIX_FADV_NORMAL" "POSIX_FADV_SEQUENTIAL" "POSIX_FADV_RANDOM" "POSIX_FADV_NOREUSE" "POSIX_FADV_WILLNEED" "POSIX_FADV_DONTNEED"

       "PRIO_PROCESS" "PRIO_PGRP" "PRIO_USER"

       "RTLD_DEEPBIND" "RTLD_GLOBAL" "RTLD_LAZY" "RTLD_LOCAL" "RTLD_MEMBER" "RTLD_NOAUTODEFER" "RTLD_NODELETE" "RTLD_NOLOAD" "RTLD_NOW"

       "RWF_APPEND" "RWF_DSYNC" "RWF_HIPRI" "RWF_NOWAIT" "RWF_SYNC"

       "SEEK_SET" "SEEK_CUR" "SEEK_END" "SEEK_DATA" "SEEK_HOLE" "F_OK" "R_OK" "W_OK" "X_OK"

       "S_IFMT"  "S_IFBLK"  "S_IFCHR"  "S_IFIFO"  "S_IFREG"  "S_IFDIR"  "S_IFLNK"  "S_IFSOCK" "S_ISUID" "S_ISGID" "S_IRWXU" "S_IRUSR" "S_IWUSR" "S_IXUSR" "S_IRWXG" "S_IRGRP" "S_IWGRP" "S_IXGRP" "S_IRWXO"
       "S_IROTH" "S_IWOTH" "S_IXOTH" "S_ISVTX"

       "ST_NOSUID" "ST_RDONLY"

       "ST_MANDLOCK" "ST_NOATIME" "ST_NODEV" "ST_NODIRATIME" "ST_NOEXEC" "ST_RELATIME" "ST_SYNCHRONOUS"

       "ST_ASYNC" "ST_DEFEXPORTED" "ST_EXKERB" "ST_EXNORESPORT" "ST_EXPORTANON" "ST_EXPORTED" "ST_EXPUBLIC"  "ST_EXRDONLY"  "ST_LOCAL"  "ST_LOG"  "ST_NOCOREDUMP"  "ST_NODEVMTIME"  "ST_QUOTA"  "ST_ROOTFS"
       "ST_SYMPERM" "ST_UNION"

       "UTIME_NOW" "UTIME_OMIT"

       "_CS_GNU_LIBC_VERSION"    "_CS_GNU_LIBPTHREAD_VERSION"   "_CS_LFS64_CFLAGS"   "_CS_LFS64_LDFLAGS"   "_CS_LFS64_LIBS"   "_CS_LFS64_LINTFLAGS"   "_CS_LFS_CFLAGS"   "_CS_LFS_LDFLAGS"   "_CS_LFS_LIBS"
       "_CS_LFS_LINTFLAGS"      "_CS_PATH"      "_CS_POSIX_V5_WIDTH_RESTRICTED_ENVS"       "_CS_POSIX_V6_ILP32_OFF32_CFLAGS"       "_CS_POSIX_V6_ILP32_OFF32_LDFLAGS"       "_CS_POSIX_V6_ILP32_OFF32_LIBS"
       "_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS"      "_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS"      "_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS"     "_CS_POSIX_V6_ILP32_OFFBIG_LIBS"     "_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS"
       "_CS_POSIX_V6_LP64_OFF64_CFLAGS"        "_CS_POSIX_V6_LP64_OFF64_LDFLAGS"        "_CS_POSIX_V6_LP64_OFF64_LIBS"        "_CS_POSIX_V6_LP64_OFF64_LINTFLAGS"        "_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS"
       "_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS"      "_CS_POSIX_V6_LPBIG_OFFBIG_LIBS"      "_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS"      "_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS"     "_CS_POSIX_V7_ILP32_OFF32_CFLAGS"
       "_CS_POSIX_V7_ILP32_OFF32_LDFLAGS"      "_CS_POSIX_V7_ILP32_OFF32_LIBS"      "_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS"       "_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS"       "_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS"
       "_CS_POSIX_V7_ILP32_OFFBIG_LIBS"        "_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS"        "_CS_POSIX_V7_LP64_OFF64_CFLAGS"        "_CS_POSIX_V7_LP64_OFF64_LDFLAGS"        "_CS_POSIX_V7_LP64_OFF64_LIBS"
       "_CS_POSIX_V7_LP64_OFF64_LINTFLAGS"     "_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS"      "_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS"      "_CS_POSIX_V7_LPBIG_OFFBIG_LIBS"      "_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS"
       "_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS"   "_CS_V5_WIDTH_RESTRICTED_ENVS"   "_CS_V6_ENV"   "_CS_V6_WIDTH_RESTRICTED_ENVS"   "_CS_V7_ENV"   "_CS_V7_WIDTH_RESTRICTED_ENVS"  "_CS_XBS5_ILP32_OFF32_CFLAGS"
       "_CS_XBS5_ILP32_OFF32_LDFLAGS"   "_CS_XBS5_ILP32_OFF32_LIBS"   "_CS_XBS5_ILP32_OFF32_LINTFLAGS"    "_CS_XBS5_ILP32_OFFBIG_CFLAGS"    "_CS_XBS5_ILP32_OFFBIG_LDFLAGS"    "_CS_XBS5_ILP32_OFFBIG_LIBS"
       "_CS_XBS5_ILP32_OFFBIG_LINTFLAGS"    "_CS_XBS5_LP64_OFF64_CFLAGS"    "_CS_XBS5_LP64_OFF64_LDFLAGS"    "_CS_XBS5_LP64_OFF64_LIBS"    "_CS_XBS5_LP64_OFF64_LINTFLAGS"   "_CS_XBS5_LPBIG_OFFBIG_CFLAGS"
       "_CS_XBS5_LPBIG_OFFBIG_LDFLAGS" "_CS_XBS5_LPBIG_OFFBIG_LIBS" "_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS"

       "_PC_2_SYMLINKS"  "_PC_ALLOC_SIZE_MIN"  "_PC_ASYNC_IO"  "_PC_CHOWN_RESTRICTED"  "_PC_FILESIZEBITS"  "_PC_LINK_MAX"  "_PC_MAX_CANON"  "_PC_MAX_INPUT"  "_PC_NAME_MAX"  "_PC_NO_TRUNC"  "_PC_PATH_MAX"
       "_PC_PIPE_BUF" "_PC_PRIO_IO" "_PC_REC_INCR_XFER_SIZE" "_PC_REC_MAX_XFER_SIZE" "_PC_REC_MIN_XFER_SIZE" "_PC_REC_XFER_ALIGN" "_PC_SOCK_MAXBUF" "_PC_SYMLINK_MAX" "_PC_SYNC_IO" "_PC_VDISABLE"

       "_SC_2_CHAR_TERM"  "_SC_2_C_BIND"  "_SC_2_C_DEV"  "_SC_2_C_VERSION" "_SC_2_FORT_DEV" "_SC_2_FORT_RUN" "_SC_2_LOCALEDEF" "_SC_2_PBS" "_SC_2_PBS_ACCOUNTING" "_SC_2_PBS_CHECKPOINT" "_SC_2_PBS_LOCATE"
       "_SC_2_PBS_MESSAGE" "_SC_2_PBS_TRACK" "_SC_2_SW_DEV" "_SC_2_UPE" "_SC_2_VERSION" "_SC_ADVISORY_INFO" "_SC_AIO_LISTIO_MAX" "_SC_AIO_MAX" "_SC_AIO_PRIO_DELTA_MAX" "_SC_ARG_MAX" "_SC_ASYNCHRONOUS_IO"
       "_SC_ATEXIT_MAX" "_SC_AVPHYS_PAGES" "_SC_BARRIERS" "_SC_BASE" "_SC_BC_BASE_MAX"  "_SC_BC_DIM_MAX"  "_SC_BC_SCALE_MAX"  "_SC_BC_STRING_MAX"  "_SC_CHARCLASS_NAME_MAX"  "_SC_CHAR_BIT"  "_SC_CHAR_MAX"
       "_SC_CHAR_MIN"   "_SC_CHILD_MAX"   "_SC_CLK_TCK"   "_SC_CLOCK_SELECTION"  "_SC_COLL_WEIGHTS_MAX"  "_SC_CPUTIME"  "_SC_C_LANG_SUPPORT"  "_SC_C_LANG_SUPPORT_R"  "_SC_DELAYTIMER_MAX"  "_SC_DEVICE_IO"
       "_SC_DEVICE_SPECIFIC"  "_SC_DEVICE_SPECIFIC_R"  "_SC_EQUIV_CLASS_MAX"  "_SC_EXPR_NEST_MAX"  "_SC_FD_MGMT"  "_SC_FIFO"   "_SC_FILE_ATTRIBUTES"   "_SC_FILE_LOCKING"   "_SC_FILE_SYSTEM"   "_SC_FSYNC"
       "_SC_GETGR_R_SIZE_MAX"  "_SC_GETPW_R_SIZE_MAX"  "_SC_HOST_NAME_MAX"  "_SC_INT_MAX"  "_SC_INT_MIN"  "_SC_IOV_MAX" "_SC_IPV6" "_SC_JOB_CONTROL" "_SC_LEVEL1_DCACHE_ASSOC" "_SC_LEVEL1_DCACHE_LINESIZE"
       "_SC_LEVEL1_DCACHE_SIZE"   "_SC_LEVEL1_ICACHE_ASSOC"   "_SC_LEVEL1_ICACHE_LINESIZE"   "_SC_LEVEL1_ICACHE_SIZE"    "_SC_LEVEL2_CACHE_ASSOC"    "_SC_LEVEL2_CACHE_LINESIZE"    "_SC_LEVEL2_CACHE_SIZE"
       "_SC_LEVEL3_CACHE_ASSOC"  "_SC_LEVEL3_CACHE_LINESIZE"  "_SC_LEVEL3_CACHE_SIZE"  "_SC_LEVEL4_CACHE_ASSOC"  "_SC_LEVEL4_CACHE_LINESIZE"  "_SC_LEVEL4_CACHE_SIZE"  "_SC_LINE_MAX"  "_SC_LOGIN_NAME_MAX"
       "_SC_LONG_BIT" "_SC_MAPPED_FILES"  "_SC_MB_LEN_MAX"  "_SC_MEMLOCK"  "_SC_MEMLOCK_RANGE"  "_SC_MEMORY_PROTECTION"  "_SC_MESSAGE_PASSING"  "_SC_MINSIGSTKSZ"  "_SC_MONOTONIC_CLOCK"  "_SC_MQ_OPEN_MAX"
       "_SC_MQ_PRIO_MAX"  "_SC_MULTI_PROCESS"  "_SC_NETWORKING"  "_SC_NGROUPS_MAX"  "_SC_NL_ARGMAX"  "_SC_NL_LANGMAX" "_SC_NL_MSGMAX" "_SC_NL_NMAX" "_SC_NL_SETMAX" "_SC_NL_TEXTMAX" "_SC_NPROCESSORS_CONF"
       "_SC_NPROCESSORS_ONLN" "_SC_NZERO" "_SC_OPEN_MAX" "_SC_PAGESIZE" "_SC_PAGE_SIZE" "_SC_PASS_MAX" "_SC_PHYS_PAGES"  "_SC_PII"  "_SC_PII_INTERNET"  "_SC_PII_INTERNET_DGRAM"  "_SC_PII_INTERNET_STREAM"
       "_SC_PII_OSI"   "_SC_PII_OSI_CLTS"  "_SC_PII_OSI_COTS"  "_SC_PII_OSI_M"  "_SC_PII_SOCKET"  "_SC_PII_XTI"  "_SC_PIPE"  "_SC_POLL"  "_SC_PRIORITIZED_IO"  "_SC_PRIORITY_SCHEDULING"  "_SC_RAW_SOCKETS"
       "_SC_READER_WRITER_LOCKS" "_SC_REALTIME_SIGNALS" "_SC_REGEXP" "_SC_REGEX_VERSION" "_SC_RE_DUP_MAX" "_SC_RTSIG_MAX" "_SC_SAVED_IDS"  "_SC_SCHAR_MAX"  "_SC_SCHAR_MIN"  "_SC_SELECT"  "_SC_SEMAPHORES"
       "_SC_SEM_NSEMS_MAX"  "_SC_SEM_VALUE_MAX"  "_SC_SHARED_MEMORY_OBJECTS"  "_SC_SHELL"  "_SC_SHRT_MAX"  "_SC_SHRT_MIN"  "_SC_SIGNALS" "_SC_SIGQUEUE_MAX" "_SC_SIGSTKSZ" "_SC_SINGLE_PROCESS" "_SC_SPAWN"
       "_SC_SPIN_LOCKS" "_SC_SPORADIC_SERVER" "_SC_SSIZE_MAX"  "_SC_SS_REPL_MAX"  "_SC_STREAMS"  "_SC_STREAM_MAX"  "_SC_SYMLOOP_MAX"  "_SC_SYNCHRONIZED_IO"  "_SC_SYSTEM_DATABASE"  "_SC_SYSTEM_DATABASE_R"
       "_SC_THREADS"    "_SC_THREAD_ATTR_STACKADDR"    "_SC_THREAD_ATTR_STACKSIZE"    "_SC_THREAD_CPUTIME"    "_SC_THREAD_DESTRUCTOR_ITERATIONS"   "_SC_THREAD_KEYS_MAX"   "_SC_THREAD_PRIORITY_SCHEDULING"
       "_SC_THREAD_PRIO_INHERIT"     "_SC_THREAD_PRIO_PROTECT"     "_SC_THREAD_PROCESS_SHARED"      "_SC_THREAD_ROBUST_PRIO_INHERIT"      "_SC_THREAD_ROBUST_PRIO_PROTECT"      "_SC_THREAD_SAFE_FUNCTIONS"
       "_SC_THREAD_SPORADIC_SERVER"   "_SC_THREAD_STACK_MIN"   "_SC_THREAD_THREADS_MAX"   "_SC_TIMEOUTS"   "_SC_TIMERS"  "_SC_TIMER_MAX"  "_SC_TRACE"  "_SC_TRACE_EVENT_FILTER"  "_SC_TRACE_EVENT_NAME_MAX"
       "_SC_TRACE_INHERIT"  "_SC_TRACE_LOG"  "_SC_TRACE_NAME_MAX"   "_SC_TRACE_SYS_MAX"   "_SC_TRACE_USER_EVENT_MAX"   "_SC_TTY_NAME_MAX"   "_SC_TYPED_MEMORY_OBJECTS"   "_SC_TZNAME_MAX"   "_SC_T_IOV_MAX"
       "_SC_UCHAR_MAX"   "_SC_UINT_MAX"   "_SC_UIO_MAXIOV"   "_SC_ULONG_MAX"   "_SC_USER_GROUPS"   "_SC_USER_GROUPS_R"   "_SC_USHRT_MAX"   "_SC_V6_ILP32_OFF32"  "_SC_V6_ILP32_OFFBIG"  "_SC_V6_LP64_OFF64"
       "_SC_V6_LPBIG_OFFBIG"  "_SC_V7_ILP32_OFF32"  "_SC_V7_ILP32_OFFBIG"   "_SC_V7_LP64_OFF64"   "_SC_V7_LPBIG_OFFBIG"   "_SC_VERSION"   "_SC_WORD_BIT"   "_SC_XBS5_ILP32_OFF32"   "_SC_XBS5_ILP32_OFFBIG"
       "_SC_XBS5_LP64_OFF64"  "_SC_XBS5_LPBIG_OFFBIG"  "_SC_XOPEN_CRYPT"  "_SC_XOPEN_ENH_I18N"  "_SC_XOPEN_LEGACY"  "_SC_XOPEN_REALTIME"  "_SC_XOPEN_REALTIME_THREADS"  "_SC_XOPEN_SHM" "_SC_XOPEN_STREAMS"
       "_SC_XOPEN_UNIX" "_SC_XOPEN_VERSION" "_SC_XOPEN_XCU_VERSION" "_SC_XOPEN_XPG2" "_SC_XOPEN_XPG3" "_SC_XOPEN_XPG4"

NOTES
       removeat() is a home-grown nonstandard extension present only in this module.

       preadv() and pwritev() are nonstandard extensions present in Linux and BSD.

       execveat(), openat2(), preadv2(), pwritev2() and renameat2() are nonstandard extensions present in Linux.

       fstatat(), lstat() and stat() do not set the special underscore filehandle "_" (mostly because I have no clue how that works).

       open(), openat() and openat2() do not set the "O_CLOEXEC" flag automatically. You have to take care of that yourself if needed.

       isalnum() and friends were cowardly removed from the POSIX module with Perl 5.24.0. They have found a cozy home here with a fix for a long-standing bug.

       "SEEK_DATA" and "SEEK_HOLE" were added to "unistd.h" in POSIX.1-2024 <https://pubs.opengroup.org/onlinepubs/9799919799/> (Issue 8). Before that, they were nonstandard extensions present in  Linux,
       Solaris, FreeBSD, and DragonFly BSD.

       For  some  inexplicable  reason, Perl forbids you to use the built-in chmod() and chown() on an opendir() handle and to use readdir() and rewinddir() on a sysopen() handle (provided it refers to a
       directory).  Needless to say that chmod() and chown() from POSIX::2008 happily work with opendir() handles, and of course you can use readdir() and rewinddir() on an openat() handle that refers to
       a directory.

AUTHOR
       Initially hacked together by Carsten Gaebler.

LICENSE
       This library is free software. You can redistribute and/or modify it under the terms of the Do What The Fuck You Want To Public License, Version 2, as published by Sam  Hocevar.  See  the  COPYING
       file or <http://www.wtfpl.net/> for more details.

perl v5.40.1                                                                                     2025-09-28                                                                                POSIX::2008(3pm)
