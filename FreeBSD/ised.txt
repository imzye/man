ised(1)                 FreeBSD General Commands Manual                ised(1)

NAME
       ised - generating integer and floating point sequences

SYNOPSIS
       ised [--m] [--p] [--n] [--f input_file] [--a load_file] [--l
       apply_to_file] [--x modify_file] [--k awk_file] [--o output_file] [--t
       code_line] [--d delimiter] [--D int_format] [--F float_format] code ...


DESCRIPTION
       ised processes arithmetic expressions involving arrays and returns
       output array of values. Options and code lines are processed in order
       of appearance. If ised is called without arguments, it reads from
       standard input. Press ^D (EOF) or enter a single q to exit when in
       interactive mode.

       When input consists only of arrays of length one (scalars), ised
       behaves as an ordinary calculator.

       Options can also be used from command line in interactive mode or in
       files, invoked by --f.


OPTIONS
       --f  input_file
              Reads and processes input_file one line at a time, equivalent to
              giving every line as separate command line argument.

              ised --f - is not equivalent to running it without arguments, as
              the latter also invokes interactive GNU readline prompt.


       --a  load_file
              Loads load_file into memory. Every line has it's own memory
              slot, starting at $1.  At the end, line count is saved in memory
              slot $0. All lines are evaluated before saving.


       --l apply_to_file { code | --f file }
              code or file is applied on every line of apply_to_file.  Each
              line is loaded into memory slot $1 while line number is in $0.


       --x modify_file { code | --f file }
              Similar to --l, but instead of direct evaluation of lines in
              modify_file, it splits the line into numbers and strings. The
              numbers are read and stored into $1, then the code or file is
              applied. The output has the same form as the input, with the
              numbers replaced with those returned by the code or  file. The
              $0 memory slot contains the current line number.


       --k awk_file { code | --f file }
              Similar to --x, but instead of smartly finding the numbers and
              storing them all into the same array, it splits each input line
              at delimiters and stores each column into a separate memory
              slot, starting with $1. Non-numeric fields are preserved in the
              output without warning. Changes to the memory slots by the user
              are reflected in the output. The output is delimited by the
              delimiter, provided by --d. If code is not terminated by a
              semicolon, the return value of code or file is appended to the
              rest of the output.



       --o output_file
              Sets the file where standard output is redirected to. Everything
              after this call will be redirected to output_file, until the
              next call to --o.  Calling --o - reverts back to the standard
              output.


       --t code_line
              code_line is evaluated as usual, but results of every semicolon-
              terminated substatement are printed as columns. Essentially this
              is a transposed version of --p option. If code_line contains
              only one statement, the result is similar to setting delimiter
              to newline (\n). If code_line is to be appled line-by-line to a
              file, both --x and --k behave as --l.


       --d  delimiter
              string delimiter is used to delimit values of output array.
              Default is space.


       --D  int_format
              format for printf function for integers. Default: %d.


       --F  float_format
              format for printf function for floating point values. Default:
              %g.



       --m    dump memory page.


       --p,--n
              --p forces ised to print results even when suppressed by
              semicolon. Every semicolon-terminated substatement is output
              with terminating newline, so this can be used to split lines
              when in --l mode. This option persists until it is turned off
              with --n.



       --v    show program version and license disclaimer.


COMMANDS
       ised operators all work on arrays of values. Even single values are
       treated as arrays with length of one. Spacing between operators and
       values is optional.  Values can be either floating point or integers
       and retain information about their type unless changed. Same operators
       behave differently for each type.

       In general, operators starting with colon (:) mean component-wise
       evaluation.

       Behaviour in case of illegal arithmetic output (such as division by
       zero or root of negative values) is uncertain and may return either
       nan, zero or some other non-standard result. This should not be relied
       upon as it may change in future releases.  The case of integer
       overflows is to be avoided by user as the program does not issue a
       warning and the output is wrong and unpredictable. The same holds for
       conversion of floats to integers. Since version 2.2.3, integer
       overflows are handled by implicit conversion into floating point type
       if compiled for x86-64 architecture, but caution is still advised, as
       the handling may not catch all the problematic cases.


   Comments
       Lines are considered as comments if preceded by #!. If #! appears in
       the middle of the line, everything behind it is commented out.
       Completely blank lines are also ignored, but lines with whitespace
       characters will be treated normally. This way user can seperate several
       blocks of output by empty lines.

       Scripts can be made executable and evaluated without invoking ised
       explicitly.  This is done by including declaration

       #!/usr/local/bin/ised --f

       in the first line of the script. This line is obviously treated as
       comment.

       In apply-to-file mode, comments and blank lines are preserved in input,
       but don't count as active lines and therefore don't increment line
       counter. If a file contains mixed data, it can still be processed line-
       by-line if non-numerical data is commented out.



   Arrays and Separators
       Values, separated by commas (,) of spaces ( ) are treated as components
       of an array. Array separation has lowest precedence, so any operators
       are evaluated before the array is collected. Nested arrays are
       flattened before further evaluation. Arrays are enclosed in braces {},
       outermost braces are optional.

       Output to terminal and history is suppressed by semicolon ; which can
       occur any number of times in every line (putting it at the end
       suppreses all output, but still evaluates memory operations, if they're
       present).


       Examples:

       {1 2 {3 4} 5,6} = {1 2 3 4 5 6}

       {1 2+3 4 5*6+7} = {1 5 4 37}

       1 5 1+1 = {1 5 2}


   Array Constructors
       [n]    generates sequence 0..n-1


       [n1 n2]
              generates sequence n1..n2 with increment 1. If n2<n1, sequence
              is descending.


       [n1 m1..mi n2]
              generates sequence between n1, n2, but with cycling increments,
              given as m1..mi.

              Example:  [0 1 2 10]={0 1 3 4 6 7 9}


       (x)    repeats number x. This way parentheses can be used for
              evaluation precedence or for function arguments in scalar
              context.


       (x n)  generates array of n repetitions of number x.


       (x m1..mi n)
              generates sequence of length n, starting at x with cycling
              increments m1..mi.

              If n is negative, the increments are used |n| times, so for i
              increments, the output sequence has |n|*i+1 elements.

              Examples:

              (0 1 2 10)={0 1 3 4 6 7 9 10 12 13}

              (0 [1 5] -1)={0 1 3 6 10 15}


       {x1..xi}
              array grouping


   Component-wise Operators
       x:+y   x:-y   x:*y   x:/y   x:%y   x:^y
              result is an array, where each component is e.g. a sum (or other
              binary operations above) of corresponding components of x and y.
              In case of different lengths of arrays, smaller length is used.
              Operations coresponding to above operators are: addition,
              substraction, multiplication, division, modulo, exponentiation.
              Note that modulo works for both integer and non-integer values.
              Modulo always satisfies this equation:  i{x/dy}*y+x%y=x


   Scalar-producing Operators
       @+x    returns sum of components of x.


       @*x    returns product of components of x.


       x+*y   returns a result of alternating addition and subtraction, in the
              form ((x_0+y_0)*x_1+y_1)*x_2+y_2+...

              If x is shorter than y, the elements of x are cyclically reused
              from the beginning of the array. If y is shorter than x, it is
              padded with zeroes. This way, a scalar x can be used to evaluate
              a polynomial with unit leading coefficient.


       gcd lcm
              return greatest common divisor and least common multiple of the
              numbers in the array, respectively.  If the array includes
              noninteger numbers, a warning is issued and an empty array is
              returned. The result of gcd is negative if an odd number of the
              array are negative.


       avg var

              return linear average and variance (mean square dispersion).
              avg{x} is shorter notation for @+x/d#x and doesn't require
              inputting the array twice or storing it in memory.

              Example: avg{0 1.5 3}={1.5}


       nrm x y
              returns generalized x-norm of vector y. If x is a vector, the
              result contains all specified norms. x=2 corresponds to
              Pythagoras' theorem, which is available also as operator @=.

              Examples:

              nrm2{1 1 1}={sqrt3}

              nrm{1 3}{1 1}={2. cbrt2}



   Function Maps
       sin cos tan atn asn acs abs exp sqt cbt log
              evaluates a function on every element of array, e.g. sin{1 2
              3}={sin1 sin2 sin3}. Functions corresponding to above operators
              are sine, cosine, tangent, arc tangent, arc sine, arc cosine,
              magnitude, exponential, square root, cubic root, natural
              logarithm.  Long operators atan asin acos sqrt cbrt are also
              valid. Exponential function is also available as e^, but has a
              lower precedence (the same as the operator ^). The unary /
              prefix is also a function map: /x=1.0/x.


       x!     evaluates factorial on every element of array x. For floating
              point values it evaluates gamma(x+1). For negative integers, it
              returns 1.


       r f i d
              prefixes that modify values of array elements.


              r      rounds values to closest integer.

              f      returns fractional part of values. It is always in range
                     0..1 and represents distance to downwards rounded
                     integer, even for negative values.

              i      returns integer part of values. Expression fx+ix=x always
                     holds.

              d      converts values to floating point. For example, 1/2=0 but
                     1/d2=0.5.


       ran    randomizes elements of array. For integers, it returns random
              integers strictly smaller than given value. For floating values
              it returns real numbers.


       phi    calculates the Euler totient function for positive integers. The
              nonpositive and noninteger values are skipped.


       bj x y   by x y

              applies x-th Bessel function of first/second kind to array y.  x
              should be one or more integers. Floating point values are cast
              to integers and a warning is issued.


   Tensor Operators
       x+y   x-y   x*y   x/y   x%y   x^y
              evaluate corresponding operations on every possible pair between
              elements of x and y. Most useful when one of the arguments is a
              scalar.  Beware, the division operator / acts as an unary
              operator (inversion) when it has no left operand, or has a space
              on the left, but not on the right. For instance, /3 is
              equivalent to 1.0/3.

              Examples:

              {1 2 3 4}*{1 -1}={1 -1 2 -2 3 -3 4 -4}

              {2 3 -5}*2={4 6 -10}


       xey    operator for exponential notation. Useful mostly in scalar
              context, e.g.  1.3e-5, but can be used in general for evaluating
              exponential notation for all combinations.


       xcy    evaluates binomial symbol (x over y). It supports floating point
              values.

              Example: 3c{0 1 2 3}={1 3 3 1}


   Polynomial Operators
       The following set of operators treat arrays as polynomial coefficients.
       First element corresponds to zero-order term, and so on, e.g.  {1 2 3}
       <=> 3x^2 + 2x + 1.


       x++y   x--y
              polynomial addition and substraction. This is similar to
              operators :+ :-, but the length of output array is equal to
              length of the larger array.


       x**y   computes product of two polynomials. It terms of arrays, this
              evaluates to the convolution of x and y.


       x//y   x%%y
              computes quotient and remainder in long polynomial division.
              Returned arrays always contain floating point values, regardless
              the input. Leading zeroes are trimmed from the output.


       px x y evaluates polynomial x in points, given in array y.


       pd x   computes derivative of polynomial x. Equivalent to {x<<-1}:*[1
              #x].


       pz x   returns all real roots of polynomial x. Resulting array is not
              guaranteed to be sorted in any way.

              This operator uses Sturm's sequence to isolate the roots, and
              proceeds with Newton-Raphson iteration. It works quite well for
              well-behaved polynomials. Accuracy is questionable if there are
              roots with multiplicity 3 or higher.

              The algorithms outputs warning messages if the accuracy is
              questionable, or if the iteration fails to converge to a result.


       zp x   is the inverse of the pz operator. It takes the set of roots and
              returns the minimal polynomial with given roots, with the
              leading coefficient normalized to 1.

              pzzp should return the same array as on the input, up to a
              reordering of elements (excepting the numerical errors in root
              finding, especially if there are multiple roots). Conversely,
              zppz does not necessarily return the initial array, as it
              ignores the normalization factor and irreducible factors that
              don't have any real roots.


       F x    returns the prime factorization of x. If x has many components,
              the factors are concatenated in a way that makes the product of
              the output array equal to the product of the input array. That
              makes the negative integer to produce an additional -1 factor,
              while floating point input numbers stay intact.


   Vector Operators
       x@:y   returns dot product of vectors x and y. In case of different
              array lengths, overhead is discarded.


       x@^y   returns cross product of vectors x and y, if the vectors are
              three-dimensional. In general case, it returns components
              z_i=x_{i+1}*y_{i+2}-x_{i+2}*y_{i+1}.

              This generalization is useful for polygon geometry. For polygon
              with coordinates {x_i,y_i}, the area of the polygon is
              0.5*@+{x@^y}. Similar formulas exist for polygon center and
              other expressions.


       @!x    normalizes vector x.


       @=x    returns length of vector x. Shoter notation of general norm:
              {@=x}={nrm2x}.


   Set Operators
       x&y    returns elements that are in both x and y.


       x|y    concatenates arrays x and y. Produces the same result as {x y}.

              [deprecated] This operator is an unnecessary waste of notation.
              It should have had the interleaving effect, now represented by
              Y.


       x\y    returns elements of x that are not present in y.


       x|&y   is the xor operation on arrays. Returns elements, present in
              only one of the arrays.


       xYy    interleaves the arrays x and y.


       ~x     reverses order of array x.


       Sx     sorts array in ascending order.


       #x     returns number of elements in array.


       #_xy   counts occurences of elements of x in y. This is selective
              variant of # operator.

              Example: #_{0 1 4}{1 2 3 4 4 1}={0 2 2}


       #__xy  distributes elements of y into a histogram where elements of x
              divide the real numbers into bins. The size of the output is one
              element more than the size of x. The first bin extends from
              negative infinity to the first element of x and the last extends
              to the positive infinity. x is expected to be in ascending
              order.



       ?x     returns indices of nonzero elements of x. Only integer zero
              counts as zero.

              This operator is intended for use with index operator (_), to
              select elements that satisfy some logical test. For example,
              x_?{x<1000} returns only elements, smaller than 1000.

              To skip an entire array if it doesn't satisfy a condition, use ?
              operator in combination with +. For example, x+?{#x==3} prints x
              only if its length equals 3. This functionality relies on the
              fact that tensor summation with empty array returns empty array.


       ?_x y  returns the indices of elements of x in the array y. If the
              element is found more than once, only the first index is
              returned. If the element is not present in y, a value -1 is
              returned.


       S_x    returns the indices that would sort the array x. It's always
              true that Sx=x_S_x.


       x=y    returns 1 if arrays are equal, 0 otherwise.


   Element Selection Operators
       x<<y   for positive values of y, returns first y values of x (as unix
              utility head). For negative values, it returns everything except
              first y values. If y is an array, it concatenates all results.
              y should be array of integers.  Useful for array cycling: {1 2 3
              4}<<{-2 2}={3 4 1 2}.


       x>>y   same as above, except it works from the back of the array.


       x_y    returns elements of x at indices y. It interpolates for
              noninteger indices and wraps around for indices out of range.


       U P N O E I D X
              conditional selectors. Return elements that satisfy a certain
              condition.


              U      unique, deletes duplicate elements

              P      positive

              N      negative

              O      odd

              E      even

              I      integers

              D      floating point values

              X      prime numbers



       min max
              return the smallest and the largest component of the array
              respectively.


       Zx     `zilch` returns an empty array. This operator is useful for
              suppressing output from functions with side-effects, such as the
              @ operator.



   Constants
       pi     returns  3.14159265358979323846264


       deg    returns the value of angular degree in radians,
              0.017453292519943295769


       emc    returns Euler-Mascheroni constant,  0.57721566490153286


       pm mp  plus/minus and minus/plus constants. They output arrays {1,-1}
              and {-1,1} respectively. They can be used to compute results of
              multivalued formulas simultaneously, for example quadratic
              equation.


   Memory Operators
       Memory slots are enumerated by integers. For floating point values,
       integer part is used. This may change in future versions.


       Named variables can be used instead of integer enumeration with the use
       of backticks.


       @xy    puts array y into memory slots, enumerated by elements of x.  x
              should be integers. Floating point numbers are cast to integers
              and warning is issued.


       $x     concatenates arrays found at memory slots, enumerated by x. For
              negative values, it returns array from history instead of
              memory, $-1 being most recent entry. x should be integers.


       @`<name>`y
              puts array y into the memory slot, represented by the given
              <name>.


       $`<name>`
              retrieves the variable, named by the given <name>.



       ised manages memory as hashed map, so a memory position can be every
       positive integer. Saving array to slot $100 doesn't allocate any more
       memory than saving to slot $1. Results are added to history for input
       lines from files (--f option) or interactive mode, unless the line
       terminates with a semicolon. Negative slots are reserved for internal
       use by the named variable system and are not accessible by direct
       dereference. Instead, history is accessed by the negative arguments of
       the $ operator.


   Comparison and Equality operators
       For logical evaluation, ised provides comparison operators. Result of
       comparison is 1 for true and 0 for false. Equality and inequality
       operators also check if types of both values are equal.

       For boolean analysis of resulting arrays, use multiplication for and
       operator and summation for or operator. Incorporating additional
       operators for this functionality would be redundant, as the result is
       equivalent. But beware, multiplication and summation have higher
       precedence than comparison operators, so use grouping operator {} to
       achieve desirable effect.



       x:<y   x:>y   x:<=y   x:>=y   x:==y   x:<>y
              Comparison and equality, evaluated component-wise. Result is an
              array with size of the shorter of the input arrays.


       x<y   x>y   x<=y   x>=y   x==y   x<>y
              Same as above, but evaluated on every possible pair of values.
              Size of the output array is product of input sizes (see Tensor
              operators for details and example).


   Function definitions
       ised implements a rudimentary mechanism for function definitions. It
       enables storing an expression and evaluate it later upon command. The
       functions are stored in a map structure and are accessed via integer
       function ids. A function id is returned when the function is declared.
       No particular order of the function ids should be assumed. The zero (0)
       function id is reserved to for an identity function (no-op).

       The functions may include memory manipulation, which makes them as
       versatile as functions in any programming language. They can be
       designed as procedures ignoring input and output and operate on memory,
       plain-old-functions that take an argument and return a result, or any
       combination of both.


       {:expression:}
              Function declaration. The expression is parsed, stored into the
              function memory and its unique id is returned. The id is
              guarranteed to be nonzero. The returned id may be stored in
              memory and used later.  Within the function, operator x is used
              to refer to the function's argument. The function is not
              evaluated at this point.


       f::x   Function evaluation. f is an array of function ids, which are
              applied sequentially to the array x, left-to-right. It should be
              understood as composition of function; the result from the
              previous function is passed to the next as its argument.


       f:::x  Function iteration. Array of function ids f is evaluated
              repeatedly on the argument x. The iteration stops when the
              argument no longer changes or maximum number of iterations is
              reached. The maximum number of iterations is 65536 by default,
              but can be queried and changed using system call Q{105 ...} (see
              the section on system calls). This operator can be emulated by
              the ordinary function evaluation and system call for setting the
              instruction pointer, Q{103 ...}, but the implementation is quite
              complex. As functional iteration until convergence is common in
              math, this operator is a valuable shortcut.


       f@::x  Function map. Array of function ids f is evaluated on each
              element of the array x. This is meant to allow creation of user
              functions that don't have to handle the array nature of the
              argument themselves.


       x      This operator evaluates to the argument supplied to the
              function. In case of nested functions, it refers to the
              innermost function's argument. Outside a function, it has the
              value of the current line (when used with --l or --x), or
              invalid otherwise.


       The function evaluation operator (::) is enough to implement all basic
       control structures. ised is therefore a Turing complete language.


       function call:
              {fun}::{arg}

       conditional execution (if-statement):
              {{false-fun true-fun}_{condition}}::{arg}

       switch statement:
              {{fun1 fun2 fun3 fun4 ...}_switch}::{arg}

       static repetition (for-statement):
              (fun n)::{arg}

       recursion:
              {@mem {:do-something-with $mem::x :}}::{arg} The implementation
              of the function must be carefully devised, otherwise the
              execution might get stuck in an infinite recursion.

       general loop (while-statement):
              { body-fun jump-test }::{arg}

              Such simple implementation has the loop contents in body-fun and
              implements jump-fun such that its argument unchanged, but sets
              the program counter to zero if a condition is met. The program
              counter is set via system call operator Q{103 n} where n is
              simply which function in left-hand side of the operator :: is
              evaluated next.  For example, { {:x+1:} {:x Q{103 -{x>10}}:}
              }::{arg} increments the argument by one until it becomes greater
              than 10. In that case, the system call sets the program counter
              to -1, which is out of range and the evaluation stops.

              More complex flow control is possible, as the operator Q{103 n}
              can be used exactly like a goto statement. Q{102} can be used to
              find the current program counter and calculate relative jumps.


   System calls
       The internal state of ised can be accessed and modified using the
       system call operator Qx. The argument x is an array, where the first
       component is system call id number and the rest are optional arguments
       to the system call. The list of system calls will be expanded in future
       versions of ised.

       Example: use ised --l load_file '$1 Q{$1>3}' to output the specified
       file, but terminate as soon as it encounters a number greater than 3.


       The system call ids are available as named variables, specified between
       the backticks as `<name>`. For instance, a call Q{`EXIT` 42} terminates
       the program with a return value of 42.


       The list of system call numbers and names:

       0 [NOP]: no-op

       1 [EXIT]: exit
              Exits with return value 0 or the value specified as an optional
              argument.

       100 [BREAK]: break
              Interrupts the loading of files by commands --f, --l, --a or --x
              and aborts evaluation of the current line.

       101 [CONT]: continue
              Aborts evaluation of the current line and proceeds to the next
              line in the file.

       102 [PC]: get program counter
              Returns the index of currently evaluated function in innermost
              evaluation operator ::.

       103 [PCSET]: set program counter
              Sets the index of next evaluated function in innermost operator
              ::. If argument is out of bounds, it terminates the evaluation.
              If without arguments, it does nothing.

       104 [STACKDEPTH]: get stack depth
              Return the number of nested functions around the call. If not in
              a function, it returns 0.

       105 [MAXITER]: get/set iteration limit
              Without argument, the iteration limit for operator ::: is
              returned. With argument, it is changed to the given
              (nonnegative) value.

       1000 [HISTORY_COUNT]: get history count
              Returns the number of history entries, or -1 if history is
              disabled.

       1001 [HISTORY_ENABLE]: disable history
              Disables remembering previous results or enables it, if called
              with a nonzero argument.

       1002 [HISTORY_CLEAR]: clear history
              Clears the history.

       2000 [MEM_INDEX]: get/set indexing memory slot
              Without arguments, it sets the memory slot where current line
              number is stored (default is 0). With argument, it sets it.

       2001 [MEM_INPUT]: get/set input memory slot
              Same as 2000, but for the memory slot where the current input
              line is stored (default 1).

       2002 [MEM_OFFSET]: get/set file loading offset
              Same as 2000, but for the memory slot where --a continues
              loading lines to. At startup, this is 0 so the first memory slot
              filled is $1 and is advanced with each loaded line.

       2003 [MEM_CLEAR]: delete from memory
              Clear entire contents of memory if called without arguments. The
              optional argument is a list of memory slots to delete.

       2004 [MEM_LIST]: get memory list
              Lists the occupied memory slots.

       2050 [FUN_CLEAR]: delete function
              Clears all the functions if called without arguments.  The
              optional argument is a list of function ids to delete.

       2051 [FUN_LIST]: get function list
              Lists the occupied function ids.

       3000 [VERSION]: ised version
              Returns the array, containing the version number
              {major,minor,revision}.

       3001 [SIZEOF_INT]: int size
              Returns the size of integer type in bytes.

       3002 [SIZEOF_FLOAT]: float size
              Returns the size of float type in bytes.

       3003 [DEBUG]: debug level
              Returns the debugging level, set at compile-time.

       3004 [READLINE_STATUS]: readline status
              Returns the array indicating if various libreadline
              functionalities are enabled (use --v for details).

       3005 [OVERFLOW_STATUS]: overflow enabled
              Returns 1 if overflow handling was enabled at compile-time and 0
              otherwise.

       5000 [TIME]: system time
              Returns unix time in seconds if called without arguments. The
              arguments can be list of values, which specify the time fields
              to output:

              0 [TIME.EPOCH] = epoch

              1 [TIME.SEC] = sec

              2 [TIME.MIN] = min

              3 [TIME.HOUR] = hour

              4 [TIME.MONTHDAY] = month-day

              5 [TIME.MONTH] = month

              6 [TIME.YEAR] = year

              7 [TIME.WEEKDAY] = week-day

              8 [TIME.YEARDAY] = year-day


       For instance, a call Q{`TIME` `TIME.YEAR` `TIME.MONTH` `TIME.DAY`} may
       return the array {2013 10 31}.


       5001 [PROCESS_TIME]: process time
              Returns array containing real time, user time and system time in
              seconds.

       5002 [SLEEP]: sleep
              Sleep for the amount of seconds specified in the argument.

       5050 [PID]: pid
              Return the PID of this process.


EXAMPLES
       ised '@0[2 100];$0\{$0*$0}'
              returns all prime numbers up to 100. It utilises memory to
              prevent code repetition.


       ised '(0 (1 2 10) 10)'
              generates squares of numbers up to 10, by using nested
              constructors. Inner constructor generates increments for outer
              constructor.


       ised --l file '$0 ~$1'
              reverses lines of file and prepends line numbers.


       ised '@0 {0.5*{1+sqt5}};r{{$0^[1 20]:-(-$0)^-[1 20]}/sqt5}'
              generates Fibonacci sequence using direct exponential formula.


       ised --d '\n' '[0 1/d5 10]'
              generates evenly spaced values between 0 and 10, separated by a
              newline. Same functionality as

              seq 0 0.2 10


       ised --d '\n' '[0 pi/100 pi]' | ised --F '%+12.6f' --l - 'd{$1 sin$1
       cos$1 tan$1 exp$1 $1^2}'
              generates nicely formatted table of several functions in range
              between 0 and pi. Note the use of placeholder - for standard
              input.


       ised --o tmp_file --t '[0 pi/100 pi]' --o - --F '%+12.6f' --l tmp_file
       'd{$1 sin$1 cos$1 tan$1 exp$1 $1^2}'
              previous example, achieved in one pass using a temporary
              intermediate file. Note the use of placeholder - for standard
              output.


       ised '{1.4^[11]}@:{1./[11]!} exp1.4'
              calculation of exp(1.4) by summation of series, compared to
              exact value.


       ised '@1 60;@2 72;@3[1 $1];{$1%$3==0}:*{$2%$3==0}:*$3\0'
              returns list of common divisors of 60 and 72. Numbers 60 and 72
              are first stored in memory, together with list of possible
              divisors, for easier readability. Note the use of multiplication
              for boolean and evaluation.  The same can be achieved more
              elegantly with operator ?:

              ised '@1 60;@2 72;@3[1 $1];$3_?{{$1%$3==0}:*{$2%$3==0}}'


       ised '@1 60;@2 72;{$1*[1 $2]&$2*[1 $1]}_0'
              returns least common multiple of 60 and 72.


       ised --d '+' '2^[10]' | ised
              illustration how changing output format can produce useful input
              for other programs, in this case, ised itself. This is useful
              for easier input of operator repetition, for example the power
              tower:

              ised --d '^' '(1/sqt2 10)' | ised --l - '-$1' this outputs
              solution of equation 2^x=x^2.


       ised '@1{2}@2{3}@3{-5};{-$2+pm*sqt{$2^2-4*$1*$3}}/{2*$1}'
              solves quadratic equation 2x^2+3x-5. Capability of handling
              arrays is exploited to give both solutions at once. pm operator
              is shorthand for array {1,-1}.

              The same can be achieved with built-in polynomial solver:

              ised '@1{2}@2{3}@3{-5};pz{$3 $2 $1}'

              Note that the intermediate variables $1,$2,$3 were only used to
              make the expression more readable.


       yes 0 | ised '@2{145}' --l - '@2{{$2/2 3*$2+1}_{$2%2}} Q{100 $2==1}'
              outputs the Hailstone sequence for the number 145. It uses GNU
              core utility yes to produce an infinite loop and terminates
              using a conditional system call 100 (break).


       ised --D '%02d' --d ':' 'Q{5002 60-Q{5000 1}};Q{5000 3 2 1}'
              Waits for the minute to change and then displays the current
              time, so that the seconds will be zero. It uses the time-related
              system call utilities 5000 (system time) and 5002 (sleep).


AUTHOR
       Simon Copar

SEE ALSO
       seq(1)

                                  May 1, 2014                          ised(1)
