Tie::FileLRUCache(3)  User Contributed Perl Documentation Tie::FileLRUCache(3)


NAME
       Tie::FileLRUCache - A lightweight but robust filesystem based
       persistent LRU cache

CHANGES
       1.06 2020.10.08  - Changed license to MIT License. Updated maintainer
       info.
                          Updated build files. Added GitHub repo meta to
       build.
                          Changed minimum supported version of Perl to 5.6.

       1.05 2005.09.13  - Changes to pod tests to make them more CPANTS
       friendly.
                          No functional changes.

       1.04 2005.09.13  - Removed use of lexical warnings pragma to fix
       compatibility
                          with Perl 5.005.

                          Fixed minor typographical errors in documentation.

       1.03 2005.09.10 - Changed build test to handle difference in treatment
       of hashes
                         in scalar context between 5.6.x and 5.8.x versions of
       Perl that
                         caused a test failure under Perl 5.6.x.

       1.02 2005.09.08 - Added build tests. Major code cleanup. Improved
       platform portability.
                         Added and documented 'cache_dir', 'keep_last' and
       'number_of_entries'
                         methods. Added Module::Build support.

       1.01 1999.12.09 - Added detainting in internal cache maintaining
                         functions to evade Taint's tainting
                         of filenames read via readdir().

SYNOPSIS
   OBJECT INTERFACE
        use Tie::FileLRUCache;
        my $cache = Tie::FileLRUCache->new({ -cache_dir => $directory, -keep_last => 100 });

        # Inserting value into LRU cache using '-key'
        $cache->update({ -key => $key, -value => $value });


        # Inserting value into LRU cache using '-cache_key'
        my $cache_key = $cache->make_cache_key({ -key => $key });
        $cache->update({ -cache_key => $cache_key, -value => $value });


        # Checking LRU cache
        my ($in_cache,$value) = $cache->check({ -key => $key });
        if ($in_cache) {
            return $value;
        }
        # Not in cache - do something else


        # Checking LRU cache with speed up hack for objects, hashes, arrays etc used as keys
        my $cache_key = $cache->make_cache_key({ -key => $something });
        my ($in_cache,$value) = $cache->check({ -cache_key => $cache_key });
        if ($in_cache) {
            return $value;
        }
        # Not in cache - do something else


        # Deleting a key and its value from the cache
        $cache->delete({ -key => $key });


        # Clearing LRU cache
        $cache->clear;

   TIED INTERFACE
        use Tie::FileLRUCache;

        [$X =] tie %hash,  'Tie::FileLRUCache', $cache_dir, $keep_last_n;

        # Adding a key/value to the cache
        $hash{$key} = $value;

        # Checking the cache
        if (not exists $hash{$key}) {;
            # No match
              .
              .
              .

        } else {
            my $value = $hash{$key};
              .
              .
              .

        }

        # Removing a value from the cache;
        delete $hash{$key};

        # Clearing the cache
        %hash = ();

       Note: Iteration over the cache (each, keys, values) is _NOT_ supported.

DESCRIPTION
       Provides a lightweight persistent filesystem based LRU cache.

       It uses the 'last accessed' timestamp generated by the file system to
       determine the 'oldest' cache entry and discards the oldest cache
       entries when needed to stay under the -keep_last limit.

       If you store thing very fast (such that many entries receive the same
       time stamp), it is essentially a coin toss which entry within a single
       timestamped second gets purged from the cache to make room for new
       ones.

       It is not designed to handle huge numbers of cached items. It is
       probably unwise to set the 'keep_last' higher than around 100.

OBJECT METHODS
       new({[ -cache_dir => $cache_directory] [, -keep_last => $keep_last_n ]
       }); Creates and optionally initializes a Tie::FileLRUCache object:

           Example:

             my $cache = Tie::FileLRUCache->new({
                                  -cache_dir => '/tmp/testing',
                                  -keep_last => 100,
                                });

           The default cache size is 100 entries unless specified.

       check({ -key => $key });
           Reads the cache for the key.

           Returns two values: $cache_hit (true if a hit was found, false if
           not)
                               $value     (the cached value, undef if no hit)

           Examples:

              my ($cache_hit,$value) = $cache->check({ -key => $key });

              my ($cache_hit,$value) = $cache->check({ -cache_key => $cache_key });

           The '-key' form is used when you just want to use a raw key. It can
           use blessed objects, hash refs, scalars, or array refs as keys. The
           more complex structures take a speed penalty for computing a
           canonical form.  You can minimize this penalty by using the
           '-cache_key' form instead.

           The '-cache_key' form is used for performance reasons when using
           keys such as complex blessed objects or hashes as a key. The
           -cache_key is obtained with a call to 'make_cache_key'. It is legal
           to mix -cache_key and -key based calls - they are cross-compatible.

       make_cache_key({ -key => $key });
           Generates a cache key by canonicalizing a passed key as a network
           ordered canonical Storable string.

           Example:

            my $cache_key = $cache->make_cache_key({ -key => $key });

       clear;
           Completely clears the cache of all cache entries.

       update({ [-key => $key,] [-cache_key => $cache_key, ], -value => $value
       [, -keep_last => $keep_last_n ] });
           Updates the Least Recently Used (LRU) cache for the specified key
           with the passed value.  '-keep_last' is optional after the first
           access to a dataset. It will use the most recent 'keep_last' used
           if not specified.

           It is legal to use ordinary scalars, hash references, or array
           references as keys as well as objects as -keys or -values.
           Basically, anything that Storable can reproducibly serialize can be
           used.

           Examples:

            $cache->update({ -key => $key, -value => $value });

            $cache->update({ -key => $key, -value => $value, -keep_last => 100});

            my $cache_key = $cache->make_cache_key({ -key => $key });
            $cache->update({ -cache_key => $cache_key, -value => $value });

            my $cache_key = $cache->make_cache_key({ -key => $key });
            $cache->update({ -cache_key => $cache_key, -value => $value, -keep_last => 50 });

            -cache_key is assumed to be a simple scalar value for use as a key.

            -key can be pretty much anything Storable can successfully and reproducibly serialize.

           One or the other must be passed.

       delete({ -key => $key });
           Forces the deletion of a specific key from the cache.

           Example:

            $cache->delete({ -key => $key });

       cache_dir([$cache_directory_path]);
           Get/Set accessor for the cache directory path.

           Ex.

             my $cache_directory = $cache->cache_dir;

             $cache->cache_dir($cache_directory);

       keep_last([$keep_last_n]);
           Get/Set accessor for the keep last N setting.

           Ex.

             my $n_last = $cache->keep_last;

             $cache->keep_last(20);

       number_of_entries;
           Returns the current number of entries in the cache.

COPYRIGHT
       Copyright 1999, 2020 Jerilyn Franz and FreeRun Technologies, Inc. All
       Rights Reserved.

VERSION
        1.06 released 2020.10.08

LICENSE
       MIT License

       Copyright (c) 2020 Jerilyn Franz

       Permission is hereby granted, free of charge, to any person obtaining a
       copy of this software and associated documentation files (the
       "Software"), to deal in the Software without restriction, including
       without limitation the rights to use, copy, modify, merge, publish,
       distribute, sublicense, and/or sell copies of the Software, and to
       permit persons to whom the Software is furnished to do so, subject to
       the following conditions:

       The above copyright notice and this permission notice shall be included
       in all copies or substantial portions of the Software.

       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
       OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
       IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
       CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
       TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
       SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

DISCLAIMER
       THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
       WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
       MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

       Use of this software in any way or in any form, source or binary, is
       not allowed in any country which prohibits disclaimers of any implied
       warranties of merchantability or fitness for a particular purpose or
       any disclaimers of a similar nature.

       IN NO EVENT SHALL I BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
       SPECIAL, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE
       OF THIS SOFTWARE AND ITS DOCUMENTATION (INCLUDING, BUT NOT LIMITED TO,
       LOST PROFITS) EVEN IF I HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGE

AUTHOR
       Jerilyn Franz

TODO
       Nothing.

perl v5.40.2                      2020-10-08              Tie::FileLRUCache(3)
