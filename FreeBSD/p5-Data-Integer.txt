Data::Integer(3)      User Contributed Perl Documentation     Data::Integer(3)


NAME
       Data::Integer - details of the native integer data type

SYNOPSIS
           use Data::Integer qw(natint_bits);

           $n = natint_bits;

           # and other constants; see text

           use Data::Integer qw(nint sint uint nint_is_sint nint_is_uint);

           $ni = nint($ni);
           $si = sint($si);
           $ui = uint($ui);
           if(nint_is_sint($ni)) { ...
           if(nint_is_uint($ni)) { ...

           use Data::Integer qw(
               nint_sgn sint_sgn uint_sgn
               nint_abs sint_abs uint_abs
               nint_cmp sint_cmp uint_cmp
               nint_min sint_min uint_min
               nint_max sint_max uint_max
               nint_neg sint_neg uint_neg
               nint_add sint_add uint_add
               nint_sub sint_sub uint_sub);

           $sn = nint_sgn($ni);
           $sn = sint_sgn($si);
           $sn = uint_sgn($ui);
           $ni = nint_abs($ni);
           $si = sint_abs($si);
           $ui = uint_abs($ui);
           @sorted_nints = sort { nint_cmp($a, $b) } @nints;
           @sorted_sints = sort { sint_cmp($a, $b) } @sints;
           @sorted_uints = sort { uint_cmp($a, $b) } @uints;
           $ni = nint_min($na, $nb);
           $si = sint_min($sa, $sb);
           $ui = uint_min($ua, $ub);
           $ni = nint_max($na, $nb);
           $si = sint_max($sa, $sb);
           $ui = uint_max($ua, $ub);
           $ni = nint_neg($ni);
           $si = sint_neg($si);
           $ui = uint_neg($ui);
           $ni = nint_add($na, $nb);
           $si = sint_add($sa, $sb);
           $ui = uint_add($ua, $ub);
           $ni = nint_sub($na, $nb);
           $si = sint_sub($sa, $sb);
           $ui = uint_sub($ua, $ub);

           use Data::Integer qw(
               sint_shl uint_shl
               sint_shr uint_shr
               sint_rol uint_rol
               sint_ror uint_ror);

           $si = sint_shl($si, $dist);
           $ui = uint_shl($ui, $dist);
           $si = sint_shr($si, $dist);
           $ui = uint_shr($ui, $dist);
           $si = sint_rol($si, $dist);
           $ui = uint_rol($ui, $dist);
           $si = sint_ror($si, $dist);
           $ui = uint_ror($ui, $dist);

           use Data::Integer qw(
               nint_bits_as_sint nint_bits_as_uint
               sint_bits_as_uint uint_bits_as_sint);

           $si = nint_bits_as_sint($ni);
           $ui = nint_bits_as_uint($ni);
           $ui = sint_bits_as_uint($si);
           $si = uint_bits_as_sint($ui);

           use Data::Integer qw(
               sint_not uint_not
               sint_and uint_and
               sint_nand uint_nand
               sint_andn uint_andn
               sint_or uint_or
               sint_nor uint_nor
               sint_orn uint_orn
               sint_xor uint_xor
               sint_nxor uint_nxor
               sint_mux uint_mux);

           $si = sint_not($si);
           $ui = uint_not($ui);
           $si = sint_and($sa, $sb);
           $ui = uint_and($ua, $ub);
           $si = sint_nand($sa, $sb);
           $ui = uint_nand($ua, $ub);
           $si = sint_andn($sa, $sb);
           $ui = uint_andn($ua, $ub);
           $si = sint_or($sa, $sb);
           $ui = uint_or($ua, $ub);
           $si = sint_nor($sa, $sb);
           $ui = uint_nor($ua, $ub);
           $si = sint_orn($sa, $sb);
           $ui = uint_orn($ua, $ub);
           $si = sint_xor($sa, $sb);
           $ui = uint_xor($ua, $ub);
           $si = sint_nxor($sa, $sb);
           $ui = uint_nxor($ua, $ub);
           $si = sint_mux($sa, $sb, $sc);
           $ui = uint_mux($ua, $ub, $uc);

           use Data::Integer qw(
               sint_madd uint_madd
               sint_msub uint_msub
               sint_cadd uint_cadd
               sint_csub uint_csub
               sint_sadd uint_sadd
               sint_ssub uint_ssub);

           $si = sint_madd($sa, $sb);
           $ui = uint_madd($ua, $ub);
           $si = sint_msub($sa, $sb);
           $ui = uint_msub($ua, $ub);
           ($carry, $si) = sint_cadd($sa, $sb, $carry);
           ($carry, $ui) = uint_cadd($ua, $ub, $carry);
           ($carry, $si) = sint_csub($sa, $sb, $carry);
           ($carry, $ui) = uint_csub($ua, $ub, $carry);
           $si = sint_sadd($sa, $sb);
           $ui = uint_sadd($ua, $ub);
           $si = sint_ssub($sa, $sb);
           $ui = uint_ssub($ua, $ub);

           use Data::Integer qw(natint_hex hex_natint);

           print natint_hex($value);
           $value = hex_natint($string);

DESCRIPTION
       This module is about the native integer numerical data type.  A native
       integer is one of the types of datum that can appear in the numeric
       part of a Perl scalar.  This module supplies constants describing the
       native integer type.

       There are actually two native integer representations: signed and
       unsigned.  Both are handled by this module.

NATIVE INTEGERS
       Each native integer format represents a value using binary place value,
       with some fixed number of bits.  The number of bits is the same for
       both signed and unsigned representations.  In each case the least-
       significant bit has the value 1, the next 2, the next 4, and so on.  In
       the unsigned representation, this pattern continues up to and including
       the most-significant bit, which for a 32-bit machine therefore has the
       value 2^31 (2147483648).  The unsigned format cannot represent any
       negative numbers.

       In the signed format, the most-significant bit is exceptional, having
       the negation of the value that it does in the unsigned format.  Thus on
       a 32-bit machine this has the value -2^31 (-2147483648).  Values with
       this bit set are negative, and those with it clear are non-negative;
       this bit is also known as the "sign bit".

       It is usual in machine arithmetic to use one of these formats at a
       time, for example to add two signed numbers yielding a signed result.
       However, Perl has a trick: a scalar with a native integer value
       contains an additional flag bit which indicates whether the signed or
       unsigned format is being used.  It is therefore possible to mix signed
       and unsigned numbers in arithmetic, at some extra expense.

CONSTANTS
       Each of the extreme-value constants has two names, a short one and a
       long one.  The short names are more convenient to use, but the long
       names are clearer in a context where other similar constants exist.

       Due to the risks of Perl changing the behaviour of a native integer
       value that has been involved in floating point arithmetic (see "BUGS"),
       the extreme-value constants are actually non-constant functions that
       always return a fresh copy of the appropriate value.  The returned
       value is always a pure native integer value, unsullied by floating
       point or string operations.

       natint_bits
           The width, in bits, of the native integer data types.

       min_nint
       min_natint
           The minimum representable value in either representation.  This is
           -2^(natint_bits - 1).

       max_nint
       max_natint
           The maximum representable value in either representation.  This is
           2^natint_bits - 1.

       min_sint
       min_signed_natint
           The minimum representable value in the signed representation.  This
           is -2^(natint_bits - 1).

       max_sint
       max_signed_natint
           The maximum representable value in the signed representation.  This
           is 2^(natint_bits - 1) - 1.

       min_uint
       min_unsigned_natint
           The minimum representable value in the unsigned representation.
           This is zero.

       max_uint
       max_unsigned_natint
           The maximum representable value in the unsigned representation.
           This is 2^natint_bits - 1.

FUNCTIONS
       Each "nint_", "sint_", or "uint_" function operates on one of the three
       integer formats.  "nint_" functions operate on Perl's union of signed
       and unsigned; "sint_" functions operate on signed integers; and "uint_"
       functions operate on unsigned integers.  Except where indicated
       otherwise, the function returns a value of its primary type.

       Parameters A, B, and C, where present, must be numbers of the
       appropriate type: specifically, with a numerical value that can be
       represented in that type.  If there are multiple flavours of zero, due
       to floating point funkiness, all zeroes are treated the same.
       Parameters with other names have other requirements, explained with
       each function.

       The functions attempt to detect unsuitable arguments, and "die" if an
       invalid argument is detected, but they can't notice some kinds of
       incorrect argument.  Generally, it is the caller's responsibility to
       provide a sane numerical argument, and supplying an invalid argument
       will cause mayhem.  Only the numeric value of plain scalar arguments is
       used; the string value is completely ignored, so dualvars are not a
       problem.

   Canonicalisation and classification
       These are basic glue functions.

       nint(A)
       sint(A)
       uint(A)
           These functions each take an argument in a specific integer format
           and return its numerical value.  This is the argument
           canonicalisation that is performed by all of the functions in this
           module, presented in isolation.

       nint_is_sint(A)
           Takes a native integer of either type.  Returns a truth value
           indicating whether this value can be exactly represented as a
           signed native integer.

       nint_is_uint(A)
           Takes a native integer of either type.  Returns a truth value
           indicating whether this value can be exactly represented as an
           unsigned native integer.

   Arithmetic
       These functions operate on numerical values rather than just bit
       patterns.  They will all "die" if the true numerical result doesn't fit
       into the result format, rather than give a wrong answer.

       nint_sgn(A)
       sint_sgn(A)
       uint_sgn(A)
           Returns +1 if the argument is positive, 0 if the argument is zero,
           or -1 if the argument is negative.

       nint_abs(A)
       sint_abs(A)
       uint_abs(A)
           Absolute value (magnitude, discarding sign).

       nint_cmp(A, B)
       sint_cmp(A, B)
       uint_cmp(A, B)
           Arithmetic comparison.  Returns -1, 0, or +1, indicating whether A
           is less than, equal to, or greater than B.

       nint_min(A, B)
       sint_min(A, B)
       uint_min(A, B)
           Arithmetic minimum.  Returns the arithmetically lesser of the two
           arguments.

       nint_max(A, B)
       sint_max(A, B)
       uint_max(A, B)
           Arithmetic maximum.  Returns the arithmetically greater of the two
           arguments.

       nint_neg(A)
       sint_neg(A)
       uint_neg(A)
           Negation: returns -A.

       nint_add(A, B)
       sint_add(A, B)
       uint_add(A, B)
           Addition: returns A + B.

       nint_sub(A, B)
       sint_sub(A, B)
       uint_sub(A, B)
           Subtraction: returns A - B.

   Bit shifting
       These functions all operate on the bit patterns representing integers,
       mostly ignoring the numerical values represented.  In most cases the
       results for particular numerical arguments are influenced by the word
       size, because that determines where a bit being left-shifted will drop
       off the end of the word and where a bit will be shifted in during a
       rightward shift.

       With the exception of rightward shifts (see below), each pair of
       functions performs exactly the same operations on the bit sequences.
       There inevitably can't be any functions here that operate on Perl's
       union of signed and unsigned; you must choose, by which function you
       call, which type the result is to be tagged as.

       sint_shl(A, DIST)
       uint_shl(A, DIST)
           Bitwise left shift (towards more-significant bits).  DIST is the
           distance to shift, in bits, and must be an integer in the range [0,
           natint_bits).  Zeroes are shifted in from the right.

       sint_shr(A, DIST)
       uint_shr(A, DIST)
           Bitwise right shift (towards less-significant bits).  DIST is the
           distance to shift, in bits, and must be an integer in the range [0,
           natint_bits).

           When performing an unsigned right shift, zeroes are shifted in from
           the left.  A signed right shift is different: the sign bit gets
           duplicated, so right-shifting a negative number always gives a
           negative result.

       sint_rol(A, DIST)
       uint_rol(A, DIST)
           Bitwise left rotation (towards more-significant bits, with the
           most-significant bit wrapping round to the least-significant bit).
           DIST is the distance to rotate, in bits, and must be an integer in
           the range [0, natint_bits).

       sint_ror(A, DIST)
       uint_ror(A, DIST)
           Bitwise right rotation (towards less-significant bits, with the
           least-significant bit wrapping round to the most-significant bit).
           DIST is the distance to rotate, in bits, and must be an integer in
           the range [0, natint_bits).

   Format conversion
       These functions convert between the various native integer formats by
       reinterpreting the bit patterns used to represent the integers.  The
       bit pattern remains unchanged; its meaning changes, and so the
       numerical value changes.  Perl scalars preserve the numerical value,
       rather than just the bit pattern, so from the Perl point of view these
       are functions that change numbers into other numbers.

       nint_bits_as_sint(A)
           Converts a native integer of either type to a signed integer, by
           reinterpreting the bits.  The most-significant bit (whether a sign
           bit or not) becomes a sign bit.

       nint_bits_as_uint(A)
           Converts a native integer of either type to an unsigned integer, by
           reinterpreting the bits.  The most-significant bit (whether a sign
           bit or not) becomes an ordinary most-significant bit.

       sint_bits_as_uint(A)
           Converts a signed integer to an unsigned integer, by reinterpreting
           the bits.  The sign bit becomes an ordinary most-significant bit.

       uint_bits_as_sint(A)
           Converts an unsigned integer to a signed integer, by reinterpreting
           the bits.  The most-significant bit becomes a sign bit.

   Bitwise operations
       These functions all operate on the bit patterns representing integers,
       completely ignoring the numerical values represented.  They are mostly
       not influenced by the word size, in the sense that they will produce
       the same numerical result for the same numerical arguments regardless
       of word size.  However, a few are affected by the word size: those on
       unsigned operands that return a non-zero result if given zero
       arguments.

       Each pair of functions performs exactly the same operations on the bit
       sequences.  There inevitably can't be any functions here that operate
       on Perl's union of signed and unsigned; you must choose, by which
       function you call, which type the result is to be tagged as.

       sint_not(A)
       uint_not(A)
           Bitwise complement (NOT).

       sint_and(A, B)
       uint_and(A, B)
           Bitwise conjunction (AND).

       sint_nand(A, B)
       uint_nand(A, B)
           Bitwise inverted conjunction (NAND).

       sint_andn(A, B)
       uint_andn(A, B)
           Bitwise conjunction with inverted argument (A AND (NOT B)).

       sint_or(A, B)
       uint_or(A, B)
           Bitwise disjunction (OR).

       sint_nor(A, B)
       uint_nor(A, B)
           Bitwise inverted disjunction (NOR).

       sint_orn(A, B)
       uint_orn(A, B)
           Bitwise disjunction with inverted argument (A OR (NOT B)).

       sint_xor(A, B)
       uint_xor(A, B)
           Bitwise symmetric difference (XOR).

       sint_nxor(A, B)
       uint_nxor(A, B)
           Bitwise symmetric similarity (NXOR).

       sint_mux(A, B, C)
       uint_mux(A, B, C)
           Bitwise multiplex.  The output has a bit from B wherever A has a 1
           bit, and a bit from C wherever A has a 0 bit.  That is, the result
           is (A AND B) OR ((NOT A) AND C).

   Machine arithmetic
       These functions perform arithmetic operations that are inherently
       influenced by the word size.  They always produce a well-defined output
       if given valid inputs.  There inevitably can't be any functions here
       that operate on Perl's union of signed and unsigned; you must choose,
       by which function you call, which type the result is to be tagged as.

       sint_madd(A, B)
       uint_madd(A, B)
           Modular addition.  The result for unsigned addition is (A + B) mod
           2^natint_bits.  The signed version behaves similarly, but with a
           different result range.

       sint_msub(A, B)
       uint_msub(A, B)
           Modular subtraction.  The result for unsigned subtraction is (A -
           B) mod 2^natint_bits.  The signed version behaves similarly, but
           with a different result range.

       sint_cadd(A, B, CARRY_IN)
       uint_cadd(A, B, CARRY_IN)
           Addition with carry.  Two word arguments (A and B) and an input
           carry bit (CARRY_IN, which must have the value 0 or 1) are all
           added together.  Returns a list of two items: an output carry and
           an output word (of the same signedness as the inputs).  Precisely,
           the output list (CARRY_OUT, R) is such that CARRY_OUT*2^natint_bits
           + R = A + B + CARRY_IN.

       sint_csub(A, B, CARRY_IN)
       uint_csub(A, B, CARRY_IN)
           Subtraction with carry (borrow).  The second word argument (B) and
           an input carry bit (CARRY_IN, which must have the value 0 or 1) are
           subtracted from the first word argument (A).  Returns a list of two
           items: an output carry and an output word (of the same signedness
           as the inputs).  Precisely, the output list (CARRY_OUT, R) is such
           that R - CARRY_OUT*2^natint_bits = A - B - CARRY_IN.

       sint_sadd(A, B)
       uint_sadd(A, B)
           Saturating addition.  The result is A + B if that will fit into the
           result format, otherwise the minimum or maximum value of the result
           format is returned depending on the direction in which the addition
           overflowed.

       sint_ssub(A, B)
       uint_ssub(A, B)
           Saturating subtraction.  The result is A - B if that will fit into
           the result format, otherwise the minimum or maximum value of the
           result format is returned depending on the direction in which the
           subtraction overflowed.

   String conversion
       natint_hex(VALUE)
           VALUE must be a native integer value.  The function encodes VALUE
           in hexadecimal, returning that representation as a string.
           Specifically, the output is of the form "s0xdddd", where "s" is the
           sign and "dddd" is a sequence of hexadecimal digits.

       hex_natint(STRING)
           Generates and returns a native integer value from a string encoding
           it in hexadecimal.  Specifically, the input format is
           "[s][0x]dddd", where "s" is the sign and "dddd" is a sequence of
           one or more hexadecimal digits.  The input is interpreted case
           insensitively.  If the value given in the string cannot be exactly
           represented in the native integer type, the function "die"s.

           The core Perl function "hex" (see "hex" in perlfunc) does a similar
           job to this function, but differs in several ways.  Principally,
           "hex" doesn't handle negative values, and it gives the wrong answer
           for values that don't fit into the native integer type.  In Perl
           5.6 it also gives the wrong answer for values that don't fit into
           the native floating point type.  It also doesn't enforce strict
           syntax on the input string.

BUGS
       In Perl 5.6, when a native integer scalar is used in any arithmetic
       other than specifically integer arithmetic, it gets partially
       transformed into a floating point scalar.  Even if its numerical value
       can be represented exactly in floating point, so that floating point
       arithmetic uses the correct numerical value, some operations are
       affected by the floatness.  In particular, the stringification of the
       scalar doesn't necessarily represent its exact value if it is tagged as
       floating point.

       Because of this transforming behaviour, if you need to stringify a
       native integer it is best to ensure that it doesn't get used in any
       non-integer arithmetic first.  If an integer scalar must be used in
       standard Perl arithmetic, it may be copied first and the copy operated
       upon to avoid causing side effects on the original.  If an integer
       scalar might have already been transformed, it can be cleaned by
       passing it through the canonicalisation function "nint".  The functions
       in this module all avoid modifying their arguments, and always return
       pristine integers.

       Perl 5.8+ still internally modifies integer scalars in the same
       circumstances, but seems to have corrected all the misbehaviour that
       resulted from it.

       Also in Perl 5.6, default Perl arithmetic doesn't necessarily work
       correctly on native integers.  (This is part of the motivation for the
       myriad arithmetic functions in this module.)  Default arithmetic here
       is strictly floating point, so if there are native integers that cannot
       be exactly represented in floating point then the arithmetic will
       approximate the values before operating on them.  Perl 5.8+ attempts to
       use native integer operations where possible in its default arithmetic,
       but as of Perl 5.8.8 it doesn't always succeed.  For reliable integer
       arithmetic, integer operations must still be requested explicitly.

SEE ALSO
       Data::Float, Scalar::Number, perlnumber(1)

AUTHOR
       Andrew Main (Zefram) <zefram@fysh.org>

       Currently maintained by Robert Rothenberg <rrwo@cpan.org>

COPYRIGHT
       Copyright (C) 2007, 2010, 2015, 2017, 2025 Andrew Main (Zefram)
       <zefram@fysh.org>

LICENSE
       This module is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

perl v5.40.2                      2025-04-13                  Data::Integer(3)
