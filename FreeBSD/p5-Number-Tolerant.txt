Number::Tolerant(3)   User Contributed Perl Documentation  Number::Tolerant(3)


NAME
       Number::Tolerant - tolerance ranges for inexact numbers

VERSION
       version 1.710

SYNOPSIS
        use Number::Tolerant;

        my $range  = tolerance(10 => to => 12);
        my $random = 10 + rand(2);

        die "I shouldn't die" unless $random == $range;

        print "This line will always print.\n";

DESCRIPTION
       Number::Tolerant creates a number-like object whose value refers to a
       range of possible values, each equally acceptable.  It overloads
       comparison operations to reflect this.

       I use this module to simplify the comparison of measurement results to
       specified tolerances.

        reject $product unless $measurement == $specification;

PERL VERSION
       This library should run on perls released even a long time ago.  It
       should work on any version of perl released in the last five years.

       Although it may work on older versions of perl, no guarantee is made
       that the minimum required version will not be increased.  The version
       may be increased for any reason, and there is no promise that patches
       will be accepted to lower the minimum required perl.

METHODS
   Instantiation
       new

       tolerance

       There is a "new" method on the Number::Tolerant class, but it also
       exports a simple function, "tolerance", which will return an object of
       the Number::Tolerant class.  Both use the same syntax:

        my $range = Number::Tolerant->new( $x => $method => $y);

        my $range = tolerance( $x => $method => $y);

       The meaning of $x and $y are dependent on the value of $method, which
       describes the nature of the tolerance.  Tolerances can be defined in
       five ways, at present:

         method              range
        -------------------+------------------
         plus_or_minus     | x +/- y
         plus_or_minus_pct | x +/- (y% of x)
         or_more           | x to Inf
         or_less           | x to -Inf
         more_than         | x to Inf, not x
         less_than         | x to -Inf, not x
         to                | x to y
         infinite          | -Inf to Inf
         offset            | (x + y1) to (x + y2)

       For "or_less" and "or_more", $y is ignored if passed.  For "infinite",
       neither $x nor $y is used; "infinite" should be the sole argument.  The
       first two arguments can be reversed for "more_than" and "less_than", to
       be more English-like.

       Offset tolerances are slightly unusual.  Here is an example:

         my $offset_tolerance = tolerance(10 => offset => (-3, 5));
         # stringifies to: 10 (-3 +5)

       An offset is very much like a "plus_or_minus" tolerance, but its center
       value is not necessarily the midpoint between its extremes.  This is
       significant for comparisons and numifications of the tolerance.  Given
       the following two tolerances:

         my $pm_dice = tolerance(10.5 => plus_or_minus => 7.5);
         my $os_dice = tolerance(11 => offset => (-8, 7));

       The first will sort as numerically less than the second.

       If the given arguments can't be formed into a tolerance, an exception
       will be raised.

       from_string

       A new tolerance can be instantiated from the stringification of an old
       tolerance.  For example:

        my $range = Number::Tolerant->from_string("10 to 12");

        die "Everything's OK!" if 11 == $range; # program dies of joy

       This will not yet parse stringified unions, but that will be
       implemented in the future.  (I just don't need it yet.)

       If a string can't be parsed, an exception is raised.

   stringify_as
         my $string = $tolerance->stringify_as($type);

       This method does nothing!  Someday, it will stringify the given
       tolerance as a different type, if possible.  "10 +/- 1" will
       stringify_as('plus_or_minus_pct') to "10 +/- 10%" for example.

   numify
         my $n = $tolerance->numify;

       This returns the numeric form of a tolerance.  If a tolerance has both
       a minimum and a maximum, and they are the same, then that is the
       numification.  Otherwise, numify returns undef.

   Overloading
       Tolerances overload a few operations, mostly comparisons.

       boolean
           Tolerances are always true.

       numify
           Most tolerances numify to undef; see "numify".

       stringify
           A tolerance stringifies to a short description of itself, generally
           something like "m < x < n"

            infinite  - "any number"
            to        - "m <= x <= n"
            or_more   - "m <= x"
            or_less   - "x <= n"
            more_than - "m < x"
            less_than - "x < n"
            offset    - "x (-y1 +y2)"
            constant  - "x"
            plus_or_minus     - "x +/- y"
            plus_or_minus_pct - "x +/- y%"

       equality
           A number is equal to a tolerance if it is neither less than nor
           greater than it.  (See below).

       smart match
           Same as equality.

       comparison
           A number is greater than a tolerance if it is greater than its
           maximum value.

           A number is less than a tolerance if it is less than its minimum
           value.

           No number is greater than an "or_more" tolerance or less than an
           "or_less" tolerance.

           "...or equal to" comparisons include the min/max values in the
           permissible range, as common sense suggests.

       tolerance intersection
           A tolerance "&" a tolerance or number is the intersection of the
           two ranges.  Intersections allow you to quickly narrow down a set
           of tolerances to the most stringent intersection of values.

            tolerance(5 => to => 6) & tolerance(5.5 => to => 6.5);
            # this yields: tolerance(5.5 => to => 6)

           If the given values have no intersection, "()" is returned.

           An intersection with a normal number will yield that number, if it
           is within the tolerance.

       tolerance union
           A tolerance "|" a tolerance or number is the union of the two.
           Unions allow multiple tolerances, whether they intersect or not, to
           be treated as one.  See Number::Tolerant::Union for more
           information.

EXTENDING
       This feature is slighly experimental, but it's here.

       New tolerance types may be written as subclasses of
       Number::Tolerant::Type, providing the interface described in its
       documentation.  They can then be enabled or disabled with the following
       methods:

   " enable_plugin "
         Number::Tolerant->enable_plugin($class_name);

       This method enables the named class, so that attempts to create new
       tolerances will check against this class.  Classes are checked against
       "validate_plugin" before being enabled.  An exception is thrown if the
       class does not appear to provide the Number::Tolerant::Type interface.

   " disable_plugin "
         Number::Tolerant->disable_plugin($class_name);

       This method will disable the named class, so that future attempts to
       create new tolerances will not check against this class.

   " validate_plugin "
         Number::Tolerant->validate_plugin($class_name);

       This method checks (naively) that the given class provides the
       interface defined in Number::Tolerant::Type.  If it does not, an
       exception is thrown.

TODO
       •   Extend "from_string" to cover unions.

       •   Extend "from_string" to include Number::Range-type specifications.

       •   Allow translation into forms not originally used:

            my $range    = tolerance(9 => to => 17);
            my $range_pm = $range->convert_to('plus_minus');
            $range->stringify_as('plus_minus_pct');

       •   Create a factory so that you can simultaneously work with two sets
           of plugins.

           This one is very near completion.  There will now be two classes
           that should be used:  Number::Tolerant::Factory, which produces
           tolerances, and Number::Tolerant::Tolerance, which is a tolerance.
           Both will inherit from N::T, for supporting old code, and N::T will
           dispatch construction methods to a default factory.

SEE ALSO
       The module Number::Range provides another way to deal with ranges of
       numbers.  The major differences are: N::R is set-like, not range-like;
       N::R does not overload any operators.  Number::Tolerant will not (like
       N::R) attempt to parse a textual range specification like
       "1..2,5,7..10" unless specifically instructed to.  (The valid formats
       for strings passed to "from_string" does not match Number::Range
       exactly.  See TODO.)

       The "Number::Range" code:

        $range = Number::Range->new("10..15","20..25");

       Is equivalent to the "Number::Tolerant" code:

        $range = Number::Tolerant::Union->new(10..15,20..25);

       ...while the following code expresses an actual range:

        $range = tolerance(10 => to => 15) | tolerance(20 => to => 25);

THANKS
       Thanks to Yuval Kogman and #perl-qa for helping find the bizarre bug
       that drove the minimum required perl up to 5.8

       Thanks to Tom Freedman, who reminded me that this code was fun to work
       on, and also provided the initial implementation for the offset type.

AUTHOR
       Ricardo Signes <cpan@semiotic.systems>

CONTRIBUTORS
       •   Alexandre Mestiashvili <alex@biotec.tu-dresden.de>

       •   Karen Etheridge <ether@cpan.org>

       •   Michael Carman <mjcarman@cpan.org>

       •   Ricardo SIGNES <rjbs@codesimply.com>

       •   Ricardo Signes <rjbs@semiotic.systems>

       •   Smylers <Smylers@stripey.com>

COPYRIGHT AND LICENSE
       This software is copyright (c) 2004 by Ricardo Signes.

       This is free software; you can redistribute it and/or modify it under
       the same terms as the Perl 5 programming language system itself.

perl v5.40.2                      2022-12-31               Number::Tolerant(3)
