Perl::Critic::Policy::CodeLayout::ProhibitFatCommaNewline(3)
                                           User Contributed Perl Documentation


NAME
       Perl::Critic::Policy::CodeLayout::ProhibitFatCommaNewline - keep a fat
       comma on the same line as its quoted word

DESCRIPTION
       This policy is part of the "Perl::Critic::Pulp" add-on.  It reports a
       newline between a fat comma and preceding bareword for Perl builtins,

           my %h = (caller         # bad, builtin called as a function
                    => 'abc');

       And for all words when targeting Perl 5.6 and earlier,

           use 5.006;
           my %h = (foo            # bad, all words in perl 5.6 and earlier
                    => 'def');

       When there's a newline between the word and the fat comma like this the
       word executes as a function call (builtins always, and also user
       defined in Perl 5.6 and earlier), giving its return value rather than a
       word string.

       Such a return value is probably not what was intended and on that basis
       this policy is under the "bugs" theme and medium severity (see "POLICY
       THEMES" in Perl::Critic).

   Builtins
       Perl builtin functions with a newline always execute and give their
       return value rather than a the quoted word.

           my %h = (print          # bad, builtin print() executes
                    => "abc");
           # %h is key "1" value "abc"

       The builtin is called with no arguments and that might provoke a
       warning from some, but others like "print" will quietly run.

       Dashed builtin names such as "-print" are also function calls, with a
       negate operator.

           my %h = (-print       # bad, print() call and negate
                    => "123");
           # h is key "-1" value "123"

       For the purposes of this policy the builtins are is_perl_builtin() from
       Perl::Critic::Utils.  It's possible this is more builtins than the
       particular Perl in use, but guarding against all will help if going to
       a newer Perl in the future.

   Non-Builtins
       In Perl 5.6 and earlier all words "foo" execute as a function call when
       there's a newline before the fat comma.

           sub foo {
             return 123
           }
           my %h = (foo
                    => "def");
           # in Perl 5.6 and earlier %h is key "123" value "def"

       Under "use strict" an error is thrown if no such function, in the usual
       way.  A word builtin is a function call if it exists (with a warning
       about being interpreted that way), or a bareword if not.

       This policy prohibits all words with newline before fat comma when
       targeting Perl 5.6 or earlier.  This means either an explicit "use
       5.006" or smaller, or no such minimum "use" at all.

       One subtle way an executing word with newline before fat comma can go
       undetected (in 5.6 and earlier still) is an accidental redefinition of
       a constant,

           use constant FOO => "blah";
           use constant FOO
             => "some value";
           # makes a constant subr called blah (in Perl 5.6)

       "constant.pm" might reject some return values from FOO(), eg. a number,
       but a string like "blah" here quietly expands and creates a constant
       blah().

       The difference between Perl 5.6 and later Perl is that in 5.6 the
       parser only looked as far as a newline for a possible quoting "=>" fat
       comma.  In Perl 5.8 and later for non-builtins the lookahead continues
       beyond any newlines and comments.  For Perl builtins the behaviour is
       the same, in all versions the lookahead stops at the newline.

   Avoiding Problems
       Putting the fat comma on the same line as the word ensures it quotes in
       all cases.

           my %h = (-print =>    # ok, fat comma on same line quotes
                    "123");

       If for layout purposes you do want a newline then the suggestion is to
       give a string or perhaps a parenthesized expression since that doesn't
       rely on the "=>" fat comma quoting.  A fat comma can still emphasize a
       key/value pair.

           my %h = ('print'      # ok, string
                    =>
                    123);

       Alternately if instead a function call is really what's intended
       (builtin or otherwise) then parens can be used in the normal way to
       ensure it's a call (as per perltrap the rule being "if it looks like a
       function, it is a function").

           my %h = (foo()        # ok, function call
                    =>
                    123);

   Disabling
       As always if you don't care about this then you can disable
       "ProhibitFatCommaNewline" from your .perlcriticrc in the usual way (see
       "CONFIGURATION" in Perl::Critic),

           [-CodeLayout::ProhibitFatCommaNewline]

SEE ALSO
       Perl::Critic::Pulp, Perl::Critic, perlop

HOME PAGE
       <http://user42.tuxfamily.org/perl-critic-pulp/index.html>

COPYRIGHT
       Copyright 2011, 2013, 2014, 2015, 2016, 2017, 2019, 2021 Kevin Ryde

       Perl-Critic-Pulp is free software; you can redistribute it and/or
       modify it under the terms of the GNU General Public License as
       published by the Free Software Foundation; either version 3, or (at
       your option) any later version.

       Perl-Critic-Pulp is distributed in the hope that it will be useful, but
       WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
       General Public License for more details.

       You should have received a copy of the GNU General Public License along
       with Perl-Critic-Pulp.  If not, see <http://www.gnu.org/licenses/>.

perl v5.40.2                      2021-02-27
                  Perl::Critic::Policy::CodeLayout::ProhibitFatCommaNewline(3)
