DBIx::Simple(3)       User Contributed Perl Documentation      DBIx::Simple(3)


NAME
       DBIx::Simple - Very complete easy-to-use OO interface to DBI

SYNOPSIS
   DBIx::Simple
           $db = DBIx::Simple->connect(...)  # or ->new

           $db->keep_statements = 16
           $db->lc_columns = 1
           $db->result_class = 'DBIx::Simple::Result';

           $db->begin_work         $db->commit
           $db->rollback           $db->disconnect
           $db->func(...)          $db->last_insert_id

           $result = $db->query(...)

   DBIx::SImple + SQL::Interp
           $result = $db->iquery(...)

   DBIx::Simple + SQL::Abstract
           $db->abstract = SQL::Abstract->new(...)

           $result = $db->select(...)
           $result = $db->insert(...)
           $result = $db->update(...)
           $result = $db->delete(...)

   DBIx::Simple::Result
           @columns = $result->columns

           $result->into($foo, $bar, $baz)
           $row = $result->fetch

           @row = $result->list      @rows = $result->flat
           $row = $result->array     @rows = $result->arrays
           $row = $result->hash      @rows = $result->hashes
           @row = $result->kv_list   @rows = $result->kv_flat
           $row = $result->kv_array  @rows = $result->kv_arrays
           $obj = $result->object    @objs = $result->objects

           %map = $result->map              %grouped = $result->group
           %map = $result->map_hashes(...)  %grouped = $result->group_hashes(...)
           %map = $result->map_arrays(...)  %grouped = $result->group_arrays(...)

           $rows = $result->rows

           $dump = $result->text

           $result->finish

   DBIx::Simple::Result + DBIx::XHTML_Table
           $html = $result->html(...)

           $table_object = $result->xto(...)

   Examples
       Please read DBIx::Simple::Examples for code examples.

DESCRIPTION
       DBIx::Simple provides a simplified interface to DBI, Perl's powerful
       database module.

       This module is aimed at rapid development and easy maintenance. Query
       preparation and execution are combined in a single method, the result
       object (which is a wrapper around the statement handle) provides easy
       row-by-row and slurping methods.

       The "query" method returns either a result object, or a dummy object.
       The dummy object returns undef (or an empty list) for all methods and
       when used in boolean context, is false. The dummy object lets you
       postpone (or skip) error checking, but it also makes immediate error
       checking simply "$db->query(...) or die $db->error".

   DBIx::Simple methods
       Class methods

       connect($dbh), "connect($dsn, $user, $pass, \%options)"
       new($dbh), "new($dsn, $user, $pass, \%options)"
                     The "connect" or "new" class method takes either an
                     existing DBI object ($dbh), or a list of arguments to
                     pass to "DBI->connect". See DBI for a detailed
                     description.

                     You cannot use this method to clone a DBIx::Simple
                     object: the $dbh passed should be a DBI::db object, not a
                     DBIx::Simple object.

                     For new connections, PrintError is disabled by default.
                     If you enable it, beware that it will report line numbers
                     in DBIx/Simple.pm.

                     For new connections, RaiseError is enabled by default
                     unless the environment variable
                     "PERL_DBIX_SIMPLE_NO_RAISEERROR" is set to a non-empty
                     non-0 value.

                     This method is the constructor and returns a DBIx::Simple
                     object on success. On failure, it returns undef.

       Object methods

       "query($query, @values)"
                     Prepares and executes the query and returns a result
                     object.

                     If the string "(??)" is present in the query, it is
                     replaced with a list of as many question marks as
                     @values.

                     The database drivers substitute placeholders (question
                     marks that do not appear in quoted literals) in the query
                     with the given @values, after them escaping them. You
                     should always use placeholders, and never use raw user
                     input in database queries.

                     On success, returns a DBIx::Simple::Result object. On
                     failure, returns a DBIx::Simple::Dummy object.

       iquery(...)   Uses SQL::Interp to interpolate values into a query, and
                     uses the resulting generated query and bind arguments
                     with "query". See SQL::Interp's documentation for usage
                     information.

                     Requires Mark Stosberg's SQL::Interp, which is available
                     from CPAN. SQL::Interp is a fork from David Manura's
                     SQL::Interpolate.

       "select", "insert", "update", "delete"
                     Calls the respective method on "abstract", and uses the
                     resulting generated query and bind arguments with
                     "query". See SQL::Abstract's documentation for usage
                     information. You can override the object by assigning to
                     the "abstract" property.

                     Requires Nathan Wiger's SQL::Abstract, which is available
                     from CPAN.

       "begin_work", "begin", "commit", "rollback"
                     These transaction related methods call the DBI respective
                     methods and Do What You Mean. See DBI for details.

                     "begin" is an alias for "begin_work".

       func(...)     Calls the "func" method of DBI. See DBI for details.

       last_insert_id(...)
                     Calls the "last_insert_id" method of DBI. See DBI for
                     details. Note that this feature requires DBI 1.38 or
                     newer.

       "disconnect"  Destroys (finishes) active statements and disconnects.
                     Whenever the database object is destroyed, this happens
                     automatically if DBIx::Simple handled the connection
                     (i.e. you didn't use an existing DBI handle). After
                     disconnecting, you can no longer use the database object
                     or any of its result objects.

       Object properties

       "dbh"         Exposes the internal database handle. Use this only if
                     you know what you are doing. Keeping a reference or doing
                     queries can interfere with DBIx::Simple's garbage
                     collection and error reporting.

       "lc_columns = $bool"
                     When true at time of query execution, makes several
                     result object methods use lower cased column names.
                     "lc_columns" is true by default.

       "keep_statements = $integer"
                     Sets the number of statement objects that DBIx::Simple
                     can keep for reuse. This can dramatically speed up
                     repeated queries (like when used in a loop).
                     "keep_statements" is 16 by default.

                     A query is only reused if it equals a previously used one
                     literally. This means that to benefit from this caching
                     mechanism, you must use placeholders and never
                     interpolate variables yourself.

                         # Wrong:
                         $db->query("INSERT INTO foo VALUES ('$foo', '$bar', '$baz')");
                         $db->query("SELECT FROM foo WHERE foo = '$foo' OR bar = '$bar'");

                         # Right:
                         $db->query('INSERT INTO foo VALUES (??)', $foo, $bar, $baz);
                         $db->query('SELECT FROM foo WHERE foo = ? OR bar = ?', $foo, $baz);

                     Of course, automatic value escaping is a much better
                     reason for using placeholders.

       "result_class = $string"
                     Class to use for result objects. Defaults to
                     DBIx::Simple::Result. A constructor is not used.

       "error"       Returns the error string of the last DBI method. See the
                     discussion of ""err"" and ""errstr"" in DBI.

       "abstract = SQL::Abstract->new(...)"
                     Sets the object to use with the "select", "insert",
                     "update" and "delete" methods. On first access, will
                     create one with SQL::Abstract's default options.

                     Requires Nathan Wiger's SQL::Abstract, which is available
                     from CPAN.

                     In theory, you can assign any object to this property, as
                     long as that object has these four methods, and they
                     return a list suitable for use with the "query" method.

   DBIx::Simple::Dummy
       The "query" method of DBIx::Simple returns a dummy object on failure.
       Its methods all return an empty list or undef, depending on context.
       When used in boolean context, a dummy object evaluates to false.

   DBIx::Simple::Result methods
       Methods documented to return "a list" return a reference to an array of
       the same in scalar context, unless something else is explicitly
       mentioned.

       "columns"     Returns a list of column names. Affected by "lc_columns".

       bind(LIST)    Binds the given LIST of variables to the columns. Unlike
                     with DBI's "bind_columns", passing references is not
                     needed.

                     Bound variables are very efficient. Binding a tied
                     variable doesn't work.

       attr(...)     Returns a copy of an sth attribute (property). See
                     "Statement Handle Attributes" in DBI for details.

       func(...)     This calls the "func" method on the sth of DBI. See DBI
                     for details.

       "rows"        Returns the number of rows affected by the last row
                     affecting command, or -1 if the number of rows is not
                     known or not available.

                     For SELECT statements, it is generally not possible to
                     know how many rows are returned. MySQL does provide this
                     information. See DBI for a detailed explanation.

       "finish"      Finishes the statement. After finishing a statement, it
                     can no longer be used.  When the result object is
                     destroyed, its statement handle is automatically finished
                     and destroyed. There should be no reason to call this
                     method explicitly; just let the result object go out of
                     scope.

       Fetching a single row at a time

       "fetch"       Returns a reference to the array that holds the values.
                     This is the same array every time.

                     Subsequent fetches (using any method) may change the
                     values in the variables passed and the returned
                     reference's array.

       into(LIST)    Combines "bind" with "fetch". Returns what "fetch"
                     returns.

       "list"        Returns a list of values, or (in scalar context), only
                     the last value.

       "array"       Returns a reference to an array.

       "hash"        Returns a reference to a hash, keyed by column name.
                     Affected by "lc_columns".

       "kv_list"     Returns an ordered list of interleaved keys and values.
                     Affected by "lc_columns".

       "kv_array"    Returns a reference to an array of interleaved column
                     names and values. Like kv, but returns an array reference
                     even in list context. Affected by "lc_columns".

       "object($class, ...)"
                     Returns an instance of $class. See "Object construction".
                     Possibly affected by "lc_columns".

       Fetching all remaining rows

       "flat"        Returns a flattened list.

       "arrays"      Returns a list of references to arrays

       "hashes"      Returns a list of references to hashes, keyed by column
                     name. Affected by "lc_columns".

       "kv_flat"     Returns an flattened list of interleaved column names and
                     values. Affected by "lc_columns".

       "kv_arrays"   Returns a list of references to arrays of interleaved
                     column names and values.  Affected by "lc_columns".

       "objects($class, ...)"
                     Returns a list of instances of $class. See "Object
                     construction". Possibly affected by "lc_columns".

       "map"
       "group"       Constructs a simple hash, using the two columns as
                     key/value pairs. Should only be used with queries that
                     return two columns. Returns a list of interleaved keys
                     and values, or (in scalar context), a reference to a
                     hash.

                     With unique keys, use "map". With non-unique keys, use
                     "group", which gives an array of values per key.

       map_hashes($column_name)
       group_arrays($column_number)
                     Constructs a hash keyed by the values in the chosen
                     column, and returns a list of interleaved keys and
                     values, or (in scalar context), a reference to a hash.
                     Affected by "lc_columns".

                     With unique keys, use "map_hashes", which gives a single
                     hash per key. With non-unique keys, use "group_hashes",
                     which gives an array of hashes per key.

       map_arrays($column_number)
       group_arrays($column_number)
                     Constructs a hash keyed by the values in the chosen
                     column, and returns a list of interleaved keys and
                     values, or (in scalar context), a reference to a hash.

                     With unique keys, use "map_arrays", which gives a single
                     array per key. With non-unique keys, use "group_arrays",
                     which gives an array of arrays per key.

       xto(%attr)    Returns a DBIx::XHTML_Table object, passing the
                     constructor a reference to %attr.

                     Requires Jeffrey Hayes Anderson's DBIx::XHTML_Table,
                     which is available from CPAN.

                     In general, using the "html" method (described below) is
                     much easier. "xto" is available in case you need more
                     flexibility. Not affected by "lc_columns".

       html(%attr)   Returns an (X)HTML formatted table, using the
                     DBIx::XHTML_Table module. Passes a reference to %attr to
                     both the constructor and the "output" method.

                     Requires Jeffrey Hayes Anderson's DBIx::XHTML_Table,
                     which is available from CPAN.

                     This method is a shortcut method. That means that

                         $result->html

                         $result->html(
                             tr => { bgcolor => [ 'silver', 'white' ] },
                             no_ucfirst => 1
                         )

                     do the same as:

                         $result->xto->output

                         $result->xto(
                             tr => { bgcolor => [ 'silver', 'white' ] }
                         )->output(
                             no_ucfirst => 1
                         );

       text($type)   Returns a string with a simple text representation of the
                     data. $type can be any of: "neat", "table", "box". It
                     defaults to "table" if Text::Table is installed, to
                     "neat" if it isn't.

                     "table" and "box" require Anno Siegel's Text::Table,
                     which is available from CPAN.

   Object construction
       DBIx::Simple has basic support for returning results as objects. The
       actual construction method has to be provided by the chosen class,
       making this functionality rather advanced and perhaps unsuited for
       beginning programmers.

       When the "object" or "objects" method is called on the result object
       returned by one of the query methods, two approaches are tried. In
       either case, pass the name of a class as the first argument. A prefix
       of a single colon can be used as an alias for "DBIx::Simple::Result::",
       e.g. ":Example" is short for "DBIx::Simple::Result::Example". Modules
       are loaded on demand.

       The default class when no class is given, is ":RowObject". It requires
       Jos Boumans' Object::Accessor, which is available from CPAN.

       Simple object construction

       When "object" is given a class that provides a "new" method, but not a
       "new_from_dbix_simple" method, "new" is called with a list of
       interleaved column names and values, like a flattened hash, but
       ordered. "objects" causes "new" to be called multiple times, once for
       each remaining row.

       Example:

           {
               package DBIx::Simple::Result::ObjectExample;
               sub new {
                   my ($class, %args) = @_;
                   return bless $class, \%args;
               }

               sub foo { ... }
               sub bar { ... }
           }


           $db->query('SELECT foo, bar FROM baz')->object(':ObjectExample')->foo();

       Advanced object construction

       When "object" or "objects" is given a class that provides a
       "new_from_dbix_simple" method, any "new" is ignored, and
       "new_from_dbix_simple" is called with a list of the
       DBIx::Simple::Result object and any arguments passed to "object" or
       "objects".

       "new_from_dbix_simple" is called in scalar context for "object", and in
       list context for "objects". In scalar context, it should fetch exactly
       one row, and in list context, it should fetch all remaining rows.

       Example:

           {
               package DBIx::Simple::Result::ObjectExample;
               sub new_from_dbix_simple {
                   my ($class, $result, @args) = @_;
                   return map { bless $class, $_ } $result->hashes if wantarray;
                   return       bless $class, $result->hash;
               }

               sub foo { ... }
               sub bar { ... }
           }

           $db->query('SELECT foo, bar FROM baz')->object(':ObjectExample')->foo();

MISCELLANEOUS
       The mapping methods do not check whether the keys are unique. Rows that
       are fetched later overwrite earlier ones.

LICENSE
       Pick your favourite OSI approved license :)

       http://www.opensource.org/licenses/alphabetical

AUTHOR
       Juerd Waalboer <#####@juerd.nl> <http://juerd.nl/>

SEE ALSO
       perl, perlref

       DBI, DBIx::Simple::Examples, SQL::Abstract, DBIx::XHTML_Table

perl v5.40.2                      2017-12-08                   DBIx::Simple(3)
