SerialPort(3)         User Contributed Perl Documentation        SerialPort(3)


NAME
       Device::SerialPort - Linux/POSIX emulation of Win32::SerialPort
       functions.

SYNOPSIS
         use Device::SerialPort qw( :PARAM :STAT 0.07 );

   Constructors
         # $lockfile is optional
         $PortObj = new Device::SerialPort ($PortName, $quiet, $lockfile)
              || die "Can't open $PortName: $!\n";

         $PortObj = start Device::SerialPort ($Configuration_File_Name)
              || die "Can't start $Configuration_File_Name: $!\n";

         $PortObj = tie (*FH, 'Device::SerialPort', $Configuration_File_Name)
              || die "Can't tie using $Configuration_File_Name: $!\n";

   Configuration Utility Methods
         $PortObj->alias("MODEM1");

         $PortObj->save($Configuration_File_Name)
              || warn "Can't save $Configuration_File_Name: $!\n";

         # currently optional after new, POSIX version expected to succeed
         $PortObj->write_settings;

         # rereads file to either return open port to a known state
         # or switch to a different configuration on the same port
         $PortObj->restart($Configuration_File_Name)
              || warn "Can't reread $Configuration_File_Name: $!\n";

         # "app. variables" saved in $Configuration_File, not used internally
         $PortObj->devicetype('none');     # CM11, CM17, 'weeder', 'modem'
         $PortObj->hostname('localhost');  # for socket-based implementations
         $PortObj->hostaddr(0);            # false unless specified
         $PortObj->datatype('raw');        # in case an application needs_to_know
         $PortObj->cfg_param_1('none');    # null string '' hard to save/restore
         $PortObj->cfg_param_2('none');    # 3 spares should be enough for now
         $PortObj->cfg_param_3('none');    # one may end up as a log file path

         # test suite use only
         @necessary_param = Device::SerialPort->set_test_mode_active(1);

         # exported by :PARAM
         nocarp || carp "Something fishy";
         $a = SHORTsize;                       # 0xffff
         $a = LONGsize;                        # 0xffffffff
         $answer = yes_true("choice");         # 1 or 0
         OS_Error unless ($API_Call_OK);       # prints error

   Configuration Parameter Methods
         # most methods can be called two ways:
         $PortObj->handshake("xoff");           # set parameter
         $flowcontrol = $PortObj->handshake;    # current value (scalar)

         # The only "list context" method calls from Win32::SerialPort
         # currently supported are those for baudrate, parity, databits,
         # stopbits, and handshake (which only accept specific input values).
         @handshake_opts = $PortObj->handshake; # permitted choices (list)

         # similar
         $PortObj->baudrate(9600);
         $PortObj->parity("odd");
         $PortObj->databits(8);
         $PortObj->stopbits(1);        # POSIX does not support 1.5 stopbits

         # these are essentially dummies in POSIX implementation
         # the calls exist to support compatibility
         $PortObj->buffers(4096, 4096);        # returns (4096, 4096)
         @max_values = $PortObj->buffer_max;   # returns (4096, 4096)
         $PortObj->reset_error;                # returns 0

         # true/false parameters (return scalar context only)
         # parameters exist, but message processing not yet fully implemented
         $PortObj->user_msg(ON);       # built-in instead of warn/die above
         $PortObj->error_msg(ON);      # translate error bitmasks and carp

         $PortObj->parity_enable(F);   # faults during input
         $PortObj->debug(0);

         # true/false capabilities (read only)
         # most are just constants in the POSIX case
         $PortObj->can_baud;                   # 1
         $PortObj->can_databits;               # 1
         $PortObj->can_stopbits;               # 1
         $PortObj->can_dtrdsr;                 # 1
         $PortObj->can_handshake;              # 1
         $PortObj->can_parity_check;           # 1
         $PortObj->can_parity_config;          # 1
         $PortObj->can_parity_enable;          # 1
         $PortObj->can_rlsd;                   # 0 currently
         $PortObj->can_16bitmode;              # 0 Win32-specific
         $PortObj->is_rs232;                   # 1
         $PortObj->is_modem;                   # 0 Win32-specific
         $PortObj->can_rtscts;                 # 1
         $PortObj->can_xonxoff;                # 1
         $PortObj->can_xon_char;               # 1 use stty
         $PortObj->can_spec_char;              # 0 use stty
         $PortObj->can_interval_timeout;       # 0 currently
         $PortObj->can_total_timeout;          # 1 currently
         $PortObj->can_ioctl;                  # automatically detected
         $PortObj->can_status;                 # automatically detected
         $PortObj->can_write_done;             # automatically detected
         $PortObj->can_modemlines;     # automatically detected
         $PortObj->can_wait_modemlines;# automatically detected
         $PortObj->can_intr_count;             # automatically detected
         $PortObj->can_arbitrary_baud; # automatically detected

   Operating Methods
         ($count_in, $string_in) = $PortObj->read($InBytes);
         warn "read unsuccessful\n" unless ($count_in == $InBytes);

         $count_out = $PortObj->write($output_string);
         warn "write failed\n"         unless ($count_out);
         warn "write incomplete\n"     if ( $count_out != length($output_string) );

         if ($string_in = $PortObj->input) { PortObj->write($string_in); }
            # simple echo with no control character processing

         if ($PortObj->can_wait_modemlines) {
           $rc = $PortObj->wait_modemlines( MS_RLSD_ON );
           if (!$rc) { print "carrier detect changed\n"; }
         }

         if ($PortObj->can_modemlines) {
           $ModemStatus = $PortObj->modemlines;
           if ($ModemStatus & $PortObj->MS_RLSD_ON) { print "carrier detected\n"; }
         }

         if ($PortObj->can_intr_count) {
           $count = $PortObj->intr_count();
           print "got $count interrupts\n";
         }

         if ($PortObj->can_arbitrary_baud) {
           print "this port can set arbitrary baud rates\n";
         }

         ($BlockingFlags, $InBytes, $OutBytes, $ErrorFlags) = $PortObj->status;
             # same format for compatibility. Only $InBytes and $OutBytes are
             # currently returned (on linux). Others are 0.
             # Check return value of "can_status" to see if this call is valid.

         ($done, $count_out) = $PortObj->write_done(0);
            # POSIX defaults to background write. Currently $count_out always 0.
            # $done set when hardware finished transmitting and shared line can
            # be released for other use. Ioctl may not work on all OSs.
            # Check return value of "can_write_done" to see if this call is valid.

         $PortObj->write_drain;  # POSIX alternative to Win32 write_done(1)
                                 # set when software is finished transmitting
         $PortObj->purge_all;
         $PortObj->purge_rx;
         $PortObj->purge_tx;

             # controlling outputs from the port
         $PortObj->dtr_active(T);              # sends outputs direct to hardware
         $PortObj->rts_active(Yes);            # return status of ioctl call
                                               # return undef on failure

         $PortObj->pulse_break_on($milliseconds); # off version is implausible
         $PortObj->pulse_rts_on($milliseconds);
         $PortObj->pulse_rts_off($milliseconds);
         $PortObj->pulse_dtr_on($milliseconds);
         $PortObj->pulse_dtr_off($milliseconds);
             # sets_bit, delays, resets_bit, delays
             # returns undef if unsuccessful or ioctls not implemented

         $PortObj->read_const_time(100);       # const time for read (milliseconds)
         $PortObj->read_char_time(5);          # avg time between read char

         $milliseconds = $PortObj->get_tick_count;

   Methods used with Tied FileHandles
         $PortObj = tie (*FH, 'Device::SerialPort', $Configuration_File_Name)
              || die "Can't tie: $!\n";             ## TIEHANDLE ##

         print FH "text";                           ## PRINT     ##
         $char = getc FH;                           ## GETC      ##
         syswrite FH, $out, length($out), 0;        ## WRITE     ##
         $line = <FH>;                              ## READLINE  ##
         @lines = <FH>;                             ## READLINE  ##
         printf FH "received: %s", $line;           ## PRINTF    ##
         read (FH, $in, 5, 0) or die "$!";          ## READ      ##
         sysread (FH, $in, 5, 0) or die "$!";       ## READ      ##
         close FH || warn "close failed";           ## CLOSE     ##
         undef $PortObj;
         untie *FH;                                 ## DESTROY   ##

         $PortObj->linesize(10);                    # with READLINE
         $PortObj->lastline("_GOT_ME_");            # with READLINE, list only

             ## with PRINT and PRINTF, return previous value of separator
         $old_ors = $PortObj->output_record_separator("RECORD");
         $old_ofs = $PortObj->output_field_separator("COMMA");

   Destructors
         $PortObj->close || warn "close failed";
             # release port to OS - needed to reopen
             # close will not usually DESTROY the object
             # also called as: close FH || warn "close failed";

         undef $PortObj;
             # preferred unless reopen expected since it triggers DESTROY
             # calls $PortObj->close but does not confirm success
             # MUST precede untie - do all three IN THIS SEQUENCE before re-tie.

         untie *FH;

   Methods for I/O Processing
         $PortObj->are_match("text", "\n");    # possible end strings
         $PortObj->lookclear;                  # empty buffers
         $PortObj->write("Feed Me:");          # initial prompt
         $PortObj->is_prompt("More Food:");    # not implemented

         my $gotit = "";
         until ("" ne $gotit) {
             $gotit = $PortObj->lookfor;       # poll until data ready
             die "Aborted without match\n" unless (defined $gotit);
             sleep 1;                          # polling sample time
         }

         printf "gotit = %s\n", $gotit;                # input BEFORE the match
         my ($match, $after, $pattern, $instead) = $PortObj->lastlook;
             # input that MATCHED, input AFTER the match, PATTERN that matched
             # input received INSTEAD when timeout without match
         printf "lastlook-match = %s  -after = %s  -pattern = %s\n",
                                  $match,      $after,        $pattern;

         $gotit = $PortObj->lookfor($count);   # block until $count chars received

         $PortObj->are_match("-re", "pattern", "text");
             # possible match strings: "pattern" is a regular expression,
             #                         "text" is a literal string

DESCRIPTION
       This module provides an object-based user interface essentially
       identical to the one provided by the Win32::SerialPort module.

   Initialization
       The primary constructor is new with either a PortName, or a
       Configuretion File specified.  With a PortName, this will open the port
       and create the object. The port is not yet ready for read/write access.
       First, the desired parameter settings must be established. Since these
       are tuning constants for an underlying hardware driver in the Operating
       System, they are all checked for validity by the methods that set them.
       The write_settings method updates the port (and will return True under
       POSIX). Ports are opened for binary transfers. A separate "binmode" is
       not needed.

         $PortObj = new Device::SerialPort ($PortName, $quiet, $lockfile)
              || die "Can't open $PortName: $!\n";

       The $quiet parameter is ignored and is only there for compatibility
       with Win32::SerialPort.  The $lockfile parameter is optional.  It will
       attempt to create a file (containing just the current process id) at
       the location specified. This file will be automatically deleted when
       the $PortObj is no longer used (by DESTROY). You would usually request
       $lockfile with $quiet true to disable messages while attempting to
       obtain exclusive ownership of the port via the lock. Lockfiles are
       experimental in Version 0.07. They are intended for use with other
       applications. No attempt is made to resolve port aliases (/dev/modem ==
       /dev/ttySx) or to deal with login processes such as getty and uugetty.

       Using a Configuration File with new or by using second constructor,
       start, scripts can be simplified if they need a constant setup. It
       executes all the steps from new to write_settings based on a previously
       saved configuration. This constructor will return "undef" on a bad
       configuration file or failure of a validity check. The returned object
       is ready for access. This is new and experimental for Version 0.055.

         $PortObj2 = start Device::SerialPort ($Configuration_File_Name)
              || die;

       The third constructor, tie, will combine the start with Perl's support
       for tied FileHandles (see perltie). Device::SerialPort will implement
       the complete set of methods: TIEHANDLE, PRINT, PRINTF, WRITE, READ,
       GETC, READLINE, CLOSE, and DESTROY. Tied FileHandle support is new with
       Version 0.04 and the READ and READLINE methods were added in Version
       0.06. In "scalar context", READLINE sets stty_icanon to do character
       processing and calls lookfor. It restores stty_icanon after the read.
       In "list context", READLINE does Canonical (line) reads if stty_icanon
       is set or calls streamline if it is not. (stty_icanon is not altered).
       The streamline choice allows duplicating the operation of
       Win32::SerialPort for cross-platform scripts.

       The implementation attempts to mimic STDIN/STDOUT behaviour as closely
       as possible: calls block until done and data strings that exceed
       internal buffers are divided transparently into multiple calls. In
       Version 0.06, the output separators $, and "$\" are also applied to
       PRINT if set.  The output_record_separator and output_field_separator
       methods can set Port-FileHandle-Specific versions of $, and "$\" if
       desired. Since PRINTF is treated internally as a single record PRINT,
       "$\" will be applied.  Output separators are not applied to WRITE
       (called as "syswrite FH, $scalar, $length, [$offset]").  The
       input_record_separator $/ is not explicitly supported - but an
       identical function can be obtained with a suitable are_match setting.

         $PortObj2 = tie (*FH, 'Device::SerialPort', $Configuration_File_Name)
              || die;

       The tied FileHandle methods may be combined with the Device::SerialPort
       methods for read, input, and write as well as other methods. The
       typical restrictions against mixing print with syswrite do not apply.
       Since both (tied) read and sysread call the same "$ob->READ" method,
       and since a separate "$ob->read" method has existed for some time in
       Device::SerialPort, you should always use sysread with the tied
       interface (when it is implemented).

               Certain parameters SHOULD be set before executing
               write_settings.  Others will attempt to deduce defaults from
               the hardware or from other parameters. The Required parameters
               are:

               baudrate

               Any legal value.

               parity

               One of the following: "none", "odd", "even".

               By default, incoming parity is not checked.  This mimics the
               behavior of most terminal programs (like "minicom").  If you
               need parity checking enabled, please use the "stty_inpck" and
               "stty_istrip" functions.

               databits

               An integer from 5 to 8.

               stopbits

               Legal values are 1 and 2.

               handshake

               One of the following: "none", "rts", "xoff".

       Some individual parameters (eg. baudrate) can be changed after the
       initialization is completed. These will be validated and will update
       the serial driver as required. The save method will write the current
       parameters to a file that start, tie, and restart can use to
       reestablish a functional setup.

         $PortObj = new Win32::SerialPort ($PortName, $quiet)
              || die "Can't open $PortName: $^E\n";    # $quiet is optional

         $PortObj->user_msg(ON);
         $PortObj->databits(8);
         $PortObj->baudrate(9600);
         $PortObj->parity("none");
         $PortObj->stopbits(1);
         $PortObj->handshake("rts");

         $PortObj->write_settings || undef $PortObj;

         $PortObj->save($Configuration_File_Name);
         $PortObj->baudrate(300);
         $PortObj->restart($Configuration_File_Name);  # back to 9600 baud

         $PortObj->close || die "failed to close";
         undef $PortObj;                               # frees memory back to perl

   Configuration Utility Methods
       Use alias to convert the name used by "built-in" messages.

         $PortObj->alias("MODEM1");

       Starting in Version 0.07, a number of Application Variables are saved
       in $Configuration_File. These parameters are not used internally. But
       methods allow setting and reading them. The intent is to facilitate the
       use of separate configuration scripts to create the files. Then an
       application can use start as the Constructor and not bother with
       command line processing or managing its own small configuration file.
       The default values and number of parameters is subject to change.

         $PortObj->devicetype('none');
         $PortObj->hostname('localhost');  # for socket-based implementations
         $PortObj->hostaddr(0);            # a "false" value
         $PortObj->datatype('raw');        # 'record' is another possibility
         $PortObj->cfg_param_1('none');
         $PortObj->cfg_param_2('none');    # 3 spares should be enough for now
         $PortObj->cfg_param_3('none');

   Configuration and Capability Methods
       The Win32 Serial Comm API provides extensive information concerning the
       capabilities and options available for a specific port (and instance).
       This module will return suitable responses to facilitate porting code
       from that environment.

       The get_tick_count method is a clone of the Win32::GetTickCount()
       function. It matches a corresponding method in Win32::CommPort.  It
       returns time in milliseconds - but can be used in cross-platform
       scripts.

               Binary selections will accept as true any of the following:
               "("YES", "Y", "ON", "TRUE", "T", "1", 1)" (upper/lower/mixed
               case) Anything else is false.

               There are a large number of possible configuration and option
               parameters.  To facilitate checking option validity in scripts,
               most configuration methods can be used in two different ways:

               method called with an argument

               The parameter is set to the argument, if valid. An invalid
               argument returns false (undef) and the parameter is unchanged.
               The function will also carp if $user_msg is true. The port will
               be updated immediately if allowed (an automatic write_settings
               is called).

               method called with no argument in scalar context

               The current value is returned. If the value is not initialized
               either directly or by default, return "undef" which will parse
               to false.  For binary selections (true/false), return the
               current value. All current values from "multivalue" selections
               will parse to true.

               method called with no argument in list context

               Methods which only accept a limited number of specific input
               values return a list consisting of all acceptable choices. The
               null list "(undef)" will be returned for failed calls in list
               context (e.g. for an invalid or unexpected argument). Only the
               baudrate, parity, databits, stopbits, and handshake methods
               currently support this feature.

   Operating Methods
       Version 0.04 adds pulse methods for the RTS, BREAK, and DTR bits. The
       pulse methods assume the bit is in the opposite state when the method
       is called. They set the requested state, delay the specified number of
       milliseconds, set the opposite state, and again delay the specified
       time.  These methods are designed to support devices, such as the X10
       "FireCracker" control and some modems, which require pulses on these
       lines to signal specific events or data. Timing for the active part of
       pulse_break_on is handled by POSIX::tcsendbreak(0), which sends a
       250-500 millisecond BREAK pulse. It is NOT guaranteed to block until
       done.

         $PortObj->pulse_break_on($milliseconds);
         $PortObj->pulse_rts_on($milliseconds);
         $PortObj->pulse_rts_off($milliseconds);
         $PortObj->pulse_dtr_on($milliseconds);
         $PortObj->pulse_dtr_off($milliseconds);

       In Version 0.05, these calls and the rts_active and dtr_active calls
       verify the parameters and any required ioctl constants, and return
       "undef" unless the call succeeds. You can use the can_ioctl method to
       see if the required constants are available. On Version 0.04, the
       module would not load unless asm/termios.ph was found at startup.

   Stty Shortcuts
       Version 0.06 adds primitive methods to modify port parameters that
       would otherwise require a "system("stty...");" command. These act much
       like the identically-named methods in Win32::SerialPort. However, they
       are initialized from "current stty settings" when the port is opened
       rather than from defaults. And like stty settings, they are passed to
       the serial driver and apply to all operations rather than only to I/O
       processed via the lookfor method or the tied FileHandle methods.  Each
       returns the current setting for the parameter. There are no "global" or
       "combination" parameters - you still need system("stty...") for that.

       The methods which handle CHAR parameters set and return values as
       ord(CHAR).  This corresponds to the settings in the POSIX termios
       cc_field array. You are unlikely to actually want to modify most of
       these. They reflect the special characters which can be set by stty.

         $PortObj->is_xon_char($num_char);     # VSTART (stty start=.)
         $PortObj->is_xoff_char($num_char);    # VSTOP
         $PortObj->is_stty_intr($num_char);    # VINTR
         $PortObj->is_stty_quit($num_char);    # VQUIT
         $PortObj->is_stty_eof($num_char);     # VEOF
         $PortObj->is_stty_eol($num_char);     # VEOL
         $PortObj->is_stty_erase($num_char);   # VERASE
         $PortObj->is_stty_kill($num_char);    # VKILL
         $PortObj->is_stty_susp($num_char);    # VSUSP

       Binary settings supported by POSIX will return 0 or 1. Several
       parameters settable by stty do not yet have shortcut methods. Contact
       me if you need one that is not supported. These are the common choices.
       Try "man stty" if you are not sure what they do.

         $PortObj->stty_echo;
         $PortObj->stty_echoe;
         $PortObj->stty_echok;
         $PortObj->stty_echonl;
         $PortObj->stty_ignbrk;
         $PortObj->stty_istrip;
         $PortObj->stty_inpck;
         $PortObj->stty_parmrk;
         $PortObj->stty_ignpar;
         $PortObj->stty_icrnl;
         $PortObj->stty_igncr;
         $PortObj->stty_inlcr;
         $PortObj->stty_opost;
         $PortObj->stty_isig;
         $PortObj->stty_icanon;

       The following methods require successfully loading ioctl constants.
       They will return "undef" if the needed constants are not found. But the
       method calls may still be used without syntax errors or warnings even
       in that case.

         $PortObj->stty_ocrlf;
         $PortObj->stty_onlcr;
         $PortObj->stty_echoke;
         $PortObj->stty_echoctl;

   Lookfor and I/O Processing
       Some communications programs have a different need - to collect (or
       discard) input until a specific pattern is detected. For lines, the
       pattern is a line-termination. But there are also requirements to
       search for other strings in the input such as "username:" and
       "password:". The lookfor method provides a consistant mechanism for
       solving this problem.  It searches input character-by-character looking
       for a match to any of the elements of an array set using the are_match
       method. It returns the entire input up to the match pattern if a match
       is found. If no match is found, it returns "" unless an input error or
       abort is detected (which returns undef).

       Unlike Win32::SerialPort, lookfor does not handle backspace, echo, and
       other character processing. It expects the serial driver to handle
       those and to be controlled via stty. For interacting with humans, you
       will probably want stty_icanon(1) during lookfor to obtain familiar
       command-line response. The actual match and the characters after it (if
       any) may also be viewed using the lastlook method. It also adopts the
       convention from Expect.pm that match strings are literal text (tested
       using index) unless preceeded in the are_match list by a "-re", entry.
       The default are_match list is "("\n")", which matches complete lines.

          my ($match, $after, $pattern, $instead) = $PortObj->lastlook;
            # input that MATCHED, input AFTER the match, PATTERN that matched
            # input received INSTEAD when timeout without match ("" if match)

          $PortObj->are_match("text1", "-re", "pattern", "text2");
            # possible match strings: "pattern" is a regular expression,
            #                         "text1" and "text2" are literal strings

       Everything in lookfor is still experimental. Please let me know if you
       use it (or can't use it), so I can confirm bug fixes don't break your
       code.  For literal strings, $match and $pattern should be identical.
       The $instead value returns the internal buffer tested by the match
       logic.  A successful match or a lookclear resets it to "" - so it is
       only useful for error handling such as timeout processing or reporting
       unexpected responses.

       The lookfor method is designed to be sampled periodically (polled). Any
       characters after the match pattern are saved for a subsequent lookfor.
       Internally, lookfor is implemented using the nonblocking input method
       when called with no parameter. If called with a count, lookfor calls
       "$PortObj->read(count)" which blocks until the read is Complete or a
       Timeout occurs. The blocking alternative should not be used unless a
       fault time has been defined using read_interval, read_const_time, and
       read_char_time. It exists mostly to support the tied FileHandle
       functions sysread, getc, and <FH>. When stty_icanon is active, even the
       non-blocking calls will not return data until the line is complete.

       The internal buffers used by lookfor may be purged by the lookclear
       method (which also clears the last match). For testing, lookclear can
       accept a string which is "looped back" to the next input. This feature
       is enabled only when set_test_mode_active(1). Normally, lookclear will
       return "undef" if given parameters. It still purges the buffers and
       last_match in that case (but nothing is "looped back"). You will want
       stty_echo(0) when exercising loopback.

       The matchclear method is designed to handle the "special case" where
       the match string is the first character(s) received by lookfor. In this
       case, "$lookfor_return == """, lookfor does not provide a clear
       indication that a match was found. The matchclear returns the same
       $match that would be returned by lastlook and resets it to "" without
       resetting any of the other buffers. Since the lookfor already searched
       through the match, matchclear is used to both detect and step-over
       "blank" lines.

       The character-by-character processing used by lookfor is fine for
       interactive activities and tasks which expect short responses. But it
       has too much "overhead" to handle fast data streams.There is also a
       streamline method which is a fast, line-oriented alternative with just
       pattern searching. Since streamline uses the same internal buffers, the
       lookclear, lastlook, are_match, and matchclear methods act the same in
       both cases. In fact, calls to streamline and lookfor can be interleaved
       if desired (e.g. an interactive task that starts an upload and returns
       to interactive activity when it is complete).

       There are two additional methods for supporting "list context" input:
       lastline sets an "end_of_file" Regular Expression, and linesize permits
       changing the "packet size" in the blocking read operation to allow
       tuning performance to data characteristics. These two only apply during
       READLINE. The default for linesize is 1. There is no default for the
       lastline method.

       The Regular Expressions set by are_match and lastline will be pre-
       compiled using the qr// construct on Perl 5.005 and higher.  This
       doubled lookfor and streamline speed in my tests with Regular
       Expressions - but actual improvements depend on both patterns and input
       data.

       The functionality of lookfor includes a limited subset of the
       capabilities found in Austin Schutz's Expect.pm for Unix (and Tcl's
       expect which it resembles). The "$before, $match, $pattern, and $after"
       return values are available if someone needs to create an "expect"
       subroutine for porting a script. When using multiple patterns, there is
       one important functional difference: Expect.pm looks at each pattern in
       turn and returns the first match found; lookfor and streamline test all
       patterns and return the one found earliest in the input if more than
       one matches.

   Exports
       Nothing is exported by default. The following tags can be used to have
       large sets of symbols exported:

       :PARAM
           Utility subroutines and constants for parameter setting and test:

                   LONGsize        SHORTsize       nocarp          yes_true
                   OS_Error

       :STAT
           The Constants named BM_* and CE_* are omitted. But the modem status
           (MS_*) Constants are defined for possible use with modemlines and
           wait_modemlines. They are assigned to corresponding functions, but
           the bit position will be different from that on Win32.

           Which incoming bits are active:

                   MS_CTS_ON    - Clear to send
               MS_DSR_ON    - Data set ready
               MS_RING_ON   - Ring indicator
               MS_RLSD_ON   - Carrier detected
               MS_RTS_ON    - Request to send (might not exist on Win32)
               MS_DTR_ON    - Data terminal ready (might not exist on Win32)

           If you want to write more POSIX-looking code, you can use the
           constants seen there, instead of the Win32 versions:

               TIOCM_CTS, TIOCM_DSR, TIOCM_RI, TIOCM_CD, TIOCM_RTS, and TIOCM_DTR

           Offsets into the array returned by status:

                   ST_BLOCK        ST_INPUT        ST_OUTPUT       ST_ERROR

       :ALL
           All of the above. Except for the test suite, there is not really a
           good reason to do this.

PINOUT
       Here is a handy pinout map, showing each line and signal on a standard
       DB9 connector:

       1 DCD   Data Carrier Detect

       2 RD    Receive Data

       3 TD    Transmit Data

       4 DTR   Data Terminal Ready

       5 SG    Signal Ground

       6 DSR   Data Set Ready

       7 RTS   Request to Send

       8 CTS   Clear to Send

       9 RI    Ring Indicator

NOTES
       The object returned by new is NOT a Filehandle. You will be
       disappointed if you try to use it as one.

       e.g. the following is WRONG!!

        print $PortObj "some text";

       This module uses POSIX termios extensively. Raw API calls are very
       unforgiving. You will certainly want to start perl with the -w switch.
       If you can, use strict as well. Try to ferret out all the syntax and
       usage problems BEFORE issuing the API calls (many of which modify
       tuning constants in hardware device drivers....not where you want to
       look for bugs).

       With all the options, this module needs a good tutorial. It doesn't
       have one yet.

EXAMPLE
       It is recommended to always use "read(255)" due to some unexpected
       behavior with the termios under some operating systems (Linux and
       Solaris at least).  To deal with this, a routine is usually needed to
       read from the serial port until you have what you want.  This is a
       quick example of how to do that:

        my $port=Device::SerialPort->new("/dev/ttyS0");

        my $STALL_DEFAULT=10; # how many seconds to wait for new input

        my $timeout=$STALL_DEFAULT;

        $port->read_char_time(0);     # don't wait for each character
        $port->read_const_time(1000); # 1 second per unfulfilled "read" call

        my $chars=0;
        my $buffer="";
        while ($timeout>0) {
               my ($count,$saw)=$port->read(255); # will read _up to_ 255 chars
               if ($count > 0) {
                       $chars+=$count;
                       $buffer.=$saw;

                       # Check here to see if what we want is in the $buffer
                       # say "last" if we find it
               }
               else {
                       $timeout--;
               }
        }

        if ($timeout==0) {
               die "Waited $STALL_DEFAULT seconds and never saw what I wanted\n";
        }

PORTING
       For a serial port to work under Unix, you need the ability to do
       several types of operations.  With POSIX, these operations are
       implemented with a set of "tc*" functions.  However, not all Unix
       systems follow this correctly.  In those cases, the functions change,
       but the variables used as parameters generally turn out to be the same.

       Get/Set RTS
           This is only available through the
           bit-set(TIOCMBIS)/bit-clear(TIOCMBIC) ioctl function using the RTS
           value(TIOCM_RTS).

            ioctl($handle,$on ? $TIOCMBIS : $TIOCMBIC, $TIOCM_RTS);

       Get/Set DTR
           This is available through the bit-set(TIOCMBIS)/bit-clear(TIOCMBIC)
           ioctl function using the DTR value(TIOCM_DTR)

            ioctl($handle,$on ? $TIOCMBIS : $TIOCMBIC, $TIOCM_DTR);

           or available through the DTRSET/DTRCLEAR ioctl functions, if they
           exist.

            ioctl($handle,$on ? $TIOCSDTR : $TIOCCDTR, 0);

       Get modem lines
           To read Clear To Send (CTS), Data Set Ready (DSR), Ring Indicator
           (RING), and Carrier Detect (CD/RLSD), the TIOCMGET ioctl function
           must be used.

            ioctl($handle, $TIOCMGET, $status);

           To decode the individual modem lines, some bits have multiple
           possible constants:

           Clear To Send (CTS)
               TIOCM_CTS

           Data Set Ready (DSR)
               TIOCM_DSR

           Ring Indicator (RING)
               TIOCM_RNG TIOCM_RI

           Carrier Detect (CD/RLSD)
               TIOCM_CAR TIOCM_CD

       Get Buffer Status
           To get information about the state of the serial port input and
           output buffers, the TIOCINQ and TIOCOUTQ ioctl functions must be
           used.  I'm not totally sure what is returned by these functions
           across all Unix systems.  Under Linux, it is the integer number of
           characters in the buffer.

            ioctl($handle,$in ? $TIOCINQ : $TIOCOUTQ, $count);
            $count = unpack('i',$count);

       Get Line Status
           To get information about the state of the serial transmission line
           (to see if a write has made its way totally out of the serial port
           buffer), the TIOCSERGETLSR ioctl function must be used.
           Additionally, the "Get Buffer Status" methods must be functioning,
           as well as having the first bit of the result set (Linux is
           TIOCSER_TEMT, others unknown, but we've been using TIOCM_LE even
           though that should be returned from the TIOCMGET ioctl).

            ioctl($handle,$TIOCSERGETLSR, $status);
            $done = (unpack('i', $status) & $TIOCSER_TEMT);

       Set Flow Control
           Some Unix systems require special TCGETX/TCSETX ioctls functions
           and the CTSXON/RTSXOFF constants to turn on and off CTS/RTS "hard"
           flow control instead of just using the normal POSIX tcsetattr
           calls.

            ioctl($handle, $TCGETX, $flags);
            @bytes = unpack('SSSS',$flags);
            $bytes[0] = $on ? ($CTSXON | $RTSXOFF) : 0;
            $flags = pack('SSSS',@bytes);
            ioctl($handle, $TCSETX, $flags);

KNOWN LIMITATIONS
       The current version of the module has been tested with Perl 5.003 and
       above. It was initially ported from Win32 and was designed to be used
       without requiring a compiler or using XS. Since everything is
       (sometimes convoluted but still pure) Perl, you can fix flaws and
       change limits if required. But please file a bug report if you do.

       The read method, and tied methods which call it, currently can use a
       fixed timeout which approximates behavior of the Win32::SerialPort
       read_const_time and read_char_time methods. It is used internally by
       select. If the timeout is set to zero, the read call will return
       immediately. A read larger than 255 bytes will be split internally into
       255-byte POSIX calls due to limitations of select and VMIN.  The
       timeout is reset for each 255-byte segment. Hence, for large reads, use
       a read_const_time suitable for a 255-byte read. All of this is
       expeimental in Version 0.055.

         $PortObj->read_const_time(500);       # 500 milliseconds = 0.5 seconds
         $PortObj->read_char_time(5);          # avg time between read char

       The timing model defines the total time allowed to complete the
       operation.  A fixed overhead time is added to the product of bytes and
       per_byte_time.

       Read_Total = read_const_time + (read_char_time * bytes_to_read)

       Write timeouts and read_interval timeouts are not currently supported.

       On some machines, reads larger than 4,096 bytes may be truncated at
       4,096, regardless of the read size or read timing settings used. In
       this case, try turning on or increasing the inter-character delay on
       your serial device. Also try setting the read size to

         $PortObj->read(1) or $PortObj->read(255)

       and performing multiple reads until the transfer is completed.

BUGS
       See the limitations about lockfiles. Experiment if you like.

       With all the currently unimplemented features, we don't need any more.
       But there probably are some.

       Please send comments and bug reports to kees@outflux.net.

Win32::SerialPort & Win32API::CommPort
   Win32::SerialPort Functions Not Currently Supported
         $LatchErrorFlags = $PortObj->reset_error;

         $PortObj->read_interval(100);         # max time between read char
         $PortObj->write_char_time(5);
         $PortObj->write_const_time(100);

   Functions Handled in a POSIX system by "stty"
               xon_limit       xoff_limit      xon_char        xoff_char
               eof_char        event_char      error_char      stty_intr
               stty_quit       stty_eof        stty_eol        stty_erase
               stty_kill       stty_clear      is_stty_clear   stty_bsdel
               stty_echoke     stty_echoctl    stty_ocrnl      stty_onlcr

   Win32::SerialPort Functions Not Ported to POSIX
               transmit_char

   Win32API::CommPort Functions Not Ported to POSIX
               init_done       fetch_DCB       update_DCB      initialize
               are_buffers     are_baudrate    are_handshake   are_parity
               are_databits    are_stopbits    is_handshake    xmit_imm_char
               is_baudrate     is_parity       is_databits     is_write_char_time
               debug_comm      is_xon_limit    is_xoff_limit   is_read_const_time
               suspend_tx      is_eof_char     is_event_char   is_read_char_time
               is_read_buf     is_write_buf    is_buffers      is_read_interval
               is_error_char   resume_tx       is_stopbits     is_write_const_time
               is_binary       is_status       write_bg        is_parity_enable
               is_modemlines   read_bg         read_done       break_active
               xoff_active     is_read_buf     is_write_buf    xon_active

   "raw" Win32 API Calls and Constants
       A large number of Win32-specific elements have been omitted. Most of
       these are only available in Win32::SerialPort and Win32API::CommPort as
       optional Exports. The list includes the following:

       :RAW
           The API Wrapper Methods and Constants used only to support them
           including PURGE_*, SET*, CLR*, EV_*, and ERROR_IO*

       :COMMPROP
           The Constants used for Feature and Properties Detection including
           BAUD_*, PST_*, PCF_*, SP_*, DATABITS_*, STOPBITS_*, PARITY_*, and
           COMMPROP_INITIALIZED

       :DCB
           The constants for the Win32 Device Control Block including CBR_*,
           DTR_*, RTS_*, *PARITY, *STOPBIT*, and FM_*

   Compatibility
       This code implements the functions required to support the MisterHouse
       Home Automation software by Bruce Winter. It does not attempt to
       support functions from Win32::SerialPort such as stty_emulation that
       already have POSIX implementations or to replicate Win32 idosyncracies.
       However, the supported functions are intended to clone the equivalent
       functions in Win32::SerialPort and Win32API::CommPort. Any
       discrepancies or omissions should be considered bugs and reported to
       the maintainer.

AUTHORS
        Based on Win32::SerialPort.pm, Version 0.8, by Bill Birthisel
        Ported to linux/POSIX by Joe Doss for MisterHouse
        Ported to Solaris/POSIX by Kees Cook for Sendpage
        Ported to BSD/POSIX by Kees Cook
        Ported to Perl XS by Kees Cook

        Currently maintained by:
        Kees Cook, kees@outflux.net, http://outflux.net/

SEE ALSO
       Win32API::CommPort

       Win32::SerialPort

       perltoot - Tom Christiansen's Object-Oriented Tutorial

COPYRIGHT
        Copyright (C) 1999, Bill Birthisel. All rights reserved.
        Copyright (C) 2000-2007, Kees Cook.  All rights reserved.

       This module is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

POD ERRORS
       Hey! The above document had some coding errors, which are explained
       below:

       Around line 2647:
           You can't have =items (as at line 2653) unless the first thing
           after the =over is an =item

       Around line 2737:
           You can't have =items (as at line 2747) unless the first thing
           after the =over is an =item

perl v5.40.2                      2007-10-24                     SerialPort(3)
