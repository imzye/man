Mojo::Pg(3)           User Contributed Perl Documentation          Mojo::Pg(3)


NAME
       Mojo::Pg - Mojolicious ♥ PostgreSQL

SYNOPSIS
         use Mojo::Pg;

         # Use a PostgreSQL connection string for configuration
         my $pg = Mojo::Pg->new('postgresql://postgres@/test');

         # Select the server version
         say $pg->db->query('SELECT VERSION() AS version')->hash->{version};

         # Use migrations to create a table
         $pg->migrations->name('my_names_app')->from_string(<<EOF)->migrate;
         -- 1 up
         CREATE TABLE names (id SERIAL PRIMARY KEY, name TEXT);
         -- 1 down
         DROP TABLE names;
         EOF

         # Use migrations to drop and recreate the table
         $pg->migrations->migrate(0)->migrate;

         # Get a database handle from the cache for multiple queries
         my $db = $pg->db;

         # Use SQL::Abstract to generate simple CRUD queries for you
         $db->insert('names', {name => 'Isabell'});
         my $id = $db->select('names', ['id'], {name => 'Isabell'})->hash->{id};
         $db->update('names', {name => 'Belle'}, {id => $id});
         $db->delete('names', {name => 'Belle'});

         # Insert a few rows in a transaction with SQL and placeholders
         eval {
           my $tx = $db->begin;
           $db->query('INSERT INTO names (name) VALUES (?)', 'Sara');
           $db->query('INSERT INTO names (name) VALUES (?)', 'Stefan');
           $tx->commit;
         };
         say $@ if $@;

         # Insert another row with SQL::Abstract and return the generated id
         say $db->insert('names', {name => 'Daniel'}, {returning => 'id'})->hash->{id};

         # JSON roundtrip
         say $db->query('SELECT ?::JSON AS foo', {json => {bar => 'baz'}})
           ->expand->hash->{foo}{bar};

         # Select all rows blocking with SQL::Abstract
         say $_->{name} for $db->select('names')->hashes->each;

         # Select all rows non-blocking with SQL::Abstract
         $db->select('names' => sub ($db, $err, $results) {
           die $err if $err;
           say $_->{name} for $results->hashes->each;
         });
         Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

         # Concurrent non-blocking queries (synchronized with promises)
         my $now   = $pg->db->query_p('SELECT NOW() AS now');
         my $names = $pg->db->query_p('SELECT * FROM names');
         Mojo::Promise->all($now, $names)->then(sub ($now, $names) {
           say $now->[0]->hash->{now};
           say $_->{name} for $names->[0]->hashes->each;
         })->catch(sub ($err) {
           warn "Something went wrong: $err";
         })->wait;

         # Send and receive notifications non-blocking
         $pg->pubsub->listen(foo => sub ($pubsub, $payload) {
           say "foo: $payload";
           $pubsub->notify(bar => $payload);
         });
         $pg->pubsub->listen(bar => sub ($pubsub, $payload) {
           say "bar: $payload";
         });
         $pg->pubsub->notify(foo => 'PostgreSQL rocks!');
         Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

DESCRIPTION
       Mojo::Pg is a tiny wrapper around DBD::Pg that makes PostgreSQL
       <http://www.postgresql.org> a lot of fun to use with the Mojolicious
       <https://mojolicious.org> real-time web framework. Perform queries
       blocking and non-blocking, use all SQL features
       <https://www.postgresql.org/docs/current/static/sql.html> PostgreSQL
       has to offer, generate CRUD queries from data structures, manage your
       database schema with migrations and build scalable real-time web
       applications with the publish/subscribe pattern.

BASICS
       Database and statement handles are cached automatically, and will be
       reused transparently to increase performance. You can handle connection
       timeouts gracefully by holding on to them only for short amounts of
       time.

         use Mojolicious::Lite -signatures;
         use Mojo::Pg;

         helper pg => sub { state $pg = Mojo::Pg->new('postgresql://postgres@/test') };

         get '/' => sub ($c) {
           my $db = $c->pg->db;
           $c->render(json => $db->query('SELECT NOW() AS now')->hash);
         };

         app->start;

       In this example application, we create a "pg" helper to store a
       Mojo::Pg object. Our action calls that helper and uses the method "db"
       in Mojo::Pg to dequeue a Mojo::Pg::Database object from the connection
       pool. Then we use the method "query" in Mojo::Pg::Database to execute
       an SQL <http://www.postgresql.org/docs/current/static/sql.html>
       statement, which returns a Mojo::Pg::Results object. And finally we
       call the method "hash" in Mojo::Pg::Results to retrieve the first row
       as a hash reference.

       While all I/O operations are performed blocking, you can wait for long
       running queries asynchronously, allowing the Mojo::IOLoop event loop to
       perform other tasks in the meantime. Since database connections usually
       have a very low latency, this often results in very good performance.

       Every database connection can only handle one active query at a time,
       this includes asynchronous ones. To perform multiple queries
       concurrently, you have to use multiple connections.

         # Performed concurrently (5 seconds)
         $pg->db->query('SELECT PG_SLEEP(5)' => sub ($db, $err, $results) {...});
         $pg->db->query('SELECT PG_SLEEP(5)' => sub ($db, $err, $results) {...});

       All cached database handles will be reset automatically if a new
       process has been forked, this allows multiple processes to share the
       same Mojo::Pg object safely.

GROWING
       And as your application grows, you can move queries into model classes.

         package MyApp::Model::Time;
         use Mojo::Base -base, -signatures;

         has 'pg';

         sub now ($self) {
           return $self->pg->db->query('SELECT NOW() AS now')->hash;
         }

         1;

       Which get integrated into your application with helpers.

         use Mojolicious::Lite -signatures;
         use Mojo::Pg;
         use MyApp::Model::Time;

         helper pg   => sub { state $pg   = Mojo::Pg->new('postgresql://postgres@/test') };
         helper time => sub { state $time = MyApp::Model::Time->new(pg => shift->pg) };

         get '/' => sub ($c) {
           $c->render(json => $c->time->now);
         };

         app->start;

EXAMPLES
       This distribution also contains two great example applications
       <https://github.com/mojolicious/mojo-pg/tree/main/examples/> you can
       use for inspiration. The minimal chat
       <https://github.com/mojolicious/mojo-pg/tree/main/examples/chat.pl>
       application will show you how to scale WebSockets to multiple servers,
       and the well-structured blog <https://github.com/mojolicious/mojo-
       pg/tree/main/examples/blog> application how to apply the MVC design
       pattern in practice.

EVENTS
       Mojo::Pg inherits all events from Mojo::EventEmitter and can emit the
       following new ones.

   connection
         $pg->on(connection => sub ($pg, $dbh) {
           ...
         });

       Emitted when a new database connection has been established.

         $pg->on(connection => sub ($pg, $dbh) {
           $dbh->do('SET search_path TO my_schema');
         });

ATTRIBUTES
       Mojo::Pg implements the following attributes.

   abstract
         my $abstract = $pg->abstract;
         $pg          = $pg->abstract(SQL::Abstract::Pg->new);

       SQL::Abstract::Pg object used to generate CRUD queries for
       Mojo::Pg::Database, defaults to enabling "array_datatypes" and setting
       "name_sep" to "." and "quote_char" to """.

         # Generate WHERE clause and bind values
         my($stmt, @bind) = $pg->abstract->where({foo => 'bar', baz => 'yada'});

   auto_migrate
         my $bool = $pg->auto_migrate;
         $pg      = $pg->auto_migrate($bool);

       Automatically migrate to the latest database schema with "migrations",
       as soon as "db" has been called for the first time.

   database_class
         my $class = $pg->database_class;
         $pg       = $pg->database_class('MyApp::Database');

       Class to be used by "db", defaults to Mojo::Pg::Database. Note that
       this class needs to have already been loaded before "db" is called.

   dsn
         my $dsn = $pg->dsn;
         $pg     = $pg->dsn('dbi:Pg:dbname=foo');

       Data source name, defaults to "dbi:Pg:".

   max_connections
         my $max = $pg->max_connections;
         $pg     = $pg->max_connections(3);

       Maximum number of idle database handles to cache for future use,
       defaults to 1.

   migrations
         my $migrations = $pg->migrations;
         $pg            = $pg->migrations(Mojo::Pg::Migrations->new);

       Mojo::Pg::Migrations object you can use to change your database schema
       more easily.

         # Load migrations from file and migrate to latest version
         $pg->migrations->from_file('/home/sri/migrations.sql')->migrate;

   options
         my $options = $pg->options;
         $pg         = $pg->options({AutoCommit => 1, RaiseError => 1});

       Options for database handles, defaults to activating "AutoCommit",
       "AutoInactiveDestroy" as well as "RaiseError" and deactivating
       "PrintError" as well as "PrintWarn". Note that "AutoCommit" and
       "RaiseError" are considered mandatory, so deactivating them would be
       very dangerous.

   parent
         my $parent = $pg->parent;
         $pg        = $pg->parent(Mojo::Pg->new);

       Another Mojo::Pg object to use for connection management, instead of
       establishing and caching our own database connections.

   password
         my $password = $pg->password;
         $pg          = $pg->password('s3cret');

       Database password, defaults to an empty string.

   pubsub
         my $pubsub = $pg->pubsub;
         $pg        = $pg->pubsub(Mojo::Pg::PubSub->new);

       Mojo::Pg::PubSub object you can use to send and receive notifications
       very efficiently, by sharing a single database connection with many
       consumers.

         # Subscribe to a channel
         $pg->pubsub->listen(news => sub ($pubsub, $payload) {
           say "Received: $payload";
         });

         # Notify a channel
         $pg->pubsub->notify(news => 'PostgreSQL rocks!');

   search_path
         my $path = $pg->search_path;
         $pg      = $pg->search_path(['$user', 'foo', 'public']);

       Schema search path assigned to all new connections.

         # Isolate tests and avoid race conditions when running them in parallel
         my $pg = Mojo::Pg->new('postgresql:///test')->search_path(['test_one']);
         $pg->db->query('DROP SCHEMA IF EXISTS test_one CASCADE');
         $pg->db->query('CREATE SCHEMA test_one');
         ...
         $pg->db->query('DROP SCHEMA test_one CASCADE');

   username
         my $username = $pg->username;
         $pg          = $pg->username('sri');

       Database username, defaults to an empty string.

METHODS
       Mojo::Pg inherits all methods from Mojo::EventEmitter and implements
       the following new ones.

   db
         my $db = $pg->db;

       Get a database object based on "database_class" (which is usually
       Mojo::Pg::Database) for a cached or newly established database
       connection. The DBD::Pg database handle will be automatically cached
       again when that object is destroyed, so you can handle problems like
       connection timeouts gracefully by holding on to it only for short
       amounts of time.

         # Add up all the money
         say $pg->db->select('accounts')->hashes->reduce(sub { $a->{money} + $b->{money} });

   from_string
         $pg = $pg->from_string('postgresql://postgres@/test');
         $pg = $pg->from_string(Mojo::Pg->new);

       Parse configuration from connection string or use another Mojo::Pg
       object as "parent".

         # Just a database
         $pg->from_string('postgresql:///db1');

         # Just a service
         $pg->from_string('postgresql://?service=foo');

         # Username and database
         $pg->from_string('postgresql://sri@/db2');

         # Short scheme, username, password, host and database
         $pg->from_string('postgres://sri:s3cret@localhost/db3');

         # Username, domain socket and database
         $pg->from_string('postgresql://sri@%2ftmp%2fpg.sock/db4');

         # Username, database and additional options
         $pg->from_string('postgresql://sri@/db5?PrintError=1&pg_server_prepare=0');

         # Service and additional options
         $pg->from_string('postgresql://?service=foo&PrintError=1&RaiseError=0');

         # Username, database, an option and search_path
         $pg->from_string('postgres://sri@/db6?&PrintError=1&search_path=test_schema');

   new
         my $pg = Mojo::Pg->new;
         my $pg = Mojo::Pg->new('postgresql://postgres@/test');
         my $pg = Mojo::Pg->new(Mojo::Pg->new);

       Construct a new Mojo::Pg object and parse connection string with
       "from_string" if necessary.

         # Customize configuration further
         my $pg = Mojo::Pg->new->dsn('dbi:Pg:service=foo');

   reset
         $pg = $pg->reset;

       Reset connection cache.

DEBUGGING
       You can set the "DBI_TRACE" environment variable to get some advanced
       diagnostics information printed by DBI.

         DBI_TRACE=1
         DBI_TRACE=15
         DBI_TRACE=SQL

API
       This is the class hierarchy of the Mojo::Pg distribution.

       • Mojo::Pg

       • Mojo::Pg::Database

       • Mojo::Pg::Migrations

       • Mojo::Pg::PubSub

       • Mojo::Pg::Results

       • Mojo::Pg::Transaction

AUTHOR
       Sebastian Riedel, "sri@cpan.org".

CREDITS
       In alphabetical order:

         Christopher Eveland

         Dan Book

         Flavio Poletti

         Hernan Lopes

         Joel Berger

         Matt S Trout

         Peter Rabbitson

         William Lindley

COPYRIGHT AND LICENSE
       Copyright (C) 2014-2022, Sebastian Riedel and others.

       This program is free software, you can redistribute it and/or modify it
       under the terms of the Artistic License version 2.0.

SEE ALSO
       <https://github.com/mojolicious/mojo-pg>, Mojolicious::Guides,
       <https://mojolicious.org>.

perl v5.40.2                      2022-03-10                       Mojo::Pg(3)
