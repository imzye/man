DBIx::Class::ResultSet::RecursiveUpdate(3) User Contributed Perl Documentation


NAME
       DBIx::Class::ResultSet::RecursiveUpdate - like update_or_create - but
       recursive

VERSION
       version 0.45

SYNOPSIS
           # The functional interface:

           my $schema = MyDB::Schema->connect();
           my $new_item = DBIx::Class::ResultSet::RecursiveUpdate::Functions::recursive_update(
               resultset => $schema->resultset('User'),
               updates => {
                   id => 1,
                   owned_dvds => [
                       {
                           title => "One Flew Over the Cuckoo's Nest"
                       }
                   ]
               },
               unknown_params_ok => 1,
           );


           # As ResultSet subclass:

           __PACKAGE__->load_namespaces( default_resultset_class => '+DBIx::Class::ResultSet::RecursiveUpdate' );

           # in the Schema file (see t/lib/DBSchema.pm).  Or appropriate 'use base' in the ResultSet classes.

           my $user = $schema->resultset('User')->recursive_update({
               id => 1,
               owned_dvds => [
                   {
                       title => "One Flew Over the Cuckoo's Nest"
                   }
               ]
           }, {
               unknown_params_ok => 1,
           });

           # You'll get a warning if you pass non-result specific data to
           # recursive_update. See L</"Additional data in the updates hashref">
           # for more information how to prevent this.

DESCRIPTION
       You can feed the ->create method of DBIx::Class with a recursive
       datastructure and have the related records created. Unfortunately you
       cannot do a similar thing with update_or_create. This module tries to
       fill that void until DBIx::Class has an api itself.

       The functional interface can be used without modifications of the
       model, for example by form processors like
       HTML::FormHandler::Model::DBIC.

       It is a base class for DBIx::Class::ResultSets providing the method
       recursive_update which works just like update_or_create but can
       recursively update or create result objects composed of multiple rows.
       All rows need to be identified by primary keys so you need to provide
       them in the update structure (unless they can be deduced from the
       parent row. For example a related row of a belongs_to relationship). If
       any of the primary key columns are missing, a new row will be created,
       with the expectation that the missing columns will be filled by it (as
       in the case of auto_increment primary keys).

       If the resultset itself stores an assignment for the primary key, like
       in the case of:

           my $restricted_rs = $user_rs->search( { id => 1 } );

       you need to inform recursive_update about the additional predicate with
       the fixed_fields attribute:

           my $user = $restricted_rs->recursive_update( {
                   owned_dvds => [
                   {
                       title => 'One Flew Over the Cuckoo's Nest'
                   }
                   ]
               },
               {
                   fixed_fields => [ 'id' ],
               }
           );

       For a many_to_many (pseudo) relation you can supply a list of primary
       keys from the other table and it will link the record at hand to those
       and only those records identified by them. This is convenient for
       handling web forms with check boxes (or a select field with multiple
       choice) that lets you update such (pseudo) relations.

       For a description how to set up base classes for ResultSets see
       "load_namespaces" in DBIx::Class::Schema.

   Additional data in the updates hashref
       If you pass additional data to recursive_update which doesn't match a
       column name, column accessor, relationship or many-to-many helper
       accessor, it will throw a warning by default. To disable this behaviour
       you can set the unknown_params_ok attribute to a true value.

       The warning thrown is: "No such column, relationship, many-to-many
       helper accessor or generic accessor '$key'"

       When used by HTML::FormHandler::Model::DBIC this can happen if you have
       additional form fields that aren't relevant to the database but don't
       have the noupdate attribute set to a true value.

       NOTE: in a future version this behaviour will change and throw an
       exception instead of a warning!

DESIGN CHOICES
       Columns and relationships which are excluded from the updates hashref
       aren't touched at all.

   Treatment of belongs_to relations
       In case the relationship is included but undefined in the updates
       hashref, all columns forming the relationship will be set to null.  If
       not all of them are nullable, DBIx::Class will throw an error.

       Updating the relationship:

           my $dvd = $dvd_rs->recursive_update( {
               id    => 1,
               owner => $user->id,
           });

       Clearing the relationship (only works if cols are nullable!):

           my $dvd = $dvd_rs->recursive_update( {
               id    => 1,
               owner => undef,
           });

       Updating a relationship including its (full) primary key:

           my $dvd = $dvd_rs->recursive_update( {
               id    => 1,
               owner => {
                   id   => 2,
                   name => "George",
               },
           });

   Treatment of might_have relationships
       In case the relationship is included but undefined in the updates
       hashref, all columns forming the relationship will be set to null.

       Updating the relationship:

           my $user = $user_rs->recursive_update( {
               id => 1,
               address => {
                   street => "101 Main Street",
                   city   => "Podunk",
                   state  => "New York",
               }
           });

       Clearing the relationship:

           my $user = $user_rs->recursive_update( {
               id => 1,
               address => undef,
           });

   Treatment of has_many relations
       If a relationship key is included in the data structure with a value of
       undef or an empty array, all existing related rows will be deleted, or
       their foreign key columns will be set to null.

       The exact behaviour depends on the nullability of the foreign key
       columns and the value of the "if_not_submitted" parameter. The
       parameter defaults to undefined which neither nullifies nor deletes.

       When the array contains elements they are updated if they exist,
       created when not and deleted if not included.

       All foreign table columns are nullable

       In this case recursive_update defaults to nullifying the foreign
       columns.

       Not all foreign table columns are nullable

       In this case recursive_update deletes the foreign rows.

       Updating the relationship:

           Passing ids:

           my $user = $user_rs->recursive_update( {
               id         => 1,
               owned_dvds => [1, 2],
           });

           Passing hashrefs:

           my $user = $user_rs->recursive_update( {
               id         => 1,
               owned_dvds => [
                   {
                       name => 'temp name 1',
                   },
                   {
                       name => 'temp name 2',
                   },
               ],
           });

           Passing objects:

           my $user = $user_rs->recursive_update( {
               id         => 1,
               owned_dvds => [ $dvd1, $dvd2 ],
           });

           You can even mix them:

           my $user = $user_rs->recursive_update( {
               id         => 1,
               owned_dvds => [ 1, { id => 2 } ],
           });

       Clearing the relationship:

           my $user = $user_rs->recursive_update( {
               id         => 1,
               owned_dvds => undef,
           });

           This is the same as passing an empty array:

           my $user = $user_rs->recursive_update( {
               id         => 1,
               owned_dvds => [],
           });

   Treatment of many-to-many pseudo relations
       If a many-to-many accessor key is included in the data structure with a
       value of undef or an empty array, all existing related rows are
       unlinked.

       When the array contains elements they are updated if they exist,
       created when not and deleted if not included.

       RecursiveUpdate defaults to calling 'set_$rel' to update many-to-many
       relationships.  See "many_to_many" in DBIx::Class::Relationship for
       details.  set_$rel effectively removes and re-adds all relationship
       data, even if the set of related items did not change at all.

       If DBIx::Class::IntrospectableM2M is in use, RecursiveUpdate will look
       up the corresponding has_many relationship and use this to recursively
       update the many-to-many relationship.

       While both mechanisms have the same final result, deleting and re-
       adding all relationship data can have unwanted consequences if triggers
       or method modifiers are defined or logging modules like
       DBIx::Class::AuditLog are in use.

       The traditional "set_$rel" behaviour can be forced by passing
       "m2m_force_set_rel => 1" to recursive_update.

       See "is_m2m" for many-to-many pseudo relationship detection.

       Updating the relationship:

           Passing ids:

           my $dvd = $dvd_rs->recursive_update( {
               id   => 1,
               tags => [1, 2],
           });

           Passing hashrefs:

           my $dvd = $dvd_rs->recursive_update( {
               id   => 1,
               tags => [
                   {
                       id   => 1,
                       file => 'file0'
                   },
                   {
                       id   => 2,
                       file => 'file1',
                   },
               ],
           });

           Passing objects:

           my $dvd = $dvd_rs->recursive_update( {
               id   => 1,
               tags => [ $tag1, $tag2 ],
           });

           You can even mix them:

           my $dvd = $dvd_rs->recursive_update( {
               id   => 1,
               tags => [ 2, { id => 3 } ],
           });

       Clearing the relationship:

           my $dvd = $dvd_rs->recursive_update( {
               id   => 1,
               tags => undef,
           });

           This is the same as passing an empty array:

           my $dvd = $dvd_rs->recursive_update( {
               id   => 1,
               tags => [],
           });

       Make sure that set_$rel used to update many-to-many relationships even
       if IntrospectableM2M is loaded:

           my $dvd = $dvd_rs->recursive_update( {
               id   => 1,
               tags => [1, 2],
           },
           { m2m_force_set_rel => 1 },
           );

INTERFACE
METHODS
   recursive_update
       The method that does the work here.

   is_m2m
       Arguments: $name
       Return Value: true, if $name is a many to many pseudo-relationship

       The function gets the information about m2m relations from
       DBIx::Class::IntrospectableM2M. If it isn't loaded in the ResultSource
       class, the code relies on the fact:

           if($object->can($name) and
                    !$object->result_source->has_relationship($name) and
                    $object->can( 'set_' . $name )
                )

       to identify a many to many pseudo relationship. In a similar ugly way
       the ResultSource of that many to many pseudo relationship is detected.

       So if you need many to many pseudo relationship support, it's strongly
       recommended to load DBIx::Class::IntrospectableM2M in your ResultSource
       class!

   get_m2m_source
       Arguments: $name
       Return Value: $result_source

CONFIGURATION AND ENVIRONMENT
       DBIx::Class::RecursiveUpdate requires no configuration files or
       environment variables.

DEPENDENCIES
           DBIx::Class

       optional but recommended:
           DBIx::Class::IntrospectableM2M

INCOMPATIBILITIES
       None reported.

BUGS AND LIMITATIONS
       The list of reported bugs can be viewed at
       <http://rt.cpan.org/Public/Dist/Display.html?Name=DBIx-Class-ResultSet-RecursiveUpdate>.

       Please report any bugs or feature requests to
       "bug-DBIx-Class-ResultSet-RecursiveUpdate@rt.cpan.org", or through the
       web interface at <http://rt.cpan.org>.

AUTHORS
       •   Zbigniew Lukasiak <zby@cpan.org>

       •   John Napiorkowski <jjnapiork@cpan.org>

       •   Alexander Hartmaier <abraxxa@cpan.org>

       •   Gerda Shank <gshank@cpan.org>

COPYRIGHT AND LICENSE
       This software is copyright (c) 2025 by Zbigniew Lukasiak, John
       Napiorkowski, Alexander Hartmaier.

       This is free software; you can redistribute it and/or modify it under
       the same terms as the Perl 5 programming language system itself.

perl v5.40.2                      2025-01-09
                                    DBIx::Class::ResultSet::RecursiveUpdate(3)
