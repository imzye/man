JOE()                                                                    JOE()

NAME
       JOE - Joe´s Own Editor

Syntax
       joe [global-options] [ [local-options] filename ]...
       jstar [global-options] [ [local-options] filename ]...
       jmacs [global-options] [ [local-options] filename ]...
       rjoe [global-options] [ [local-options] filename ]...
       jpico [global-options] [ [local-options] filename ]...

Description
       JOE is a powerful console screen editor. It has a "mode-less" user
       interface which is similar to many user-friendly PC editors. Users of
       Micro-Pro´s WordStar or Borland´s "Turbo" languages will feel at home.
       JOE is a full featured UNIX screen-editor though, and has many features
       for editing programs and text.

       JOE also emulates several other editors. JSTAR is a close imitation of
       WordStar with many "JOE" extensions. JPICO is a close imitation of the
       Pine mailing system´s PICO editor, but with many extensions and
       improvements. JMACS is a GNU-EMACS imitation. RJOE is a restricted
       version of JOE, which allows you to edit only the files specified on
       the command line.

       Although JOE is actually five different editors, it still requires only
       one executable, but one with five different names. The name of the
       editor with an "rc" appended gives the name of JOE´s initialization
       file, which determines the personality of the editor.

       JOE is free software; you can distribute it and/or modify it under the
       terms of the GNU General Public License as published by the Free
       Software Foundation. JOE is available over the Internet from
       http://www.sourceforge.net/projects/joe-editor.

Usage
       To start the editor, type joe followed by zero or more names of files
       you want to edit. Each file name may be preceded by a local option
       setting (see the local options table which follows). Other global
       options, which apply to the editor as a whole, may also be placed on
       the command line (see the global options table which follows). If you
       are editing a new file, you can either give the name of the new file
       when you invoke the editor, or in the editor when you save the new
       file. A modified syntax for file names is provided to allow you to edit
       program output, standard input/output, or sections of files or devices.
       See the section Filenames below for details.

       Once you are in the editor, you can type in text and use special
       control-character sequences to perform other editing tasks. To find out
       what the control-character sequences are, read the rest of this man
       page or type ^K H for help in the editor.

       Now for some obscure computer-lore:

       The ^ means that you hold down the Control key while pressing the
       following key (the same way the Shift key works for uppercase letters).
       A number of control-key sequences are duplicated on other keys, so that
       you don´t need to press the control key: Esc will work in place of ^[,
       Del will work in place of ^?, Backspace will work in place of ^H, Tab
       will work in place of ^I, Return or Enter will work in place of ^M and
       Linefeed will work in place of ^J. Some keyboards may give you trouble
       with some control keys. ^_, ^^ and ^@ can usually be entered without
       pressing shift (i.e., try ^-, ^6 and ^2). Other keyboards may reassign
       these to other keys. Try: ^., ^, and ^/. ^Space can usually be used in
       place of ^@. ^\ and ^] are interpreted by many communication programs,
       including telnet and kermit. Usually you just hit the key twice to get
       it to pass through the communication program.

       On some keyboards, holding the Alt key down while pressing another key
       is the same as typing Esc before typing the other key.

       Once you have typed ^K H, the first help window appears at the top of
       the screen. You can continue to enter and edit text while the help
       window is on. To page through other topics, hit Esc , and Esc . (that
       is, Esc , and Esc .). Use ^K H to dismiss the help window.

       You can customize the keyboard layout, the help screens and a number of
       behavior defaults by copying JOE´s initialization file (usually
       /etc/joe/joerc) to .joerc in your home directory and then by modifying
       it. See the section joerc below.

       To have JOE used as your default editor for e-mail and News, you need
       to set the EDITOR and VISUAL environment variables in your shell
       initialization file (.cshrc or .profile) to refer to JOE (JOE usually
       resides as /usr/bin/joe).

       There are a number of other obscure invocation parameters which may
       have to be set, particularly if your terminal screen is not updating as
       you think it should. See the section Environment variables below.



Command Line Options
       These options can also be specified in the joerc file. Local options
       can be set depending on the file-name extension. Programs (.c, .h or .p
       extension) usually have autoindent enabled. Wordwrap is enabled on
       other files, but rc files have it disabled.

       An option is enabled when it´s given like this:



           -wordwrap




       An option is disabled when it´s given like this:



           --wordwrap




       Some options take arguments. Arguments are given like this:



           -lmargin 5




       The following global options may be specified on the command line:

       •   asis
           Characters with codes above 127 will be sent to the terminal as-is,
           instead of as inverse of the corresponding character below 128. If
           this does not work, check your terminal server. This option has no
           effect if UTF-8 encoding is used.


       •   assume_256color
           Assume ANSI-like terminal emulator supports 256 colors even if
           termcap entry says it doesn´t.


       •   assume_color
           Assume ANSI-like terminal emulator supports color even if termcap
           entry says it doesn´t.


       •   text_color color
           Set color for text.


       •   status_color color
           Set color for status bar.


       •   help_color color
           Set color for help.


       •   menu_color color
           Set color for menus.


       •   prompt_color color
           Set color for prompts.


       •   msg_color color
           Set color for messages.


       •   autoswap
           Automatically swap ^K B with ^K K if necessary to mark a legal
           block during block copy/move commands.


       •   backpath path
           Sets path to a directory where all backup files are to be stored.
           If this is unset (the default) backup files are stored in the
           directory containing the file.


       •   baud nnn
           Set the baud rate for the purposes of terminal screen optimization
           (overrides value reported by stty). JOE inserts delays for baud
           rates below 19200, which bypasses tty buffering so that typeahead
           will interrupt the screen output. Scrolling commands will not be
           used for 38400 baud and above. This is useful for X-terms and other
           console ttys which really aren´t going over a serial line.


       •   beep
           Enable beeps when edit commands return errors, for example when the
           cursor goes past extremes.


       •   break_links
           When enabled, JOE first deletes the file before writing it in order
           to break hard-links and symbolic-links.


       •   break_hardlinks
           When enabled, and the file is not a symbolic links, JOE first
           deletes the file before writing it in order to break hard-links.


       •   brpaste
           When JOE starts, send command to the terminal emulator that enables
           "bracketed paste mode" (but only if the terminal seems to have the
           ANSI command set). In this mode, text pasted into the window is
           bracketed with ESC [ 2 0 0 ~ and ESC [ 2 0 1 ~.


       •   columns nnn
           Set number of columns in terminal emulator (in case termcap entry
           is wrong). This is only useful on old system which don´t have the
           "get window size" ioctl.


       •   csmode
           Enable continued search mode: Successive ^K Fs repeat the current
           search instead of prompting for a new one.


       •   dopadding
           Enable JOE to send padding NULs to the terminal (for very old
           terminals).


       •   exask
           When set, ^K X prompts for a new name before saving the file.


       •   floatmouse
           When set, mouse clicks can position the cursor beyond the ends of
           lines.


       •   guess_crlf
           When set, JOE tries to guess the file format MS-DOS or UNIX.


       •   guess_indent
           When set, JOE tries to guess the indentation character and
           indentation step based on the contents of the file. The algorithm
           is to find the greatest common factor of the three most common
           indentations found in the file.


       •   guess_non_utf8
           When set, enable guessing of non-UTF-8 files in UTF-8 locales.


       •   guess_utf8
           When set, enable guessing of UTF-8 files in non-UTF-8 locales.


       •   guess_utf16
           When set, enable guessing of UTF-16 files. If a UTF-16BE or
           UTF-16LE file is detected, it is converted to UTF-8 during load,
           and converted back to UTF-16 during save.


       •   helpon
           When set, start off with the on-line help enabled.


       •   help_is_utf8
           When set, the help text in the joerc file is assumed to be UTF-8.


       •   icase
           Search is case insensitive by default when set.


       •   joe_state
           Enable reading and writing of ~/.joe_state file


       •   joexterm
           Set this if xterm was configured with --paste64 option for better
           mouse support.


       •   keepup
           The column number on the status line is updated constantly when
           this is set, otherwise it is updated only once a second.


       •   language language
           Sets language for aspell.


       •   lightoff
           Automatically turn off ^K B ^K K highlighting after a block
           operation.


       •   lines nnn
           Set number of lines in terminal emulator (in case termcap entry is
           wrong). This is only useful on old system which don´t have the "get
           window size" ioctl.


       •   marking
           Enable marking mode: highlights between ^K B and cursor.


       •   menu_above
           Put menus above prompt instead of below them.


       •   menu_explorer
           Stay in menu when a directory is selected (otherwise the directory
           is added to the path and the cursor jumps back to the prompt).


       •   menu_jump
           Jump into the file selection menu when Tab Tab is hit.


       •   mid
           If this option is set and the cursor moves off the window, the
           window will be scrolled so that the cursor is in the center. This
           option is forced on slow terminals which don´t have scrolling
           commands.


       •   left nn
           This sets the number of columns the screen scrolls to the left when
           cursor moves past the left edge or when the crawll command is
           issued. If nn is negative, then it´s the fraction of the screen to
           scroll. For example, -2 means scroll 1/2 the screen.


       •   right nn
           This sets the number of columns the screen scrolls to the right
           when cursor moves past the right edge or when the crawlr command is
           issued. If nn is negative, then it´s the fraction of the screen to
           scroll. For example, -3 means scroll 1/3 the screen.


       •   mouse
           Enable xterm mouse support.


       •   nobackups
           Disable backup files.


       •   nocurdir
           Disable current-directory prefix in prompts.


       •   noexmsg
           Disable exiting message ("File not changed so no update needed")


       •   nolinefeeds
           Disable sending linefeeds to preserve screen history in terminal
           emulator´s scroll-back buffer (only relevant when notite mode is
           enabled).


       •   nolocks
           Disable EMACS compatible file locks.


       •   nomodcheck
           Disable periodic file modification check.


       •   nonotice
           This option prevents the copyright notice from being displayed when
           the editor starts.


       •   nosta
           This option eliminates the top-most status line. It´s nice for when
           you only want to see your text on the screen or if you´re using a
           vt52.


       •   notagsmenu
           Disable selection menu for tags search with multiple results.


       •   notite
           Disable ti and te termcap sequences which are usually set up to
           save and restore the terminal screen contents when JOE starts and
           exits.


       •   pastehack
           If keyboard input comes in as one block assume it´s a mouse paste
           and disable autoindent and wordwrap.


       •   noxon
           Disable ^S and ^Q flow control, possibly allowing ^S and ^Q to be
           used as editor keys.


       •   orphan
           Orphan extra files given on the command line instead of creating
           windows for them (the files are loaded, but you need to use
           switch-buffer commands to access them).


       •   pg nnn
           Set number of lines to keep during Page Up and Page Down (use -1
           for 1/2 window size).


       •   regex
           Use standard regular expression syntax by default, instead of the
           JOE syntax (where special characters have their meaning only when
           preceded with backslash).


       •   restore
           Set to have cursor positions restored to last positions of
           previously edited files.


       •   rtbutton
           Swap left and right mouse buttons.


       •   search_prompting
           Show previous search string in search command (like in PICO).


       •   skiptop nnn
           When set to N, the first N lines of the terminal screen are not
           used by JOE and are instead left with their original contents. This
           is useful for programs which call JOE to leave a message for the
           user.


       •   square
           Enable rectangular block mode.


       •   transpose
           Transpose rows with columns in all menus.


       •   title
           Display context (titles) in status line.  When enabled this shows
           the first line of the function that the cursor is in on the status
           line.  The syntax file context.jsf identifies which lines are title
           lines.


       •   type
           Select file type, overriding the automatically determined type. The
           file types are defined in the ftyperc file.


       •   undo_keep nnn
           Sets number of undo records to keep (0 means infinite).


       •   usetabs
           Set to allow rectangular block operations to use tabs.


       •   wrap
           Enable search to wrap to beginning of file.





       The following local options may be specified on the command line:

       •   +nnn
           The cursor starts on the specified line.


       •   autoindent
           Enable auto-indent mode. When you hit Enter on an indented line,
           the indentation is duplicated onto the new line.


       •   c_comment
           Enable ^G skipping of C-style comments /.../


       •   cpara characters
           Sets list of characters which can indent paragraphs.


       •   cnotpara characters
           Sets list of characters which begin lines which are definitely not
           part of paragraphs.


       •   cpp_comment
           Enable ^G skipping of C++-style comments // ...


       •   crlf
           JOE uses CR-LF as the end of line sequence instead of just LF. This
           is for editing MS-DOS or VMS files.


       •   encoding encoding
           Set file encoding (like utf-8 or 8859-1).


       •   flowed
           Set to force an extra space after each line of a paragraph but the
           last.


       •   force
           When set, a final newline is appended to the file if there isn´t
           one when the file is saved.


       •   french
           When set, only one space is inserted after periods in paragraph
           reformats instead of two.


       •   hex
           Enable hex-dump mode.


       •   highlight
           Enable syntax highlighting.


       •   highlighter_context
           Enable use of syntax file to identify comments and strings which
           should be skipped over during ^G matching.


       •   indentc nnn
           Sets the indentation character for shift left and shift right (^K ,
           and ^K .). Use 32 for Space, 9 for Tab.


       •   indentfirst
           When set, the smart home key jumps to the indentation point first,
           otherwise it jumps to column 1 first.


       •   istep nnn
           Sets indentation step.


       •   linums
           Enable line number display.


       •   lmargin
           Set left margin.


       •   lmsg
           Define left-side status bar message.


       •   overwrite
           Enable overtype mode. Typing overwrites existing characters instead
           of inserting before them.


       •   picture
           Enable "picture" mode- allows cursor to go past ends of lines.


       •   pound_comment
           ^G ignores # ... comments.


       •   purify
           Fix indentation if necessary before shifting or smart backspace.
           For example, if indentation uses a mix of tabs and spaces, and
           indentc is space, then indentation will be converted to all spaces
           before the shifting operation.


       •   rdonly
           Set read-only mode.


       •   rmargin nnn
           Set right margin.


       •   rmsg string
           Define right-side status bar message.


       •   semi_comment
           ^G ignores ; ... comments.


       •   single_quoted
           ^G ignores ´...´


       •   smartbacks
           Enable smart backspace and tab. When this mode is set backspace and
           tab indent or unindent based on the values of the istep and indentc
           options.


       •   smarthome
           Home key first moves cursor to beginning of line, then if hit
           again, to the first non-blank character.


       •   smsg string
           Define status command format when cursor is on a character.


       •   spaces
           Insert spaces when Tab key is hit.


       •   syntax syntax
           Set syntax for syntax highlighting.


       •   tab nnn
           Set tab stop width.


       •   text_delimiters word delimiter list
           Give list of word delimiters which ^G will step through.




       For example, "begin=end:if=elif=else=endif" means that ^G will jump
       between the matching if, elif, else and endif.

       •   vhdl_comment
           ^G ignores -- ... comments


       •   wordwrap
           JOE wraps the previous word when you type past the right margin.


       •   zmsg string
           Define status command format when cursor is at end of file.


       •   xmsg string
           Define startup message (usually the copyright notice).


       •   aborthint string
           Give the key sequence to show in prompts for abort (usually ^C).


       •   helphint string
           Give the key sequence to show in prompts for help (usually ^K H).





   Colors and attributes
       Combine attributes and up to one foreground color and one background
       color to create arguments for color options like text_color. For
       example: bold+bg_green+blue

       •   Attributes: bold, inverse, blink, dim, underline, and italic

       •   Foreground colors: white, cyan, magenta, blue, yellow, green, red,
           or black

       •   Background colors: bg_white, bg_cyan, bg_magenta, bg_blue,
           bg_yellow, bg_green, bg_red or bg_black




       With a 16 color or 256 color terminal emulator (export
       TERM=xterm-16color), these brighter than normal colors become
       available:

       •   Foreground: WHITE, CYAN, MAGENTA, BLUE, YELLOW, GREEN, RED or BLACK

       •   Background: bg_WHITE, bg_CYAN, bg_MAGENTA, bg_BLUE, bg_YELLOW,
           bg_GREEN, bg_RED or bg_BLACK




       With a 256 color terminal emulator (export TERM=xterm-256color), these
       become available:

       •   fg_RGB and bg_RGB, where R, G and B rand from 0 - 5. So: fg_500 is
           bright red.

       •   fg_NN and bg_NN give shades of grey, where the intensity, NN,
           ranges from 0 - 23.




   Status line definition strings
       -lmsg defines the left-justified string and -rmsg defines the
       right-justified string. The first character of -rmsg is the background
       fill character.

       -smsg defines the status command (^K Space). -zmsg defines it when the
       cursor is at the end of the file. The last character of smsg or zmsg is
       the fill character.

       The following escape sequences can be used in these strings:



           %t  12 hour time
           %u  24 hour time
           %T  O for overtype mode, I for insert mode
           %W  W if wordwrap is enabled
           %I  A if autoindent is enabled
           %X  Rectangle mode indicator
           %n  File name
           %m  ´(Modified)´ if file has been changed
           %*  ´*´ if file has been changed
           %R  Read-only indicator
           %r  Row (line) number
           %c  Column number
           %o  Byte offset into file
           %O  Byte offset into file in hex
           %a  Ascii value of character under cursor
           %A  Ascii value of character under cursor in hex
           %w  Width of character under cursor
           %p  Percent of file cursor is at
           %l  No. lines in file
           %k  Entered prefix keys
           %S  ´*SHELL*´ if there is a shell running in window
           %M  Macro recording message
           %y  Syntax
           %e  Encoding
           %x  Context (first non-indented line going backwards)
           %dd day
           %dm month
           %dY year
           %Ename%  value of environment variable
           %Tname%  value of option (ON or OFF for Boolean options)




       These formatting escape sequences may also be given:



           \i  Inverse
           \u  Underline
           \b  Bold
           \d  Dim
           \f  Blink
           \l  Italic




Basic Editing
       When you type characters into the editor, they are normally inserted
       into the file being edited (or appended to the file if the cursor is at
       the end of the file). This is the normal operating mode of the editor.
       If you want to replace some existing text, you have to delete the old
       text before or after you type in the replacement text. The Backspace
       key can be used for deleting text: move the cursor to right after the
       text you want to delete and hit Backspace a number of times.

       Hit the Enter or Return key to insert a line-break. For example, if the
       cursor was in the middle of a line and you hit Enter, the line would be
       split into two lines with the cursor appearing at the beginning of the
       second line. Hit Backspace at the beginning of a line to eliminate a
       line-break.

       Use the arrow keys to move around the file. If your keyboard doesn´t
       have arrow keys (or if they don´t work for some reason), use ^F to move
       forwards (right), ^B to move backwards (left), ^P to move to the
       previous line (up), and ^N to move to the next line (down). The right
       and left arrow keys simply move forwards or backwards one character at
       a time through the text: if you´re at the beginning of a line and you
       press left-arrow, you will end up at the end of the previous line. The
       up and down arrow keys move forwards and backwards by enough characters
       so that the cursor appears in the same column that it was in on the
       original line.

       If you want to indent the text you enter, you can use the Tab key. This
       inserts a special control character which makes the characters which
       follow it begin at the next tab stop. Tab stops normally occur every 8
       columns, but this can be changed with the ^T D command. PASCAL and C
       programmers often set tab stops on every 4 columns.

       If for some reason your terminal screen gets messed up (for example, if
       you receive a mail notice from biff), you can have the editor refresh
       the screen by hitting ^R.

       There are many other keys for deleting text and moving around the file.
       For example, hit ^D to delete the character the cursor is on instead of
       deleting backwards like Backspace. ^D will also delete a line-break if
       the cursor is at the end of a line. Type ^Y to delete the entire line
       the cursor is on or ^J to delete just from the cursor to the end of the
       line.

       Hit ^A to move the cursor to the beginning of the line it´s on. Hit ^E
       to move the cursor to the end of the line. Hit ^U or ^V for scrolling
       the cursor up or down 1/2 a screen´s worth.
       "Scrolling" means that the text on the screen moves, but the cursor
       stays at the same place relative to the screen. Hit ^K U or ^K V to
       move the cursor to the beginning or the end of the file. Look at the
       help screens in the editor to find even more delete and movement
       commands.

       If you make a mistake, you can hit ^_ to "undo" it. On most keyboards
       you hit just ^- to get ^_, but on some you might have to hold both the
       Shift and Control keys down at the same time to get it. If you "undo"
       too much, you can "redo" the changes back into existence by hitting ^^
       (type this with just ^6 on most keyboards).

   Cursor position history
       If you were editing in one place within the file, and you then
       temporarily had to look or edit some other place within the file, you
       can get back to the original place by hitting ^K -. This command
       actually returns you to the last place you made a change in the file.
       You can step through a history of places with ^K - and ^K =, in the
       same way you can step through the history of changes with the "undo"
       and "redo" commands.

   Save and exit
       When you are done editing the file, hit ^K X to exit the editor. You
       will be prompted for a file name if you hadn´t already named the file
       you were editing.

       When you edit a file, you actually edit only a copy of the file. So if
       you decide that you don´t want the changes you made to a file during a
       particular edit session, you can hit ^C to exit the editor without
       saving them.

       If you edit a file and save the changes, a backup copy of that file is
       created in the current directory, with a ~ appended to the name, which
       contains the original version of the file.

   File operations
       You can hit ^K D to save the current file (possibly under a different
       name from what the file was called originally). After the file is
       saved, you can hit ^K E to edit a different file.

       If you want to save only a selected section of the file, see the
       section on Blocks below.

       If you want to include another file in the file you´re editing, use ^K
       R to insert it.



   Filenames
       Wherever JOE expects you to enter a file name, whether on the command
       line or in prompts within the editor, you may also type:

       •   !command




       To read or write data to or from a shell command. For example, use joe
       ´!ls´ to get a copy of your directory listing to edit or from within
       the editor use ^K D !mail jhallen@world.std.com to send the file being
       edited to me.

       •   >>filename




       Use this to have JOE append the edited text to the end of the file
       "filename."

       •   filename,START,SIZE




       Use this to access a fixed section of a file or device. START and SIZE
       may be entered in decimal (ex.: 123) octal (ex.: 0777) or hexadecimal
       (ex.: 0xFF). For example, use joe /dev/fd0,508,2 to edit bytes 508 and
       509 of the first floppy drive in Linux.

       •   -




       Use this to get input from the standard input or to write output to the
       standard output. For example, you can put JOE in a pipe of commands:
       quota -v | joe | mail root, if you want to complain about your low
       quota.

   Using JOE in a shell script
       JOE used to use /dev/tty to access the terminal. This caused a problem
       with idle-session killers (they would kill JOE because the real tty
       device was not being accessed for a long time), so now JOE only uses
       /dev/tty if you need to pipe a file into JOE, as in:



           echo "hi" | joe




       If you want to use JOE in a shell script which has its stdin/stdout
       redirected, but you do not need to pipe to it, you should simply
       redirect JOE´s stdin/stdout to /dev/tty:



           joe filename  </dev/tty >/dev/tty




   Word wrap and formatting
       If you type past the right edge of the screen in a C or PASCAL language
       file, the screen will scroll to the right to follow the cursor. If you
       type past the right edge of the screen in a normal file (one whose name
       doesn´t end in .c, .h or .p), JOE will automatically wrap the last word
       onto the next line so that you don´t have to hit Enter. This is called
       word-wrap mode. Word-wrap can be turned on or off with the ^T W
       command. JOE´s initialization file is usually set up so that this mode
       is automatically turned on for all non-program files. See the section
       below on the joerc file to change this and other defaults.

       Aside for Word-wrap mode, JOE does not automatically keep paragraphs
       formatted like some word-processors. Instead, if you need a paragraph
       to be reformatted, hit ^K J. This command "fills in" the paragraph that
       the cursor is in, fitting as many words in a line as is possible. A
       paragraph, in this case, is a block of text separated above and below
       by a blank line.

       The margins which JOE uses for paragraph formatting and word-wrap can
       be set with the ^T L and ^T R commands. If the left margin is set to a
       value other than 1, then when you start typing at the beginning of a
       line, the cursor will immediately jump to the left margin.

       There are a number of options which control the paragraph reformatter
       and word wrapper:

       •   The cpara option provides a list of characters which can indent a
           paragraph. For example, in e-mail quoted matter is indicated by >
           at the beginnings of line, so this character should be in the cpara
           list.

       •   The cnotpara option provides a list of characters which, if they
           are the first non-whitespace character of a line, indicate that the
           line is not to be included as part of a paragraph for formatting.
           For example, lines beginning with ´.´ in nroff can not be paragraph
           lines.

       •   Autoindent mode affects the formatter. If autoindent is disabled,
           only the first line will be indented. If autoindent is enabled, the
           entire paragraph is indented.

       •   french determines how many spaces are inserted after periods.

       •   When flowed is enabled, a space is inserted after each but the last
           line of the paragraph. This indicates that the lines belong
           together as a single paragraph in some programs.

       •   When overtype is enabled, the word wrapper will not insert lines.




   Centering
       If you want to center a line within the margins, use the ^K A command.

   Spell checker
       Hit Esc N to check the spelling of the word the cursor is on using the
       aspell program (or ispell program if you modify the joerc file). Hit
       Esc L to check the highlighted block or the entire file if no block is
       highlighted.

       JOE passes the language and character encoding to the spell checker. To
       change the language, hit ^T V. For example, use en_US for English.

   Overtype mode
       Sometimes it´s tiresome to have to delete old text before or after you
       insert new text. This happens, for example, when you are changing a
       table and you want to maintain the column position of the right side of
       the table.
       When this occurs, you can put the editor in overtype mode with ^T T.
       When the editor is in this mode, the characters you type in replace
       existing characters, in the way an idealized typewriter would. Also,
       Backspace simply moves left instead of deleting the character to the
       left, when it´s not at the end or beginning of a line. Overtype mode is
       not the natural way of dealing with text electronically, so you should
       go back to insert-mode as soon as possible by typing ^T T again.

       If you need to insert while you´re in overtype mode, hit ^@. This
       inserts a single Space into the text.

   Control and Meta characters
       Each character is represented by a number. For example, the number for
       ´A´ is 65 and the number for ´1´ is 49. All of the characters which you
       normally see have numbers in the range of 32 - 126 (this particular
       arbitrary assignment between characters and numbers is called the ASCII
       character set). The numbers outside of this range, from 0 to 255,
       aren´t usually displayed, but sometimes have other special meanings.
       The number 10, for example, is used for the line-breaks. You can enter
       these special, non-displayed control characters by first hitting ^Q and
       then hitting a character in the range @ A B C ... X Y Z [ ^ ] \ _ to
       get the number 0 - 31, and ? to get 127. For example, if you hit ^Q J,
       you´ll insert a line-break character, or if you hit ^Q I, you´ll insert
       a Tab character (which does the same thing the Tab key does). A useful
       control character to enter is 12 (^Q L), which causes most printers to
       advance to the top of the page. You´ll notice that JOE displays this
       character as an underlined L. You can enter the characters above 127,
       the meta characters, by first hitting ^\. This adds 128 to the next
       (possibly control) character entered. JOE displays characters above 128
       in inverse-video. Some foreign languages, which have more letters than
       English, use the meta characters for the rest of their alphabet. You
       have to put the editor in asis mode to have these passed untranslated
       to the terminal.

       Note: JOE now normally passes all 8-bits to the terminal unless the
       locale is set to C or POSIX. If the locale is C or POSIX, then the asis
       flag determines if meta characters are shown in inverse video or passed
       directly to the terminal.

       Note: In older version of JOE, you had to use Esc ´ to enter control
       characters.

Character sets and UTF-8
       JOE natively handles two classes of character sets: UTF-8 and byte
       coded (like ISO-8859-1). For these character sets, the file is loaded
       as-is into memory, and is exactly preserved during save, even if it
       contains UTF-8 coding errors.

       It can not yet natively handle other major classes such as UTF-16 or
       GB2312. There are other restrictions: character sets must use LF (0x0A)
       or CR-LF (0x0D - 0x0A) as line terminators, space must be 0x20 and tab
       must be 0x09. Basically, the files must be UNIX or MS-DOS compatible
       text files.

       This means EBCDIC will not work properly (but you would need to handle
       fixed record length lines anyway) and character sets which use CR
       terminated lines (MACs) will not yet work.

       JOE now supports UTF-16 (both big endian and little endian). It
       supports UTF-16 by converting to UTF-8 during load, and converting back
       to UTF-16 during save.

       The terminal and the file can have different encodings. JOE will
       translate between the two. Currently, one of the two must be UTF-8 for
       translation to work.

       The character set for the terminal and the default character set
       assumed for files is determined by the ´LC_ALL´ environment variable
       (and if that´s not set, LC_CTYPE and LANG are also checked).

       For example, if LC_ALL is set to:



           de_DE




       Then the character set will be ISO-8859-1.

       If LC_ALL is set to:



           de_DE.UTF-8




       The character set will be UTF-8.

       Hit ^T E to change the coding for the file. Hit Tab Tab at this prompt
       to get a list of available codings. There are a number of built-in
       character sets, plus you can install character sets in the
       ~/.joe/charmaps and /usr/share/joe/charmaps directories.

       Check: /usr/share/i18n/charmaps for example character set files. Only
       byte oriented character sets will work. Also, the file should not be
       gzipped (all of the charmap files in /usr/share/i18n/charmaps on my
       computer were compressed). The parser is very bad, so basically the
       file has to look exactly like the example one in
       /usr/share/joe/charmaps.

       You can hit ^K Space to see the current character set.

       You can hit ^Q x to enter a Unicode character if the file coding is
       UTF-8.

Prompts
       Most prompts record a history of the responses you give them. You can
       hit up and down arrow to step through these histories.

       Prompts are actually single line windows with no status line, so you
       can use any editing command that you normally use on text within the
       prompts. The prompt history is actually just other lines of the same
       "prompt file". Thus you can can search backwards though the prompt
       history with the normal ^K F command if you want.

       Since prompts are windows, you can also switch out of them with ^K P
       and ^K N.

   Completion and selection menus
       You can hit Tab in just about any prompt to request JOE to complete the
       word you are typing. If JOE beeps, there are either no completions or
       many. As with the "bash" shell, hit Tab twice to bring up a list of all
       the possibilities. This list is actually a menu, but by default, the
       cursor does not jump into it since it is usually easier to just type in
       your selection. You can, however, jump into the menu window with ^K P
       (move to previous window) and use the arrow keys and <Enter> to make
       your selection. Also in a menu, you can hit the first letter of any of
       the items to make the cursor jump directly to it. The ^T option menu
       works like this.

       If the menu is too large to fit in the window, you can hit Page Up and
       Page Down to scroll it (even if you have not jumped into it).

       Tab completion works in the search and replace prompts as well. In this
       case, JOE tries to complete the word based on the contents of the
       buffer. If you need search for the Tab character itself, you can enter
       it with ^Q Tab.

       Also, you can hit Esc Enter in a text window to request JOE to complete
       the word you are typing. As with the search prompt, JOE tries to
       complete the word based on the contents of the buffer. It will bring up
       a menu of possibilities if you hit Esc Enter twice.

Where am I?
       Hit ^K Space to have JOE report the line number, column number, and
       byte number on the last line of the screen. The number associated with
       the character the cursor is on (its ASCII code) is also shown. You can
       have the line number and/or column number always displayed on the
       status line by placing the appropriate escape sequences in the status
       line setup strings. Edit the joerc file for details.

What if I hit <strong>^K</strong> by accident?
       Hit the space bar. This runs an innocuous command (it shows the line
       number on the status bar).

Temporarily suspending the editor
       If you need to temporarily stop the editor and go back to the shell,
       hit ^K Z. You might want to do this to stop whatever you´re editing and
       answer an e-mail message or read this man page, for example. You have
       to type fg or exit (you´ll be told which when you hit ^K Z) to return
       to the editor.

Searching for text
       Hit ^K F to have the editor search forwards or backwards for a text
       fragment (string) for you. You will be prompted for the text to search
       for. After you hit Enter, you are prompted to enter options.
       You can just hit Enter again to have the editor immediately search
       forwards for the text, or you can enter one or more of these options:

       •   b





       Search backwards instead of forwards.

       •   i





       Treat uppercase and lower case letters as the same when searching.
       Normally uppercase and lowercase letters are considered to be
       different.

       •   nnn





       (where nnn is a number) If you enter a number, JOE searches for the Nth
       occurrence of the text. This is useful for going to specific places in
       files structured in some regular manner.

       •   r





       Replace text. If you enter the r option, then you will be further
       prompted for replacement text. Each time the editor finds the search
       text, you will be prompted as to whether you want to replace the found
       search text with the replacement text. You hit: y to replace the text
       and then find the next occurrence, n to not replace this text, but to
       then find the next occurrence, r to replace all of the remaining
       occurrences of the search text in the remainder of the file without
       asking for confirmation (subject to the nnn option above), or ^C to
       stop searching and replacing.

       You can also hit B or Backspace to back up to the previously found text
       (if it had been replaced, the replacement is undone).

       •   a





       The search covers all loaded buffers. So to replace all instances of
       "foo" with "bar" in all .c files in the current directory:



           joe *.c
              ^K F
                  foo <Enter>
                  ra <Enter>
                  bar <Enter>




       •   e





       The search covers all files in the grep or make error list. You can use
       a UNIX command to generate a list of files and search and replace
       through the list. So to replace all instances of "foo" with "bar" in
       all .c files which begin with f. You can also use "ls" and "find"
       instead of grep to create the file list.



           Esc G
             grep -n foo f*.c <Enter>
           ^K F
                  foo <Enter>
              re <Enter>
              bar <Enter>




       •   x





       JOE will use the standard syntax for regular expressions if this option
       is given. In the standard syntax, these characters have their special
       meanings directly, and do not have to be escaped with backslash: ., *,
       +, ?, {, }, (, ), |, ^, $ and [.

       •   y





       JOE will use the JOE syntax for regular expressions instead of the
       standard syntax. This overrides the "-regex" option.

       •   v





       JOE will send debug information about the regular expression to the
       startup log. The log can be viewed with the showlog command.

       You can hit ^L to repeat the previous search.

       You can hit ^K H at the search and replace options prompt to bring up a
       list of all search and replace options.

   Regular Expressions
       A number of special character sequences may be entered as search text:

       •   \*





       This finds zero or more of the item to the left. For example, if you
       give AB\*C as the search text, JOE will try to find an A followed by
       any number of Bs, and then a C.

       •   \+





       This finds one or more of the item to the left. For example, if you
       give AB\+C as the search text, JOE will try to find an A followed by
       one or more Bs, and then a C.

       •   \?





       This indicates that the item to the left is optional. For example, if
       you give AB\?C as the search text, JOE will find AC or ABC.

       •   \{min,max}





       This indicates that JOE should try to find a string with a specific
       number of occurrences of the item to the left. For example, AX\{2,5}B
       will match these strings: AXXB, AXXXB, AXXXXB, and AXXXXXB. Min can be
       left out to indicate 0 occurrences. Max (and the comma) can be left out
       to indicate any number of occurrences.

       •   \.





       This finds exactly one character. For example, if you give A\.B as the
       search text, JOE will find AXB, but not AB or AXXB.

       •   \!





       This works like ., but matches a balanced C-language expression. For
       example, if you search for malloc(\!\*), then JOE will find all
       function calls to malloc, even if there was a ) within the parenthesis.

       •   \|





       This finds the item on the left or the item on the right. For example,
       if you give A\|B as the search text, JOE will try to find either an A
       or a B.

       •   \( \)





       Use these to group characters together. For example, if you search for
       \(foo\)\+, then JOE will find strings like "foo", and "foofoofoo".

       •   ^ \$





       These match the beginnings and endings of lines. For example, if you
       give ^test\$, then JOE with find test on a line by itself.

       •   \\\





       These match the beginnings and endings of words. For example, if you
       give \is\\, then JOE will find the word "is" but will not find the "is"
       in "this".

       •   \[...]





       This matches any single character which appears within the brackets.
       For example, if \[Tt]his is entered as the search string, then JOE
       finds both This and this. Ranges of characters can be entered within
       the brackets. For example, \[A-Z] finds any uppercase letter. If the
       first character given in the brackets is ^, then JOE tries to find any
       character not given in the the brackets. To include - itself, include
       it as the last or first character (possibly after ^).

       •   \\





       Matches a single \.

       •   \n





       This finds the special end-of-line or line-break character.

       A number of special character sequences may also be given in the
       replacement string:

       •   \&





       This gets replaced by the text which matched the search string. For
       example, if the search string was \\*\\, which matches words, and you
       give "\&", then JOE will put quote marks around words.

       •   \1 - \9





       These get replaced with the text which matched the Nth grouping; the
       text within the Nth set of \( \).

       •   \l, \u





       Convert the next character of the replacement text to lowercase or
       uppercase.

       •   \L, \U





       Convert all following replacement text to lowercase or uppercase.
       Conversion stops when \E is encountered.

       •   \\





       Use this if you need to put a \ in the replacement string.

       •   \n





       Use this if you need to put a line-break in the replacement string.

       Some examples:

       Suppose you have a list of addresses, each on a separate line, which
       starts with "Address:" and has each element separated by commas. Like
       so:

       Address: S. Holmes, 221b Baker St., London, England

       If you wanted to rearrange the list, to get the country first, then the
       city, then the person´s name, and then the address, you could do this:

       Type ^K F to start the search, and type:

       Address:\(\.\*\),\(\.\*\),\(\.\*\),\(\.\*\)\$

       to match "Address:", the four comma-separated elements, and then the
       end of the line. When asked for options, you would type r to replace
       the string, and then type:

       Address:\4,\3,\1,\2

       To shuffle the information the way you want it. After hitting return,
       the search would begin, and the sample line would be changed to:

       Address: England, London, S. Holmes, 221b Baker St.



   Escape sequences
       JOE understands the following escape sequences withing search and
       replacement strings:

       •   \x{10ffff}





       This matches a specific Unicode code point given in hexadecimal.

       •   \xFF





       This matches a specific character specified in hexadecimal.

       •   \377





       This matches a specific character specified in octal.

       •   \p{Ll}





       This matches any character in the named Unicode category or block.

       The block names, such as "Latin-1 Supplement" or "Arabic" can be found
       here:

       Unicode Blocks ftp://ftp.unicode.org/Public/8.0.0/ucd/Blocks.txt

       The category names such as "Ll" can be found here:

       Unicode Categories
       ftp://ftp.unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values

       Note that a single letter matches all of the category names which start
       with that letter. For example, \p{N} (any number) include \p{Nd}
       (decimal digit), \p{Nl} (letter number) and \p{No} (other number).

       •   \d





       This matches any Unicode digit. This is the same as \p{Nd}.

       •   \D





       This matches anything except for a Unicode digit. This is the same as
       \[^\p{Nd}].

       •   \w





       This matches any word character. This is the same as
       \[^\p{C}\p{P}\p{Z}].

       •   \W





       This matches anything except for a word character. This is the same as
       \[\p{C}\p{P}\p{Z}].

       •   \s





       This matches any space character. This is the same as \[\t\r\f\n\p{Z}].

       •   \S





       This matches anything except for a spacing character. This is the same
       as \[^\t\r\f\n\p{Z}].

       •   \i





       This matches an identifier start character. This is the same as
       \[\p{L}\p{Pc}\p{Nl}].

       •   \I





       This matches anything except for an identifier start character. This is
       the same as \[^\p{L}\p{Pc}\p{Nl}].

       •   \c





       This matches an identifier continuation character. This is the same as
       \[\i\p{Mn}\p{Mc}\p{Nd}\x{200c}\x{200d}].

       •   \C





       This matches anything except for an identifier continuation character.
       This is the same as \[^\i\p{Mn}\p{Mc}\p{Nd}\x{200c}\x{200d}].

       •   \t Tab

       •   \n Newline

       •   \r Carriage return

       •   \b Backspace

       •   \a Alert

       •   \f Formfeed

       •   \e Escape

       •   \\ Backslash




Incremental search
       Use Esc S to start an increment search forwards, or Esc R to start an
       incremental search backwards. As you type the search string, the cursor
       will jump to the first text that matches the regular expression you
       have entered so far.

       Hit Esc S or Esc R again to find the next occurrence of the text or to
       switch the direction of the search.

       ^S, ^\ and ^L have the same effect as Esc S. ^R has the same effect as
       Esc R. These keys are to support JMACS.

       Hit Backspace to undo the last incremental search action. The last
       action could be a repeat of a previous search or the entering of a new
       character.

       Use ^Q to insert control characters into the search text. Previously, `
       could also be used for this.

       Hit any other key to exit the increment search.

Goto matching delimiter
       Hit ^G to jump between matching delimiters. This works on both
       character delimiters (like ´(´ and ´)´) and word delimiters for
       languages like Pascal and Verilog which use "begin" and "end" to
       delimit blocks. It also works for matching start and end tags in XML.
       If a word is not known, ^G starts a search with the word moved into the
       search prompt.

       For ^G to work on word delimiters, the cursor must be positioned on the
       first letter of the word. So in XML, if the cursor is on the < in
       <foo>, it will jump to the >. But if it is one the ´f´, it will jump to
       the matching </foo>. Likewise, in C, ^G will jump between #if, #else
       and #endif, but you need to position the cursor on the letter, not the
       ´#´.

       ^G is smart enough to skip delimiters found in quoted or commented-out
       matter. You need to tell JOE how your language indicates this: see the
       ftyperc file for examples of how this is done.

       The are a number of options which control the behavior of ^G. These
       options control which kinds of comments ^G can skip over:

       •   c_comment

       •   cpp_comment

       •   pount_comment

       •   semi_comment

       •   vhdl_comment




       These options determine which kinds of strings ^G can skip over:

       •   single_quoted

       •   double_quoted




       This option allows an annotated syntax file to determine which text can
       be counted as comments or strings which can be skipped over by ^G:

       •   highlighter_context




       This option enables the use of syntax files to identify comments and
       strings which should be skipped over during ^G matching. The syntax
       file states should be annotated with the string and comment keywords
       for this to work.

       •   text_delimiters




       This option provides a list of word delimiters to match. For example,
       "begin=end:if=elif=else=endif" means that ^G will jump between the
       matching if, elif, else and endif. It will also jump between begin and
       end.

       ^G has a built-in table for matching character delimiters- it knows
       that ( goes with ).

       ^G has a built-in parser to handle start/end tag matching for XML.



Regions
       If you want to move, copy, save or delete a specific section of text,
       you can do it with highlighted blocks. First, move the cursor to the
       start of the section of text you want to work on, and press ^K B. Then
       move the cursor to the character just after the end of the text you
       want to affect and press ^K K. The text between the ^K B and ^K K
       should become highlighted. Now you can move your cursor to someplace
       else in your document and press ^K M to move the highlighted text
       there.
       You can press ^K C to make a copy of the highlighted text and insert it
       to where the cursor is positioned. ^K Y to deletes the highlighted
       text. ^K W, writes the highlighted text to a file.

       A very useful command is ^K /, which filters a block of text through a
       UNIX command. For example, if you select a list of words with ^K B and
       ^K K, and then type ^K / sort, the list of words will be sorted.
       Another useful UNIX command for ^K /, is tr. If you type ^K / tr a-z
       A-Z, then all of the letters in the highlighted block will be converted
       to uppercase.

   How do I deselect a highlighted region?
       After you are finished with some region operations, you can just leave
       the highlighting on if you don´t mind it (but don´t accidentally hit ^K
       Y). If it really bothers you, however, just hit ^K B ^K K, to turn the
       highlighting off.

       Beginning with JOE 4.2, you can hit ^C to cancel the region selection.

   New ways of selecting regions
       The classic way is to hit ^K B at the beginning and ^K K at the end.
       These set pointers called markb and markk. Once these are set you can
       jump to markb with Esc B and jump to markk with Esc K.

       New way: hit Ctrl-Right Arrow to start selecting rightward. Each time
       you hit Ctrl-Right Arrow, the block is extended one more to the right.
       This uses a simple macro: "begin_marking,rtarw,toggle_marking".

       Unfortunately, there is no standard way to get the keysequence given by
       the terminal emulator when you hit Ctrl-Right Arrow. Instead you have
       to determine this sequence yourself and enter it directly in the joerc
       file. Some examples are given for Xterm and gnome-terminal. Hit ^Q
       Ctrl-Right Arrow within JOE to have the sequence shown on your screen.
       Note that Putty uses Esc Esc [ C which will not appear with ^Q Right
       Arrow (also Esc Esc is the set bookmark command, so you need to unbind
       it to do this in Putty).

       Also you can hit Ctrl-Delete to cut and Ctrl-Insert to paste if the
       sequence for these keys are known.

       The mouse can also be used to select text if mouse support is enabled
       in JOE.

Indenting program blocks
       Auto-indent mode is toggled with the ^T I command. The joerc file is
       normally set up so that files with names ending with .p, .c or .h have
       auto-indent mode enabled. When auto-indent mode is enabled and you hit
       Enter, the cursor will be placed in the same column that the first
       non-whitespace character was on in the original line.

       You can use the ^K , and ^K . commands to shift a block of text to the
       left or right. If no highlighting is set when you give these commands,
       the program block (as indicated by indentation) that the cursor is
       located in will be selected, and will be moved by subsequent ^K , and
       ^K . commands.

       The number of columns these commands shift by and the character used
       for shifting can be set through the istep and indentc options. These
       options are available in the ^T menu. Also, ^T = can be used to quickly
       select from a number of common values for indentation step and
       character.

       JOE has a number of additional options related to indenting programs:

       •   smartbacks
           Enable smart backspace and tab. When this mode is set Backspace and
           Tab indent or unindent based on the values of the istep and indentc
           options.


       •   smarthome
           The Home and ^A keys first move the cursor to the beginning of the
           line, then if hit again, to the first non-blank character.


       •   indentfirst
           Smart home goes to first non-blank character first, instead of
           going to the beginning of the line first.


       •   purify
           Fix indentation if necessary before shifting or smart backspace.
           For example, if indentation uses a mix of tabs and spaces, and
           indentc is space, then indentation will be converted to all spaces
           before the shifting operation.


       •   guess_indent
           When set, JOE tries to guess the indentation character and
           indentation step based on the contents of the file. The algorithm
           is to find the greatest common factor of the three most common
           indentations found in the file.





Rectangle mode
       Type ^T X to have ^K B and ^K K select rectangular blocks instead of
       stream-of-text blocks. This is also known as columnar mode. This mode
       is useful for moving, copying, deleting or saving columns of text. You
       can also filter columns of text with the ^K / command- if you want to
       sort a column, for example. The insert file command, ^K R is also
       affected.

       When rectangle mode is selected, overtype mode is also useful (^T T).
       When overtype mode is selected, rectangles will replace existing text
       instead of getting inserted before it. Also the delete block command
       (^K Y) will clear the selected rectangle with Spaces and Tabs instead
       of deleting it. Overtype mode is especially useful for the filter block
       command (^K /), since it will maintain the original width of the
       selected column.

Picture mode
       Use ^T P to enter or exit picture mode. Picture mode helps with ASCII
       drawings.

       Picture mode controls how JOE handles the case where the cursor is past
       the ends of lines. This happens when you use the up or down arrow keys
       to move the cursor from the end of a long line to a short line.

       If you attempt to type a character in this case:

       If picture mode is off, the cursor will jump to the end of the line and
       insert it there.

       If picture mode is on, the line is filled with spaces so that the
       character can be inserted at the cursor position.

Windows
       You can edit more than one file at the same time or edit two or more
       different places of the same file. To do this, hit ^K O, to split the
       screen into two windows. Use ^K P or ^K N to move the cursor into the
       top window or the lower window. Use ^K E to edit a new file in one of
       the windows. A window will go away when you save the file with ^K X or
       abort the file with ^C. If you abort a file which exists in two
       windows, one of the window goes away, not the file.

       You can hit ^K O within a window to create even more windows. If you
       have too many windows on the screen, but you don´t want to eliminate
       them, you can hit ^K I. This will show only the window the cursor is
       in, or if there was only one window on the screen to begin with, try to
       fit all hidden windows on the screen. If there are more windows than
       can fit on the screen, you can hit ^K N on the bottom-most window or ^K
       P on the top-most window to get to them.

       If you gave more than one file name to JOE on the command line, each
       file will be placed in a different window.

       You can change the height of the windows with the ^K G and ^K T
       commands.

   Windowing system model
       JOE has an unusual model for its windowing system. Basically you have a
       ring of windows, but only a section of this ring may fit on the screen.
       The windows not on the screen still exist, they are just scrolled off.
       When you hit ^K N on the bottom window of the screen, it scrolls
       further windows from the ring onto the screen, possibly letting the top
       window scroll out of view.

       Native JOE tries to keep each loaded buffer in a window, so users can
       find all of the buffers by scrolling through the windows. The explode
       command (^K I) either expands all windows to the size of the screen so
       that only one window can fit on the screen, or shrinks them all as much
       as possible to fit many on the screen.

       On the other hand, JOE supports "orphan" buffers- files loaded into the
       editor, but which are not in a window. ^C normally closes a window and
       discards the buffer that was in it. If you hit ^C on the last remaining
       window, it will normally exit the editor. However, if there are orphan
       buffers, ^C will instead load them into this final window to give you a
       chance to explicitly discard them. If the orphan option is given on the
       command line, as in joe -orphan *.c, then JOE only loads the first file
       into a window and leaves all the rest as orphans.

       orphan also controls whether the edit command ^K E creates a new window
       for a newly loaded file, or reuses the current window (orphaning its
       previous occupant).

       The bufed command prompts for a name of a buffer to switch into a
       window. Its completion list will show all buffers, including orphans
       and buffers which appear in other windows. Esc V and Esc U (nbuf and
       pbuf commands) allow you to cycle through all buffers within a single
       window.

       Windows maintain a stack of occupants to support the pop-up shell
       window feature. When a pop-up window is dismissed, the previous buffer
       is returned to the window.

Scratch buffers
       Scratch buffers are buffers which JOE does not worry about trying to
       preserve. JOE will not ask to save modified scratch buffers. Pop-up
       shell windows, the startup log and compile and grep message windows are
       scratch buffers. You can create your own scratch buffer with the
       scratch command.

       The following commands load scratch buffers:

       •   showlog Show startup log

       •   mwind Show message window (compile / grep messages from Esc C and
           Esc G commands).




Keyboard macros
       Macros allow you to record a series of keystrokes and replay them with
       the press of two keys. This is useful to automate repetitive tasks. To
       start a macro recording, hit ^K [ followed by a number from 0 to 9. The
       status line will display (Macro n recording...). Now, type in the
       series of keystrokes that you want to be able to repeat. The commands
       you type will have their usual effects. Hit ^K ] to stop recording the
       macro. Hit ^K followed by the number you recorded the macro in to
       execute one iteration of the key-strokes.

       For example, if you want to put "**" in front of a number of lines, you
       can type:

       ^K [ 0 ^A **down arrow\ ^K ]

       Which starts the macro recording, moves the cursor to the beginning of
       the line, inserts "**", moves the cursor down one line, and then ends
       the recording. Since we included the key-strokes needed to position the
       cursor on the next line, we can repeatedly use this macro without
       having to move the cursor ourselves, something you should always keep
       in mind when recording a macro.

   Keyboard macro subroutines
       If you find that the macro you are recording itself has a repeated set
       of key-strokes in it, you can record a macro within the macro, as long
       as you use a different macro number. Also you can execute previously
       recorded macros from within new macros.

   Query suspend
       If your macro includes a prompt for user input, and you want the user
       to fill in the prompt every time the macro is executed, hit ^K ? at the
       point in the macro recording where the user action is required.
       Keyboard input will not be recorded at this point. When the user
       completes the prompt, macro recording will continue.

       When the macro is executed, the macro player will pause at the point
       where ^K ? was entered to allow user input. When the user completes the
       prompt, the player continues with the rest of the macro.

   Repeat
       You can use the repeat command, ^K \, to repeat a macro, or any other
       edit command or even a normal character, a specified number of times.
       Hit ^K \, type in the number of times you want the command repeated and
       press Enter. The next edit command you now give will be repeated that
       many times. For example, to delete the next 20 lines of text, type:

       ^K \ 20return^Y

Macros and commands
       A macro is a comma separated list of commands. When the macro is
       executed, each command is executed until either the end of the list is
       reached, or one of the commands fails (non-zero return value from the
       command). Failed commands beep if you have beeps enabled (^T B).

       Hit Esc D to insert the current set of keyboard macros as text into the
       current buffer. For example, the "**" insert macro above looks like
       this:



           home,"**",dnarw ^K 0    Macro 0




       You could insert this into your .joerc file and change the key sequence
       (the K 0) to something more permanent.

   Define your own
       You can bind macros to key sequences or define your own named macros in
       the joerc file. For example, this will define a macro called foo:



           :def foo eof,bol




       foo will position the cursor at the beginning of the last line of the
       file. eof jumps to the end of the file. bol jumps to the beginning of a
       line. Once a macro has been named this way it will show up in the
       completion list of the Esc X command prompt.

   Command prompt
       You can execute a macro directly by typing it into the command prompt.
       Hit Esc X to bring up the command prompt. Hit Tab at this prompt for a
       completion list of all available commands.

       Here is a complete list of commands.

   Macro don´t stop modifier
       Sometimes, you expect commands to sometimes fail, but want the rest of
       the commands in the list to be executed anyway. To mark a command which
       is allowed to fail, postfix it with ´!´. For example, here a macro
       which hits down page in the window above:



           prevw,pgdn!,nextw




       If prevw fails, the macro is aborted as usual. Even if pgdn fails
       (already at end of buffer), nextw will be executed so that the cursor
       is returned to the original window.

   Macro repeat argument modifiers
       Repeat arguments can be specified with ^K \. When a command is executed
       with a repeat argument, it is repeatedly executed the specified number
       of times. If the repeat argument is negative, an opposite command (if
       one exists) is executed instead. For example, if you repeat "rtarw" -3
       times, "ltarw" will be repeated 3 times. If a negative argument is
       given for a command which does not have an opposite, the repeat
       argument is ignored.

       Normally, if a repeat argument is specified for a macro, the macro is
       simply repeated the given number of times. If a negative argument is
       given, the argument is ignored.

       Sometimes you want to allow negative arguments for macros and have
       their behavior modified. To do this, postfix each command within the
       macro which should be switched to its opposite for negative arguments
       with ´-´. For example, here is the page down other window macro:



           prevw,pgdn-!,nextw




       Now if you execute this with an argument of -2, it will be repeated
       twice, but pgup will be executed instead of pgdn. (note that several
       postfix modifiers can be placed after each command).

       Sometimes when a repeat argument is given to macro, you want only one
       of the commands in the list to be repeated, not the entire macro. This
       can be indicated as follows:



           prevw,pgdn#!,nextw




       If this is executed with an argument of 2, prevw is executed once, pgdn
       is executed twice, and nextw is executed once.

       Finally, even more complex semantics can be expressed with the "if"
       command:



           if~,"arg<0",then,
               ltarw,
           else,
               rtarw,
           endif




       When the macro is executed, the "arg" math variable is set to the given
       repeat argument. The "argset" variable is set to true if the user set
       an argument, even if it´s 1. If no argument was given, argset is false.

       If any command in the list is postfixed with ~ (if above), the macro is
       not repeated, even if there is an argument. ´arg´ is still set to the
       given repeat count, however.

   ´psh´/´query´ interaction
       The ´psh´ command saves the ^K B and ^K K positions on a stack. When
       the macro completes, (or when the ´pop´ command is called) the
       positions are restored.

       The ´query´ command suspends macro execution until the current dialog
       is complete. It also suspends the automatic ´pop´ which happens at the
       end of a macro- so if the macro ends in a dialog you often want to call
       ´query´ to prevent the ^K B ^K K positions from being restored too
       early.

Tags search
       If you are editing a large C program with many source files, you can
       use the ctags program to generate a tags file. This file contains a
       list of program symbols and the files and positions where the symbols
       are defined.

       First, create the tags file with the "ctags" program. For example:



           ctags *.c *.h




       This will create a file called "tags" in the current directory.

       JOE looks for the "tags" file in the current directory. If there is
       none, it will try to open the file specified by the TAGS environment
       variable.

       Paths in the tags file are always relative to location of the tags file
       itself.

       The tags file contains a list of identifier definition locations in one
       of these formats:



           identifier filename /search-expression/[;comments]

           identifier filename ?search-expression?[;comments]

           identifier filename line-number[;comments]




       Some versions of ctags include class-names in the identifiers:



           class::member




       In this case, JOE will match on any of these strings:



           member
           ::member
           class::member




       Some versions of ctags include a filename in the identifier:



           filename:identifier




       In this case JOE will only find the identifier if the buffer name
       matches the filename.

       The search-expression is a vi regular expression, but JOE only supports
       the following special characters:



           ^ at the beginning means expression starts at beginning of line

           $ at the end means expression ends at end of line

           \x quote x (suppress meaning of /, ?, ^ or $)




       Type ^K ; to bring up a tags search prompt. If the cursor had been on
       an identifier, the prompt is pre-loaded with it. Tab completion works
       in this prompt (it uses the tags file to find completions).

       When you hit Enter, the tags search commences:

       If there is one and only one match, JOE will jump directly to the
       definition.

       If there are multiple matches, then the behavior is controlled by the
       notagsmenu option. If notagsmenu is enabled JOE jumps to the first
       definition. If you hit ^K ; again before hitting any other keys, JOE
       jumps to the next definition, and so on. The "tagjump" command also
       performs this function.

       If notagsmenu is disabled, JOE brings up a menu of all the matches. You
       select the one you want and JOE jumps to it. If you hit ^K ; again
       before hitting any other keys, the same menu re-appears with the cursor
       left in the original location.

       You can hit ^K - to move the cursor back to the original location
       before the tags search (often ^C will work as well).

       Since ^K ; loads the definition file into the current window, you
       probably want to split the window first with ^K O, to have both the
       original file and the definition file loaded.

Calculator
       JOE has a built-in calculator which can be invoked with Esc M.

   Math functions
       sin, cos, tan, exp, sqrt, cbrt, ln, log, asin, acos, atan, sinh, cosh,
       tanh, asinh, acosh, atanh, int, floor, ceil, abs, erf, erfc, j0, j1,
       y0, y1

   Variables
       •   e
           Set to ´e´


       •   pi
           Set to ´pi´


       •   top
           Set to line number of top window line


       •   lines
           Set to number of lines in file


       •   line
           Set to current line number


       •   col
           Set to current column number


       •   byte
           Set to current byte number


       •   size
           Set to buffer size


       •   height
           Set to window height


       •   width
           Set to window width


       •   char
           Set to ASCII val of character under cursor


       •   markv
           True if there is a valid block set (^KB ... ^KK)


       •   rdonly
           True if file is read-only


       •   arg
           Current repeat argument


       •   argset
           True if a repeat argument was given


       •   is_shell
           True if executed in an active shell window


       •   no_windows
           No. buffer windows on the screen


       •   ans
           Result of previous expression





   Commands
       •   hex
           Hex display mode


       •   dec
           Decimal display mode


       •   ins
           Insert ´ans´ into buffer


       •   sum
           Sum of numbers in block


       •   cnt
           Count numbers in block


       •   avg
           Average value of numbers in block


       •   dev
           Standard deviation of numbers in block


       •   eval
           Evaluate math expressions in block (or whole file if no block set).


       •   joe(...)
           Execute a JOE macro (argument in same format as joerc file macros).
           Return value of JOE macro is returned (for macro success, return
           true (non-zero)).





       For example:



           joe(sys,"[ 1 == 1 ]",rtn)




       ([ 1 == 1 ]) is a shell command. "[" is a synonym for the "test" UNIX
       command.

       Returns true.

       Remember: argument for JOE macro command "if" is a math expression. So
       for example, the macro:



           if,"joe(sys,\"[ 1 == 1 ]\",rtn)",then,"TRUE",endif




       Types TRUE into the buffer.

   Operators:
       •   !x
           Logical not of x.


       •   x
           Raise x to power of y.


       •   a*b
           Multiply.


       •   a/b
           Divide.


       •   a%b
           Modulus.


       •   a+b
           Add.


       •   a-b
           Subtract.


       •   a<b
           True if a is less than b.


       •   a<=b
           True if a is less than or equal to b.


       •   a>b
           True if a is greater than b.


       •   a>=b
           True if a is greater than or equal to b.


       •   a==b
           True if a equals b.


       •   a!=b
           True if a does not equal b.


       •   a&&b
           True if both a and b are true.


       •   a||b
           True if ether a or b are true.


       •   a?b:c
           If a is true return b, otherwise return c.


       •   a=b
           Assign b to a.


       •   a:b
           Execute a, then execute b.





       &&, || and ? : work as in C and sh as far as side effects: if the

       left side of && is false, the right side is not evaluated.
       is expression separator.

Shell windows
       Hit ^K ´ to run a command shell in one of JOE´s windows. When the
       cursor is at the end of a shell window (use ^K V if it´s not), whatever
       you type is passed to the shell instead of the buffer. Any output from
       the shell or from commands executed in the shell is appended to the
       shell window (the cursor will follow this output if it´s at the end of
       the shell window). This command is useful for recording the results of
       shell commands- for example the output of make, the result of grepping
       a set of files for a string, or directory listings from FTP sessions.
       Besides typeable characters, the keys ^C, Backspace, Del, Return and ^D
       are passed to the shell. Type the shell exit command to stop recording
       shell output. If you press ^C in a shell window, when the cursor is not
       at the end of the window, the shell is killed.

       If you use Bash, you can hit: ^Q Up Arrow and ^Q Down Arrow to scroll
       through Bash´s history buffer. Other keys work as well: try ^Q ^A to go
       to beginning of line or ^Q ^E to go to end of line. Unfortunately JOE
       only emulates a dumb terminal, so you have to use a lot of imagination
       to do any editing beyond hitting backspace.

       In general, any character quoted with ^Q is sent to the shell.

       Also sent to the shell: Tab, Backspace, Enter, ^C and ^D.



Pop-up shell windows
       Hit F1 - F4 to open and switch between shell windows.

       Pop-up shell windows use a full terminal emulator so that when you type
       "man ls" it´s formatted correctly (it works well enough so that some
       interactive programs can be used). Even so, the shell window is still
       an edit buffer.

       The old shell window (with no terminal emulation) still exists: use ^K
       ´ to invoke it as usual. This is useful to see control sequences
       emitted by a program.

       More of the keys get passed to the running program in pop-up shell
       windows compared with the older one. There is a :vtshell section of the
       joerc file to control which ones. In particular arrow keys and Ctrl-C
       are passed to the program. It means you can easily step through bash
       history with the arrow keys, or abort programs the normal way with
       Ctrl-C.

       On the other hand, loss of Ctrl-C means it´s less obvious how to close
       the window. One way is to move the cursor off of the shell data entry
       point (with Ctrl-P), and then hit Ctrl-C. Another is to hit ^K Q.
       Finally, you can type ´pop´ at the command prompt.

       If you need to pass a key to the shell that JOE normally uses, quote
       it. For example, if you invoke "emacs -nw" in the shell window, you can
       exit it with:



           ^Q ^X ^C




       To quickly position the cursor back to the point where data is entered
       into the shell, hit ^K V.

       When you open a shell window, a JOE-specific startup-script is sourced.
       It´s located in /etc/joe/shell.sh (also /etc/joe/shell.csh). It
       contains some aliases which allow you to control JOE with fake shell
       commands. I have these commands so far:

       •   clear
           erase shell window (delete buffer contents)


       •   joe file
           edit a file in JOE


       •   math 1+2
           evaluate equation using JOE´s calculator


       •   cd xyz
           change directory, keep JOE up to date


       •   markb
           same as ^KB


       •   markk
           same as ^KK


       •   mark command
           execute shell command, mark it´s output


       •   parse command
           execute shell command, parse it´s output for file names and line
           numbers (for find or grep)


       •   parser comman
           execute shell command, parse it´s output for errors (for gcc)


       •   release
           release parsed errors


       •   pop
           dismiss shell window (same as ^K Q)





       These work by emitting an escape sequence recognized by the terminal
       emulator: Esc { joe_macro }. When this is received, the macro is
       executed. For security, only macros defined in the joerc file which
       begin with "shell_" can be executed this way.

   Use cases
       Pop-up shell windows have a number of nice use cases:

       •   Use it to browse manual pages

           Hit F1 and type "man fopen". Use ´b´ (´u´) and space to control
           more (or less) while viewing the manual. You can leave the manual
           on the screen in one window while editing in another window.

       •   Use it to switch directories

           Hit F1 and navigate to the directory while using cd. Once you are
           in the right place, hit ^K E to load a file (or type "edit file"
           from the shell).

       •   Use it in conjunction with the error parser to find files

           Hit F1 and navigate to a directory. Use grep or find (or both) to
           generate a list of files):






                   parse grep -n FIXME *.c




       Or:



                   markb; find . | xargs grep -n FIXME; markk; parse




       (Note that you can´t say this:



                   parse find . | xargs grep -n FIXME




       ...the issue is that only the words to the left of the pipe symbol are
       passed as arguments to the parse command).

       Now use ^P to position the cursor on one of the lines of the list. Hit
       Esc Space to have JOE edit the file and jump to the specified line
       (also you can use Esc - and Esc = to step through the list).

       •   Use it in conjunction with search and replace to edit many files

           Once JOE has a list of files (from above), use search and replace
           with the ´e´ option to visit all of them:






                   ^K F
                      Find: <text>
                      Options: re
                      Replace: <replacement text>




       •   Build your project




       Easily capture errors from a build with:



                   parserr make




       Hit Esc = and Esc - to step through the errors.

   How it works..
       •   There is a new mode "ansi". (Esc X mode ansi). When this mode is
           enabled, the screen updater hides escape sequences which are in the
           buffer. Otherwise you get a big mess from the sequences surrounding
           colored output from ´ls´.

       •   There is a new built-in syntax: "ansi". (^T Y ansi). This syntax
           parses the ANSI color control sequences so that text gets colored.

       •   There is a terminal emulator to interpret control sequences from
           the shell program. It emulates a terminal by modifying the contents
           of an edit buffer.

       •   When the edit window is resized we tell the shell by issuing the
           TIOCSSIZE or TIOCSWINSZ ioctl. This way, the program running in the
           shell knows the window size.




Compiler and grep/find parsers
       JOE has two parsers which can be used to generate the error list (list
       of file names / line numbers).

       The "parserr" command parses the entire buffer, or if the block is set,
       just the highighted block for compiler error messages. The messages
       should be in this format:



           <junk> file.name <junk> line-number <junk> : <junk>




       The file name needs to be made of numbers, letters, ´/´, ´.´ and ´-´.
       It must have at leat one ´.´ in it. There needs to be a colon somewhere
       after the line number. Lines not in this format are ignored.

       The "gparse´ command parses the entire buffer, or if the block is set,
       just the highlighted block for a list of filenames or filenames with
       line numbers from "grep -n", "find" and similar programs.



           filename

           filename:<junk>

           filename:line-number:<junk>




       Once JOE has the error list, there are a number of things you can do
       with it:

       •   Visit the files/locations in the list with Esc - and Esc =

       •   Search and replace across all files in the list by using the ´e´
           search and replace option.

       •   Clear the list by using the "release" command.




       Also, you can use Esc Space (´jump´ command) to parse the line the
       cursor is on and jump to the parsed filename and line number. ´jump´
       uses the grep/find parser unless ´parserr´ had been previously issued
       in the buffer.

   Grep-find
       Hit Esc G to bring up the prompt. Enter a command which results in file
       names with line numbers, for example: ´grep -n fred *.c´. This will
       list all instances of ´fred´ in the *.c files. You need the ´-n´ to get
       the line numbers.

       Now you can hit Esc Space on one of the lines to jump to the selected
       file. Also, you can use Esc = and Esc - to step through each line.

   Compile
       Hit Esc C to save all modified files and then bring up the compile
       prompt. Enter the command you want to use for the compiler (typically
       "make -w"). The compiler will run in a shell window. When it´s
       complete, the results are parsed.

       The ´-w´ flag should be given to "make" so that it prints messages
       whenever it changes directories. The message are in this format:



           make[1]: Entering directory `/home/jhallen/joe-editor-mercurial/joe´




       If there are any errors or warnings from the compiler you can hit Esc
       Space on one of the lines to jump to the selected file. Also, you can
       use Esc = and Esc - to step through each line.

Syntax highlighting
       To enable highlight use ^T H.

       To select the syntax, use ^T Y. You can hit Tab Tab at the prompt for a
       completion list.

       JOE tries to determine the syntax to use based on the name and contents
       of the file. The configuration file /etc/joe/ftyperc contains the
       definitions.

       Each syntax is defined by a file located /usr/share/joe/syntax/.

How JOE syntax highlighting works
       from c.jsf
       http://joe-editor.hg.sourceforge.net/hgweb/joe-editor/joe-editor/file/tip/syntax/c.jsf.in,
       slightly modified

       A deterministic state machine that performs lexical analysis of the
       target language is provided in a syntax file. (This is the "assembly
       language" of syntax highlighting. A separate program could in principal
       be used to convert a regular expression NFA syntax into this format).

       Each state begins with:



           :<name> <color-name> <context>




       name\ is the state´s name.

       color-name\ is the color used for characters eaten by the state (really
       a symbol for a user definable color).

       context\ tells JOE if the current character is part of a comment or a
       string. This allows JOE to skip over comments and strings when matching
       characters such as parentheses. To use this feature, the
       highlighter_context option must be applied to the files highlighted by
       the corresponding syntax. To apply the option, add it to ftyperc for
       those file entries.

       The valid contexts are:

       •   comment This character is part of a comment. Example: /* comment */

       •   string This character is part of a string. Examples: "string" ´c´
           ´string´




       The comment and string delimiters themselves should be marked with the
       appropriate context. The context is considered to be part of the color,
       so the recolor=-N and recolormark options apply the context to previous
       characters.

       The first state defined is the initial state.

       Within a state, define transitions (jumps) to other states. Each jump
       has the form:



               <character-list> <target-state-name> [<option>s]




       There are three ways to specify character-list\s, either * for any
       character not otherwise specified, % or & to match the character in the
       delimiter match buffer (% matches the saved character exactly, while &
       matches the opposite character, for example ( will match ) when & is
       used) or a literal list of characters within quotes (ranges and escape
       sequences allowed: see Escape Sequences). When the next character
       matches any in the list, a jump to the target-state is taken and the
       character is eaten (we advance to the next character of the file to be
       colored).

       The * transition should be the first transition specified in the state.

       There are several options:

       •   noeat - Do not eat the character, instead feed it to the next state
           (this tends to make the states smaller, but be careful: you can
           make infinite loops). ´noeat´ implies ´recolor=-1´.

       •   recolor=-N - Recolor the past N characters with the color of the
           target-state. For example once /* is recognized as the start of C
           comment, you want to color the /* with the C comment color with
           recolor=-2.

       •   mark - Mark beginning of a region with current position.

       •   markend - Mark end of region.

       •   recolormark - Recolor all of the characters in the marked region
           with the color of the target-state. If markend is not given, all of
           the characters up to the current position are recolored. Note that
           the marked region can not cross line boundaries and must be on the
           same line as recolormark.

       •   buffer - Start copying characters to a string buffer, beginning
           with this one (it´s OK to not terminate buffering with a matching
           ´strings´, ´istrings´ or ´hold´ option- the buffer is limited to
           leading 23 characters).

       •   save_c - Save character in delimiter match buffer.

       •   save_s - Copy string buffer to delimiter match buffer.

       •   strings - A list of strings follows. If the buffer matches any of
           the given strings, a jump to the target-state in the string list is
           taken instead of the normal jump.

       •   istrings - Same as strings, but case is ignored. Note: strings and
           istrings should be the last option on the line. They cause any
           options which follow them to be ignored.

       •   hold - Stop buffering string- a future ´strings´ or ´istrings´ will
           look at contents of buffer at this point. Useful for distinguishing
           commands and function calls in some languages ´write 7´ is a
           command ´write (´ is a function call- hold lets us stop at the
           space and delay the string lookup until the ( or 7.




       The format of the string list is:



               "string"   <target-state> [<options>s]
               "string"   <target-state> [<options>s]
               "&"        <target-state> [<options>s]   # matches contents of delimiter match buffer
               done




       (all of the options above are allowed except "strings", "istrings" and
       "noeat". noeat is always implied after a matched string).

       Weirdness: only states have colors, not transitions. This means that
       you sometimes have to make dummy states with



               *    <next-state>    noeat




       just to get a color specification.

       Delimiter match buffer is for perl and shell: a regex in perl can be
       s<..>(...) and in shell you can say: <<EOS ....... EOS. The idea is
       that you capture the first delimiter into the match buffer (the < or
       first "EOS") and then match it to the second one with "&" in a string
       or character list.

   Subroutines
       Highlighter state machines can now make subroutine calls. This works by
       template instantiation: the called state machine is included in your
       current state machine, but is modified so that the return address
       points to the called. There is still no run-time stack (the state is
       represented as a single integer plus the saved delimiter string).

       Recursion is allowed, but is self limited to 5 levels.

       Note: this recursion limit is obsolete. Subroutines now do use a stack
       so the call-depth is limitless.

       To call a subroutine, use the ´call´ option:



               "\""    fred    call=string(dquote)




       The subroutine called ´string´ is called and the jump to ´fred´ is
       ignored. The ´dquote´ option is passed to the subroutine.

       If you use recolor along with call, the color used is that of the first
       state of the subroutine.

       The subroutine itself returns to the caller like this:



               "\""    whatever    return




       If we´re in a subroutine, it returns to the target state of the call
       ("fred" in the above example). If we´re not in a subroutine, it jumps
       to "whatever".

       If you use recolor along with return, the color used is from the
       returned state ("fred" in the example above).

       There are several ways of delimiting subroutines which show up in how
       it is called. Here are the options:

       •   call=string() - A file called string.jsf is the subroutine. The
           entire file is the subroutine. The starting point is the first
           state in the file.

       •   call=library.string() - A file called library.jsf has the
           subroutine. The subroutine within the file is called string.

       •   call=.string() - There is a subroutine called string in the current
           file.




       When a subroutine is within a file, but is not the whole file, it is
       delimited as follows:



           .subr string






       Option flags can be passed to subroutines which control
       preprocessor-like directives. For example:



           .ifdef dquote
               "\""    idle    return
               "´"     idle    return




       .else is also available. .ifdefs can be nested.



The joerc file
       ^T options, the help screens and the key-sequence to editor command
       bindings are all defined in JOE´s initialization file. If you make a
       copy of this file (which normally resides in /etc/joe/joerc) to
       $HOME/.joerc, you can customize these setting to your liking. The
       syntax of the initialization file should be fairly obvious and there
       are further instructions in it.

       The joerc file has a directive to include another file (:include). This
       facility is used to include a file called ftyperc (usually located in
       /etc/joe/ftyperc). ftyperc has the file type table which determines
       which local options (including syntax for the highlighter) are applied
       to each file type.

   Initialization file loading sequence
       If the path for an initialization file begins with ´/´ (you can specify
       this with the include directive), JOE only tries to load it from the
       absolute path. Otherwise, JOE tries to load initialization files (the
       joerc file and any files included in it, typically ftyperc) from three
       places:

       •   "$HOME/.joerc" - The user´s personalized joerc file.

       •   "/etc/joe/joerc" - The system´s joerc file. The exact path is fixed
           during the build, and is determined by the --sysconfdir configure
           script option.

       •   "*joerc" - Built-in file This means JOE searches for the file in a
           table of files linked in with the JOE binary (they are in the
           builtins.c file). A built-in joerc file is provided so that the
           editor will run in cases where system´s joerc is inaccessible.




       If the system´s joerc file is newer than the user´s joerc file, JOE
       will print a warning in the startup log. Previous versions of JOE would
       prompt the user for this case- the idea was that JOE may be unusable
       with an out of date initialization file.

   joerc file sections
       The joerc file is broken up into a number of sections:

       •   Global options Options which are not file specific, like noxon.

       •   File name and content dependent options Options which depend on the
           file type, such as autoindent. The ftyperc file is included in this
           section.

       •   ^T menu system definition Use :defmenu to define a named menu of
           macros. The menu command brings up a specific named menu. ^T is a
           macro which brings up the root menu: menu,"root",rtn.

       •   Help screen contents Each help screen is named. The name is used to
           implement context dependent help.

       •   Key bindings Key binding tables are defined. You can define as many
           as you like (you can switch to a specific one with the keymap
           command), but the following must be provided:

       •   main Editing windows

       •   prompt Prompt windows

       •   query Single-character query prompts

       •   querya Single-character query for quote

       •   querysr Single-character query for search and replace

       •   shell Shell windows

       •   vtshell Terminal emulator shell windows








       Key binding tables can inherit bindings from already defined tables.
       This allows you to group common key bindings into a single table which
       is inherited by the others.

   Mode command
       Many options can be controlled with the ^T menu. This menu is defined
       in the joerc file. Each option in the ^T menu just executes a macro.
       Usually the macro is the mode command. You can execute the mode command
       directly with:



           Esc X mode <enter>




       Hit Tab Tab for a completion list of all options.

   Menu command
       This command calls up a named menu of macros which was defined in the
       joerc file.



           Esc X menu <enter>




       As usual, hit Tab Tab at the prompt for a completion list of the menus
       which exist.

       ^T is bound to the simple macro menu,"root",rtn- it brings up the root
       of the options menu system.

Xterm Mouse support
       There are two levels of mouse support. The -mouse option enables the
       first level, which will work with any stock Xterm. If -joexterm is also
       set, mouse support is enhanced, but you need a recent version of XTerm,
       and it needs to be ./configured with the --enable-paste64 option.

       When -mouse is set, you can:

       •   Left-click in a text window to set the cursor position. Left-click
           in a different window to move the cursor to a different window.

       •   Select text with the mouse. Left-click and drag to select some
           text- it will be as if you had used ^K B and ^K K to mark it.
           Left-click (but don´t drag) to position the cursor somewhere else.
           Middle click to copy the selected text to the cursor- it will be as
           if you had hit ^K C. If you drag past the edge of the text window,
           the window will auto-scroll to select more text. Unfortunately,
           Xterm does not send any codes when the cursor is outside of the
           Xterm frame itself, so this only works if the mouse is still
           contained within the Xterm frame. I´ve sent a patch to the Xterm
           maintainer to improve this, but he has not taken it yet.

       •   Resize windows with the mouse: click and hold on a status line
           dividing two windows to move it.

       •   Select menu entries (such as any completion menu or the ^T options
           menu): click on the menu item to position the cursor on it.
           Double-click on a menu item to select it (same as hitting return
           with cursor on it).

       •   If your mouse has a wheel, turning the wheel will scroll the window
           with the cursor.




       Unfortunately, when -mouse is selected, cut and paste between X windows
       does not work as it normally does in a shell window (left-click and
       drag to select, middle click to paste). Instead, you have to hold the
       shift key down to do this: shift-left-click and drag to select, and
       shift-middle click to paste. Note that pasting text into JOE this way
       has problems: any ` characters will get messed up because ` means quote
       the following control character. Also if auto-indent is enabled, pasted
       text will not be indented properly.

       Note: these problems with pasting have been resolved in recent versions
       of JOE.

       •   JOE enables "bracketed paste" mode in Xterm so that pasted text is
           bracketed with an escape sequence. This sequence causes JOE to
           disable the autoindent, wordwrap and spaces modes for the paste,
           and restores them when the paste is complete.

       •   Even if the terminal emulator does not have this bracketed paste
           mode, JOE detects pasted text by timing: If text arrives all at
           once (all in the same buffer), the text is assumed to be pasted
           text and autoindent and wordwrap are temporarily disabled.




       When -joexterm is set (and you have ./configured Xterm with
       --enable-paste64):

       •   Cut & paste are properly integrated with X. Text selected with
           left-click-drag is available for pasting into other X windows (even
           if the selected text is larger than the text window). Text selected
           in other X windows can be pasted into JOE with middle-click. There
           are no problems pasting text containing ` or with auto-indent.




       --enable-paste64 allows an application program to communicate Base-64
       encoded selection data to and from the Xterm. The program has full
       control over what is in the selection data and when it is received or
       sent.

Color Xterm support
       JOE can make use of monochrome Xterm, 8-color Xterm, 16-color Xterm,
       88-color Xterm and 256-color Xterm. The number of colors which Xterm
       supports is determined by which "configure" script options are set
       before the Xterm source code is compiled. The termcap or terminfo entry
       must support how your Xterm is configured. On my Slackware Linux
       distribution, you have to set the TERM environment variable to one of
       these:

       •   xterm

       •   xterm-color

       •   xterm-16color

       •   xterm-88color

       •   xterm-256color




       If the termcap/terminfo entry is missing, you can add the
       "-assume_256color" option to the joerc file. Note that this was broken
       for terminfo in versions of JOE below 3.4.

       When it is working, the command: "joe -assume_256color -text_color
       bg_222" should have a gray background.

Hex edit mode
       When this mode is selected (either put -hex on the command line, or
       look for "Hex edit mode" after hitting ^T), the buffer is displayed as
       a hex dump, but all of the editing commands operate the same way. It is
       most useful to select overtype mode in conjunction with hex dump (hit
       ^T T). Then typing will not insert.

       •   To enter the hex byte 0xF8 type ^Q x F 8

       •   You can use ^K C to copy a block as usual. If overtype mode is
           selected, the block will overwrite the destination data without
           changing the size of the file. Otherwise it inserts.

       •   Hit Esc X byte <Enter>, to jump to a particular byte offset. Hex
           values can be entered into this prompt like this: 0x2000.

       •   Search, incremental search, and search & replace all operate as
           usual.






Environment variables
       For JOE to operate correctly, a number of other environment settings
       must be correct. The throughput (baud rate) of the connection between
       the computer and your terminal must be set correctly for JOE to update
       the screen smoothly and allow typeahead to defer the screen update. Use
       the stty nnn command to set this. You want to set it as close as
       possible to actual throughput of the connection. For example, if you
       are connected via a 1200 baud modem, you want to use this value for
       stty. If you are connected via 14.4k modem, but the terminal server you
       are connected to connects to the computer a 9600 baud, you want to set
       your speed as 9600 baud. The special baud rate of 38400 or extb is used
       to indicate that you have a very-high speed connection, such as a
       memory mapped console or an X-window terminal emulator. If you can´t
       use stty to set the actual throughput (perhaps because of a modem
       communicating with the computer at a different rate than it´s
       communicating over the phone line), you can put a numeric value in the
       BAUD environment variable instead (use setenv BAUD 9600 for csh or
       BAUD=9600; export BAUD for sh).

       The TERM environment variable must be set to the type of terminal
       you´re using. If the size (number of lines/columns) of your terminal is
       different from what is reported in the TERMCAP or TERMINFO entry, you
       can set this with the stty rows nn cols nn command, or by setting the
       LINES and COLUMNS environment variables. The terminal size is variable
       on modern systems and is determined by an ioctl, so these parameters
       often have no effect.

       JOE normally expects that flow control between the computer and your
       terminal to use ^S/^Q handshaking (i.e., if the computer is sending
       characters too fast for your terminal, your terminal sends ^S to stop
       the output and ^Q to restart it). If the flow control uses out-of-band
       or hardware handshaking or if your terminal is fast enough to always
       keep up with the computer output and you wish to map ^S/^Q to edit
       commands, you can set the environment variable NOXON to have JOE
       attempt to turn off ^S/^Q handshaking. If the connection between the
       computer and your terminal uses no handshaking and your terminal is not
       fast enough to keep up with the output of the computer, you can set the
       environment variable DOPADDING to have JOE slow down the output by
       interspersing PAD characters between the terminal screen update
       sequences.

       Here is a complete list of the environment variables:

       •   BAUD
           Tell JOE the baud rate of the terminal (overrides value reported by
           stty).


       •   COLUMNS
           Set number of columns in terminal emulator (in case termcap entry
           is wrong). This is only useful on old system which don´t have the
           "get window size" ioctl.


       •   DOPADDING
           Enable JOE to send padding NULs to the terminal when set (for very
           old terminals).


       •   HOME
           Used to get path to home directory for ~ expansion and also to find
           ~/.joerc file ~/.joe directory.


       •   HOSTNAME
           Used to get hostname to put in EMACS compatible locks.


       •   JOETERM
           Gives terminal type: JOE will use this instead of TERM if it´s set.


       •   LANG
           Sets locale (like en_US.utf-8). JOE uses the first of these which
           is set: LC_ALL, LC_CTYPE, LANG.


       •   LC_ALL
           Sets locale (like en_US.utf-8). JOE uses the first of these which
           is set: LC_ALL, LC_CTYPE, LANG.


       •   LC_CTYPE
           Sets locale (like en_US.utf-8). JOE uses the first of these which
           is set: LC_ALL, LC_CTYPE, LANG.


       •   LINES
           Set number of lines in terminal emulator (in case termcap entry is
           wrong). This is only useful on old system which don´t have the "get
           window size" ioctl.


       •   NOXON
           Disable ^S and ^Q flow control, possibly allowing ^S and ^Q to be
           used as editor keys.


       •   SHELL
           Path to shell (like /bin/sh). This is used in several places: If
           you are on a system with no job control, this shell is invoked when
           you hit ^K Z. Also this is the shell which is run in shell windows.
           If SHELL is not set (Cygwin) or if it´s set to /bin/sh, JOE invokes
           the first of these which exists: /bin/bash, /usr/bin/bash, /bin/sh.


       •   SIMPLE_BACKUP_SUFFIX
           If this is set, it is appended to the file name instead of ~ to
           create the backup file name.


       •   TAGS
           If set to a path to a file, JOE tries to use this as the "tags"
           file if there is no "tags" file in the current directory.


       •   TEMP
           If set, gives path to directory to open swapfile instead of /tmp


       •   TERMCAP
           Used by JOE´s built-in termcap file parser (not used for terminfo).
           A termcap entry can be placed directly in this variable (which will
           be used if it matches TERM), or if it begins with /, it gives a
           list of paths to termcap files to search.


       •   TERMPATH
           Gives list of paths to termcap files to search when TERMCAP has a
           termcap entry (otherwise it´s ignored). The default list of paths
           to termcap files (when TERMCAP and TERMPATH do not have it) is:
           "~/.termcap /etc/joe/termcap /etc/termcap"


       •   TERM
           Gives terminal type, like "vt100" or "xterm".


       •   USER
           Used to get user name for EMACS compatible file locks.







JOE commands grouped by function
       These commands can be entered at the Esc X prompt.

   Background programs
       •   bknd
           Run a shell in a window


       •   vtbknd
           Run a shell in a terminal emulator window


       •   killproc
           Kill program in current window


       •   run
           Run a UNIX command in a window


       •   sys
           Run a UNIX command and return to editor when done (I/O does not go
           through editor, but we get the command´s return status).




   Blocks
       •   blkcpy
           Copy marked block to cursor


       •   blkdel
           Delete marked block


       •   blkmove
           Move marked block to cursor


       •   blksave
           Save marked block into a file


       •   copy
           Copy block to kill-ring


       •   drop
           Set markb. If it was already set, eliminate Ait.


       •   dropon
           Set markb. If it was already set, eliminate it. Turn on marking
           mode.


       •   toggle_marking
           If we´re in a block: clear markb and markk. If marking is off: set
           markb and turn on marking. If marking is on: set markk (swap if
           necessary with markb) and turn marking off.


       •   begin_marking
           If we´re on an edge of a block: set markb to other edge and turn on
           marking mode. Otherwise set markb to cursor and turn on marking
           mode.


       •   select
           Set markb. If it was already set, do nothing.


       •   filt
           Filter block or file through a UNIX command


       •   markb
           Set beginning of block mark


       •   markk
           Set end of block mark


       •   markl
           Mark current line


       •   nmark
           Eliminate markb and markk


       •   picokill
           Delete line or block


       •   pop
           Restore markb and markk values from stack


       •   psh
           Push markb and markk values onto a stack


       •   swap
           Switch cursor with markb


       •   tomarkb
           Move cursor to markb


       •   tomarkbk
           Move cursor to markb or markk


       •   tomarkk
           Move cursor to markk


       •   yank
           Insert top of kill ring


       •   yankpop
           Scroll through kill ring


       •   yapp
           Append next kill to top of kill ring


       •   upper
           Convert everything in block to uppercase


       •   lower
           Convert everything in block to lowercase




   Buffers
       •   bufed
           Buffer menu


       •   edit
           Load file into window: asks to reload if buffer exists


       •   switch
           Load file into window: always uses buffer if it exists


       •   scratch
           Push a scratch buffer into current window


       •   popabort
           Abort and pop window from stack (do nothing if stack empty)


       •   nbuf
           Load next buffer into current window


       •   pbuf
           Load previous buffer into current window


       •   reload
           Re-read file into buffer (revert)


       •   reloadall
           Re-read all unmodified buffers




   Cursor Motion
       •   bof
           Move cursor to beginning of file


       •   bol
           Move cursor to beginning of line (always)


       •   bop
           Move to beginning of a paragraph


       •   bos
           Move to beginning of screen


       •   bkwdc
           Search backwards for a character


       •   byte
           Move cursor to specific byte offset into the file.


       •   col
           Move cursor to specific column number.


       •   dnarw
           Move cursor down one line


       •   eof
           Move cursor to end of file


       •   eol
           Move cursor to end of line


       •   eop
           Move cursor to end of paragraph


       •   fwrdc
           Search forward for matching character


       •   gomark
           Move cursor to a bookmark


       •   home
           Move cursor to beginning of line


       •   line
           Move cursor to specified line


       •   ltarw
           Move cursor left


       •   nedge
           Move cursor to next edge


       •   nextpos
           Move cursor to next position in cursor position history


       •   nextword
           Move cursor to end of next word


       •   pedge
           Move cursor to previous edge


       •   prevpos
           Move cursor to previous position in cursor position history


       •   prevword
           Move cursor to beginning of previous word


       •   rtarw
           Move cursor right


       •   setmark
           Set a bookmark


       •   tomatch
           Move cursor to matching delimiter


       •   tos
           Move cursor to top of screen


       •   uparw
           Move cursor up




   Deletion
       •   backs
           Backspace


       •   backw
           Backspace a word


       •   delbol
           Delete to beginning of line


       •   delch
           Delete character under cursor


       •   deleol
           Delete to end of line


       •   dellin
           Delete entire line


       •   delw
           Delete word to right




   Error parsing
       •   nxterr
           Goto next parsed error


       •   parserr
           Parse errors in current file


       •   gparse
           Parse grep list in current file


       •   jump
           Parse current line and jump to it


       •   prverr
           Go to previous parsed error


       •   showerr
           Show current message


       •   grep
           Execute grep command, parse when done


       •   build
           Execute build command, parse when done


       •   release
           Release error/grep records




   Exit
       •   cancel
           Like abort, but doesn´t return failure: useful in macros to escape
           out of a prompt.


       •   abort
           Abort current buffer/window. Prompt if it is changed.


       •   abortbuf
           Like above, but just fail if it would have to prompt because it´s
           the last window on a modified buffer.


       •   ask
           Prompt to save current file: user says yes return, user says no:
           run ´abort´. Use in a macro: "ask,query,exsave"


       •   exsave
           Save file and exit


       •   lose
           EMACS kill buffer. The buffer is deleted- any windows with it get a
           replacement scratch buffer.


       •   querysave
           Prompt to save each modified buffer. Use in a macro:
           "querysave,query,killjoe"


       •   killjoe
           Exit JOE immediately without checking for modified buffers




   Files
       •   cd
           Set directory prefix


       •   save
           Save file


       •   savenow
           Save immediately, unless file name is not known


       •   insf
           Insert a file




   Formatting
       •   center
           Center line


       •   fmtblk
           Format all paragraphs in a block


       •   format
           Format current paragraph


       •   lindent
           Indent to the left


       •   rindent
           Indent to the right




   Help
       •   help
           Turn help on or off


       •   hnext
           Switch to next help screen


       •   hprev
           Switch to previous help screen




   Inserting
       •   ctrl
           Type next key


       •   finish
           Complete word in text window


       •   insc
           Insert a space


       •   open
           Insert newline


       •   quote
           Insert a control character


       •   quote8
           Insert a meta character


       •   rtn
           Return / Enter key


       •   type
           Insert typed character


       •   secure_type
           Insert typed character, but only allowed in prompt windows (not
           allowed in shell windows)




   Macros
       •   macros
           Insert keyboard macros into current file


       •   play
           Execute a macro


       •   query
           Suspend macro recording for user query


       •   record
           Record a macro


       •   stop
           Stop recording macro




   Menu
       •   backsmenu
           Undo in file completion menu


       •   bofmenu
           Move to beginning of menu


       •   bolmenu
           Move to beginning of line in a menu


       •   dnarwmenu
           Move down one line in a menu


       •   eolmenu
           Move cursor to end of line in a menu


       •   eofmenu
           Move cursor to end of menu


       •   ltarwmenu
           Move cursor left in a menu


       •   rtarwmenu
           Move cursor right in menu


       •   uparwmenu
           Move cursor up in menu


       •   dnslidemenu
           Scroll menu down one line


       •   upslidemenu
           Scroll menu up one line


       •   pgupmenu
           Scroll menu up


       •   pgdnmenu
           Scroll menu down


       •   tabmenu
           Tab through menu




   Misc
       •   beep
           Beep


       •   execmd
           Execute a JOE command


       •   debug_joe
           Insert debug information into buffer


       •   math
           Calculator


       •   maths
           Secure Calculator (no way to run joe() macros)


       •   mode
           Mode prompt


       •   menu
           Menu prompt


       •   msg
           Display a message


       •   notmod
           Clear the modified flag


       •   retype
           Refresh screen


       •   shell
           Suspend process or execute a sub-shell


       •   stat
           Display cursor position


       •   tag
           Tags file search


       •   tagjump
           Jump to next tags file search match (only if notagsmenu is set)


       •   timer
           Execute a macro periodically


       •   txt
           Insert text. If first character is `, then text is assumed to be a
           format string (that is, the string used to define the status line
           for the rmsg and lmsg options) and is formatted before the
           insertion.


       •   name
           Insert current file name


       •   language
           Insert current language


       •   charset
           Insert current character set


       •   keymap
           Switch to another keymap




   Prompts
       •   complete
           Complete a file-name in a prompt


       •   if
           Only run following cmds if expr is true (non-zero)


       •   then
           Same as rtn but only works in prompt windows


       •   elsif
           Try a new condition


       •   else
           Toggle truth flag


       •   endif
           Start running cmds again





       Here is an example ´if´ macro:

       if,"char==65",then,"it´s an A",else,"it´s not an A",endif __^[ q__

       When you hit __^[ q__, if the character under the cursor is an ´A´:
       "it´s a A" is inserted into the buffer, otherwise "it´s not an A" is
       inserted.

       "if" creates a math prompt (like __Esc M__). "then" is like "rtn"- it
       hits the return key for this prompt.

       Within the math prompt, the following variables are available:

       •   char
           ASCII value of character under cursor


       •   width
           Width of screen


       •   height
           Height of screen


       •   byte
           byte number


       •   col
           column number


       •   line
           line number


       •   lines
           no. lines in file


       •   top
           line number of top line of window




   Repeat
       •   arg
           Prompt for repeat argument


       •   uarg
           Universal argument




   Scrolling
       •   crawll
           Pan screen left


       •   crawlr
           Pan screen right


       •   dnslide
           Scroll screen down 1 line


       •   pgdn
           Scroll screen down


       •   pgup
           Scroll screen up


       •   upslide
           Scroll up one line




   Search and replace
       •   ffirst
           Find text


       •   fnext
           Repeat previous search


       •   isrch
           Incremental search forward


       •   qrepl
           Search and replace


       •   rfirst
           Search backwards for text


       •   rsrch
           Reverse incremental search




   Windows
       •   explode
           Display one window or display all windows


       •   dupw
           Duplicate current window


       •   groww
           Increase size of window


       •   nextw
           Move cursor to next window


       •   prevw
           Go to previous window


       •   shrinkw
           Shrink window


       •   splitw
           Split window into two


       •   tw0
           Eliminate this window


       •   tw1
           Show only one window


       •   mwind
           Get error messages window on the screen and put cursor in it.


       •   showlog
           Get startup log scratch buffer into window.


       •   mfit
           Fit two windows on the screen: make current window 6 lines, and
           give rest of space to window above. The window above is either the
           existing previous window, a newly created one if there wasn´t one.




   Undo
       •   redo
           Re-execute the latest undone change


       •   undo
           Undo last change




   Mouse
       •   tomouse
           Move the cursor to where the mouse was clicked/dragged


       •   defmdown
           Default single-click handler, usually bound to MDOWN.  Positions
           cursor to mouse and begins a region.


       •   defmup
           Default single-click release handler, usually bound to MUP.
           Completes selection of a region.


       •   defmdrag
           Default single-click drag handler, usually bound to MDRAG.  Selects
           a region of text a character at a time.


       •   defm2down
           Default double-click handler, usually bound to M2DOWN.


       •   defm2up
           Default double-click release handler, usually bound to M2UP.


       •   defm2drag
           Default double-click drag handler, usually bound to M2DRAG.
           Selects a region of text a word at a time.


       •   defm3down
           Default triple-click handler, usually bound to M3DOWN.


       •   defm3up
           Default triple-click release handler, usually bound to M3UP.


       •   defm3drag
           Default triple-click drag handler, usually bound to M3DRAG.
           Selects a region of text a line at a time.


       •   defmiddledown
           Default middle click handler, usually bound to MIDDLEDOWN.  This
           inserts text.


       •   defmiddleup
           Default middle click release handler, usually bound to MIDDLEUP.


       •   xtmouse
           Handle xterm mouse events, usually bound to Esc [ M.  It parses the
           rest of the sequence and generates fake "keys" that can be bound to
           macros in the joerc file.  It uses a timer to detect double-click
           and triple-click.  The keys are: MUP, MDOWN, MDRAG, M2UP, M2DOWN,
           M2DRAG, M3UP, M3DOWN, M3DRAG, MWUP and MWDOWN.


       •   extmouse
           Handle extended xterm mouse events, usually bound to Esc [ <.


       •   paste
           Insert base64 encoded text (for XTerm --enable-base64 option).


       •   brpaste
           Disable autoindent, wordwrap and spaces. The idea is to bind this
           to Esc [ 2 0 0 ~ so that when the terminal emulator sends a mouse
           paste, the text is inserted as-is.


       •   brpaste_done
           Restore autoindent, wordwrap and spaces modes to their original
           values before brpaste. The idea is to bind this to Esc [ 2 0 1 ~ so
           that these modes are restored after a mouse paste.






                                  March 2016                             JOE()
