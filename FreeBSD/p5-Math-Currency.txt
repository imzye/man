Math::Currency(3)     User Contributed Perl Documentation    Math::Currency(3)


NAME
       Math::Currency - Exact Currency Math with Formatting and Rounding

VERSION
       version 0.53

SYNOPSIS
        use Math::Currency qw(Money $LC_MONETARY);

        my $dollar = Math::Currency->new("$12,345.67");
        my $taxamt = $dollar * 0.28;

        # this sets the default format for all objects w/o their own format
        Math::Currency->format('EUR');

        my $euro = Money(12345.67);
        my $euro_string = Money(12345.67)->bstr();

        # or if you already have a Math::Currency object
        $euro_string = "$euro";

DESCRIPTION
       Currency math is actually more closely related to integer math than it
       is to floating point math.  Rounding errors on addition and subtraction
       are not allowed and division/multiplication should never create more
       accuracy than the original values.  All currency values should round to
       the closest cent or whatever the local equivalent should happen to be.

       However, repeated mathematical operations on currency values can lead
       to inaccurate results, if rounding is performed at each intermediate
       step.  In order to preserve appropriate accuracy, the Math::Currency
       values are stored with an additional two places of accuracy internally
       and only rounded to the "correct" precision when the value is displayed
       (either by the default stringification or through the use of as_float
       or as_int).

       All common mathematical operations are overloaded, so once you
       initialize a currency variable, you can treat it like any number and
       the module will do the right thing.  This module is a thin layer over
       Math::BigFloat which is itself a layer over Math::BigInt.

METHODS
   new
       Create a new currency object.  This can be called a number of ways:

       •   new()

           Creates a new currency object with value "0".

       •   new($value)

           Creates a new currency object with the given value. Note that
           $value should be quoted to avoid locale formatting issues.  E.g.:
           new('1234.56').

       •   new($value, $curency)

           Creates a new currency object in the given locale.  See "Predefined
           Locales".

   format($key, $value)
       Set object or global formatting.  See "Object Formats" for more
       information.

   as_float
       Bare floating point notation without currency formatting.

       When storing the value into a database, you often need a string which
       corresponds to the value of the currency as a floating point number,
       but without the special currency formatting.  That is what this object
       method produces.  Be sure and use e.g. DECIMAL(10,2) in MySQL, or
       NUMERIC(10,3) in PostgreSQL to ensure that you don't have any floating
       point rounding issues going from/to the database.

   copy
       Returns a copy of the current Math::Currency object.

   as_int
       Some US credit card gateways require all transactions to be expressed
       in pennies.  This object method returns an integer value that
       corresponds to the currency value multiplied by 10 to the power of the
       number of decimal places of precision.  Essentially, this expresses the
       currency amount in the smallest discrete value allowed with that
       currency, so for currency expressed in dollars, this method returns the
       same value in pennies.

   localize
       Reinitialize the global (if called with no arguments), or local (if
       called with a reference to a hashref) format hash.

       If you don't want to always have to remember to reinitialize the POSIX
       settings when you switch locales, see always_init

       Examples:

       •   "Math::Currency->localize()"

           Renitialize the global internal format hash using the current
           locale

       •   "Math::Currency->localize(\$format)"

           Renitialize the hashref $format using the current locale.

   available_locales
       Get the list of available locales on this system

   always_init
       If you don't want to always have to remember to reinitialize the POSIX
       settings when you switch locales, you can call this with a true value.

        Math::Currency->always_init(1);

       Alternatively, you can set the global variable:

        $Math::Currency::always_init = 1;

       and every single time a Math::Currency object is printed, the global
       $FORMAT will be updated to the locale current at that time.  This may
       be a performance hit.  It would be better if you followed the method of
       manually updating the global format immediately after you reset the
       locale.

       Notes

       •   This function will reset only the global format and will not have
           effect on objects created with their own overridden formats, even
           if they were originally based on the global format.

       •   You must have all the locale files in question already loaded; the
           list reported by "locale -a" is not always a reliable judge of what
           files you might actually have installed.  If you try and set a
           nonexistant locale, or set the same locale as is already active,
           the module will silently retain the current locale settings.

   use_int
       Default: false

       Pass a true value to this to indicate that the international currency
       symbol ("INT_CURR_SYMBOL") should be used instead of local currency
       symbol ("CURRENCY_SYMBOL").  Note that this is a global setting for the
       library and will affect all objects.  For example, in the "USD" locale,
       stringification of 1234.56 looks like:

       •   use_int(0)

           $1,234.56

       •   use_int(1)

           USD 1,234.56

FUNCTIONS
   Money
       This an exportable function that constructs a new object.  Takes the
       same arguments as new().

Important Note on Input Values
       Since the point of this module is to perform currency math and not
       floating point math, it is important to understand how the initial
       value passed to new() may have nasty side effects if done improperly.
       Most of the time, the following two objects are identical:

               $cur1 = new Math::Currency 1000.01;
               $cur2 = new Math::Currency "1000.01";

       However, only the second is guaranteed to do what you think it should
       do.  The reason for that lies in how Perl treats bare numbers as
       opposed to strings.  The first new() will receive the Perl-stringified
       representation of the number 1000.01, whereas the second new() will
       receive the string "1000.01" instead.  With most locale settings, this
       will be largely identical.  However, with many European locales (like
       fr_FR), the first new() will receive the string "1 000,01" and this
       will cause Math::BigFloat to report this as NAN (Not A Number) because
       of the odd posix driven formatting.

       For this reason, it is always recommended that input values be quoted
       at all times, even if your POSIX locale does not have this unfortunate
       side effect.

Output Formatting
       Each currency value can have an individual format or the global
       currency format can be changed to reflect local usage.  I used the
       suggestions in Tom Christiansen's PerlTootC
       <http://www.perl.com/language/misc/perltootc.html#Translucent_Attributes>
       to implement translucent attributes.  If you have set your locale
       values correctly, this module will pick up your local settings or US
       standards if you haven't.  You can also specify an output format using
       one of the predefined Locale formats or your own custom format.

   Locale Support
       This module uses the builtin locale support provided by your operating
       system to generate the appropriate currency formatting.  Much of this
       support will happen automagically if you have your LANG environment
       setting correct.  If you chose not to install multiple locales when you
       installed your operating system, you will only be able to use your
       default locale format or one of the "Predefined Locales" included in
       the distribution.

       The automatic locale support will take effect if you request a locale
       by name in the for lc_CC (language/country code) like fr_CA (French
       Canadian) or en_NZ (English New Zealand).  If you pregenerate your
       "Custom Locale", an alias class will be added so that you can refer to
       the currency by either the locale name or the INT_CURR_SYMBOL (e.g. USD
       or GBP).

       IMPORTANT NOTE: there are multiple locales which implement the EUR
       (Euro) currency, each with slightly different formatting rules (aren't
       standards wonderful).  If you "use" multiple currencies that represent
       EUR, the last one loaded will be available as the INT_CURR_SYMBOL
       shortcut.  You should always use the locale name to refer to these
       currencies, if you are mixing them in a single program.

   Predefined Locales
       There are currently four predefined Locale formats:

           en_US = United States dollars (the default if no locale)
           en_GB = British Pounds Sterling
           ja_JP = Japanese Yen
           de_DE = German Euro

       These currency formats are implemented using subclasses for easy
       extension (see "Custom Locales" for details on creating new subclasses
       for unsupported locales).  If you are using a locale in a country that
       uses the Euro, you should create your own local format file using your
       default LANG setting, since the Euro formatting rules are country
       specific.

       If you want to use any locale other than your default in a single
       script, there are two different ways to specify which currency format
       you wish to use, with somewhat subtle differences:

       •   Additional parameter to new()

           If you need a single currency of a different type than the others
           in your program, use this mode:

             use Math::Currency;
             my $dollars = Math::Currency->new("1.23"); # default behavior
             my $euros = Math::Currency->new("1.23", "de_DE"); # different format

           The last line above will automatically load the applicable subclass
           and use that formatting for that specific object.  These formats
           can either use a pre-generated subclass or will automatically
           generate an automatic "Custom Locale",

       •   Directly calling the subclass

           If all (or most) of your currency values should be formatted using
           the same rules, create the objects directly using the subclass:

             use Math::Currency::ja_JP; # Japanese Yen
             my $yen = Math::Currency::JPY->new("1.345"); # compatibility class
             my $yen2 = $yen->new("3.456"); # you can use an existing object

   Currency Symbol
       The locale definition includes two different Currency Symbol strings:
       one is the native character(s), like $ or £ or ¥; the other is the
       three character string defined by the ISO4217 specification followed by
       the normal currency separation character (frequently space).  The
       default behavior is to always display the native CURRENCY_SYMBOL unless
       a global parameter is set:

           $Math::Currency::use_int = 1; # print the currency symbol text

       where the INT_CURR_SYMBOL text will used instead.

   Custom Locales
       The included file, scripts/new_currency, will automatically create a
       new currency formatting subclass, based on your current locale, or any
       arbitrary locale supported by your operating system.  For most unix-
       like O/S's, the following command will list the locale files installed:

           locale -a

       and any of those installed locales can [potentially] be used to create
       a new locale formatting file.

       It is not necessary to do this, since using the format command to
       switch to a locale which doesn't already have a subclass defined for it
       will attempt to generate a locale format on the fly.  However, it
       should be noted that the automated generation method will merely look
       for the first locales that uses the requested INT_CURR_SYMBOL.  There
       may be several locales which use that same currency symbol, with subtle
       differences (this is especially true of the EUR format), so it is best
       to pre-generate all of the POSIX currency subclasses you expect, based
       on the locales you wish to support, to utilize when installing this
       module, instead of relying on the autogeneration methods.

       To create a new locale formatting subclass, change to the top level
       build directory for Math::Currency and run the following command:

           scripts/new_currency [xx_XX]

       where xx_XX is the locale name obtained from the `locale -a` command.
       This will create a new locale subclass in the lib/Math/Currency/
       directory, and this file will be installed when `./Build install` is
       next run.

       If you run the script without any commandline option, it will take the
       contents of your LANG environment variable and generate your default
       locale.  NOTE that if you are using a UTF-8 locale, the generated file
       will also be UTF-8 (which may not be what you want).  You probably
       always want to specify the locale name when generating new classes.

       The new_currency script will function from within the current build
       directory, and doesn't depend the current version of Math::Currency
       being already installed, so you can build all of your commonly used
       locale files and install them at once.

   Global Format
       Global formatting can be changed by setting the package global format
       like this:

           Math::Currency->format('USD');

   POSIX Locale Global Formatting
       In addition to the four predefined formats listed above, you can also
       use the POSIX monetary format for a locale which you are not currently
       running (e.g. for a web site).  You can set the global monetary format
       in effect at any time by using:

           use POSIX qw( locale_h );
           setlocale(LC_ALL,"en_GB");   # some locale alias
           Math::Currency->localize;    # reinitialize global format

       If you don't want to always have to remember to reinitialize the POSIX
       settings when you switch locales, see always_init

   Object Formats
       Any object can have it's own format different from the current global
       format, like this:

           $pounds  = Math::Currency->new(1000, 'GBP');
           $dollars = Math::Currency->new(1000); # inherits default US format
           $dollars->format( 'USD' ); # explicit object format

   Format Parameters
       The format must contains all of the commonly configured LC_MONETARY
       Locale settings.  For example, these are the values of the default US
       format (with comments):
         {
           INT_CURR_SYMBOL    => 'USD',  # ISO currency text
           CURRENCY_SYMBOL    => '$',    # Local currency character
           MON_DECIMAL_POINT  => '.',    # Decimal seperator
           MON_THOUSANDS_SEP  => ',',    # Thousands seperator
           MON_GROUPING       => '3',    # Grouping digits
           POSITIVE_SIGN      => '',     # Local positive sign
           NEGATIVE_SIGN      => '-',    # Local negative sign
           INT_FRAC_DIGITS    => '2',    # Default Intl. precision
           FRAC_DIGITS        => '2',    # Local precision
           P_CS_PRECEDES      => '1',    # Currency symbol location
           P_SEP_BY_SPACE     => '0',    # Space between Currency and value
           N_CS_PRECEDES      => '1',    # Negative version of above
           N_SEP_BY_SPACE     => '0',    # Negative version of above
           P_SIGN_POSN        => '1',    # Position of positive sign
           N_SIGN_POSN        => '1',    # Position of negative sign
         }

       See chart below for how the various sign character and location
       settings interact.

       Each of the formatting parameters can be individually changed at the
       object or class (global) level; if an object is currently sharing the
       global format, all the global parameters will be copied prior to
       setting the overrided parameters.  For example:

           $dollars = Math::Currency->new(1000); # inherits default US format
           $dollars->format('CURRENCY_SYMBOL',' Bucks'); # now has its own format
           $dollars->format('P_CS_PRECEDES',0); # now has its own format
           print $dollars; # displays as "1000 Bucks"

       Or you can also set individual elements of the current global format:

           Math::Currency->format('CURRENCY_SYMBOL',' Bucks'); # global changed

       The [NP]_SIGN_POSN parameter determines how positive and negative signs
       are displayed.  [NP]_CS_PRECEEDS determines where the currency symbol
       is shown.  [NP]_SEP_BY_SPACE determines whether the currency symbol
       cuddles the value or not.  The following table shows the relationship
       between these three parameters:

                                                      p_sep_by_space
                                                0          1          2

        p_cs_precedes = 0   p_sign_posn = 0    (1.25$)    (1.25 $)   (1.25 $)
                            p_sign_posn = 1    +1.25$     +1.25 $    +1.25 $
                            p_sign_posn = 2     1.25$+     1.25 $+    1.25$ +
                            p_sign_posn = 3     1.25+$     1.25 +$    1.25+ $
                            p_sign_posn = 4     1.25$+     1.25 $+    1.25$ +

        p_cs_precedes = 1   p_sign_posn = 0   ($1.25)   ($ 1.25)   ($ 1.25)
                            p_sign_posn = 1   +$1.25    +$ 1.25    + $1.25
                            p_sign_posn = 2    $1.25+    $ 1.25+     $1.25 +
                            p_sign_posn = 3   +$1.25    +$ 1.25    + $1.25
                            p_sign_posn = 4   $+1.25    $+ 1.25    $ +1.25

       (the negative variants are similar).

HISTORY
       Created by John Peacock <jpeacock@cpan.org> who maintained this module
       up to version 0.4502.  Versions 0.48 and later were maintained by
       Michael Schout <mschout@cpan.org>

SEE ALSO
       •   perllocale

       •   Math::BigFloat

       •   Math::BigInt

SOURCE
       The development version is on github at
       <https://https://github.com/mschout/perl-math-currency> and may be
       cloned from <git://https://github.com/mschout/perl-math-currency.git>

BUGS
       Please report any bugs or feature requests on the bugtracker website
       <https://github.com/mschout/perl-math-currency/issues>

       When submitting a bug or request, please include a test-file or a patch
       to an existing test-file that illustrates the bug or desired feature.

AUTHOR
       Michael Schout <mschout@cpan.org>

COPYRIGHT AND LICENSE
       This software is copyright (c) 2001 by John Peacock
       <jpeacock@cpan.org>.

       This is free software; you can redistribute it and/or modify it under
       the same terms as the Perl 5 programming language system itself.

perl v5.40.2                      2023-07-06                 Math::Currency(3)
