Object::Container(3)  User Contributed Perl Documentation Object::Container(3)


NAME
       Object::Container - simple object container

SYNOPSIS
           use Object::Container;

           # initialize container
           my $container = Object::Container->new;

           # register class
           $container->register('HTML::TreeBuilder');

           # register class with initializer
           $container->register('WWW::Mechanize', sub {
               my $mech = WWW::Mechanize->new( stack_depth => 1 );
               $mech->agent_alias('Windows IE 6');
               return $mech;
           });

           # get object
           my $mech = $container->get('WWW::Mechanize');

           # also available Singleton interface
           my $container = Object::Container->instance;

           # With singleton interface, you can use register/get method as class method
           Object::Container->register('WWW::Mechanize');
           my $mech = Object::Container->get('WWW::Mechanize');

           # Export singleton interface
           use Object::Container 'container';
           container->register('WWW::Mechanize');
           my $mech = container->get('WWW::Mechanize');
           my $mech = container('WWW::Mechanize'); # same as above

           # Subclassing singleton interface
           package MyContainer;
           use Object::Container '-base';

           register mech => sub { WWW::Mechanize->new };

           # use it
           use MyContainer 'con';

           con('mech')->get('http://example.com');

DESCRIPTION
       This module is a object container interface which supports both OO
       interface and Singleton interface.

       If you want to use one module from several places, you might use
       Class::Singleton to access the module from any places. But you should
       subclass each modules to singletonize.

       This module provide singleton container instead of module itself, so it
       is easy to singleton multiple classes.

       Object::Registrar is a similar module to this. But Object::Container
       has also OO interface and supports lazy initializer. (describing below)

   OO and Singleton interfaces
       This module provide two interfaces: OO and Singleton.

       OO interface is like this:

           my $container = Object::Container->new;

       It is normal object oriented interface. And you can use multiple
       container at the same Time:

           my $container1 = Object::Container->new;
           my $container2 = Object::Container->new;

       Singleton is also like this:

           my $container = Object::Container->instance;

       instance method always returns singleton object. With this interface,
       you can 'register' and 'get' method as class method:

           Object::Container->register('WWW::Mechanize');
           my $mech = Object::Container->get('WWW::Mechanize');

       When you want use multiple container with Singleton interface, you have
       to create subclass like this:

           MyContainer1->get('WWW::Mechanize');
           MyContainer2->get('WWW::Mechanize');

   Singleton interface with EXPORT function for lazy people
       If you are lazy person, and don't want to write something long code
       like:

           MyContainer->get('WWW::Mechanize');

       This module provide export functions to shorten this.  If you use your
       container with function name, the function will be exported and act as
       container:

           use MyContainer 'container';

           container->register(...);

           container->get(...);
           container(...);             # shortcut to ->get(...);

   Subclassing singleton interface for lazy people
       If you are lazy person, and don't want to write something long code in
       your subclass like:

           __PACKAGE__->register( ... );

       Instead of above, this module provide subclassing interface.  To do
       this, you need to write below code to subclass instead of "use base".

           use Object::Container '-base';

       And then you can register your object via DSL functions:

           register ua => sub { LWP::UserAgent->new };

   lazy loading and resolve dependencies
       The object that is registered by 'register' method is not initialized
       until calling 'get' method.

           Object::Container->register('WWW::Mechanize', sub { WWW::Mechanize->new }); # doesn't initialize here
           my $mech = Object::Container->get('WWW::Mechanize'); # initialize here

       This feature helps you to create less resource and fast runtime script
       in case of lots of object registered.

       And you can resolve dependencies between multiple modules with
       Singleton interface.

       For example:

           Object::Container->register('HTTP::Cookies', sub { HTTP::Cookies->new( file => '/path/to/cookie.dat' ) });
           Object::Container->register('LWP::UserAgent', sub {
               my $cookies = Object::Container->get('HTTP::Cookies');
               LWP::UserAgent->new( cookie_jar => $cookies );
           });

       You can resolve dependencies by calling 'get' method in initializer
       like above.

       In that case, only LWP::UserAgent and HTTP::Cookies are initialized.

METHODS
   new
       Create new object.

   instance
       Create singleton object and return it.

   register( $class, @args )
   register( $class_or_name, $initialize_code )
   register( { class => $class_or_name ... } )
       Register classes to container.

       Most simple usage is:

           Object::Container->register('WWW::Mechanize');

       First argument is class name to object. In this case, execute
       'WWW::Mechanize->new' when first get method call.

           Object::Container->register('WWW::Mechanize', @args );

       is also execute 'WWW::Mechanize->new(@args)'.

       If you use different constructor from 'new', want to custom
       initializer, or want to include dependencies, you can custom
       initializer to pass a coderef as second argument.

           Object::Container->register('WWW::Mechanize', sub {
               my $mech = WWW::Mechanize->new( stack_depth );
               $mech->agent_alias('Windows IE 6');
               return $mech;
           });

       This coderef (initialize) should return object to contain.

       With last way you can pass any name to first argument instead of class
       name.

           Object::Container->register('ua1', sub { LWP::UserAgent->new });
           Object::Container->register('ua2', sub { LWP::UserAgent->new });

       If you want to initialize and register at the same time, the following
       can.

           Object::Container->register({ class => 'LWP::UserAgent', preload => 1 });

       initializer option can be specified.

           Object::Container->register({ class => 'WWW::Mechanize', initializer => sub {
               my $mech = WWW::Mechanize->new( stack_depth );
               $mech->agent_alias('Windows IE 6');
               return $mech;
           }, preload => 1 });

       This is the same as written below.

           Object::Container->register('WWW::Mechanize', sub {
               my $mech = WWW::Mechanize->new( stack_depth );
               $mech->agent_alias('Windows IE 6');
               return $mech;
           });
           Object::Container->get('WWW::Mechanize');

       If you specify args option is:

           Object::Container->register({ class => 'LWP::UserAgent', args => \@args, preload => 1 });

       It is, as you know, the same below.

           Object::Container->register('LWP::UserAgent', @args);
           Object::Container->get('LWP::UserAgent');

   unregister($class_or_name)
       Unregister classes from container.

   get($class_or_name)
       Get the object that registered by 'register' method.

       First argument is same as 'register' method.

   remove($class_or_name)
       Remove the cached object that is created at "get" method above.

       Return value is the deleted object if it's exists.

   ensure_class_loaded($class)
       This is utility method that load $class if $class is not loaded.

       It's useful when you want include dependency in initializer and want
       lazy load the modules.

   load_all
   load_all_except(@classes_or_names)
       This module basically does lazy object initializations, but in some
       situation, for Copy-On-Write or for runtime speed for example, you
       might want to preload objects.  For the purpose "load_all" and
       "load_all_except" method are exists.

           Object::Container->load_all;

       This method is load all registered object at once.

       Also if you have some objects that keeps lazy loading, do like
       following:

           Object::Container->load_all_except(qw/Foo Bar/);

       This means all objects except 'Foo' and 'Bar' are loaded.

EXPORT FUNCTIONS ON SUBCLASS INTERFACE
       Same functions for "load_all" and "load_all_except" exists at subclass
       interface.  Below is list of these functions.

   preload(@classes_or_names)
   preload_all
   preload_all_except
       As predictable by name, "preload_all" is equals to "load_all" and
       "preload_all_except" is equals to <load_all_except>.

SEE ALSO
       Class::Singleton, Object::Registrar.

AUTHOR
       Daisuke Murase <typester@cpan.org>

COPYRIGHT & LICENSE
       Copyright (c) 2009 KAYAC Inc. All rights reserved.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

       The full text of the license can be found in the LICENSE file included
       with this module.

perl v5.40.2                      2025-08-09              Object::Container(3)
