SAVVYCAN(1)                        SavvyCAN                        SAVVYCAN(1)



NAME
       savvycan - SavvyCAN Documentation

       Contents:

MAIN / START UP SCREEN
       [image]

       This screen embodies the core of the program. Here you will find the
       master list of all frames. Also, here you can navigate to the other
       aspects of the program. You can have multiple sub-windows open at once
       - in fact, quite often this is very beneficial.

THE MAIN FRAME LIST
       The main frame list takes up the majority of the main screen. This list
       consists of the following sections:

       • Timestamp: The timestamp is either in microseconds or seconds. This
         is a setting in preferences. Either way, the timestamp can have
         microsecond resolution. The difference is just whether there is a
         decimal point or not. GVRET has the ability to maintain full
         microsecond resolution for timestamping purposes. There is a third
         timing mode where the timestamp can be customized and is based upon
         the actual "clock" time.

       • ID: The ID is specified either in hexadecimal or decimal (a
         preference you can set). This is the message identifier sent over the
         CAN bus.

       • Ext: 0 = Standard message (11 bit ID). 1 = Extended message (29 bit
         ID)

       • Dir: Either "Rx" or "Tx" to show whether SavvyCAN has received or
         sent this message.

       • Bus: SavvyCAN supports a variety of capture hardware. GVRET
         compatible devices can support more than one bus. The bus a frame
         came in on is specified here. Many file formats do not specify bus
         and thus all frames will be loaded as bus 0.

       • Len: The number of data bytes that were sent with this frame. It can
         range from 0 to 8.

       • Data: All of the data bytes separated by spaces. Can be in either
         hexadecimal or decimal (preference). If "Interpret Frames" is checked
         you will also see extra data at the end of any frames that have DBC
         data. To see the rest of this data click upon the frame in the list.
         It will automatically expand to show all signals attached to that
         frame.

THE BOTTOM STATUSBAR
       At the very bottom of the main screen is a status bar with two
       sections.

       • The first section shows the connection status. You will see the
         number of currently connected buses here.

       • The second section shows which file is currently loaded. This is
         updated by loading or saving.

THE REST OF THE MAIN WINDOW
       To the right of the main frames list is an area that shows the total
       number of captured frames and the frames per second. Total frames might
       not match the number of shown frames. If you've deselected any IDs in
       the filter list then fewer frames will be shown. Frames per second is
       calculated as an average and so will wind up or down when there is a
       sudden change.

       Suspend Capturing / Resume Capturing is a button that will temporarily
       disable frame capture or re-enable it. This can be used to keep
       everything connected without capturing traffic for a short time. This
       can help to not capture traffic in between tests.

       The "Normalize Frame Timing" button is used to reset the lowest
       timestamp to "0" and offset all other timestamps accordingly. This is
       useful to remove the starting offset when you start up the GVRET board
       long before actual traffic starts. SavvyCAN is designed such that this
       doesn't really matter most of the time but normalizing the timing might
       be useful to help correlate the timing between two different captures.

       The "Clear Frames" button will erase all captured messages. They will
       be irreversibly erased and all memory will be freed.

       The "Auto Scroll Window" checkbox will cause the main frame list to
       hunt toward the bottom of the list as frames come in. It will normally
       not be quite at the very bottom as, for performance reasons, the
       program runs at quarter second updates to things like the auto scroll.
       Thus, the main list will be scrolled to the bottom four times per
       second.

       The "Interpret Frames" checkbox is used to specify whether the loaded
       DBC file should be used to interpret all available messages and
       signals. One might want this off for performance reasons (interpreting
       takes some extra processor power and RAM) or to declutter the main
       frame list.

       The "Overwrite Mode" checkbox is used to ensure that only the newest
       frame for each message ID is shown. That is, if 100 messages with ID
       0x105 come in you will see only the newest one. This is generally used
       alongside "Interpret Frames" to interpret frames and always see the
       up-to-date information.

       "Frame Filtering" provides a list of all the frame IDs seen so far. Any
       ID which is checked will be shown in the main list. Any ID which is
       unchecked will not.  This can be used to hone in on frames of
       importance while hiding frames that are currently of no interest. The
       filtered list can be saved as well.

LOADING AND SAVING FRAMES
       What CANBus analysis tool would be complete without an easy way to load
       and save frames?

       SavvyCAN can load and save in several formats (a few of which are
       listed below):

              • CRTD: This format was made by Mark Webb-Johnson for OVMS (open
                vehicle monitoring system) and other related tools. It is a
                reasonably readable and compact format.

              • GVRET: This is the native format for GVRET and SavvyCAN. The
                GVRET format saves more information such as the bus a frame
                originated on. This format is in CSV (comma delimited) format
                and as such can easily be loaded into your favorite
                spreadsheet program as well.

              • Generic ID/DATA - Another CSV format. This is a very cut down
                format with limited information.

              • BusMaster - This is the format output by the BusMaster CANBus
                program. BusMaster is an open source Windows-only somewhat
                clone of CANAlyzer (the 800lb gorilla in the analysis space).
                The ability to load and save in this format makes SavvyCAN
                fully capable of swapping data with BusMaster should you need
                to do so.

              • Microchip - Format output by Microchip CANBus tools. Perhaps
                you have logs that were captured with a $100 Microchip dongle?
                You can load them in SavvyCAN.

       There are many other formats supported. Some are only supported for
       writing, some only for reading. The list of supported formats is
       expanded every so often.

FILTERS
       You might notice that there are three entries in the file menu that
       mention filters. SavvyCAN can filter messages so that you only see some
       of the messages coming in on the bus. It still saves all incoming
       messages but you are able to filter which you will view at any given
       time.  SavvyCAN allows for loading and saving the list of frames you'd
       like to view so that you can easily switch "sets" of frames to view.
       Also, when saving you can optionally save just the frames that you have
       filtered instead of every captured frame. Filters are set in the lower
       right-hand of the this screen. All IDs are selected by default. To
       deselect an ID click on the checkbox next to it. You can also deselect
       all IDs or select all IDs. These are useful if you only want to view a
       couple of IDs (click None then the few you need) or you just want to
       remove a couple (click All and then deselect the ones you don't care
       about).

WHAT IS DBC AND WHY WOULD I CARE?!
       I'm glad you asked. DBC is a file format used to specify how "signals"
       are stored in "messages." A message is essentially a unique packet of
       data sent on the CAN bus. Ordinarily this message is differentiated by
       frame ID. Each ID is a different message (usually).  A signal is a
       piece of data stored in a message. For instance, ID 0x105 might be a
       message from the vehicle control unit to the motor inverter. Within
       that message bytes 0 and 1 might encode the desired torque. That would
       be a signal. A DBC file allows these relationships to be specified and
       named. It also allows for scaling of values stored in a signal.
       Additionally, a signal can have values associated with textual output.
       For instance, if a signal encodes the current gear then a DBC file can
       define that a value of 0 means "Park" and a value of 1 means "Drive".
       This makes analysis a lot easier since you do not need to remember the
       mapping yourself. In this way data can be better understood by users of
       the program. Also, other windows can use the DBC file for such things
       as being able to graph a signal without having to figure out the actual
       details of that signal.

HOW DBC INTERACTS WITH THE MAIN SCREEN?
       First of all, one can load and save DBC files from the "DBC File
       Manager" found in the File menu. Also in the File menu it is possible
       to save the currently loaded frames but with DBC decoding. This is
       somewhat like the normal saving functionality with a two differences:
       there is only one output format and that format has all signals
       contained in each message listed and decoded.

CONNECTION WINDOW
       .  [image]

       The connection window is used to add, remove, and modify connections.
       At the moment it is possible to use any QT SerialBus compatible device
       and any GVRET compatible device in any of the supported operating
       systems. SerialBus supports socketcan on linux, passthrough on Linux
       and Windows 32 bit, and Vector, PeakCAN, and TinyCAN on supported OS's.

       At this time GVRET compatible devices are: EVTVDue, EVTV CANDue
       (1.3/2/2.1/2.2), Teensy 3.1-3.6, Macchina M2, EVTV ESP32 Due.

CONNECTING TO A DONGLE
       SavvyCAN is able to connect to GVRET compatible devices to capture new
       traffic. These devices will present as serial ports on the connected
       PC.  To connect to a dongle select the proper serial port and click
       "Create New Connection".  If a valid device is found on that serial
       port the first statusbar section will update and the currently set
       canbus speeds will show in the table at the left of the window.  These
       speeds can then be changed by clicking on the speed (or otherwise
       selecting the cell in the table) and typing in a new value. Leaving the
       cell will update the speed to the new value. GVRET devices also support
       setting "listen only" on each bus. This mode causes the device to not
       acknowledge any traffic or try to modify the bus at all. It is as it
       says, a mode where you can only listen to whatever traffic is found on
       the bus. Some older GVRET devices supported a mode where you could
       change the second bus between single wire CAN and normal CAN. This is
       deprecated. However, newer GVRET devices have dedicated single wire CAN
       buses and the relevant bus will show the checkbox.

       SavvyCAN can also connect to a wide variety of CAN hardware through the
       built-in QT SerialBus drivers. These drivers vary by operating system
       but support socketcan on LINUX and Vector tools on both LINUX and
       Windows. When you select "QT SerialBus Devices" you will get a list of
       device types supported. Select a device type and for most devices you
       should see the Port list fill out with all registered and valid ports
       for that driver. Socketcan devices, for instance, are automatically
       detected now. Then push "Create New Connection" and you should see the
       new connection in the table on the left of the window. Note that
       SocketCAN devices don't support changing the baud rate within a
       program. You must do this when you set up the connection via console
       commands. This is outside the scope of this documentation.  Consult the
       SocketCAN documentation for details on configuring such devices.

       The last connection option is "Remote Host." If you select this option
       then Port will change to a textbox. Enter the IP address of the remote
       (but still local to your LAN) IP address. Currently this works with
       EVTV ESP32 boards and M2 boards.

DEBUGGING CONNECTION PROBLEMS
       GVRET devices present as serial ports and have significant
       configuration options.  However, the ability to configure so many
       things and the ability to compile the firmware yourself both come as a
       double edged sword. They present many opportunities for things to go
       wrong. Because of this there is a debugging console present on the
       connection window.  Click a bus in the table then click "Enable
       Console" to cause it to start logging serial traffic. From this console
       you can see what is going on. It shows what SavvyCAN is sending and
       what it is getting back. It has extended status messages that might
       help to narrow down what is going wrong. Additionally, if you're
       feeling adventurous you can send traffic to the serial device from the
       Send line. "Send Hex" accepts a set of hex values separated by spaces.
       "Send Text" will send the raw text you type on the line. GVRET traffic
       is ordinarily binary so "Send Text" won't work very well for that. But,
       there is also a text console possible on GVRET devices. If you connect
       to them with a serial program you can configure things via a text
       console. Type ? and follow it up with some form of line ending (Cr, Lf,
       CrLf, any will work).

PREFERENCE WINDOW
       .  [image]

SETTING PREFERENCES
       There are a variety of preferences that can be set in the program and
       persisted for future sessions.

       "Save/Restore window positions and sizes": If this is set then the size
       and placement of the various windows in this application will be saved
       when the program is closed and loaded when each window is brought back
       up in the future. This can be used to create your own preferred layout.
       If you'd rather things come up in their default state every time then
       you can uncheck this box.

       "Display values as hexadecimal": A lot of the time people who are doing
       CAN reverse engineering like to see values in hexadecimal (base 16)
       instead of the more familiar decimal (base 10) system. Checking this
       box will cause most of the values in the application to show up in hex.
       This applies to CAN ids and data bytes. Unchecking this causes values
       to default to decimal instead. The reason for using hex is that each
       hex digit is 4 bits. Integers on a computer tend to be in multiples of
       8 - 8, 16, 32, 64. So, hex digits have a direct mapping to the
       underlying binary. Decimal does not have this correspondence AT ALL.
       But, the choice is yours.

       "Require validation of GVRET connection": GVRET style devices run over
       a serial connection. Serial connections can be finicky sometimes and so
       the connection can be validated to prove that everything is really
       still operating and talking. There probably isn't any reason to turn
       this off except while debugging to see if it changes anything. Mostly
       just don't touch this.

       "Time Keeping": There are a variety of ways one could timestamp CAN
       frames as they come into the program. Selecting "Seconds" will cause
       the timestamp to be expressed as seconds since the frame list was last
       cleared. This tends to be an easy choice to work with. "Microseconds"
       will express the timestamp as millionths of a second since the last
       time the frame list was cleared. This is exactly like "Seconds" mode
       but without any decimal point. You might find this to be a bit hard to
       conceptualize. The last option is "System Clock" this will timestamp
       frames with the current system time when the frame came in. This is
       still very precise but now you'll get an absolute time stamp with the
       full date and time. The display of this mode can be changed by editing
       the "Time Format String" value. It defaults to an output that looks
       like "JAN-10 12:34:53.234" But you can set it to other values. Look
       here to find a reference for how you can create new format strings:
       http://doc.qt.io/qt-4.8/qdatetime.html#toString

       "Use filtered frames in sub-windows": The main window has a filtering
       interface where you can uncheck IDs to hide them. Ordinarily when you
       bring up one of the other windows it will still use the main unfiltered
       list. Sometimes you really do want to deal with the filtered list of
       frames even in the other windows. If this is checked then the other
       windows will see the filtered list and not the unfiltered actual list
       of frames that have been captured.

       "OpenGL Accelerated AntiAliased Graphing": A personal favorite of mine.
       Checking this will cause all of the graphs to use OpenGL 3D
       acceleration. Most modern machines have some form of 3D acceleration so
       this option should be OK to use. If you check this your graphs will
       look a lot better and on good hardware should also be faster. In the
       future other options are likely to be added to the graphing screen that
       will likely only be enabled if OpenGL mode is also enabled. Try
       enabling this and see if performance is still good. It's safe to leave
       it off if in doubt.

       "Autoscroll main frame window by default": If checked it will
       automatically check the relevant checkbox on the main screen when the
       program starts. This will cause the view to automatically scroll to the
       bottom by default. This is merely a convenience option if you'd prefer
       it to be the default.

       "Use timestamp mode by default": This is another convenience option.
       With this checked the Flow view will default to using time stamps on
       the graphing area instead of frame numbers.

       "Set Auto Reference by default": The Flow view can either use static
       referencing or dynamic referencing (see the Flow view documentation for
       more info). If you'd like to use dynamic referencing and automatically
       set the reference by default then check this option.

       "Loop by default": Set the playback window to default to looping
       infinitely by default.

       "Default playback speed (ms)": Set the default timing for playback

       "Default Sending Bus": Set a default for which bus to send frames on.

       "Auto expand all nodes": Both of the referenced windows have tree views
       that potentially have a large number of nodes. It's more neat not to
       expand them all by default but it also then requires more clicks if you
       have to expand them to view the information. So, you can set whether
       you'd like to expand them all by default or not.

       After changing preferences it is the best practice to close and reopen
       the application to ensure that all settings have taken effect.

DBC FILE MANAGER
       .  [image]

WORKING WITH DBC FILES
       This screen allows you to load and save DBC files. SavvyCAN supports
       loading more than one DBC file at a time. It can even use more than one
       DBC file per bus. But, "Associated Bus" can be used to associate a
       given DBC file to only one bus. If you don't need to associate to any
       specific bus then set this value to -1 which means "any bus." The J1939
       button causes SavvyCAN to mask out J1939 message IDs to conform to
       J1939 signaling. You can create a brand new DBC file by clicking
       "Create new DBC" button. It will be automatically named a unique name
       for you. You probably don't want that name though. Any time you save a
       DBC file its name will automatically update in the list. The "Load",
       "Save", "Remove", "Edit" buttons are all straight forward. You can also
       edit a DBC file by double clicking it in the list.

DBC FILE ORDERING
       The "Move Up" and "Move Down" buttons can be used to change the order
       of DBC files. Why would you care? DBC files are accessed in the order
       they are in the list. When a frame is interpreted the system goes
       through the DBC files in order. It selects the first DBC file that is
       associated to the bus the message came in on and that implements the
       correct message ID. So, if you have multiple DBC files it is possible
       that the order might matter.

DBC MESSAGE EDITOR
       .  [image]

WORKING WITH NODES
       In DBC files a node is a device on the CAN bus. For instance, the
       engine control unit (ECU) would be a node as would a motor controller,
       a battery charger, or any other device that is connected to the CAN
       bus. DBC files let you define nodes that are set as either the sender
       or receiver of a message. This allows messages to be organized for more
       easy retrieval. To add a new node click on the empty row beneath the
       last defined node and type a new name and optionally a comment. The
       comment is not used by SavvyCAN but can be filled out for your own
       reference. When a node is selected in the top list you will then see in
       the bottom a listing of every message it sends.

WORKING WITH MESSAGES
       The bottom list is all of the messages that are sent by the selected
       node. A message is defined based on its message ID. The message ID is
       the CAN id used for this message. For normal DBC files this creates a
       one to one correspondence of ID to a given CAN ID. For J1939 messages
       special masking is done and so more than one actual CAN id will map to
       the given message ID but still only one specific J1939 PGN will come
       through. Once a message ID is entered in for a new message it will
       attempt to auto populate the Data Len column with the number of data
       bytes that message has. This is only for your information, it is not
       used by SavvyCAN. You can give the DBC message a meaningful name. The
       "Fg" and "Bg" columns can be clicked on to set a color. This will set
       the foreground and background color to use for this message. These
       colors will be used in the main frame view on the main screen when you
       click "Interpret Frames." Clicking on the "Signals" column will bring
       up the signals editor for that message so that you can edit, add, or
       remove signals from the message. The "Comments" column is once again
       not used by SavvyCAN and only for your viewing reference.

DBC SIGNAL EDITOR
       .  [image]

DEFINING AND EDITING SIGNALS
       If you're starting from scratch or otherwise adding a signal then you
       will need to right click in the list box in the upper left of the
       window. From there select "Add a New Signal." This will create a
       randomly named signal that you can then edit.

       Otherwise, select a signal to edit. The details of it will fill out the
       rest of the window.

       On the right side you can rename the signal and you'll see that it is
       renamed in the list as well.

       "Bit Length" - This sets how many bits the signal uses. Once you do
       this you'll see that that many bits are now highlighted in the 8x8 data
       grid above. The black bit is the "start" bit, green bits are the other
       bits in the signal. Gray bits are already used by another signal. You
       can still use them for the current signal too but doing so would be
       quite unusual.

       "Byte Order" - The way that the green bits are filled out is changed by
       this checkbox. Checking it selects little endian mode whereas
       deselecting chooses big endian mode. This will have an effect on any
       signal that crosses byte boundaries.

       "Type" can be: 1. UNSIGNED INTEGER - No sign bit, only positive numbers
       2. SIGNED INTEGER - The top bit is used as a sign bit 3. SINGLE
       PRECISION - Floating point number (should be a 16 bit signal) 4. DOUBLE
       PRECISION - Floating point number (should be a 32 bit signal) 5. STRING
       - Directly turn the CAN bytes into a string

       "Scale" is used to multiply the signal by the value to scale it
       appropriately

       "Bias" is added to each value generated by the signal to set it at a
       different bias point

       "Min Value" is purely informational. It is just a reference to anyone
       else viewing the DBC information as to what you expect the lowest value
       to be.

       "Max Value" is likely informational.

       "Units Name" is displayed after the value when you interpret a signal
       on the main frames list. For instance, you could set the units name to
       V so that a voltage value reads something like "12.34V" when it is
       displayed.

       "Receiving Node" This is informational at the moment. You can set which
       node (out of all your defined nodes) is the one that receives this
       signal.

       "Multiplexing" This is a somewhat involved topic. DBC signals can be
       multiplexed which means that a given frame might have a range of data
       that is not always found in every frame. There is a key of sorts that
       specifies which piece of data this particular frame is sending. This
       leads to the concept of multiplexed signals and multiplexors.
       Multiplexors are the key. They provide a value that specifies which
       multiplexed data item is being sent. A multiplexed signal is then
       connected to a specific value of the multiplexor. Thus, a multiplexed
       signal requires that a multiplexor also exists. You would normally set
       all of this to "Not multiplexed" and skip all this complication. But,
       multiplexed signals do exist. In that case the message would have one
       multiplexor and one or more multiplexed signals. So, you'd set up a
       multiplexor for the message and then create additional multiplexed
       signals that are marked as "Multiplexed" and have filled out the
       "Multiplex Value" with something unique.

       "Comment" is purely informational.

       Signals that use either "UNSIGNED INTEGER" or "SIGNED INTEGER" as their
       type can define a Value Table. This table allows text strings to be
       substituted in place of integer values. For instance, if you know that
       a value of 0x10 means PARK then you can go to the next empty entry in
       the list, type 0x10 for the value and PARK for the Text. This will make
       the interpreted value read PARK any time the signal has a value of
       0x10. This is used to make a more human friendly presentation. It
       should be noted that if the signal has a value not in the list then it
       will still be shown as it's integer value. But, known good values can
       be entered in the Value Table to make them easier to work with.

GRAPHING WINDOW
       .  [image]

CREATING A NEW GRAPH
       Right click in the graph window to bring up a popup menu. The last
       entry in the first section is "Add new graph". This brings up the Graph
       Setup Window. From there you can create a new graph.

SELECTING A GRAPH
       You can select a graph either by clicking on it or by clicking its name
       in the list of graphs up that the top right.

EDITING A GRAPH
       You can either double click its name in the list of graphs at the top
       right or select the graph, right click, and select "Edit Selected
       Graph"

DELETING GRAPHS
       There are two options. You can select a graph, right click, and select
       "Remove selected graph" or you can right click and select "Remove All
       Graphs"

MOVING AROUND
       Left clicking and dragging in the graphing area will allow you to pan
       around. The mouse wheel (if you have one) will let you zoom in and out.
       If you select the numbers on either the X or Y axis then you'll be able
       to pan and zoom on just that axis leaving the other alone. This is
       useful in order to expand or shrink the time axis or to rescale the
       vertical axis to better fit the data in view. The "+" key will zoom in,
       the "-" key zooms out. You can also zoom in and out from the pop up
       window that appears when you right click. If you've messed up your view
       and can't figure out how to fix it then right click and select "Reset
       View" to get a nice view of all the data again.

LOADING AND SAVING GRAPHS
       It can be beneficial to create a set of graphs that can be used over
       and over. You can save the currently setup graphs to a file and then
       load it later. Right click on the graphing window and use "Save graph
       definitions to file" and "Load graph definitions from file" to do this.
       You can also save a picture of the graphing window. PDF, PNG, and JPG
       are supported. Lastly, you can save a spreadsheet of all the graphed
       points.

REAL TIME GRAPHING
       Sometimes it is useful to graph while data are still being captured.
       When this is done it is additionally handy if the view follows the new
       data. In the right click pop up menu you will find "Follow end of
       graph". It is a checkbox. When it is on the current view will follow
       the end of the data captured. The "window" you've set up will scroll.
       That is, the zoom and vertical calibration will stay the same and only
       the "Time Axis" will scroll such that the end of the capture is always
       at the right hand side of the graphing window.

HIDDEN TRICKS
       If you double click on a graphed line the main window will scroll and
       the frame that produced the nearest data point to where you clicked
       will be selected. Additionally, if you selected "Synchronize Windows"
       in Flow view then the graphing view will synchronize to Flow view as
       well.

GRAPH SETUP
       .  [image]

SETTING UP A GRAPH
       This same screen is used whether you are creating a new graph or
       editing an existing graph. If you are creating a new graph then you
       have two options.

GRAPHING A DBC SIGNAL
       If you want to graph a signal from a DBC file that you have loaded then
       pick the Message from the combo box. Picking a message will then allow
       you to pick a signal within that message. After selecting both the
       message and the signal then click the "Copy Signal Parameters" button.
       This will fill out the left hand side with the proper values for you
       automatically.

MANUAL SIGNAL GRAPHING (OR EDITING)
       If you want to manually create a signal or edit an existing signal then
       you will find the relevant fields on the left hand size of the window.

       "Name" is for your reference and will be shown on the Graphing Window.

       "ID" is the frame ID to use for this graph. You can enter in either
       decimal or hex. Hex values are preceded by 0x

       "Data Len" is used to specify how many bits are in the signal to graph.
       You can graph odd bit lengths such as 9, 11, or 15 bits. These are not
       as uncommon as you might think.

       "Little Endian" switches between little and big endian mode. This will
       change how the signal grabs bits from the frame.

       Once you've set both Data Len and Little Endian you can set the bits to
       use. The 8x8 grid above is used for this. Click on the start bit and
       the rest of the bits will automatically be selected for you based on
       Data Len and Little Endian.

       "Signed" can be used to select between signed and unsigned mode.

       "Mask" will apply a mask to the value before using it.

       "Bias" allows for setting an offset to the values to bring them to a
       different resting point

       "Scale" is used as a multiplier to change the scaling of the values

       "Stride" is not often used but will cause only every "x" values to
       actually be graphed. This can be used to graph a very dense set of data
       with less points to speed things up.

       "Color" changes the color of the graphed line. It is automatically
       randomly set for new graphs but if you don't like the random color you
       can click the color and select a better one.

FLOW VIEW WINDOW
       .  [image]

THE PURPOSE OF FLOW VIEW
       Flow view is meant to show a view of what "happens to" the data for a
       given ID as time goes on. The flow is a flow of time or messages going
       by. The goal is to visualize what is going on as time passes. The
       screen is very busy but everything has the same goal - to show the data
       bytes across the list of all frames with that ID.

SELECTING AN ID TO FLOW
       Along the left most side of the window is a list of every frame ID
       captured so far. You can select any of these IDs. Once you select an ID
       you'll see the number of frames with that ID just to the right of the
       IDs list (in the bottom of the Playback Control box).

VIEWING THE FLOW
       There are a variety of ways that the data bytes for the current frame
       are displayed. Toward the middle of the window there are 8 text boxes
       that show the current value of each data byte. At the right of the
       window are two visualizations. On the top there is an 8x8 grid that
       visualizes every possible bit in a CAN message. Bits which are white
       are currently 0 or off. Bits which are black are 1 or on. Bits that are
       green are newly on in this frame. They were 0/off in the reference.
       Bits which are red are newly off in this frame. Those bits were 1/on in
       the reference.

       Below the 8x8 grid view is a graph based view. The "+" in the center
       marks the "current" time. You can thus see both into the future and the
       past (relative to the current frame) in this view. All 8 data bytes are
       graphed according to their value. You can thus see in the graph what
       the value is doing as time ticks by.

       Between these three views you should have a very good idea of how the
       data bytes change over time.

CONTROLLING THE FLOW
       The screen has many ways to control the flow. The "Playback Control"
       box has 6 icons in a 3x2 grid. The upper icons mean (from left to
       right): Go back one frame, Stop, Go forward one frame. The bottom icons
       mean: Play backward, pause, Play forward. Playback speed is used to
       control how quickly the flow happens. You can raise and lower this
       value even as the flow is playing back and it will change the flow
       speed in realtime. You can select "Loop Playback" to keep looping over
       and over. It is possible to select "0" as the frame interval. This will
       make the program progress as quickly as it can. This probably will not
       be much faster than a frame interval of 1 but it will be a bit faster.

ADDITIONAL CONTROL OPTIONS
       Below the "Playback Control" box is a set of three check boxes. "Live
       Mode" will cause the flow view to keep the current frame at the latest
       received frame from the capture hardware. This is thus a "real time"
       option where the flow will happen in real time as frames come in.
       "Synchronize windows" causes the flowing in this window to update the
       position in the main window so that the main window is always at the
       current position in flow playback. "Graph by timestamp" causes the
       "Time Axis" at the bottom of the graph view to be in seconds or
       microseconds. Deselecting this will cause that axis to instead be in
       frame number.

REFERENCE VALUES
       Previously it was mentioned that bits in the 8x8 grid are colored based
       on whether they are newly on/off or steady state compared to the
       reference. What is the reference? Well, look to the left of the 8x8
       grid. The reference values here are used for reference with the 8x8
       grid. You can set these values to something static and then see how
       bits compare to that static reference. Or, above the reference values
       is a checkbox called "Auto Reference" if this is clicked then the last
       frame is used as a reference for the current one. There are advantages
       to both options. A static reference can be used to see how things
       change compared to, say, the very first frame. Auto reference shows how
       the data changed from frame to frame. Either might yield interesting
       findings. The default values for static reference are taken from the
       values that the first frame has. You are free to change them to any
       value 0 through 0xFF.

SEEKING TO SPECIFIC VALUES
       Lastly, it is possible to seek to specific values. "Data Seek Values"
       normally default to -1. But, if a value other than -1 is found in one
       of these boxes then it will be used as a seek value. Any time the flow
       is playing back (either forward or backward) it will compare to the
       seek values. If there is a match then playback will automatically stop.
       This can be used to quickly play things back until you get to a
       specific value. One use would be to seek to a known value that precedes
       an important section you want to analyze in more depth. Also, in this
       same vein, if you click in the 8x8 grid of bits you will see that the
       cell you clicked on has the text turn blue and become bold. Any bit
       that you've selected this way will also act as a way to stop playback.
       If that bit changes, either being set or unset, then playback will
       stop. Click the cell again to deselect it.

BISECTOR WINDOW
       .  [image]

USING THE BISECTOR WINDOW
       The purpose of this window is obviously to split the list of frames
       into two pieces. You have many options for how to do this. You can
       split by:

       ID Range - Grab a set of frames between two values. Note that you
       cannot pick and choose frame IDs here but rather just use a list. If
       you want to pick and choose then use the filter interface on the main
       form and then save the filtered list from the File menu.

       Frame Number - You can split right at a given frame number. All frames
       up to that number will be on one side with all the rest on the other.

       Percentage - Pretty much just like the Frame Number option but in
       percentage instead in case that is more convenient.

       In all cases, you have the option of which side of the split you want
       to save. Click "Calculate Split" to process the split. You will see
       above the buttons a reference of how many frames there were in total
       and how many you would be saving after the split. From here you should
       be able to do one of two things:

       "Save split frames to a new file" - Save the new list of frames (after
       the split) to a file. You can save to any file format that SavvyCAN
       supports elsewhere.

       "Replace main list with split frames" - Were this to work it would
       replace the frames loaded in the rest of the application with the split
       list. I'm sure this would be a really nice thing to be able to do.
       Well, you can't right now. It's not implemented yet. So, just imagine
       you can do this. In the mean time you can save to a file then load that
       file. Sorry...

SNIFFER WINDOW
       .  [image]

USING THE SNIFFER WINDOW
       This window is essentially a turbo charged graphical version of the
       linux can_utils program "cansniffer". The general idea here is to
       display a list of frames such that you only see frames that are
       actively updating. If a given ID has not been seen in 5 seconds the ID
       portion will turn RED and then disappear from the list. In this way
       only frames that are updating are in the list. They are ordered by ID.
       Bytes that have decremented will be red and bytes that have incremented
       will be green. You can use the "Filters" area to mask away some IDs so
       that they never show up. This can help to declutter the list.

       This window updates with a 200ms interval.

NOTCHING AND UNNOTCHING
       While the window is running it keeps a running list each 200ms cycle of
       all the bits that changed in that timespan. Each 200ms this list is
       backed up and reset. If you push the notch button the system will
       remember all the bits that were set in the last 200ms window and will
       not color the output if those bits are toggled in the future. They will
       thus somewhat be ignored except that you can visually still see them
       updating. If you click the Notch button repeatedly it will add any new
       changed bits to the old changed bits. In this way you can build up a
       set of bits to ignore. Un-notching causes all notched (ignored) bits to
       be reset and thus all changes will be colored once again.

ADVANCED OPTIONS
       All of the above was valid if you do not check any of the four
       checkboxes. With the checkboxes unchecked this window is very close to
       cansniffer on the command line. But, what fun is that?  These
       checkboxes modify the way the window works in a variety of ways.

NEVER EXPIRE IDS
       This checkbox will do exactly what it says on the tin. Instead of frame
       ID's expiring after 5 seconds of inactivity they will stick around
       forever. This can be useful so that the ID you are watching doesn't
       jump up and down as IDs expire and potentially come back later on or
       new IDs are seen. With no expiration you will get a more consistent
       view of the IDs. You are still free to filter away IDs you are not
       interested in.

MUTE NOTCHED BITS
       This checkbox might sound a bit strange. With this checked any bytes
       that you have notched will ignore any notched bits and not even change
       the display to update if only notched bits were changed.  This
       completely hides all notched data. The view of the frames will then NOT
       perfectly or correctly represent the actual most up to date data for
       each ID. So, use this option with caution. But, it is handy when you
       are looking for a needle in a haystack and you don't want things
       changing if you've already told the program to notch them away.

FADE INACTIVE BYTES
       This can be used with mute or without but has a similar purpose. When
       this is checked any bytes that haven't updated recently will begin to
       fade away to white. They never quite get all the way to disappearing
       but will fade to be very light. In this way only data which is actively
       changing will be very visible. This drastically aids in helping you to
       ignore any bytes that are not changing.

VIEW BITS
       This option changes the view very starkly. This is the view shown in
       the picture associated with this topic. When View Bits is selected the
       display will change to show each bit within the bytes as separate
       blocks that each can separately be black when set and unchanged, white
       when unset and unchanged, red when freshly unset, and green when
       freshly set. This allows for a very fine grained view. Fade inactive,
       and never expire still work as usual. This mode might be a bit "busy"
       and lowers the number of IDs you can see at once. But, the choice is
       yours. You give up some density in exchange for verbosity.

FRAME DETAILS WINDOW
       .  [image]

THE PURPOSE OF FRAME DETAILS WINDOW
       This window is used to get detailed statistics about frames.

       It provides information about a given frame ID across all frames with
       that ID. You can get such information as the number of frames, the
       number of data bytes that frame ID has, the average interval between
       frames with that ID, and the minimum and maximum interval.

       Also listed are detailed statistics for each data byte in that frame.
       Each byte has listed which bits changed, the range of values found, and
       a histogram both graphically (at the right-hand side of the window) and
       textually. The textual representation shows the number of times a
       specific value occurred.

       The top right graph is a histogram of all the bits and the number of
       times each bit was set. This can be used to quickly visually see where
       data has changed.

       The bottom right graph is of each individual byte as its value varies
       over time. All textual information can be saved to a text file for
       later analysis.

FILE COMPARISON WINDOW
       .  [image]

THE PURPOSE OF THE FILE COMPARATOR
       This screen can be used to figure out what is different between a set
       of files. On one side you have a single file. This is called the "File
       of interest". On the other side you have any list of files. They're not
       listed any longer as actual files. The program can load frames from any
       number of files and dump them all into the same "bucket" of frames. You
       can thus load up a batch of files and compare them against the one
       "File of interest." The purpose of this is to figure out what is
       different. Are there IDs found only on one side? For IDs found on both
       sides are there bits set only on one side and not the other? This can
       be used to find stubborn data that you are having trouble locating. One
       use is to capture a large amount of traffic to use as "background
       noise" of sorts. Perhaps drive around for a long time or let the
       vehicle idle for some time but never do the thing you need to find.
       Then do another capture and do the thing you're missing a few times.
       Perhaps you're looking for a gear shift signal. You could capture a
       large batch of frames while idling. Then, in a second capture shift
       several times. Now, compare the two. Somewhere in the differences
       should be the gear selection you couldn't find. The list ought to be
       much more narrow than just "shooting in the dark" so to speak.

THE LAYOUT OF THE DIFFERENCES LIST
       In the differences list you'll find three main tree nodes:

       1. IDs found only in <file of interest>

             • In sub nodes you'll find every ID found only in the file of
               interest and not in any of the reference files.

       2. IDs found only in reference frames

             • In theory this should be a fairly small list. Here are any IDs
               never seen in the file of interest

       3. IDs found in both

             • Here is where the interesting information lies. The sub nodes
               here are found in both places. A list of all differences will
               be shown sub nodes of each ID node. Here you can see bits set
               only in one side or the other. You can also find values only
               found on one side or the other. These might be candidates for
               your mystery signal.

FUZZING WINDOW
       .  [image]

THE PURPOSE OF FUZZING
       Some people are big fans of fuzzing, some people have no use for it.
       There usually isn't much in between. So, what is fuzzing and why would
       you want to do it? Fuzzing is intentionally sending random information
       to see what happens. It's pretty much the "shotgun" solution - you fire
       birdshot into the air and see if it hits anything. Does that sound a
       bit dangerous? It kind of is. So, why do it? It might help you to find
       frame IDs that control things. It might help you to find a data byte
       that controls something. Used carefully it can be used to figure out
       how different values affect things.

FUZZING IS DANGEROUS
       You have now been warned. Sending random garbage over the CAN bus to
       see what happens could mess something up. It just might put your
       vehicle into gear and cause you to drive over a box full of kittens. Be
       careful! Never fuzz a car unless you're right there and you can stop
       it. Even better, don't do it unless your car is up on a hoist or jacks
       and can't drive over anyone. Even still, there is a small chance you
       could cause an adverse effect to your car. If you break something you
       own the pieces.

CONTROLLING THE FUZZY BEAST
       So, you want to give it a try? Let's do it! First of all, you can set
       the delay between frames and the burst rate. The delay is in
       milliseconds but can be set as low as 0. If the delay is set to 0 then
       the system will attempt to send frames as fast as it can. However, even
       then you may not get quite as many frames per second as you'd like.
       Even at 0 it will still be scheduled by your operating system and so
       might not quite get to the speed you want. The burst rate can cause the
       program to send one than one frame each interval. This is useful as a
       CAN bus could potentially support 2000 to 8000 frames per second. If
       you need rapid frame sending your best bet is to set the sending
       interval to 1-2ms and then adjust the burst rate until you get your
       desired sending rate. Then you can set the number of bytes to send.
       Ordinarily this would be the full 8 but you can experiment with smaller
       frames. You can set to send on a specific bus. That's all the simple
       settings. It gets a bit more complicated now.

       The "ID Scanning" box has two radio buttons:

       1. Sequential will go from "Start ID" to "End ID" then reset back to
          Start over and over.

       2. Random will pick IDs at random in the range between Start and End

       But, perhaps you don't want to fuzz IDs like that? The next box is "ID
       Selection" and the choices are:

       1. Range of IDs - this uses the aforementioned Start and End IDs

       2. Filter list - This causes it to pick frame IDs from the list below
          either sequentially or randomly according to the radio boxes under
          "ID Scanning"

       The last box is "Bit Scanning"

       1. Sequential causes it to scan bits in logically sequential order.
          That is, the first available fuzzing bit is set then the just the
          second, then the first two, etc. This causes all of the fuzzed bits
          to sequentially set in order.

       2. Sweep causes the system to set the first one, then unset that one
          and set the second bit, then unset that, etc. Thus the fuzzed bit
          sweeps and only one fuzzed bit is set at once.

       3. Random will randomly pick whether each fuzzed bit is set or not.

       In order to fuzz bits you need to set which bits to fuzz and which not
       to. As listed at the bottom of the window, there is a color code to the
       8x8 grid. Clicking cells in the grid will toggle them between their
       various values. White bits are never set, black bits are always set no
       matter what, green bits follow the fuzzing pattern you specified in
       "Bit Scanning" You can also set the bytes directly with the text boxes
       above the 8x8 grid. Setting a hexadecimal value in these boxes will set
       the relevant bits in the 8x8 grid. You must press the ENTER/RETURN key
       to set the values. Merely changing the value will not update it (as a
       safety measure).

PULLING THE TRIGGER
       Once you've configured everything click "Start Fuzzing" to give it a
       shot. You will see the number of frames sent so far listed below the
       button. Approximately four times per second the current value for each
       byte is copied into the text boxes just above the 8x8 grid. This can be
       used to see what is going on and to ensure that it is working the way
       you want it to. You can stop the fuzzing by pushing the start button
       again.

ISO-TP DECODER
       .  [image]

USING THE ISO-TP DECODER
       This window scans the existing captured frames and newly captured
       frames to see if it can find CAN traffic that seems to conform to the
       ISO-TP standard. ISO-TP is used to send multi-frame messages and as an
       encoding standard that forms the base for other protocols such as UDS
       and ODBII (which is essentially itself a subset of UDS).

       The main list at the top shows any messages that seem to conform to
       ISO-TP. There will very likely be messages here which aren't really
       ISO-TP. You can deselect IDs that seem to generate false positives so
       that they quit showing up in this list. As you can see in the picture
       only the ids 0x7E0 through 0x7EA were selected. These IDs are standard
       for UDS communication. If you want to immediately recalculate the
       results to exclude the deselected IDs then push "Interpret Previously
       Captured Frames" to regenerate the whole list. Otherwise the effect of
       changing the ID selections will only happen for newly captured frames.

       The "Show incomplete and/or corrupted messages" checkbox will cause a
       lot of false positives and should only be used as a last resort if you
       suspect that you might have some dropped traffic.

       "Use extended addressing" will cause the decoder to assume that
       extended addressing is being used on this CAN bus. Extended addressing
       adds an additional byte of addressing that is found in the data bytes
       of the frame. This isn't that commonly used but is used on some
       vehicles and ISO-TP decoding won't work properly unless this setting is
       correct. If you find that decoding seems to have failed you might try
       toggling this setting to see if it helps. Remember to click "Interpret
       Previously Captured Frames" to recalculate things for previously
       captured traffic.

       Once you have messages in the table at the top of the window you can
       click on a message to get more details about it in the text box in the
       lower left. In the picture you can see that 0x7F 0x10 0x12 was
       interpreted as a UDS error response saying that the ECU does not
       support the requested sub-function passed to the diagnostic session
       control service. This is much easier than trying to remember what all
       those bytes mean off the top of your head!

RANGE STATE WINDOW
       .  [image]

USING THE RANGE STATE WINDOW
       The purpose of this window is to search for signals that look like they
       might be important. That's a rather nebulous description. But, the idea
       is to find signals that seem to vary somewhat coherently. As you can
       see in the picture in this help, the displayed signal has some jumps
       but they look like they might "be something." That's the idea. It will
       generate a lot of false positives but it will still provide some decent
       ideas for where to look for signals. It is up to you to figure out if
       the signal is anything important or anything you can use.

       To use it first set up the follow things:

       1. The ID Filter list - Deselect any IDs you don't want to search.

       2. Sensitivity - This is a subjective measurement. It doesn't affect
          the results a lot but changing this value back and forth can alter
          what the program thinks is a relevant signal.

       3. Min Signal Size - The smallest signal you want to search for. You
          can search for signals all of the way down to 1 bit if you're
          feeling adventurous.

       4. Max Signal Size - The largest signal you want to search for. The
          range between Min and Max changes how long the process will take. If
          you set Min to 8 and Max to 16 then it will search for signals with
          8, 9, 10, 11, 12, 13, 14, 15, 16 bits. You will get duplicates as
          the same basic set of bits will be used for all of the sizes.

       5. Granularity - Sets the bit jump width. What is bit jump width? The
          number of bits that we move over each time we search for a new
          signal. If you have a granularity of 1 and a minimum signal width of
          8 then it will search starting at bit 0 for an 8 bit message then
          starting at bit 1 then bit 2, etc. If you set a granularity of 8
          then it will search for an 8 bit signal at bit 0 then search at bit
          8, then 16, etc. So this sets how finely we will search for signals.
          A lot of times signals will be found on byte edges so a granularity
          of 8 will cause all signal searches to start on byte boundaries and
          this will be OK for many things. But, some designers are more
          devious and place signals at uneven boundaries. You might need finer
          granularity to find such signals.

       6. Signal Mode - For signals over 8 bits there is a choice to make.
          Signals over 8 bits can be either in big or little endian mode. This
          relates to whether bit 0 of a signal is the highest or lowest value.
          You can search for only big endian signals, only little endian, or
          try it both ways. Usually the developer of a CAN device will stick
          to one or the other but not always.

       7. Signed Mode - Likewise, any signal over 1 bit could be either
          unsigned or signed. Signed signals have their highest bit as 1 for
          negative numbers and 0 for positive numbers. You can search for only
          unsigned signals, only signed, or try it both ways. There really
          isn't any rhyme or reason for when a signal would be signed or
          unsigned. It could easily be both ways so unless you're sure it's
          probably safest to allow the program to try it both ways and you can
          pick which looks best.

       Once you've got it all set up click "Recalculate Candidate Signals." Be
       prepared to wait depending on what options you selected. Once it is
       done processing you'll get a list of candidates in the upper list
       labeled "Candidate Signals." Here you can see all of the signals it
       found. You get the ID, the starting bit (remember, bits start at 0 and
       go through 63), the length, and whether it was signed/unsigned and
       big/little endian. If you click on or otherwise select a signal in this
       list then a graphical view of it will appear in the graphing area
       beneath. You might try the arrow keys Up and Down to move through the
       list. You can even hold down the arrow key and let it rapidly scroll.
       As it scrolls through the signals you can look at the graph and stop
       when you see a signal that catches your eye. This is useful as you can
       have hundreds of candidates and it is tedious to view them explicitly
       one at a time.

UDS SCAN WINDOW
       .  [image]

PURPOSE OF THE UDS SCAN WINDOW
       This is essentially another CAN fuzzing window but a very special one.
       This window is meant to search for UDS compliant (or nearly compliant)
       nodes on the CAN bus. It can also be used to do a blanket search for
       services, sub functions, and data items on a known UDS node.

USING THE UDS SCAN WINDOW
       UDS queries are sent out on the bus from "Starting ID" to "Ending ID".
       Usually UDS compliant ECUs will respond to 0x7E0 through 0x7E7 which is
       why those are the defaults. Some vehicles use UDS "like" protocols on
       other IDs. Usually UDS nodes reply with an ID 8 higher than the request
       ID. This is thus the default in the program. However, some nodes cheat
       and do not do this. It is quite common for responses to come from an
       address 16 higher instead. To deal with this situation there is a
       checkbox "Allow adaptive reply offset." If this is checked then replies
       will be accepted no matter what address they come from. Deselecting
       this will cause only replies of the proper offset to be accepted. The
       offset defaults to 8 but can be changed with the "Reply Offset"
       selector. Additionally, you can select which bus to scan and set how
       long you want to wait for replies.

       "Show tests with no Replies" - This checkbox does what it says. It is a
       personal preference whether you'd like to see an entry in the list for
       scans that returned no results. Sometimes an ECU will just plain ignore
       messages it doesn't like. In that case you have the option to see an
       entry in the list telling you that the message was ignored or whether
       you'd prefer to reduce clutter and just skip anything that had no
       reply.

       You need to also set a type of scan to do. You can select more than one
       type but if you don't set any then you aren't going to see any results.
       Keep that in mind as none are checked by default.

       "Read By ID" - UDS allows one to read data from the ECU by an ID
       number. These are not defined anywhere and are custom to each ECU. But,
       you can use this to scan a range of IDs to see if you get a response to
       any of them. There is no real standard for how many bytes the ID will
       be. It could be 1, it could be 2, 3, 4. It's likely to be around 2. You
       can set the number of subfunction bytes which will set the size of the
       ID. Then you can set the upper and lower bound to scan.

       "Read By Addr" - You can also read data by address. Like IDs the
       address could be different sizes depending on the hardware you are
       querying. This works the same as reading by ID but by address instead.

       "Session Ctrl" - UDS has the concept of session type. Some types are
       "normal" "extended diagnostics" "programming". Scanning for session
       type will try them all and let you know which the device supports.
       However, note that you might get a response that indicates that
       conditions are not correct or that access was denied. This probably
       means that the mode is actually supported but you'd have to do the
       right things first. This is still useful information. This scan window
       is too simple to use for further cracking of such things but the
       scripting interface is the perfect thing to use instead.

       "ECU Reset" - The ECU might also support being reset by a UDS message.
       This scan type will try the various reset types and see which are
       supported.

       "Security Access" - When a device is first started and normally
       operating it will generally not allow you to do potentially dangerous
       or sensitive operations such as downloading firmware or changing
       parameters. To do these things you need to enter a different security
       level. The security access mechanism is used for this. There are a few
       different security levels that are likely to be supported. This scan
       type will attempt to find security levels and see if they are protected
       or not. That is, unfortunately for the casual cracker, most of the time
       the elevate security levels will be protected by a challenge/response
       system. The ECU will send you a challenge in the form of one or more
       random looking bytes. You are tasked with returning the proper response
       for those challenge bytes. You generally don't have very many guesses
       before your hands are slapped. Sometimes the C/R is actually fixed and
       you can just capture valid traffic once and then use the same response
       forever. Sometimes the C/R is stupidly easy or there are only a couple
       of different possible answers. Sometimes the ECU developer actually
       took more than 2 seconds to implement these features and your work will
       be cut out for you. This scan type will find which levels the ECU seems
       to support but is unlikely to actually unlock them.

       "Tester Present" - A scan that tries to see if tester present is
       supported. It almost certainly is. This scan can be used to sweep a
       wide range of addresses just to narrow down the list of addresses to
       scan more thoroughly. Normally tester present is sent periodically by a
       connected device just to let the ECU know that someone is still there.

       "Wildcard" - Allows for you to set a lower and upper range for the
       service byte as well as the number of subfunction bytes and the range
       there as well. This allows for UDS fuzzing by shooting the moon and
       trying a huge range of traffic just to see what is supported and what
       isn't. This test can take a VERY long time if you aren't careful but
       will thoroughly determine what the ECU will support and what it won't.

PLAYBACK WINDOW
       .  [image]

PREPARING FRAMES FOR PLAYBACK
       The first order of business is to load some CAN frames that you'd like
       to play back onto a CAN bus. In the lower left is a section titled
       "Playback Sequence". It is so named because this playback interface can
       play a chain of different CAN captures very configurably. It consists
       of a list of captures to playback along with how many times to play
       each sequence item. For instance, you could play a file twice then go
       to the next, then play a third one four times. A playback item can
       either come from a file (Load File) or from the current list of
       captured frames on the main window (Load Captured Data). If you load
       the currently captured frames it truly means "currently". That is, if
       more traffic comes in it will not play that new traffic back. A
       snapshot is taken at the time you push the button. Each sequence item
       has its own list of ID filters. In this way you can send only some of
       the frame IDs from the capture and this list can be different for each
       file or capture you load. The list of ID filters can be saved and
       loaded to make the process faster in the future.

       Once you've set up a sequence of frames to playback you can also decide
       whether you'd like to loop that sequence forever or not. Up above the
       Playback Sequence and ID Filtering sections is the "Loop Sequence"
       checkbox.

PLAYING BACK FRAMES
       The playback window can send frames on a specific bus, all buses (be
       careful with that!) or "From File." Some file formats store which bus
       each frame came in on. Also, the main window stores that info. So,
       captures that stored the bus properly could be used to send frames out
       multiple buses always to the proper bus for the frame in question. But,
       if you load a capture without this info it will default to bus 0 so
       bear that in mind.

       The next order of business is frame timing. There are two approaches
       possible here. If you click "Use original frame timing from captured
       frames" then frames will be sent out in approximately the same timing
       as they came in with. The word approximately is used because it is
       difficult to get 1ms timing precision on a desktop OS. Frames that come
       in rapidly might have a 2-3ms jitter. In practice this is almost always
       irrelevant. This setting is suitable for nearly all uses.

       Alternatively, it is also possible to send on a set schedule. With the
       "Use original" checkbox not checked you can set a playback speed in
       milliseconds and a burst rate. Burst means that it'll send that many
       frames every tick. So, if you have a burst of 5 and a timing of 10ms
       then every 10ms 5 frames will be sent. This mode can provide for a
       predictable number of frames per second and could be useful to test how
       quickly a device really requires traffic without faulting. But, it will
       potentially drastically alter the timing of frames compared to their
       timing when they were captured.

       The top of the window has a series of 6 icons all in a row:

       1. White Left Arrow - Play the last frame (just one frame)

       2. Pause sign - Pause playback

       3. Green Left Arrow - Play frames backward

       4. Blue Stop Button - Stop playback and return to the first frame in
          the first capture in the sequence

       5. Green Right Arrow - Play frames forward

       6. White Right Arrow - Play the next frame (just one frame)

PLAYBACK STATUS
       Below the number spinners for Playback Speed and Burst Rate is text
       that displays the currently playing sequence item along with the
       current frame within that capture.

CUSTOM SENDER WINDOW
       .  [image]

GENERAL OVERVIEW
       This window allows you to create custom frames that will be sent out on
       one of the can buses. The uses are endless.  It can be used to generate
       valid traffic to control connected hardware. It can be used to test out
       various ideas you might have for now to interact with other devices. It
       can replay frames from one bus into the other bus but with
       modifications.

LAYOUT OF THE VIEW
       This screen is laid out as a data grid.

       • The first field is "En" which stands for Enabled. If the checkbox is
         checked then this line will be active.

       • The second field is "Bus" and sets which bus to use for sending.

       • The third field is "ID" and is the ID to use for sending. It can be
         specified in hex or decimal formats.

       • The fourth field is "Len" and sets the number of data bytes for this
         frame.

       • The fifth field is "Data" and specifies what values will be sent for
         the next frame. These values can be automatically updated by the
         modifiers which will be covered later on.

       • The sixth field is "Trigger" which specifies when this frame will be
         sent. Proper syntax for triggers is covered later.

       • The seventh field is "Modifications" which specifies how the data
         bytes for this frame will be changed for the next frame sent. Full
         syntax for this is covered later on.

       • The final field is "Count" and is automatically filled out with the
         number of frames that have been sent as a result of this line.

WRITING TRIGGER RULES
       It should first be noted that each line can contain multiple triggers.
       Each trigger is separated by a comma ','.

       Triggers are allowed to have one or more conditions. Each condition
       contained within a single trigger is separated by a space ' '.

       The program implements the following conditions:

       • id - Set the trigger to activate when a frame with the given ID is
         received. The syntax is 'id' followed by the numeric ID you want to
         match. Example: 'id0x200'

       • ms - Set the number of milliseconds to wait. This condition acts
         differently depending on whether you have set ID matching as well. If
         so then ms will cause a delay of the requested number of milliseconds
         after receiving a frame with the ID. If not, the trigger will
         constantly fire every time the requested number of milliseconds have
         elapsed. The syntax is the number of desired milliseconds followed by
         'ms'. For example: '40ms'.

       • x - Only allow this trigger to fire a set number of times. The syntax
         is the number of times you want the trigger to fire followed by 'x'.
         For example: '100x'.

       • bus - Only trigger when a frame with the given ID comes in on the
         specified bus. Otherwise the triggering frame could come from either
         bus. The syntax is 'bus' followed by either '0' or '1'. For example:
         'bus0'

       Now, a full example of a trigger line: "id0x200 5ms 10x bus0,1000ms"
       This trigger means: Trigger when a frame with ID 0x200 comes in on bus
       0. Wait 5 milliseconds before sending and only allow this to happen at
       most 10 times. Also, always trigger every 1 second and never stop doing
       this.

WRITING MODIFICATIONS
       As with the triggers, you can have multiple modifications per line;
       each of which is separated by a comma ','.

       Modifications always start with a data byte to modify The syntax is 'D'
       or 'd' followed by a number 0 through 7.  For example: 'D4'. This is
       then always followed by an equal sign '='. Thereafter there is a string
       of operands and operations.

       Operands have a special syntax. Each operand can have multiple sections
       separated by colons ':'.

       • D - A data byte. Specifies which data byte 0 - 7 from the given frame
         to use for this operation. If specified on its own it will reference
         the data in the "Data" section of this line. The syntax is 'd' or 'D'
         followed by a number 0 - 7. Example: 'D3'.

       • ID - Instead of grabbing data from this line's data bytes grab it
         from the last frame received with the given ID.  Syntax: 'ID'
         followed by a colon ':' followed by the ID to match against. Example:
         'ID:0x200'

       • BUS - Restrict which bus the frame used for grabbing the data bytes
         can come in on. Syntax: 'BUS' followed by a colon ':' followed by 0
         or 1 to specify which bus to use. Example: 'BUS:0'

       • <NUMBER> - Instead of using a data byte from somewhere you can
         instead use a numeric literal. The syntax is the same as any number -
         either a series of numbers or 0x followed by a series of numbers and
         A - F to specify a hexadecimal number. Example: 0x10.

       A few full examples of operands:

       • "bus:0:id:0x120:D3" = Grab byte 3 from the last frame with ID 0x120
         that came in on bus 0.

       • "0x200" = Use the numeric value 0x200 directly.

       • "id:0x200:D7" = Grab byte 7 from the last frame received with ID
         0x200.

       Each operand is usually followed by an operation and then a second
       operand. If no operation or second operand is found that is also OK.
       Thus a modifier can be as simple as "D0 = D1" if you choose. Operands
       can also be directly chained such that the output of the last operation
       is used as the left hand operand for the next operation. This will be
       shown later on.

       Modifiers can use the following operations:

       • + - Add the two operands together. Example: "D1 + D2"

       • - - Subtract the second operand from the first operand. Example: "D1
         - D2"

       • * - Multiply the two operands together. Example: "D1 * D2"

       • / - Divide the first operand by the second operand. Example: "D1 /
         D2"

       • & - Do the bitfield operation AND on the two operands. Example: D1 &
         0x20

       • | - Do the bitfield operation OR on the two operands. Example: D1 |
         0x10

       • ^ - Do the bitfield operation XOR on the two operands. Example: D1 ^
         0xD2

       Putting all of that together yields complete modifiers. For simplicity
       all operations are done left to right. There is no special order of
       operations like in normal mathematics.

       Here are a few examples:

       • "D0=D0+1" = Take the value in D0 within this line's data bytes, add
         1, and store it back in D0.

       • "D1=ID:0x200:D3+ID:0x200:D4&0xF0" = Grab byte 3 from the most
         recently received frame with ID 0x200 and add it to byte 4 from the
         same received frame. AND this new value with 0xF0 and finally store
         it in D1 of the data bytes for this line.

       • "D2=D4 * 10 + D3 & 0x3F" = Multiply byte 4 by 10, add the new value
         to byte 3, AND the resulting value by 0x3F and store it in byte 2.

SCRIPTING INTERFACE
       .  [image]

PURPOSE OF THE SCRIPTING INTERFACE
       To give you an open ended place where you can write JavaScript files
       that do whatever you need them to do. You can load several files at
       once and they'll all work at the same time. Scripts can expose
       parameters that can then be edited by you while the program is running.
       They also update 4 times per second so they can be used to give
       feedback of the current state of the script as well. But, it is safer
       to give status in the "Log Window" instead. However, for values that
       might need to be seen and frequently updated it might be easiest to
       show them as "Public Variables".

MANAGING SCRIPTS
       In the bottom left is the "Loaded Scripts" list. You can create a new
       script by clicking the "New" button below the list. The new script will
       have a random name until you save it. The "Del" button will delete the
       currently selected script but it will ask you first. The "Load" button
       will load a new script from a file. The "Save" button is above the main
       script view which is in the upper right of the window. "Revert" will
       revert the script to the last version that was compiled. Any changes
       you've made since compiling well be reverted. "Recompile" is used to
       compile the script and begin running the new version.

GETTING SCRIPT STATUS
       There are two places you can look for the status of a script. The "Log
       Window" is directly below the script source code editor. This window is
       shared between all scripts and shows the status of compiling scripts as
       well as log messages from each script. The script name that sent the
       log message is prepended. The number before the script name is the
       amount of time the scripting window had been open for when the message
       was sent. This unified interface can be used to keep an eye on all of
       the running scripts and to debug issues when a script is compiled. Any
       compile errors will show up in the log window. You can set the checkbox
       on "Auto Scroll Log Window" to make it continue to stay at the bottom
       of the log. You can clear the log at any time as well.

       The other way to see script status is to use the "Public Variables"
       interface. Here you will find variables that were registered by the
       current script. Each script has its own list so information that needs
       to be updated frequently and/or specific to a script and easily
       accessible should be registered here. But, public variables can have
       their value set by you, the user, as well. So, care should be taken not
       to edit variables used for script feedback and scripts shouldn't try to
       change the value of variables used for input to the program.

WRITING SCRIPTS
       You are more or less free to write JavaScript scripts but, of course,
       you aren't in a web browser so browser specific functions are just not
       there. In their place are a couple of JS objects that allow the script
       to interface with the CAN buses connected to SavvyCAN. Also, certain
       functions can be created to automatically register callbacks.

CALLBACK FUNCTIONS
       These functions can be created in your scripts to enable certain
       functionality:

       setup () - If you create a function named setup then it will be called
       as soon as the script starts. Yes, you probably could just dump code
       into no function at all right into the file but that's bad form!

       tick () - If you registered to receive a periodic tick within your
       setup function then the script interface will call this function for
       every tick. You can do whatever you need to periodically do here. But,
       you get only one tick handler so if you need multiple tick rates you'll
       have to create a fast tick here and dispatch from this function at
       different rates yourself.

       gotCANFrame (bus, id, len, data) - A callback that will be called
       whenever a CAN frame comes in that you've registered for. You did
       register for frames in your setup function didn't you? Well, if you use
       one of the below callbacks you might not need this one.

       gotISOTPMessage (bus, id, len, data) - If you are instead looking for
       ISO-TP messages (which could have been multiple CAN frames in length)
       then you can create this function and it will automatically be
       registered with the system. But, you still will need to set which
       ISO-TP message IDs you want to receive. That is covered later on.

       gotUDSMessage (bus, id, service, subfunc, len, data) - UDS messages are
       transmitted over ISO-TP but with additional structure. If you're
       looking to interface directly at the UDS level then you can create this
       function to have it automatically registered. As with raw CAN and
       ISO-TP you still need to specify which messages IDs you are interested
       in.

THE HOST OBJECT
       The first object you can use is "host" This object handles setup of the
       tick timer as well as logging output and registration of public
       variables.

       host.setTickInterval(interval) - If the interval is more than 0 then
       your tick callback will be called every "interval" milliseconds. If a
       value of 0 is passed then the tick timer will be stopped.

       host.log(text) - Send text to the log window. It will be timestamped,
       marked according to which script sent it, and placed into the log
       window.

       host.addParameter("variablename") - Add the named variable to the list
       of public variables. From then on any changes that you make in the GUI
       will immediately show up in the script and any changes the script makes
       to a value will reflect in the GUI within 250ms. Remember to use quotes
       around the variable name. You want to pass the variable name, not its
       value.

THE CAN OBJECT
       This object is your interface to raw CAN. It has the following
       functions:

       can.setFilter(id, mask, bus) - register to receive messages based on an
       ID, Mask, and Bus. It works like this. First the bus is compared. If it
       doesn't match the frame is not delivered to you. Then, the incoming
       frame has its ID ANDed with your mask. Let's say your mask is 0x7F0 and
       the incoming frame has an ID of 0x235. 0x235 AND 0x7F0 is 0x230. This
       value is compared to the ID you passed. So, if your filter ID is 0x230
       then the frame is accepted and you will get a callback with the frame.
       Otherwise the frame is not delivered to you. This masking setup is very
       common in CAN bus interfaces. Basically, the mask allows a single
       filter to accept a range of IDs. 0x7F0 would accept 16 different IDs
       (0x230 through 0x23F in this case). 0x700 accepts 256 different IDs,
       etc.

       can.clearFilters() - remove all filters and revert to a clean state.
       You will no longer receive any CAN callbacks unless you create more
       filters with setFilter.

       can.sendFrame(bus, id, length, data) - Send a CAN frame out the given
       bus. The CAN id will be what you set as will the length. The length can
       thus be different from the actual length of "data" which should be a
       valid javascript array. The length can not exceed 8. The frame will be
       sent as soon as possible so long as that bus is connected and not in
       listen only mode.

THE ISOTP OBJECT
       isotp.setFilter(id, mask, bus) - Exactly like the raw CAN version in
       the can object. Allows you to register a filter so that you can receive
       ISO-TP traffic from the filtered addresses. It should be noted that
       you'll essentially only get traffic that seems to be able to be turned
       into ISO-TP traffic. Any CAN frames obviously not ISO-TP will be
       rejected.

       isotp.clearFilters() - Clear all ISO-TP filters and no longer receive
       ISO-TP traffic.

       isotp.sendISOTP(bus, id, length, data) - As in the can version. The
       difference here is that ISO-TP messages can be longer than 8 bytes and
       so might get turned into a multi-frame set of messages with flow
       control. This is handled for you by SavvyCAN so you needn't handle of
       the details of the exchange.

THE UDS OBJECT
       uds.setFilter(id, mask, bus) - Exactly like the other two setFilter
       functions. Register for a set of IDs to be interpreted as UDS (if
       possible) and sent through to your callback. Any obviously not UDS
       traffic will be discarded.

       uds.clearFilter() - Remove all filters and quit receiving UDS traffic.

       uds.sendUDS(bus, id, service, sublen, subfunc, length, data) - Sends a
       UDS message out from the script. service must be between 0 and 255,
       subfunc can be larger than one byte if needed. data is only needed for
       extended payloads as the actual UDS protocol is handled by the service
       and subfunc parameters.

A FULL EXAMPLE SCRIPT

          var newID = 0; //set this to the ID you want your RLEC to become

          function setup ()
          {
              host.log("RLEC ID Changer");
              can.setFilter(0x0, 0x0F, 0);
              can.sendFrame(0, 0x7E0, 8, [0x0d, 1, 0, 0, 0, 0, 0, 0]);
          }

          function gotCANFrame (bus, id, len, data)
          {
               var dataBytes = [];

              if (len == 8)
              {
                  if (data[0] == 0xd && data[1] == 1 && data[2] == 0xAA)
                  {
                      host.log("Got challenge: 0x" + data[3].toString(16) + data[4].toString(16));
                      var notData3 = ~data[3];
                      var notData4 = ~data[4];
                      dataBytes[0] = 0xD;
                      dataBytes[1] = 2;
                      dataBytes[2] = ((notData4 & 0xF) << 4) + ((notData3 >> 4) & 0xF);
                      dataBytes[3] = ((notData4 >> 4) & 0xF) + ((notData3 & 0xF) << 4);
                      dataBytes[4] = 0;
                      dataBytes[5] = 0;
                      dataBytes[6] = 0;
                      dataBytes[7] = 0;
                      can.sendFrame(0, 0x7E0, 8, dataBytes);
                  }
                  if (data[0] == 0xd && data[1] == 2 && data[2] == 0xAA)
                  {
                      host.log("Passed security Check!");
                      dataBytes[0] = 4;
                      dataBytes[1] = 0x15;
                      dataBytes[2] = newID;
                      can.sendFrame(0, 0x7E0, 8, dataBytes);
                  }
                  if (data[0] ==4 && data[1] == 0x15 && data[2] == 0xAA)
                  {
                      host.log("ID Reprogramming Successful!");
                  }
              }
          }

AUTHOR
       Collin Kidder

COPYRIGHT
       2018, EVTV



189                            November 5, 2022                    SAVVYCAN(1)
