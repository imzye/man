COCOR(1)                FreeBSD General Commands Manual               COCOR(1)

NAME
       cocor - Compiler generator generator

SYNOPSIS
       cocor filename.atg [ options ]...

DESCRIPTION
       cocor reads a specification from filename.atg and generate a compiler (
       scanner, parser and main module )

OPTIONS
       -C Generate complete compiler driving module, including source listing
       featuring interleaved error message reporting.  To use this option the
       file COMPILER.FRM (or <grammar>.FRM ) must be available.

       -D Generate Source line number (#line) for each semantic action. This
       causes the semantic actions in the generated C program to be labelled
       with reference to the original .ATG file, so that one can use a
       symbolic debugger on the .ATG file.

       -L (Listing) Force listing (Normally the listing of the grammar is
       suppressed if the compilation is error free).

       -P (Parser only) Suppress generation of the scanner.  As with the
       regeneration of the definition modules, regeneration of the scanner is
       often tedious, and results in no changes from the one first generated.
       This option must be used with care.  It can also be used if a hand
       crafted scanner is to be supplied (see the notes on the use of hand
       crafted scanners in the file COCOL).

       -T (Tests) Suppress Generation of Scanner and Parser.  (If this option
       is exercised, the generation of the scanner and parser is suppressed,
       but the attributed grammar is parsed and checked for grammatical
       inconsistencies, LL(1) violations and so on).


       The following options are really intended to help with
       debugging/teaching applications.  Their effect may best be seen by
       judicious experimentation.


       -A Trace automaton

       -F Give Start and Follower sets for each non-terminal in the grammar

       -G Print top-down graph

       -S Print symbol table

       When using Coco/R, the frame files SCAN_C.FRM and SCAN_H.FRM and
       PARSER_C.FRM and PARSER_H.FRM must exist in the current directory, or
       in the directories specified by the environment variable CRFRAMES.

GRAMMAR TESTS
       Coco/R performs several tests to check if the grammar is well-formed.
       If one of the following error messages is produced, no compiler parts
       are generated.

       NO PRODUCTION FOR X
       The nonterminal X has been used, but there is no production for it.

       X CANNOT BE REACHED
       There is a production for nonterminal X, but X cannot be derived from
       the start symbol.

       X CANNOT BE DERIVED TO TERMINALS
       For example, if there is a production

             X = "(" X ")" .
             X = Y.
             Y = X.

       X and Y are nonterminals with circular derivations.

       TOKENS X AND Y CANNOT BE DISTINGUISHED
       The terminal symbols X and Y are declared to have the same structure,

       e.g.:
                 integer = digit { digit } .
                 real = digit { digit } ["." { digit } ].

       In this example, a digit string appears ambiguously to be recognized as
       an integer or as a real.

       The following messages are warnings.  They may indicate an error but
       they may also describe desired effects.  The generated compiler parts
       may still be valid.  If an LL(1) error
        is reported for a construct X , one must be aware that the generated
       parser will choose the first of several possible alternatives for X.

       X NULLABLE
       X can be derived to the empty string, e.g.  X = { Y } .

       LL(1) ERROR IN X:Y IS START OF MORE THAN ONE ALTERNATIVE
       Several alternatives in the production of X start with the terminal Y
       e.g.:
              Statement = ident ":=" Expression
                        | ident [ ActualParameters ] .

       LL(1) ERROR IN X:Y IS START AND SUCCESSOR OF NULLABLE STRUCTURE
       Nullable structures are [ ... ] and { ... }
       e.g.:
              qualident = [ ident "." ] ident .
              Statement = "IF" Expression "THEN" Statement
                          [ "ELSE" Statement ] .

       The ELSE at the start of the else part may also be a successor of a
       statement.  This LL(1) conflict is known under the name dangling else .


SEE ALSO
       Moessenboeck, H., A Generator for Fast Compiler Front-Ends.  Report
       127, Dept. Informatik, ETH Zurich (1990)

       Moessenboeck, H., A generator for production quality compilers.  Proc
       3rd Int'l Workshop on Compiler-Compilers, Schwerin FRG, 1990


BUGS
       Mail bug reports to:

       C Version:              Frankie Arzu (farzu@uvg.edu.gt)






                              local - March 1996                      COCOR(1)
