NETCDF(3)                  UNIDATA LIBRARY FUNCTIONS                 NETCDF(3)

NAME
       netcdf - Unidata's Network Common Data Form (netCDF) library interface

SYNOPSIS
       include netcdf.inc


   Most Systems:
       f77 ...  -lnetcdf -lhdf5_hl -lhdf5 -lz -lm


   CRAY PVP Systems:
       f90 -dp -i64 ... -lnetcdf

       Complete documentation for the netCDF libraries can be found at the
       netCDF website: https://www.unidata.ucar.edu/software/netcdf/.


LIBRARY VERSION
       This document describes versions 3 and 4 of Unidata netCDF data-access
       interface for the FORTRAN programming language.

       character*80 nf_inq_libvers(void)

              Returns a string identifying the version of the netCDF library,
              and when it was built, like: "3.1a of Aug 22 1996 12:57:47 $".

       The RCS ident(1) command will find a string like "$Id: @(#) netcdf
       library version 3.1a of Sep  6 1996 15:56:26 $" in the library. The
       SCCS what(1) command will find a string like "netcdf library version
       3.1a of Aug 23 1996 16:07:40 $".

RETURN VALUES
       All netCDF functions (except nf_inq_libvers() and nf_strerror()) return
       an integer status.

       If this returned status value is not equal to NF_NOERR (zero), it
       indicates that an error occurred. The possible status values are
       defined in netcdf.inc.

       character*80 nf_strerror(integer status)

              Returns a string textual translation of the status value, like
              "Attribute or variable name contains illegal characters" or "No
              such file or directory".


FILE OPERATIONS
       integer function nf_create(character*(*) path, integer cmode, integer
              ncid)

              Creates a new netCDF dataset at path, returning a netCDF ID in
              ncid.  The argument cmode may include the bitwise-or of the
              following flags: NF_NOCLOBBER to protect existing datasets
              (default silently blows them away), NF_SHARE for synchronous
              dataset updates for classic format files (default is to buffer
              accesses),

              When a netCDF dataset is created, is is opened NF_WRITE.  The
              new netCDF dataset is in define mode.  NF_64BIT_OFFSET.  to
              create a file in the 64-bit offset format (as opposed to classic
              format, the default).  NF_TRUE to create a netCDF-4/HDF5 file,
              and NF_CLASSIC_MODEL to guarantee that netCDF-4/HDF5 files
              maintain compatibility with the netCDF classic data model.

       integer function nf__create(character*(*) path, integer cmode, integer
              initialsize, integer chunksize, integer ncid)

              Like nf_create() but has additional performance tuning
              parameters.

              The argument initialsize sets the initial size of the file at
              creation time.

              See nf__open() below for an explanation of the chunksize
              parameter.

       integer function nf_open(character*(*) path, integer mode, integer
              ncid)

              (Corresponds to ncopn() in version 2)

              Opens a existing netCDF dataset at path returning a netCDF ID in
              ncid.  The type of access is described by the mode parameter,
              which may include the bitwise-or of the following flags:
              NF_WRITE for read-write access (default read-only), NF_SHARE for
              synchronous dataset updates (default is to buffer accesses), and
              NF_LOCK (not yet implemented).

              As of NetCDF version 4.1, and if TRUE support was enabled when
              the NetCDF library was built, the path parameter may specify a
              TRUE URL. In this case, the access mode is forced to be read-
              only.

       integer function nf__open(character*(*) path, integer mode, integer
              chunksize, integer ncid)

              Like nf_open() but has an additional performance tuning
              parameter.

              The argument referenced by chunksize controls a space versus
              time tradeoff, memory allocated in the netcdf library versus
              number of system calls.  Because of internal requirements, the
              value may not be set to exactly the value requested.  The actual
              value chosen is returned by reference.  Using the value
              NF_SIZEHINT_DEFAULT causes the library to choose a default.  How
              the system choses the default depends on the system.  On many
              systems, the "preferred I/O block size" is available from the
              stat() system call, struct stat member st_blksize.  If this is
              available it is used. Lacking that, twice the system pagesize is
              used.  Lacking a call to discover the system pagesize, we just
              set default chunksize to 8192.

              The chunksize is a property of a given open netcdf descriptor
              ncid, it is not a persistent property of the netcdf dataset.

              As with nf__open(), the path parameter may specify a TRUE URL,
              but the tuning parameters are ignored.

       integer function nf_redef(integer ncid)

              (Corresponds to ncredf() in version 2)

              Puts an open netCDF dataset into define mode, so dimensions,
              variables, and attributes can be added or renamed and attributes
              can be deleted.

       integer function nf_enddef(integer ncid)

              (Corresponds to ncendf() in version 2)

              Takes an open netCDF dataset out of define mode.  The changes
              made to the netCDF dataset while it was in define mode are
              checked and committed to disk if no problems occurred.  Some
              data values may be written as well, see "VARIABLE PREFILLING"
              below.  After a successful call, variable data can be read or
              written to the dataset.

       integer function nf__enddef(integer ncid, integer h_minfree, integer
              v_align, integer v_minfree, integer r_align)

              Like nf_enddef() but has additional performance tuning
              parameters.

              Caution: this function exposes internals of the netcdf version 1
              file format.  It may not be available on future netcdf
              implementations.

              The current netcdf file format has three sections, the "header"
              section, the data section for fixed size variables, and the data
              section for variables which have an unlimited dimension (record
              variables).  The header begins at the beginning of the file. The
              index (offset) of the beginning of the other two sections is
              contained in the header. Typically, there is no space between
              the sections. This causes copying overhead to accrue if one
              wishes to change the size of the sections, as may happen when
              changing names of things, text attribute values, adding
              attributes or adding variables. Also, for buffered i/o, there
              may be advantages to aligning sections in certain ways.

              The minfree parameters allow one to control costs of future
              calls to nf_redef(), nf_enddef() by requesting that minfree
              bytes be available at the end of the section.  The h_minfree
              parameter sets the pad at the end of the "header" section. The
              v_minfree parameter sets the pad at the end of the data section
              for fixed size variables.

              The align parameters allow one to set the alignment of the
              beginning of the corresponding sections. The beginning of the
              section is rounded up to an index which is a multiple of the
              align parameter. The flag value NF_ALIGN_CHUNK tells the library
              to use the chunksize (see above) as the align parameter.  The
              v_align parameter controls the alignment of the beginning of the
              data section for fixed size variables.  The r_align parameter
              controls the alignment of the beginning of the data section for
              variables which have an unlimited dimension (record variables).

              The file format requires mod 4 alignment, so the align
              parameters are silently rounded up to multiples of 4. The usual
              call, nf_enddef(ncid) is equivalent to nf__enddef(ncid, 0, 4, 0,
              4).

              The file format does not contain a "record size" value, this is
              calculated from the sizes of the record variables. This
              unfortunate fact prevents us from providing minfree and
              alignment control of the "records" in a netcdf file. If you add
              a variable which has an unlimited dimension, the third section
              will always be copied with the new variable added.

       integer function nf_sync(integer ncid)

              (Corresponds to ncsnc() in version 2)

              Unless the NF_SHARE bit is set in nf_open() or nf_create(),
              accesses to the underlying netCDF dataset are buffered by the
              library. This function synchronizes the state of the underlying
              dataset and the library.  This is done automatically by
              nf_close() and nf_enddef().

       integer function nf_abort(integer ncid)

              (Corresponds to ncabor() in version 2)

              You don't need to call this function.  This function is called
              automatically by nf_close() if the netCDF was in define mode and
              something goes wrong with the commit.  If the netCDF dataset
              isn't in define mode, then this function is equivalent to
              nf_close().  If it is called after nf_redef(), but before
              nf_enddef(), the new definitions are not committed and the
              dataset is closed.  If it is called after nf_create() but before
              nf_enddef(), the dataset disappears.

       integer function nf_close(integer ncid)

              (Corresponds to ncclos() in version 2)

              Closes an open netCDF dataset.  If the dataset is in define
              mode, nf_enddef() will be called before closing.  After a
              dataset is closed, its ID may be reassigned to another dataset.

       integer function nf_inq(integer ncid, integer ndims, integer nvars,
              integer natts, integer unlimdimid)

       integer function nf_inq_ndims(integer ncid, integer ndims)

       integer function nf_inq_nvars(integer ncid, integer nvars)

       integer function nf_inq_natts(integer ncid, integer natts)

       integer function nf_inq_unlimdim(integer ncid, integer unlimdimid)

       integer function nf_inq_format(integer ncid, integer formatn)

              Use these functions to find out what is in a netCDF dataset.
              Upon successful return, ndims will contain  the number of
              dimensions defined for this netCDF dataset, nvars will contain
              the number of variables, natts will contain the number of
              attributes, and unlimdimid will contain the dimension ID of the
              unlimited dimension if one exists, or 0 otherwise.  formatn will
              contain the version number of the dataset <format>, one of
              NF_FORMAT_CLASSIC, NF_FORMAT_64BIT, NF_FORMAT_NETCDF4, or
              NF_FORMAT_NETCDF4_CLASSIC.


       integer function nf_def_dim(integer ncid, character*(*) name, integer
              len, integer dimid)

              (Corresponds to ncddef() in version 2)

              Adds a new dimension to an open netCDF dataset, which must be in
              define mode.  name is the dimension name.  dimid will contain
              the dimension ID of the newly created dimension.


USER DEFINED TYPES
       Users many define types for a netCDF-4/HDF5 file (unless the
       NF_CLASSIC_MODEL was used when the file was creates). Users may define
       compound types, variable length arrays, enumeration types, and opaque
       types.



       integer function nf_def_compound(integer ncid, integer size,
              character*(*) name, integer typeidp)

              Define a compound type.

       integer function nf_insert_compound(integer ncid, integer ,
              character*(*) name, integer offset, integer field_typeid)

              Insert an element into a compound type. May not be done after
              type has been used, or after the type has been written by an
              enddef.

       integer function nf_insert_array_compound(integer ncid, integer ,
              character*(*) name, integer offset, integer field_typeid,
              integer ndims, integer dim_sizes(1))

              Insert an array into a compound type.

       integer function nf_inq_type(integer ncid, integer , character*(*)
              name, integer sizep)

              Learn about a type.

       integer function nf_inq_compound(integer ncid, integer , character*(*)
              name, integer sizep, integer nfieldsp)

       integer function nf_inq_compound_name(integer ncid, integer ,
              character*(*) name)

       integer function nf_inq_compound_size(integer ncid, integer , integer
              sizep)

       integer function nf_inq_compound_nfields(integer ncid, integer ,
              integer nfieldsp)

       integer function nf_inq_compound_fieldname(integer ncid, integer ,
              integer fieldid, character*(*) name)

       integer function nf_inq_compound_fieldindex(integer ncid, integer ,
              character*(*) name, integer fieldidp)

       integer function nf_inq_compound_fieldoffset(integer ncid, integer ,
              integer fieldid, integer offsetp)

       integer function nf_inq_compound_fieldtype(integer ncid, integer ,
              integer fieldid, integer field_typeid)

       integer function nf_inq_compound_fieldndims(integer ncid, integer ,
              integer fieldid, integer ndims)

       integer function nf_inq_compound_fielddim_sizes(integer ncid, integer ,
              integer fieldid, integer dim_sizes(1))

              Learn about a compound type.

       integer function nf_def_vlen(integer ncid, character*(*) name, integer
              base_typeid, integer xtypep)

              Create a varaible length array type.

       integer function nf_inq_vlen(integer ncid, integer , character*(*)
              name, integer datum_sizep, integer base_nc_typep)

              Learn about a varaible length array type.

       integer function nf_free_vlen(nc_vlen_t *vl)

              Free memory comsumed by reading data of a varaible length array
              type.

       integer function nf_put_vlen_element(integer ncid, integer , void *
              vlen_element, integer len, void * data)

              Write one VLEN.

       integer function nf_get_vlen_element(integer ncid, integer , void *
              vlen_element, integer len, void * data)

              Read one VLEN.

       integer function nf_free_string(integer len, char **data)

              Free memory comsumed by reading data of a string type.

       integer function nf_inq_user_type(integer ncid, integer , character*(*)
              name, integer , integer , integer , integer )

              Learn about a user define type.

       integer function nf_def_enum(integer ncid, integer base_typeid,
              character*(*) name, integer typeidp)

              Define an enumeration type.

       integer function nf_insert_enum(integer ncid, integer base_typeid,
              character*(*) name, const void *value)

              Insert a name-value pair into enumeration type.

       integer function nf_inq_enum_member(integer ncid, integer xtype,
              integer idx, character*(*) name, void *value)

       integer function nf_inq_enum_ident(integer ncid, integer xtype, integer
              idx, integer*8 value, character*(*) identifier)

              Learn about a name-value pair into enumeration type.

       integer function nf_def_opaque(integer ncid, integer size,
              character*(*) name, integer xtypep)

              Create an opaque type.

       integer function nf_inq_opaque(integer ncid, integer xtype,
              character*(*) name, integer sizep)

              Learn about opaque type.



GROUPS
       Users may organize data into hierarchical groups in netCDF-4/HDF5 files
       (unless NF_CLASSIC_MODEL was used when creating the file).

       integer function nf_inq_grps(integer ncid, integer numgrps, integer
              ncids(1))

              Learn how many groups (and their ncids) are available from the
              group represented by ncid.

       integer function nf_inq_grpname(integer ncid, character*(*) name)

       integer function nf_inq_grpname_full(integer ncid, integer len,
              character*(*) name)

       integer function nf_inq_grpname_len(integer ncid, integer len)

       integer function nf_inq_grp_parent(integer ncid, integer ncid)

       integer function nf_inq_grp_ncid(integer ncid, character*(*) name,
              integer ncid)

       integer function nf_inq_full_ncid(integer ncid, character*(*) name,
              integer ncid)

              Learn about a group.

       integer function nf_inq_varids(integer ncid, integer nvars, integer )

              Get the varids in a group.

       integer function nf_inq_dimids(integer ncid, integer ndims, integer
              dimids, integer include_parents)

              Get the dimids in a group and (potentially) its parents.

       integer function nf_inq_typeids(integer ncid, integer ntypes, integer
              typeids(1))

              Get the typeids of user-defined types in a group.

       integer function nf_def_grp(integer ncid, character*(*) name, integer
              ncid)

              Create a group.

DIMENSIONS
       integer function nf_inq_dimid(integer ncid, character*(*) name, integer
              dimid)

              (Corresponds to ncdid() in version 2)

              Given a dimension name, returns the ID of a netCDF dimension in
              dimid.

       integer function nf_inq_dim(integer ncid, integer dimid, character*(*)
              name, integer len)

       integer function nf_inq_dimname(integer ncid, integer dimid,
              character*(*) name)

       integer function nf_inq_dimlen(integer ncid, integer dimid, integer
              len)

              Use these functions to find out about a dimension.

              name should be  big enough (NF_MAX_NAME) to hold the dimension
              name as the name will be copied into your storage.  The length
              return parameter, len will contain the size of the dimension.
              For the unlimited dimension, the returned length is the current
              maximum value used for writing into any of the variables which
              use the dimension.

       integer function nf_rename_dim(integer ncid, integer dimid,
              character*(*) name)

              (Corresponds to ncdren() in version 2)

              Renames an existing dimension in an open netCDF dataset.  If the
              new name is longer than the old name, the netCDF dataset must be
              in define mode.  You cannot rename a dimension to have the same
              name as another dimension.

VARIABLES
       integer function nf_def_var(integer ncid, character*(*) name, integer
              xtype, integer ndims, integer dimids(1), integer varid)

              (Corresponds to ncvdef() in version 2)

              Adds a new variable to a netCDF dataset. The netCDF must be in
              define mode.  varid will be set to the netCDF variable ID.

       integer function nf_inq_varid(integer ncid, character*(*) name, integer
              varid)

              (Corresponds to ncvid() in version 2)

              Returns the ID of a netCDF variable in varid given its name.

       integer function nf_inq_var(integer ncid, integer varid, character*(*)
              name, integer xtype, integer ndims, integer dimids(1), integer
              natts)

       integer function nf_inq_varname(integer ncid, integer varid,
              character*(*) name)

       integer function nf_inq_vartype(integer ncid, integer varid, integer
              xtype)

       integer function nf_inq_varndims(integer ncid, integer varid, integer
              ndims)

       integer function nf_inq_vardimid(integer ncid, integer varid, integer
              dimids(1))

       integer function nf_inq_varnatts(integer ncid, integer varid, integer
              natts)

              Returns information about a netCDF variable, given its ID.


       integer function nf_rename_var(integer ncid, integer varid,
              character*(*) name)

              (Corresponds to ncvren() in version 2)

              Changes the name of a netCDF variable.  If the new name is
              longer than the old name, the netCDF must be in define mode.
              You cannot rename a variable to have the name of any existing
              variable.


VARIABLES in NETCDF-4 FILES
       The following functions may only be used on variables in a
       netCDF-4/HDF5 data file. These functions must be called after the
       variable is defined, but before an enddef call.

       integer function nf_def_var_deflate(integer ncid, integer varid,
       integer shuffle, integer deflate, integer deflate_level)

       Turn on compression and/or shuffle filter. (Shuffle filter is only
       useful for integer data.)

       integer function nf_inq_var_deflate(integer ncid, integer varid,
              integer shufflep, integer deflatep, integer deflate_levelp)

              Learn about a variable's deflate settings.

       integer function nf_def_var_fletcher32(integer ncid, integer varid,
              integer fletcher32)

              Turn on checksumming for a variable.

       integer function nf_inq_var_fletcher32(integer ncid, integer varid,
              integer fletcher32)

              Learn about checksumming for a variable.

       integer function nf_def_var_chunking(integer ncid, integer varid,
              integer storage, integer chunksizesp(1))

              Set chunksizes for a variable.

       integer function nf_inq_var_chunking(integer ncid, integer varid,
              integer storagep, integer chunksizesp(1))

              Learn about chunksizes for a variable.

       integer function nf_def_var_fill(integer ncid, integer varid, integer
              no_fill, integer chunksizesp(1))

              Set a fill value for a variable.

       integer function nf_inq_var_fill(integer ncid, integer varid, integer
              storagep, integer chunksizesp(1))

              Learn the fill value for a variable.

       integer function nf_def_var_endian(integer ncid, integer varid, integer
              endian)

              Set endianness of variable.

       integer function nf_inq_var_endian(integer ncid, integer varid, integer
              endianp)

              Learn the endianness of a variable.



WRITING AND READING WHOLE VARIABLES
       integer function nf_put_var_text(integer ncid, integer varid,
              character*(*) out)


       integer function nf_put_var_int1(integer ncid, integer varid, integer*1
              out(1))

       integer function nf_put_var_int2(integer ncid, integer varid, integer*2
              out(1))

       integer function nf_put_var_int(integer ncid, integer varid, integer
              out(1))


       integer function nf_put_var_real(integer ncid, integer varid, real
              out(1))

       integer function nf_put_var_double(integer ncid, integer varid,
              doubleprecision out(1))

       integer function nf_put_var_ubyte(integer ncid, integer varid,
              integer*1 out(1))

       integer function nf_put_var_ushort(integer ncid, integer varid,
              integer*2 out(1))

       integer function nf_put_var_uint(integer ncid, integer varid, integer*4
              out(1))

       integer function nf_put_var_int64(integer ncid, integer varid,
              integer*8 out(1))

       integer function nf_put_var_uint64(integer ncid, integer varid,
              integer*8 out(1))

       integer function nf_put_var_string(integer ncid, integer varid,
              character* out(1))



              Writes an entire netCDF variable (i.e. all the values).  The
              netCDF dataset must be open and in data mode.  The type of the
              data is specified in the function name, and it is converted to
              the external type of the specified variable, if possible,
              otherwise an NF_ERANGE error is returned. Note that rounding is
              not performed during the conversion. Floating point numbers are
              truncated when converted to integers.

       integer function nf_get_var_text(integer ncid, integer varid,
              character*(*) in)


       integer function nf_get_var_int1(integer ncid, integer varid, integer*1
              in(1))

       integer function nf_get_var_int2(integer ncid, integer varid, integer*2
              in(1))

       integer function nf_get_var_int(integer ncid, integer varid, integer
              in(1))


       integer function nf_get_var_real(integer ncid, integer varid, real
              in(1))

       integer function nf_get_var_double(integer ncid, integer varid,
              doubleprecision in(1))

       integer function nf_get_var_ubyte(integer ncid, integer varid,
              integer*1 in(1))

       integer function nf_get_var_ushort(integer ncid, integer varid,
              integer*2 in(1))

       integer function nf_get_var_uint(integer ncid, integer varid, integer*4
              in(1))

       integer function nf_get_var_int64(integer ncid, integer varid,
              integer*8 in(1))

       integer function nf_get_var_uint64(integer ncid, integer varid,
              integer*8 in(1))

       integer function nf_get_var_string(integer ncid, integer varid,
              character* in(1))



              Reads an entire netCDF variable (i.e. all the values).  The
              netCDF dataset must be open and in data mode.  The data is
              converted from the external type of the specified variable, if
              necessary, to the type specified in the function name.  If
              conversion is not possible, an NF_ERANGE error is returned.

WRITING AND READING ONE DATUM
       integer function nf_put_var1_text(integer ncid, integer varid, integer
              index(1), character*1 *out)


       integer function nf_put_var1_int1(integer ncid, integer varid, integer
              index(1), integer*1 *out)

       integer function nf_put_var1_int2(integer ncid, integer varid, integer
              index(1), integer*2 *out)

       integer function nf_put_var1_int(integer ncid, integer varid, integer
              index(1), integer *out)


       integer function nf_put_var1_real(integer ncid, integer varid, integer
              index(1), real *out)

       integer function nf_put_var1_double(integer ncid, integer varid,
              integer index(1), doubleprecision *out)

       integer function nf_put_var1_ubyte(integer ncid, integer varid, integer
              index(1), integer*1 *out)

       integer function nf_put_var1_ushort(integer ncid, integer varid,
              integer index(1), integer*2 *out)

       integer function nf_put_var1_uint(integer ncid, integer varid, integer
              index(1), integer*4 *out)

       integer function nf_put_var1_int64(integer ncid, integer varid, integer
              index(1), integer*8 *out)

       integer function nf_put_var1_uint64(integer ncid, integer varid,
              integer index(1), integer*8 *out)

       integer function nf_put_var1_string(integer ncid, integer varid,
              integer index(1), character* *out)



              Puts a single data value into a variable at the position index
              of an open netCDF dataset that is in data mode.  The type of the
              data is specified in the function name, and it is converted to
              the external type of the specified variable, if possible,
              otherwise an NF_ERANGE error is returned.

       integer function nf_get_var1_text(integer ncid, integer varid, integer
              index(1), character*1 in)


       integer function nf_get_var1_int1(integer ncid, integer varid, integer
              index(1), integer*1 in)

       integer function nf_get_var1_int2(integer ncid, integer varid, integer
              index(1), integer*2 in)

       integer function nf_get_var1_int(integer ncid, integer varid, integer
              index(1), integer in)


       integer function nf_get_var1_real(integer ncid, integer varid, integer
              index(1), real in)

       integer function nf_get_var1_double(integer ncid, integer varid,
              integer index(1), doubleprecision in)

       integer function nf_get_var1_ubyte(integer ncid, integer varid, integer
              index(1), integer*1 in)

       integer function nf_get_var1_ushort(integer ncid, integer varid,
              integer index(1), integer*2 in)

       integer function nf_get_var1_uint(integer ncid, integer varid, integer
              index(1), integer*4 in)

       integer function nf_get_var1_int64(integer ncid, integer varid, integer
              index(1), integer*8 in)

       integer function nf_get_var1_uint64(integer ncid, integer varid,
              integer index(1), integer*8 in)

       integer function nf_get_var1_string(integer ncid, integer varid,
              integer index(1), character* in)



              Gets a single data value from a variable at the position index
              of an open netCDF dataset that is in data mode.  The data is
              converted from the external type of the specified variable, if
              necessary, to the type specified in the function name.  If
              conversion is not possible, an NF_ERANGE error is returned.

WRITING AND READING AN ARRAY
       integer function nf_put_vara_text(integer ncid, integer varid, integer
              start(1), integer count(1), character*(*) out)


       integer function nf_put_vara_int1(integer ncid, integer varid, integer
              start(1), integer count(1), integer*1 out(1))

       integer function nf_put_vara_int2(integer ncid, integer varid, integer
              start(1), integer count(1), integer*2 out(1))

       integer function nf_put_vara_int(integer ncid, integer varid, integer
              start(1), integer count(1), integer out(1))


       integer function nf_put_vara_real(integer ncid, integer varid, integer
              start(1), integer count(1), real out(1))

       integer function nf_put_vara_double(integer ncid, integer varid,
              integer start(1), integer count(1), doubleprecision out(1))

       integer function nf_put_vara_ubyte(integer ncid, integer varid, integer
              start(1), integer count(1), integer*1 out(1))

       integer function nf_put_vara_ushort(integer ncid, integer varid,
              integer start(1), integer count(1), integer*2 out(1))

       integer function nf_put_vara_uint(integer ncid, integer varid, integer
              start(1), integer count(1), integer*4 out(1))

       integer function nf_put_vara_int64(integer ncid, integer varid, integer
              start(1), integer count(1), integer*8 out(1))

       integer function nf_put_vara_uint64(integer ncid, integer varid,
              integer start(1), integer count(1), integer*8 out(1))

       integer function nf_put_vara_string(integer ncid, integer varid,
              integer start(1), integer count(1), character* out(1))



              Writes an array section of values into a netCDF variable of an
              open netCDF dataset, which must be in data mode.  The array
              section is specified by the start and count vectors, which give
              the starting index and count of values along each dimension of
              the specified variable.  The type of the data is specified in
              the function name and is converted to the external type of the
              specified variable, if possible, otherwise an NF_ERANGE error is
              returned.

       integer function nf_get_vara_text(integer ncid, integer varid, integer
              start(1), integer count(1), character*(*) in)


       integer function nf_get_vara_int1(integer ncid, integer varid, integer
              start(1), integer count(1), integer*1 in(1))

       integer function nf_get_vara_int2(integer ncid, integer varid, integer
              start(1), integer count(1), integer*2 in(1))

       integer function nf_get_vara_int(integer ncid, integer varid, integer
              start(1), integer count(1), integer in(1))


       integer function nf_get_vara_real(integer ncid, integer varid, integer
              start(1), integer count(1), real in(1))

       integer function nf_get_vara_double(integer ncid, integer varid,
              integer start(1), integer count(1), doubleprecision in(1))

       integer function nf_get_vara_ubyte(integer ncid, integer varid, integer
              start(1), integer count(1), integer*1 in(1))

       integer function nf_get_vara_ushort(integer ncid, integer varid,
              integer start(1), integer count(1), integer*2 in(1))

       integer function nf_get_vara_uint(integer ncid, integer varid, integer
              start(1), integer count(1), integer*4 in(1))

       integer function nf_get_vara_int64(integer ncid, integer varid, integer
              start(1), integer count(1), integer*8 in(1))

       integer function nf_get_vara_uint64(integer ncid, integer varid,
              integer start(1), integer count(1), integer*8 in(1))

       integer function nf_get_vara_string(integer ncid, integer varid,
              integer start(1), integer count(1), character* in(1))



              Reads an array section of values from a netCDF variable of an
              open netCDF dataset, which must be in data mode.  The array
              section is specified by the start and count vectors, which give
              the starting index and count of values along each dimension of
              the specified variable.  The data is converted from the external
              type of the specified variable, if necessary, to the type
              specified in the function name.  If conversion is not possible,
              an NF_ERANGE error is returned.

WRITING AND READING A SLICED ARRAY
       integer function nf_put_vars_text(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), character*(*)
              out)


       integer function nf_put_vars_int1(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*1 out(1))

       integer function nf_put_vars_int2(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*2 out(1))

       integer function nf_put_vars_int(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer out(1))


       integer function nf_put_vars_real(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), real out(1))

       integer function nf_put_vars_double(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1),
              doubleprecision out(1))

       integer function nf_put_vars_ubyte(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*1 out(1))

       integer function nf_put_vars_ushort(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), integer*2
              out(1))

       integer function nf_put_vars_uint(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*4 out(1))

       integer function nf_put_vars_int64(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*8 out(1))

       integer function nf_put_vars_uint64(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), integer*8
              out(1))

       integer function nf_put_vars_string(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1),
              character* out(1))



              These functions are used for strided output, which is like the
              array section output described above, except that the sampling
              stride (the interval between accessed values) is specified for
              each dimension.  For an explanation of the sampling stride
              vector, see COMMON ARGUMENTS DESCRIPTIONS below.

       integer function nf_get_vars_text(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), character*(*) in)


       integer function nf_get_vars_int1(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*1 in(1))

       integer function nf_get_vars_int2(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*2 in(1))

       integer function nf_get_vars_int(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer in(1))


       integer function nf_get_vars_real(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), real in(1))

       integer function nf_get_vars_double(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1),
              doubleprecision in(1))

       integer function nf_get_vars_ubyte(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*1 in(1))

       integer function nf_get_vars_ushort(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), integer*2
              in(1))

       integer function nf_get_vars_uint(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*4 in(1))

       integer function nf_get_vars_int64(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), integer*8 in(1))

       integer function nf_get_vars_uint64(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), integer*8
              in(1))

       integer function nf_get_vars_string(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1),
              character* in(1))



              These functions are used for strided input, which is like the
              array section input described above, except that the sampling
              stride (the interval between accessed values) is specified for
              each dimension.  For an explanation of the sampling stride
              vector, see COMMON ARGUMENTS DESCRIPTIONS below.

WRITING AND READING A MAPPED ARRAY
       integer function nf_put_varm_text(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap,
              character*(*) out)


       integer function nf_put_varm_int1(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*1
              out(1))

       integer function nf_put_varm_int2(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*2
              out(1))

       integer function nf_put_varm_int(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer
              out(1))


       integer function nf_put_varm_real(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, real
              out(1))

       integer function nf_put_varm_double(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              doubleprecision out(1))

       integer function nf_put_varm_ubyte(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*1
              out(1))

       integer function nf_put_varm_ushort(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              integer*2 out(1))

       integer function nf_put_varm_uint(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*4
              out(1))

       integer function nf_put_varm_int64(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*8
              out(1))

       integer function nf_put_varm_uint64(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              integer*8 out(1))

       integer function nf_put_varm_string(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              character* out(1))



              These functions are used for mapped output, which is like
              strided output described above, except that an additional index
              mapping vector is provided to specify the in-memory arrangement
              of the data values.  For an explanation of the index mapping
              vector, see COMMON ARGUMENTS DESCRIPTIONS below.

       integer function nf_get_varm_text(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap,
              character*(*) in)


       integer function nf_get_varm_int1(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*1
              in(1))

       integer function nf_get_varm_int2(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*2
              in(1))

       integer function nf_get_varm_int(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer
              in(1))


       integer function nf_get_varm_real(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, real in(1))

       integer function nf_get_varm_double(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              doubleprecision in(1))

       integer function nf_get_varm_ubyte(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*1
              in(1))

       integer function nf_get_varm_ushort(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              integer*2 in(1))

       integer function nf_get_varm_uint(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*4
              in(1))

       integer function nf_get_varm_int64(integer ncid, integer varid, integer
              start(1), integer count(1), integer stride(1), imap, integer*8
              in(1))

       integer function nf_get_varm_uint64(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              integer*8 in(1))

       integer function nf_get_varm_string(integer ncid, integer varid,
              integer start(1), integer count(1), integer stride(1), imap,
              character* in(1))



              These functions are used for mapped input, which is like strided
              input described above, except that an additional index mapping
              vector is provided to specify the in-memory arrangement of the
              data values.  For an explanation of the index mapping vector,
              see COMMON ARGUMENTS DESCRIPTIONS below.

ATTRIBUTES
       integer function nf_put_att_text(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, character*(*)
              out)


       integer function nf_put_att_int1(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer*1
              out(1))

       integer function nf_put_att_int2(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer*2
              out(1))

       integer function nf_put_att_int(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer out(1))


       integer function nf_put_att_real(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, real out(1))

       integer function nf_put_att_double(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, doubleprecision
              out(1))

       integer function nf_put_att_ubyte(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer*1
              out(1))

       integer function nf_put_att_ushort(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer*2
              out(1))

       integer function nf_put_att_uint(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer*4
              out(1))

       integer function nf_put_att_int64(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer*8
              out(1))

       integer function nf_put_att_uint64(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, integer*8
              out(1))

       integer function nf_put_att_string(integer ncid, integer varid,
              character*(*) name, integer xtype, integer len, character*
              out(1))



       integer function nf_put_att(integer ncid, integer varid, character*(*)
              name, integer xtype, integer len, void * ip)

       integer function nf_get_att(integer ncid, integer varid, character*(*)
              name, void * ip)

              Unlike variables, attributes do not have separate functions for
              defining and writing values.  This family of functions defines a
              new attribute with a value or changes the value of an existing
              attribute.  If the attribute is new, or if the space required to
              store the attribute value is greater than before, the netCDF
              dataset must be in define mode.  The parameter len is the number
              of values from out to transfer.  It is often one, except that
              for nf_put_att_text() it will usually be len_trim(out).

              For these functions, the type component of the function name
              refers to the in-memory type of the value, whereas the xtype
              argument refers to the external type for storing the value.  An
              NF_ERANGE error results if a conversion between these types is
              not possible.  In this case the value is represented with the
              appropriate fill-value for the associated external type.

       integer function nf_inq_attname(integer ncid, integer varid, integer
              attnum, character*(*) name)

              Gets the name of an attribute, given its variable ID and
              attribute number.  This function is useful in generic
              applications that need to get the names of all the attributes
              associated with a variable, since attributes are accessed by
              name rather than number in all other attribute functions.  The
              number of an attribute is more volatile than the name, since it
              can change when other attributes of the same variable are
              deleted.  The attributes for each variable are numbered from 1
              (the first attribute) to nvatts, where nvatts is the number of
              attributes for the variable, as returned from a call to
              nf_inq_varnatts().


       integer function nf_inq_att(integer ncid, integer varid, character*(*)
              name, integer xtype, integer len)

       integer function nf_inq_attid(integer ncid, integer varid,
              character*(*) name, integer attnum)

       integer function nf_inq_atttype(integer ncid, integer varid,
              character*(*) name, integer xtype)

       integer function nf_inq_attlen(integer ncid, integer varid,
              character*(*) name, integer len)

              These functions return information about a netCDF attribute,
              given its variable ID and name.  The information returned is the
              external type in xtype and the number of elements in the
              attribute as len.


       integer function nf_copy_att(integer ncid, integer varid_in,
              character*(*) name, integer ncid_out, integer varid_out)

              Copies an attribute from one netCDF dataset to another.  It can
              also be used to copy an attribute from one variable to another
              within the same netCDF.  ncid_in is the netCDF ID of an input
              netCDF dataset from which the attribute will be copied.
              varid_in is the ID of the variable in the input netCDF dataset
              from which the attribute will be copied, or NF_GLOBAL for a
              global attribute.  name is the name of the attribute in the
              input netCDF dataset to be copied.  ncid_out is the netCDF ID of
              the output netCDF dataset to which the attribute will be copied.
              It is permissible for the input and output netCDF ID's to be the
              same.  The output netCDF dataset should be in define mode if the
              attribute to be copied does not already exist for the target
              variable, or if it would cause an existing target attribute to
              grow.  varid_out is the ID of the variable in the output netCDF
              dataset to which the attribute will be copied, or NF_GLOBAL to
              copy to a global attribute.

       integer function nf_rename_att(integer ncid, integer varid,
              character*(*) name, character*(*) newname)

              Changes the name of an attribute.  If the new name is longer
              than the original name, the netCDF must be in define mode.  You
              cannot rename an attribute to have the same name as another
              attribute of the same variable.  name is the original attribute
              name.  newname is the new name to be assigned to the specified
              attribute.  If the new name is longer than the old name, the
              netCDF dataset must be in define mode.

       integer function nf_del_att(integer ncid, integer varid, character*(*)
              name)

              Deletes an attribute from a netCDF dataset.  The dataset must be
              in define mode.

       integer function nf_get_att_text(integer ncid, integer varid,
              character*(*) name, character*(*) in)


       integer function nf_get_att_int1(integer ncid, integer varid,
              character*(*) name, integer*1 in(1))

       integer function nf_get_att_int2(integer ncid, integer varid,
              character*(*) name, integer*2 in(1))

       integer function nf_get_att_int(integer ncid, integer varid,
              character*(*) name, integer in(1))


       integer function nf_get_att_real(integer ncid, integer varid,
              character*(*) name, real in(1))

       integer function nf_get_att_double(integer ncid, integer varid,
              character*(*) name, doubleprecision in(1))

       integer function nf_get_att_ubyte(integer ncid, integer varid,
              character*(*) name, integer*1 in(1))

       integer function nf_get_att_ushort(integer ncid, integer varid,
              character*(*) name, integer*2 in(1))

       integer function nf_get_att_uint(integer ncid, integer varid,
              character*(*) name, integer*4 in(1))

       integer function nf_get_att_int64(integer ncid, integer varid,
              character*(*) name, integer*8 in(1))

       integer function nf_get_att_uint64(integer ncid, integer varid,
              character*(*) name, integer*8 in(1))

       integer function nf_get_att_string(integer ncid, integer varid,
              character*(*) name, character* in(1))



              Gets the value(s) of a netCDF attribute, given its variable ID
              and name.  Converts from the external type to the type specified
              in the function name, if possible, otherwise returns an
              NF_ERANGE error.  All elements of the vector of attribute values
              are returned, so you must allocate enough space to hold them.
              If you don't know how much space to reserve, call
              nf_inq_attlen() first to find out the length of the attribute.

COMMON ARGUMENT DESCRIPTIONS
       In this section we define some common arguments which are used in the
       "FUNCTION DESCRIPTIONS" section.

       integer ncid
              is the netCDF ID returned from a previous, successful call to
              nf_open() or nf_create()

       character*(*) name
              is the name of a dimension, variable, or attribute. The names of
              dimensions, variables and attributes consist of arbitrary
              sequences of alphanumeric characters (as well as underscore '_',
              period '.' and hyphen '-'), beginning with a letter or
              underscore. (However names commencing with underscore are
              reserved for system use.) Case is significant in netCDF names. A
              zero-length name is not allowed.

              The maximum allowable number of characters
               is NF_MAX_NAME.

       integer xtype
              specifies the external data type of a netCDF variable or
              attribute and is one of the following: NF_BYTE, NF_CHAR,
              NF_SHORT, NF_INT, NF_FLOAT, or NF_DOUBLE.  These are used to
              specify 8-bit integers, characters, 16-bit integers, 32-bit
              integers, 32-bit IEEE floating point numbers, and 64-bit IEEE
              floating-point numbers, respectively.


       integer dimids(1)
              is a vector of dimension ID's and defines the shape of a netCDF
              variable.  The size of the vector shall be greater than or equal
              to the rank (i.e. the number of dimensions) of the variable
              (ndims).  The vector shall be ordered by the speed with which a
              dimension varies: dimids(1) shall be the dimension ID of the
              most rapidly varying dimension and dimids(ndims) shall be the
              dimension ID of the most slowly varying dimension.  The maximum
              possible number of dimensions for a variable is given by the
              symbolic constant NF_MAX_VAR_DIMS.

       integer dimid
              is the ID of a netCDF dimension.  netCDF dimension ID's are
              allocated sequentially from the positive integers beginning with
              1.

       integer ndims
              is either the total number of dimensions in a netCDF dataset or
              the rank (i.e. the number of dimensions) of a netCDF variable.
              The value shall not be negative or greater than the symbolic
              constant NF_MAX_VAR_DIMS.

       integer varid
              is the ID of a netCDF variable or (for the attribute-access
              functions) the symbolic constant NF_GLOBAL, which is used to
              reference global attributes.  netCDF variable ID's are allocated
              sequentially from the positive integers beginning with 1.

       integer natts
              is the number of global attributes in a netCDF dataset  for the
              nf_inquire() function or the number of attributes associated
              with a netCDF variable for the nf_varinq() function.

       integer index(1)
              specifies the indicial coordinates of the netCDF data value to
              be accessed.  The indices start at 1; thus, for example, the
              first data value of a two-dimensional variable is (1,1).  The
              size of the vector shall be at least the rank of the associated
              netCDF variable and its elements shall correspond, in order, to
              the variable's dimensions.

       integer start(1)
              specifies the starting point for accessing a netCDF variable's
              data values in terms of the indicial coordinates of the corner
              of the array section.  The indices start at 1; thus, the first
              data value of a variable is (1, 1, ..., 1).  The size of the
              vector shall be at least the rank of the associated netCDF
              variable and its elements shall correspond, in order, to the
              variable's dimensions.

       integer count(1)
              specifies the number of indices selected along each dimension of
              the array section.  Thus, to access a single value, for example,
              specify count as (1, 1, ..., 1).  Note that, for strided I/O,
              this argument must be adjusted to be compatible with the stride
              and start arguments so that the interaction of the three does
              not attempt to access an invalid data co-ordinate.  The elements
              of the count vector correspond, in order, to the variable's
              dimensions.

       integer stride(1)
              specifies the sampling interval along each dimension of the
              netCDF variable.   The elements of the stride vector correspond,
              in order, to the netCDF variable's dimensions (stride(1)) gives
              the sampling interval along the most rapidly varying dimension
              of the netCDF variable).  Sampling intervals are specified in
              type-independent units of elements (a value of 1 selects
              consecutive elements of the netCDF variable along the
              corresponding dimension, a value of 2 selects every other
              element, etc.).


       imap   specifies the mapping between the dimensions of a netCDF
              variable and the in-memory structure of the internal data array.
              The elements of the index mapping vector correspond, in order,
              to the netCDF variable's dimensions (imap(1) gives the distance
              between elements of the internal array corresponding to the most
              rapidly varying dimension of the netCDF variable).  Distances
              between elements are specified in type-independent units of
              elements (the distance between internal elements that occupy
              adjacent memory locations is 1 and not the element's byte-length
              as in netCDF 2).


VARIABLE PREFILLING
       By default, the netCDF interface sets the values of all newly-defined
       variables of finite length (i.e. those that do not have an unlimited,
       dimension) to the type-dependent fill-value associated with each
       variable.  This is done when nf_enddef() is called.  The fill-value for
       a variable may be changed from the default value by defining the
       attribute `_FillValue' for the variable.  This attribute must have the
       same type as the variable and be of length one.

       Variables with an unlimited dimension are also prefilled, but on an `as
       needed' basis.  For example, if the first write of such a variable is
       to position 5, then positions 1 through 4 (and no others) would be set
       to the fill-value at the same time.

       This default prefilling of data values may be disabled by or'ing the
       NF_NOFILL flag into the mode parameter of nf_open() or nf_create(), or,
       by calling the function nf_set_fill() with the argument NF_NOFILL.  For
       variables that do not use the unlimited dimension, this call must be
       made before nf_enddef().  For variables that use the unlimited
       dimension, this call may be made at any time.

       One can obtain increased performance of the netCDF interface by using
       this feature, but only at the expense of requiring the application to
       set every single data value.  The performance enhancing behavior of
       this function is dependent on the particulars of the implementation and
       dataset format.  The flag value controlled by nf_set_fill() is per
       netCDF ID, not per variable or per write.  Allowing this to change
       affects the degree to which a program can be effectively parallelized.
       Given all of this, we state that the use of this feature may not be
       available (or even needed) in future releases. Programmers are
       cautioned against heavy reliance upon this feature.

       integer function nf_setfill(integer ncid, integer fillmode, integer
              old_fillemode)


              Determines whether or not variable prefilling will be done (see
              above).  The netCDF dataset shall be writable.  fillmode is
              either NF_FILL to enable prefilling (the default) or NF_NOFILL
              to disable prefilling.  This function returns the previous
              setting in old_fillmode.




MPP FUNCTION DESCRIPTIONS
       Additional functions for use on SGI/Cray MPP machines (_CRAYMPP).
       These are used to set and inquire which PE is the base for MPP for a
       particular netCDF. These are only relevant when using the SGI/Cray
       ``global'' Flexible File I/O layer and desire to have only a subset of
       PEs to open the specific netCDF file.  For technical reasons, these
       functions are available on all platforms.  On a platform other than
       SGI/Cray MPP, it is as if only processor available were processor 0.

       To use this feature, you need to specify a communicator group and call
       glio_group_mpi() or glio_group_shmem() prior to the netCDF nf_open()
       and nf_create() calls.

       integer function nf__create_mp(character*(*) path, integer cmode,
              integer initialsize, integer pe, integer chunksize, integer
              ncid)

              Like nf__create() but allows the base PE to be set.

              The argument pe sets the base PE at creation time. In the MPP
              environment, nf__create() and nf_create() set the base PE to
              processor zero by default.

       integer function nf__open_mp(character*(*) path, integer mode, integer
              pe, integer chunksize, integer ncid)

              Like nf__open() but allows the base PE to be set.  The argument
              pe sets the base PE at creation time. In the MPP environment,
              nf__open() and nf_open() set the base PE to processor zero by
              default.

       integer function nf_inq_base_pe(integer ncid, integer pe)

              Inquires of the netCDF dataset which PE is being used as the
              base for MPP use.  This is safe to use at any time.

       integer function nf_set_base_pe(integer ncid, integer pe)

              Resets the base PE for the netCDF dataset.  Only perform this
              operation when the affected communicator group synchronizes
              before and after the call.  This operation is very risky and
              should only be contemplated under only the most extreme cases.

ENVIRONMENT VARIABLES
       NETCDF_FFIOSPEC
           Specifies the Flexible File I/O buffers for netCDF I/O when
           executing under the UNICOS operating system (the variable is
           ignored on other operating systems).  An appropriate specification
           can greatly increase the efficiency of netCDF I/O -- to the extent
           that it can actually surpass FORTRAN binary I/O.  This environment
           variable has been made a little more generalized, such that other
           FFIO option specifications can now be added.  The default
           specification is bufa:336:2, unless a current FFIO specification is
           in operation, which will be honored.  See UNICOS Flexible File I/O
           for more information.

MAILING-LISTS
       Both a mailing list and a digest are available for discussion of the
       netCDF interface and announcements about netCDF bugs, fixes, and
       enhancements.  To begin or change your subscription to either the
       mailing-list or the digest, send one of the following in the body (not
       the subject line) of an email message to "majordomo@unidata.ucar.edu".
       Use your email address in place of jdoe@host.inst.domain.

       To subscribe to the netCDF mailing list:
              subscribe netcdfgroup jdoe@host.inst.domain
       To unsubscribe from the netCDF mailing list:
              unsubscribe netcdfgroup jdoe@host.inst.domain
       To subscribe to the netCDF digest:
              subscribe netcdfdigest jdoe@host.inst.domain
       To unsubscribe from the netCDF digest:
              unsubscribe netcdfdigest jdoe@host.inst.domain
       To retrieve the general introductory information for the mailing list:
              info netcdfgroup
       To get a synopsis of other majordomo commands:
              help

SEE ALSO
       ncdump(1), ncgen(1), netcdf(3f).

       netCDF User's Guide, published by the Unidata Program Center,
       University Corporation for Atmospheric Research, located in Boulder,
       Colorado.

       NetCDF home page at http:/www.unidata.ucar.edu/netcdf.

Printed: 1900-0-0                 1997-04-18                         NETCDF(3)
