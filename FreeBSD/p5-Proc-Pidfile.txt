Proc::Pidfile(3)      User Contributed Perl Documentation     Proc::Pidfile(3)


NAME
       Proc::Pidfile - a simple OO Perl module for maintaining a process id
       file for the current process

SYNOPSIS
           my $pp = Proc::Pidfile->new( pidfile => "/path/to/your/pidfile" );
           # if the pidfile already exists, die here
           $pidfile = $pp->pidfile();
           undef $pp;
           # unlink $pidfile here

           my $pp = Proc::Pidfile->new();
           # creates pidfile in default location
           my $pidfile = $pp->pidfile();
           # tells you where this pidfile is ...

           my $pp = Proc::Pidfile->new( silent => 1 );
           # if the pidfile already exists, exit silently here
           ...
           undef $pp;

DESCRIPTION
       Proc::Pidfile is a very simple OO interface which manages a pidfile for
       the current process.  You can pass the path to a pidfile to use as an
       argument to the constructor, or you can let Proc::Pidfile choose one
       ("/$tmpdir/$basename", where $tmpdir is from "File::Spec").

       Pidfiles created by Proc::Pidfile are automatically removed on
       destruction of the object. At destruction, the module checks the
       process id in the pidfile against its own, and against its parents (in
       case it is a spawned child of the process that originally created the
       Proc::Pidfile object), and barfs if it doesn't match either.

       If you pass a "silent" parameter to the constructor, then it will still
       check for the existence of a pidfile, but will exit silently if one is
       found. This is useful for, for example, cron jobs, where you don't want
       to create a new process if one is already running, but you don't
       necessarily want to be informed of this by cron.

   Retries
       If another instance of your script is already running, we'll retry a
       couple of times, with a random number of microseconds between each
       attempt.

       You can specify the number of retries, for example if you want to try
       more times for some reason:

        my $pp = Proc::Pidfile->new(retries => 4);

       By default this is set to 2, which means if the first attempt to set up
       a pidfile fails, it will try 2 more times, so three attempts in total.

       Setting retries to 0 (zero) will disable this feature.

       If you want to generate the number of microseconds to wait yourself,
       you can pass a code reference generating it to the constructor.

        my $backoff = 100;
        my $pp = Proc::Pidfile->new(retries => 4,
                                    backoff => sub { $backoff *= 2 });

SEE ALSO
       Proc::PID::File - provides a similar interface.

       PidFile - provides effectively the same functionality, but via class
       methods. Hasn't been updated since 2011, and has quite a few CPAN
       Testers fails.

       IPC::Pidfile - provides a simple interface, but has some restrictions,
       and its documentation even recommends you consider a different module,
       as it has a race condition.

       IPC::Lockfile - very simple interface, and uses a different mechanism:
       it tries to lock the script file which used the module.  The trouble
       with that is that you might be running someone else's script, and thus
       can't lock it.

       Sys::RunAlone - another one with a simple default interface, but can be
       configured to retry. Based on locking, rather than a pid file.  Doesn't
       work on Windows.

       Linux::Pidfile - Linux-specific solution.

REPOSITORY
       <https://github.com/neilbowers/Proc-Pidfile>

AUTHOR
       Ave Wrigley <awrigley@cpan.org>

       Now maintained by Neil Bowers <neilb@cpan.org>

COPYRIGHT
       Copyright (c) 2003 Ave Wrigley. All rights reserved. This program is
       free software; you can redistribute it and/or modify it under the same
       terms as Perl itself.

perl v5.40.2                      2023-05-26                  Proc::Pidfile(3)
