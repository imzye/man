Text::WikiFormat(3)   User Contributed Perl Documentation  Text::WikiFormat(3)


NAME
       Text::WikiFormat - module for translating Wiki formatted text into
       other formats

SYNOPSIS
               use Text::WikiFormat;
               my $html = Text::WikiFormat::format($raw);

DESCRIPTION
       The original Wiki web site had a very simple interface to edit and to
       add pages.  Its formatting rules are simple and easy to use.  They are
       also easy to translate into other, more complicated markup languages
       with this module.  It creates HTML by default, but can produce valid
       POD, DocBook, XML, or any other format imaginable.

       The most important function is format().  It is not exported by
       default.

   format()
       format() takes one required argument, the text to convert, and returns
       the converted text.  It allows two optional arguments.  The first is a
       reference to a hash of tags.  Anything passed in here will override the
       default tag behavior.  The second argument is a hash reference of
       options.  They are currently:

       •   prefix

           The prefix of any links.  In HTML mode, this is the path to the
           Wiki.  The actual linked item itself will be appended to the
           prefix.  This is useful to create full URIs:

                   { prefix => 'http://example.com/wiki.pl?page=' }

       •   extended

           A boolean flag, false by default, to use extended linking
           semantics.  This comes from the Everything Engine
           (http://everydevel.com/), which marks links with square brackets.
           An optional title may occur after the link target, preceded by an
           open pipe.  These are valid extended links:

                   [a valid link]
                   [link|title]

           Where the linking semantics of the destination format allow it, the
           result will display the title instead of the URI.  In HTML terms,
           the title is the content of an "A" element (not the content of its
           "HREF" attribute).

           You can use delimiters other than single square brackets for
           marking extended links by passing a value for
           "extended_link_delimiters" in the %tags hash when calling "format".

       •   implicit_links

           A boolean flag, true by default, to create links from
           StudlyCapsStringsNote that if you disable this flag, you should
           probably enable the "extended" one also, or there will be no way of
           creating links in your documents.  To disable it, use the pair:

                   { implicit_links => 0 }

       •   absolute_links

           A boolean flag, false by default, which treats any links that are
           absolute URIs (such as http://www.cpan.org/) specially. Any prefix
           will not apply and the URIs aren't quoted. Use this in conjunction
           with the "extended" option to detect the link.

           A link is any text that starts with a known schema followed by a
           colon and one or more non-whitespace characters.  This is a
           distinct subset of what URI recognizes as a URI, but is a good
           first-order approximation.  If you need to recognize more complex
           URIs, use the standard wiki formatting explained earlier.

           The recognized schemas are those defined in the "schema" value in
           the %tags hash. The defaults are "http", "https", "ftp", "mailto",
           and "gopher".

       •   nofollow_extended

           When used with the "extended" flag, any extended links will be
           turned into HTML tags with the "rel="nofollow"" attribute. By
           default, this option is off.

   Wiki Format
       Wiki formatting is very simple.  An item wrapped in three single quotes
       is strong.  An item wrapped in two single quotes is emphasized.  Any
       word with multiple CapitalLetters (e. g., StudlyCaps) will become a
       link.  Four or more hyphen characters at the start of a line create a
       horizontal line.  Newlines turn into the appropriate tags.  Headers are
       matching equals signs around the header text -- the more signs, the
       lesser the header.

       Lists are indented text, by one tab or four spaces by default.  You may
       disable indentation.  In unordered lists, where each item has its own
       bullet point, each item needs a leading asterisk and space.  Ordered
       lists consist of items marked with combination of one or more
       alphanumeric characters followed by a period and an optional space.
       Any indented text without either marking is code, handled literally.
       You can nest lists.

       The following is valid Wiki formatting, with an extended link as
       marked.

               = my interesting text =

               ANormalLink
               [let the Sun shine|AnExtendedLink]

               == my interesting lists ==

                   * unordered one
                   * unordered two

                   1. ordered one
                   2. ordered two
                               a. nested one
                               b. nested two

                   code one
                   code two

               The first line of a normal paragraph.
               The second line of a normal paragraph.  Whee.

EXPORT
       If you'd like to make your life more convenient, you can optionally
       import a subroutine that already has default tags and options set up.
       This is especially handy if you use a prefix:

               use Text::WikiFormat prefix => 'http://www.example.com/';
               wikiformat( 'some text' );

       Tags are interpreted as, well, tags, except for five special keys:

       •   "prefix", interpreted as a link prefix

       •   "extended", interpreted as the extended link flag

       •   "implicit_links", interpreted as the flag to control implicit links

       •   "absolute_links", interpreted as the flag to control absolute links

       •   "as", interpreted as an alias for the imported function

       Use the "as" flag to control the name by which your code calls the
       imported functionFor example,

               use Text::WikiFormat as => 'formatTextInWikiStyle';
               formatTextInWikiStyle( 'some text' );

       You might choose a better name, though.

       The calling semantics are effectively the same as those of the format()
       function.  Any additional tags or options to the imported function will
       override the defaults.  This code:

               use Text::WikiFormat as => 'wf', extended => 0;
               wf( 'some text', {}, { extended => 1 });

       enables extended links, though the default is to disable them.

       Tony Bowden <tony@kasei.com> suggested this feature, but all
       implementation blame rests solely with me.  Kate L Pugh
       (<kake@earth.li>) pointed out that it didn't work, with tests.  It
       works now.

GORY DETAILS
   Tags
       There are two types of Wiki markup: line items and blocks.  Blocks
       include lists, which are made up of lines and can also contain other
       lists.

       Line items

       There are two classes of line items: simple tags, and tags that contain
       data.  The simple tags are "newline" and "line".  The module inserts a
       newline tag whenever it encounters a newline character ("\n").  It
       inserts a line tag whenever four or more dash characters ("----") occur
       at the start of a line.  No whitespace is allowed.  These default to
       the <br> and <hr> HTML tags, respectively.  To override either, simply
       pass tags such as:

               my $html = format($text, { newline => "\n" });

       The three line items are more complex, and require subroutine
       references. This category includes the "strong" and "emphasized" tags
       as well as "link"s.  The first argument passed to the subref will be
       the data found in between the marks.  The second argument is the $opts
       hash reference.  The default action for a strong tag is equivalent to:

               my $html = format($text, { strong => sub { "<b>$_[0]</b>" } });

       As of version 0.70, you can change the regular expressions used to find
       strong and emphasized tags:

               %tags = (
                       strong_tag     => qr/\*(.+?)\*/,
                       emphasized_tag => qr|(?<!<)/(.+?)/|,
               );

               $wikitext = 'this is *strong*, /emphasized/, and */emphasized strong/*';
               $htmltext = Text::WikiFormat::format( $wikitext, \%tags, {} );

       Be aware that using forward slashes to mark anything leads to the hairy
       regular expression -- use something else.  This interface is
       experimental and may change if I find something better.  It's nice to
       be able to override those tags, though.

       Finally, there are "extended_link_delimiters", which allow you to use
       delimiters other than single square brackets for marking extended
       links.  Pass the tags as:

               my $html = format( $text, { extended_link_delimiters => [ '[[', ']]' ] });

       This allows you to use double square brackets as UseMod supports:

               [[an extended link]]
               [[a titled extended link|title]]

       Blocks

       There are five default block types: "paragraph", "header", "code",
       "unordered", and "ordered".  The parser usually finds these by
       indentation, either one or more tabs or four or more whitespace
       characters.  (This does not include newlines, however.)  Any line that
       does not fall in any of these three categories is a "paragraph".

       Code, unordered, and ordered blocks do not require indentation, but the
       parser uses it to control nesting in lists.  Be careful.  To mark a
       block as requiring indentation, use the "indented" tag, which contains
       a reference to a hash:

               my $html = format($text, {
                       indented    => { map { $_ => 1 } qw( ordered unordered code )}
               });

       Block entries in the tag hashes must contain array references.  The
       first two items are the tags used at the start and end of the block.
       The last items contain the tags used at the start and end of each line.
       Where there needs to be more processing of individual lines, use a
       subref as the third item.  This is how the module numbers ordered lines
       in HTML lists:

               my $html = format($text, { ordered => [ '<ol>', "</ol>\n",
                       sub { qq|<li value="$_[2]">$_[0]</li>\n| } ] });

       The first argument to these subrefs is the post-processed text of the
       line itself.  (Processing removes the indentation and tokens used to
       mark this as a list and checks the rest of the line for other line
       formattings.)  The second argument is the indentation level.  The
       subsequent arguments are captured variables in the regular expression
       used to find this list type.  The regexp for ordered lists is:

               qr/^([\dA-Za-z]+)\.\s*/;

       The module processes indentation first, if applicable, and stores the
       indentation level (the length of the indentation removed).  The line
       must contain one or more alphanumeric character followed by a single
       period and optional whitespace to be an ordered list item.  The module
       saves the contents of this last group, the value of the list item, and
       passes it to the subref as the third argument.

       Lists automatically start and end as necessary.

       Because of the indentation issue, there is a specific blocks processing
       in a specific order.  The "blockorder" tag governs this order.  It
       contains a reference to an array of the names of the appropriate blocks
       to process.  If you add a block type, be sure to add an entry for it in
       "blockorder":

               my $html = format($text, {
                       escaped       => [ '', '', '', '' ],
                       blocks        => {
                               invisible => qr!^--(.*?)--$!,
                       },
                       blockorder    =>
                               [qw( header line ordered unordered code paragraph invisible )],
               });

       Finding blocks

       Text::WikiFormat uses regular expressions to find blocks.  These are in
       the %tags hash under the "blocks" key.  To change the regular
       expression to find code block items, use:

               my $html     =  format($wikitext, {
                       blocks   => {
                               code => qr/^:\s+/,
                       },
                       indented => {
                               code => 1,
                       },
               );

       This will require indentation and a colon to mark code lines.  A
       potential shortcut is to use the "indent" tag to match or to change the
       indentation marker.

       Note: if you want to mark a block type as non-indented, you cannot use
       an empty regex such as "qr//".  Use a mostly-empty, always-true regex
       such as "qr/^/" instead.

       Finding Blocks in the Correct Order

       As intrepid bug reporter Tom Hukins pointed out in CPAN RT bug #671,
       the order in which Text::WikiFormat searches for blocks varies by
       platform and version of Perl.  Because some block-finding regular
       expressions are more specific than others, what you intend to be one
       type of block may turn into a different list type.

       If you're adding new block types, be aware of this.  The "blockorder"
       entry in %tags exists to force Text::WikiFormat to apply its regexes
       from most specific to least specific.  It contains an array reference.
       By default, it looks for ordered lists first, unordered lists second,
       and code references at the end.

AUTHOR
       chromatic, "chromatic@wgz.org", with much input from the Jellybean team
       (including Jonathan Paulett).  Kate L Pugh has also provided several
       patches, many failing tests, and is usually the driving force behind
       new features and releases.  If you think this module is worth buying me
       a beer, she deserves at least half of it.

       Alex Vandiver added a nice patch and tests for extended links.

       Tony Bowden, Tom Hukins, and Andy H. all suggested useful features that
       are now implemented.

       Sam Vilain, Chris Winters, Paul Schmidt, and Art Henry have all found
       and reported silly bugs.

       Blame me for the implementation.

BUGS
       The link checker in format_line() may fail to detect existing links
       that do not follow HTML, XML, or SGML style.  They may die with some
       SGML styles too.  Sic transit gloria mundi.

TODO
       •   Find a nicer way to mark list as having unformatted lines

       •   Optimize format_line() to work on a list of lines

       •   Handle nested "strong" and "emphasized" markings better

OTHER MODULES
       Brian "Ingy" Ingerson's CGI::Kwiki has a fairly nice parser.

       John McNamara's Pod::Simple::Wiki looks like a good project.

       Matt Sergeant keeps threatening to write a nice SAX-throwing Wiki
       formatter.

COPYRIGHT
       Copyright (c) 2002 - 2006, chromatic.  All rights reserved.  This
       module is distributed under the same terms as Perl itself.

perl v5.40.2                      2013-11-25               Text::WikiFormat(3)
