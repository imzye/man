loadplay(1)             FreeBSD General Commands Manual            loadplay(1)

NAME
     loadplay – CPU load player

SYNOPSIS
     loadplay -h
     loadplay [-i file] [-o file] command [...]

DESCRIPTION
     The loadplay command replays a load recording created with loadrec(1).
     The command can either be powerd(8) or powerd++(8), compatibility with
     other tools has not been tested.

   OPTIONS
     The following options are supported:

     -h, --help
             Show usage and exit.

     -i, --input file
             Read load recording from file instead of stdin.

     -o, --output file
             Output statistics to file instead of stdout.

USAGE NOTES
     The loadplay command injects the library “libloadplay.so” into command.
     This library simulates the load from the input and outputs load
     statistics.

   OUTPUT
     The first line of output contains column headings, columns are separated
     by a single space.

     The Following columns are present, columns containing %d occur for each
     core simulated:

     time[s]
             The simulation progress in 0.001 second resolution.

     cpu.%d.rec.freq[MHz]
             The recorded clock frequency, sampled at the end of the frame.

     cpu.%d.rec.load[MHz]
             The recorded load in 0.1 MHz resolution.

     cpu.%d.run.freq[MHz]
             The simulated clock frequency set by the host process, sampled at
             the end of the frame.

     cpu.%d.run.load[MHz]
             The simulated load in 0.1 MHz resolution.

   SAMPLING
     There is one sample for each recorded line. The duration of each frame
     depends on the recording, which defaults to 25 ms.  At this sample rate
     loads are dominated by noise, so a gliding average should be applied to
     any load columns for further use, such as plotting.

IMPLEMENTATION NOTES
     The injected libloadplay.so works by intercepting system function calls
     and substituting the host environment with the recording. To achieve this
     the following function calls are intercepted:

     •   sysctl(3), sysctlnametomib(3), sysctlbyname(3)

     •   daemon(3)

     •   geteuid(2)

     •   pidfile_open(3), pidfile_write(3), pidfile_close(3),
         pidfile_remove(3), pidfile_fileno(3)

   INITIALISATION
     The sysctl family of functions is backed by a table that is initialised
     from the header of the load recording. If the heading is incomplete the
     setup routines print a message on stderr.  All the following intercepted
     function calls will return failure, ensuring that the host process is
     unable to operate and terminates.

     Like powerd++(8) and loadrec(1) loadplay is core agnostic. Meaning that
     any core may have a .freq and .freq_levels sysctl handle. Due to this
     flexibility load recordings may in part or wholly be fabricated to test
     artificial loads or systems and features that do not yet exist. E.g. it
     is possible to offer a .freq handle for each core or fabricate new
     .freq_levels.

   SIMULATION
     If setup succeeds a simulation thread is started that reads the remaining
     input lines, simulates the load and updates the kern.cp_times entry in
     the thread safe sysctl table. For each frame a line of output with load
     statistics is produced.

     Interaction with the host process happens solely through the sysctl
     table. The simulation reads the recorded loads and the current core
     frequencies to update kern.cp_times.  The host process reads this data
     and adjusts the clock frequencies, which in turn affects the next frame.

   FINALISATION
     After reading the last line of input the simulation thread sends a SIGINT
     to the process to cause it to terminate.

ENVIRONMENT
     LOADPLAY_IN
             If set the file named is used for input instead of stdin.  This
             only affects the input of loadplay, the host process is not
             affected.

     LOADPLAY_OUT
             If set the file named is used for output instead of stdout.  This
             only affects the output of loadplay, the host process is not
             affected.

     LD_PRELOAD
             Used to inject the library “libloadplay.so” into the host
             process.

     LD_LIBRARY_PATH
             Is set to the same path loadplay was called through. Remains
             untouched if the path does not contain a ‘/’ character.

             I.e. calling “obj/loadplay” will set “LD_LIBRARY_PATH=obj”,
             calling “loadplay” will not.

             This behaviour facilitates running test builds of loadplay and
             the library “libloadplay.so” without performing an install.

FILES
     /usr/local/lib/libloadplay.so
             A library injected into command via the LD_PRELOAD environment
             variable.

EXAMPLES
     Play a load recording with loadplay:

         > loadplay -i loads/freq_tracking.load powerd++
         time[s] cpu.0.rec.freq[MHz] cpu.0.rec.load[MHz] cpu.0.run.freq[MHz] cpu.0.run.load[MHz] cpu.1.rec.freq[MHz] cpu.1.rec.load[MHz] cpu.1.run.freq[MHz] cpu.1.run.load[MHz] cpu.2.rec.freq[MHz] cpu.2.rec.load[MHz] cpu.2.run.freq[MHz] cpu.2.run.load[MHz] cpu.3.rec.freq[MHz] cpu.3.rec.load[MHz] cpu.3.run.freq[MHz] cpu.3.run.load[MHz]
         0.025 1700 1700.0 1700 1700.0 1700 0.0 1700 0.0 1700 1700.0 1700 1700.0 1700 850.0 1700 850.0
         0.050 1700 1700.0 1700 1700.0 1700 1700.0 1700 1700.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.075 1700 566.7 1700 566.6 1700 1700.0 1700 1700.0 1700 0.0 1700 0.0 1700 566.7 1700 566.6
         0.100 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.125 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.150 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.175 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.200 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.225 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.250 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0
         0.275 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0 1700 0.0

     Capture load and loadplay output simultaneously into two different files:

         > loadplay -i loads/freq_tracking.load -o load.csv powerd++ -f > load.out

     Capture and display loadplay output:

         > loadplay -i loads/freq_tracking.load -o load.csv powerd++ -f | tee load.out
         power:  online, load:  527 MHz, cpu0.freq: 1700 MHz, wanted: 1405 MHz
         power:  online, load:  459 MHz, cpu0.freq: 1400 MHz, wanted: 1224 MHz
         power:  online, load:  502 MHz, cpu0.freq: 1200 MHz, wanted: 1338 MHz
         power:  online, load:  548 MHz, cpu0.freq: 1300 MHz, wanted: 1461 MHz
         power:  online, load:  704 MHz, cpu0.freq: 1500 MHz, wanted: 1877 MHz
         power:  online, load:  750 MHz, cpu0.freq: 1900 MHz, wanted: 2000 MHz
         power:  online, load:  805 MHz, cpu0.freq: 2000 MHz, wanted: 2146 MHz
         power:  online, load:  772 MHz, cpu0.freq: 2200 MHz, wanted: 2058 MHz
         power:  online, load:  574 MHz, cpu0.freq: 2000 MHz, wanted: 1530 MHz
         power:  online, load:  515 MHz, cpu0.freq: 1500 MHz, wanted: 1373 MHz

SEE ALSO
     loadrec(1), powerd(8), powerd++(8), rtld(1), signal(3), tee(1)

AUTHORS
     Implementation and manual by Dominic Fandrey <kami@freebsd.org>

FreeBSD 14.1-RELEASE             March 5, 2020            FreeBSD 14.1-RELEASE
