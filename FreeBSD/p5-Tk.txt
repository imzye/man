Tie::Watch(3)                perl/Tk Documentation               Tie::Watch(3)


NAME
        Tie::Watch - place watchpoints on Perl variables.

SYNOPSIS
        use Tie::Watch;

        $watch = Tie::Watch->new(
            -variable => \$frog,
            -debug    => 1,
            -shadow   => 0,
            -fetch    => [\&fetch, 'arg1', 'arg2', ..., 'argn'],
            -store    => \&store,
            -destroy  => sub {print "Final value=$frog.\n"},
        }
        %vinfo = $watch->Info;
        $args  = $watch->Args(-fetch);
        $val   = $watch->Fetch;
        print "val=", $watch->Say($val), ".\n";
        $watch->Store('Hello');
        $watch->Unwatch;

DESCRIPTION
       This class module binds one or more subroutines of your devising to a
       Perl variable.  All variables can have FETCH, STORE and DESTROY
       callbacks.  Additionally, arrays can define CLEAR, DELETE, EXISTS,
       EXTEND, FETCHSIZE, POP, PUSH, SHIFT, SPLICE, STORESIZE and UNSHIFT
       callbacks, and hashes can define CLEAR, DELETE, EXISTS, FIRSTKEY and
       NEXTKEY callbacks.  If these term are unfamiliar to you, I really
       suggest you read perltie.

       With Tie::Watch you can:

        . alter a variable's value
        . prevent a variable's value from being changed
        . invoke a Perl/Tk callback when a variable changes
        . trace references to a variable

       Callback format is patterned after the Perl/Tk scheme: supply either a
       code reference, or, supply an array reference and pass the callback
       code reference in the first element of the array, followed by callback
       arguments.  (See examples in the Synopsis, above.)

       Tie::Watch provides default callbacks for any that you fail to specify.
       Other than negatively impacting performance, they perform the standard
       action that you'd expect, so the variable behaves "normally".  Once you
       override a default callback, perhaps to insert debug code like print
       statements, your callback normally finishes by calling the underlying
       (overridden) method.  But you don't have to!

       To map a tied method name to a default callback name simply lowercase
       the tied method name and uppercase its first character.  So FETCH
       becomes Fetch, NEXTKEY becomes Nextkey, etcetera.

       Here are two callbacks for a scalar. The FETCH (read) callback does
       nothing other than illustrate the fact that it returns the value to
       assign the variable.  The STORE (write) callback uppercases the
       variable and returns it.  In all cases the callback must return the
       correct read or write value - typically, it does this by invoking the
       underlying method.

        my $fetch_scalar = sub {
            my($self) = @_;
            $self->Fetch;
        };

        my $store_scalar = sub {
            my($self, $new_val) = @_;
            $self->Store(uc $new_val);
        };

       Here are FETCH and STORE callbacks for either an array or hash.  They
       do essentially the same thing as the scalar callbacks, but provide a
       little more information.

        my $fetch = sub {
            my($self, $key) = @_;
            my $val = $self->Fetch($key);
            print "In fetch callback, key=$key, val=", $self->Say($val);
            my $args = $self->Args(-fetch);
            print ", args=('", join("', '",  @$args), "')" if $args;
            print ".\n";
            $val;
        };

        my $store = sub {
            my($self, $key, $new_val) = @_;
            my $val = $self->Fetch($key);
            $new_val = uc $new_val;
            $self->Store($key, $new_val);
            print "In store callback, key=$key, val=", $self->Say($val),
              ", new_val=", $self->Say($new_val);
            my $args = $self->Args(-store);
            print ", args=('", join("', '",  @$args), "')" if $args;
            print ".\n";
            $new_val;
        };

       In all cases, the first parameter is a reference to the Watch object,
       used to invoke the following class methods.

METHODS
       $watch = Tie::Watch->new(-options => values);
           The watchpoint constructor method that accepts option/value pairs
           to create and configure the Watch object.  The only required option
           is -variable.

           -variable is a reference to a scalar, array or hash variable.

           -debug (default 0) is 1 to activate debug print statements internal
           to Tie::Watch.

           -shadow (default 1) is 0 to disable array and hash shadowing.  To
           prevent infinite recursion Tie::Watch maintains parallel variables
           for arrays and hashes.  When the watchpoint is created the parallel
           shadow variable is initialized with the watched variable's
           contents, and when the watchpoint is deleted the shadow variable is
           copied to the original variable.  Thus, changes made during the
           watch process are not lost.  Shadowing is on my default.  If you
           disable shadowing any changes made to an array or hash are lost
           when the watchpoint is deleted.

           Specify any of the following relevant callback parameters, in the
           format described above: -fetch, -store, -destroy.  Additionally for
           arrays: -clear, -extend, -fetchsize, -pop, -push, -shift, -splice,
           -storesize and -unshift.  Additionally for hashes: -clear, -delete,
           -exists, -firstkey and -nextkey.

       $args = $watch->Args(-fetch);
           Returns a reference to a list of arguments for the specified
           callback, or undefined if none.

       $watch->Fetch();  $watch->Fetch($key);
           Returns a variable's current value.  $key is required for an array
           or hash.

       %vinfo = $watch->Info();
           Returns a hash detailing the internals of the Watch object, with
           these keys:

            %vinfo = {
                -variable =>  SCALAR(0x200737f8)
                -debug    =>  '0'
                -shadow   =>  '1'
                -value    =>  'HELLO SCALAR'
                -destroy  =>  ARRAY(0x200f86cc)
                -fetch    =>  ARRAY(0x200f8558)
                -store    =>  ARRAY(0x200f85a0)
                -legible  =>  above data formatted as a list of string, for printing
            }

           For array and hash Watch objects, the -value key is replaced with a
           -ptr key which is a reference to the parallel array or hash.
           Additionally, for an array or hash, there are key/value pairs for
           all the variable specific callbacks.

       $watch->Say($val);
           Used mainly for debugging, it returns $val in quotes if required,
           or the string "undefined" for undefined values.

       $watch->Store($new_val);  $watch->Store($key, $new_val);
           Store a variable's new value.  $key is required for an array or
           hash.

       $watch->Unwatch();
           Stop watching the variable.

EFFICIENCY CONSIDERATIONS
       If you can live using the class methods provided, please do so.  You
       can meddle with the object hash directly and improved watch
       performance, at the risk of your code breaking in the future.

AUTHOR
       Stephen O. Lidie

HISTORY
        lusol@Lehigh.EDU, LUCC, 96/05/30
        . Original version 0.92 release, based on the Trace module from Hans Mulder,
          and ideas from Tim Bunce.

        lusol@Lehigh.EDU, LUCC, 96/12/25
        . Version 0.96, release two inner references detected by Perl 5.004.

        lusol@Lehigh.EDU, LUCC, 97/01/11
        . Version 0.97, fix Makefile.PL and MANIFEST (thanks Andreas Koenig).
          Make sure test.pl doesn't fail if Tk isn't installed.

        Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 97/10/03
        . Version 0.98, implement -shadow option for arrays and hashes.

        Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 98/02/11
        . Version 0.99, finally, with Perl 5.004_57, we can completely watch arrays.
          With tied array support this module is essentially complete, so its been
          optimized for speed at the expense of clarity - sorry about that. The
          Delete() method has been renamed Unwatch() because it conflicts with the
          builtin delete().

        Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 99/04/04
        . Version 1.0, for Perl 5.005_03, update Makefile.PL for ActiveState, and
          add two examples (one for Perl/Tk).

        sol0@lehigh.edu, Lehigh University Computing Center, 2003/06/07
        . Version 1.1, for Perl 5.8, can trace a reference now, patch from Slaven
          Rezic.

        sol0@lehigh.edu, Lehigh University Computing Center, 2005/05/17
        . Version 1.2, for Perl 5.8, per Rob Seegel's suggestion, support array
          DELETE and EXISTS.

COPYRIGHT
       Copyright (C) 1996 - 2005 Stephen O. Lidie. All rights reserved.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

Tk804.035                         2013-11-15                     Tie::Watch(3)
