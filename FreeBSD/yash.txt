YASH(1)                                                                YASH(1)

名
       yash - POSIX 準拠コマンドラインシェル

概
       yash [オ

は
       Yet another shell (yash) は Unix 系 OS
       用コマンドラインシェルです。POSIX.1-2024 規格に (一部の例外を除いて)
       準拠しています。POSIX
       準拠を謳う他のシェルよりも精確な準拠を目指しています。また、コマンド履歴やコマンドライン編集など、対話シェルとして標準的な機能も備えています。

       このプログラムは GNU General Public License (Version 2)
       の元で自由に再配布・変更などができます。た
       2.1 日本ライセンスの下で自由に再配布・変更などができます。

       Yash は渡邊裕貴 (通称まじかんと)
       という一人の開発者によって開発されています。Yash
       のソースコードレポジトリおよび ウェブサイトは GitHub
       がホストしています。

シ
       Yash がプログラムとして起動されると、yash
       はいくつかの初期化処理を行った後、コマンドを読み取って実行する処理に移ります。これらの処理の内容は、主に起動時のコマンドライン引数によって決まります。

   起
       Yash の起動時のコマンドライン引数は POSIX に準拠しています。POSIX
       で定められているとおり、引数は オプション と オペランド
       に分類されます。引数の書式に関する一般的な説明についてはコマンドの引数の構文を参照してください。オプションはオペランドより前に指定する必要があります。

       オプションに -c (--cmdline)
       オプションが含まれている場合、オペランドを少なくとも一つ与える必要があります。シェルは、この最初のオペランドをコマンドとして解釈・実行します。二つ目のオペランドがある場合は、特殊パラメータ
       0
       がそれに初期化されます。三つ目以降のオペランドは、位置パラメータになります。
       -c (--cmdline)
       オプションを指定した場合は、ファイルや標準入力からコマンドを読み込むことはありません
       (ドット組込みコマンドを使用したときを除く)。

       オプションに -s (--stdin)
       オプションが含まれている場合、シェルは標準入力から一行ずつコマンドを読み取って、解釈・実行します。オペランドはすべて位置パラメータの初期化に使われます。特殊パラメータ
       0
       はこのシェルが起動されたときに元のプログラムから受け取った最初の引数に初期化されます。

       -c (--cmdline) オプションも -s (--stdin)
       オプションも指定されなかった場合は、シェルはファイルからコマンドを読み取って解釈・実行します。最初のオペランドが読み込むファイル名と見なされ、特殊パラメータ
       0
       の値となります。残りのオペランドは位置パラメータになります。オペランドが一つもない場合は、
       -s (--stdin)
       オプションを指定したときと同様に標準入力からコマンドを読み込みます。

       -c (--cmdline) オプションと -s (--stdin)
       オプションを同時に使用することはできません。

       --help オプションまたは -V (--version)
       オプションが指定されている場合は、通常の初期化処理やコマンドの解釈・実行は一切行いません。それぞれシェルのコマンドライン引数の簡単な説明とバージョン情報を標準出力に出力した後、そのままシェルは終了します。
       -V (--version) オプションを -v (--verbose)
       オプションと共に使用すると、シェルで利用可能な機能の一覧も出力されます。

       -i (--interactive)
       オプションが指定されている場合、シェルは対話モードになります。逆に +i
       (++interactive)
       オプションが指定されている場合、シェルは対話モードになりません。 -i
       (--interactive)
       オプションが指定されていない場合でも、シェルは以下の条件をすべて満たすときに自動的に対話モードになります:

       •   +i (++interactive) オプションが指定されていない

       •   -s (--stdin) オプションが指定されているか自動的に有効になった

       •   標準入力が端末である

       •   標準エラーが端末である

       -l (--login)
       オプションが指定されている場合、シェルはログインシェルとして動作します。

       --noprofile, --norcfile, --profile, --rcfile
       各オプションは、シェルの初期化処理の動作を指定します (後述)。

       その他のオプションとして、set
       組込みコマンドで指定可能な各種オプションをシェルの起動時に指定することができます。(+
       で始まるオプションを含む)

       最初のオペランドが - であり、かつオプションとオペランドが --
       で区切られていない場合、そのオペランドは特別に無視されます。

   シ
       シェルの初期化処理は以下のように行われます。

        1. Yash はまず、(コマンドライン引数の前に渡される)
           それ自身の起動時の名前を解析します。その名前が -
           で始まる場合は、シェルはログインシェルとして動作します。また名前が
           sh である場合 (/bin/sh のように sh で終わる場合を含む) は、シェルは
           POSIX 準拠モードになります。

        2. オペランドが一つもなく、かつ標準入力と標準エラーがどちらも端末ならば、シェルは自動的に対話モードになります。ただし
           +i (++interactive)
           オプションが指定されている場合はそちらを優先します。

        3. 対話モードのシェルでは自動的にジョブ制御が有効になります。ただし +m
           (++monitor) オプションが指定されている場合はそちらを優先します。

        4. シェルは以下の初期化スクリプトを読み込んで解釈・実行します。(ただしシェルプロセスの実ユーザ
           ID と実効ユーザ ID が異なっているか、実グループ ID と実効グループ
           ID が異なっている場合を除く)

            1. シェルがログインシェルとして動作している場合は、
               --profile=ファイル名
               オプションで指定したファイルを読み込んで実行します。(ただし
               --noprofile オプションが指定されているか POSIX
               準拠モードの場合を除く)

               --profile=ファイル名
               オプションが指定されていない場合は、デフォルトとして
               $XDG_CONFIG_HOME/yash/profile もしくは ~/.yash_profile
               を読み込みます。

            2. シェルが対話モードの場合は、 --rcfile=ファイル名
               オプションで指定したファイルを読み込んで実行します。(ただし
               --norcfile オプションが指定されている場合を除く)

               --rcfile オプションが指定されていない場合は、非 POSIX
               準拠モードではファイル $XDG_CONFIG_HOME/yash/rc
               がデフォルトのファイルとして使われます。それが見付からない場合は、~/.yashrc
               を読み込みます。~/.yashrc も読み込めない場合は、ファイル
               initialization/default を YASH_LOADPATH
               から探して読み込みます。POSIX 準拠モードでは、ENV
               環境変数の値がパラメータ展開され、その結果をファイル名と見なしてファイルを読み込みます。

       XDG_CONFIG_HOME 環境変数が設定されていない場合、その値の代わりに
       ~/.config を使用します。

           注

           Yash は /etc/profile や /etc/yashrc や ~/.profile
           を自動的に読むことはありません。

コ
       シェルはコマンドを一行ずつ読み込んで解釈し、実行します。一行に複数のコマンドがある場合は、それら全てを解釈してから実行します。一つのコマンドが複数行にまたがっている場合は、そのコマンドを解釈し終えるのに必要なだけ後続の行が読み込まれます。コマンドを正しく解釈できない場合は、文法エラーとなり、コマンドは実行されません。

       非対話モードで文法エラーが発生した時は、シェルはコマンドの読み込みを中止するため、それ以降のコマンドは一切読み込まれません。

   ト
       コマンドは、いくつかのトークンによって構成されます。トークンとは、シェルの文法における一つ一つの単語のことを言います。トークンは原則として空白
       (空白文字またはタブ文字)
       によって区切られます。ただしコマンド置換などに含まれる空白はトークンの区切りとは見なしません。

       以下の記号は、シェルの文法において特別な意味を持っています。これらの記号も多くの場合他の通常のトークンの区切りとなります。

           ; & | < > ( ) [newline]

       以下の記号はトークンの区切りにはなりませんが、文法上特別な意味を持っています。

           $ ` \ " ' * ? [ # ~ = %

       以下のトークンは特定の場面において予約語と見なされます。予約語は複合コマンドなどを構成する一部となります。

           ! { } [[ case do done elif else esac fi
           for function if in then until while

       これらのトークンは以下の場面において予約語となります。

       •   それがコマンドの最初のトークンのとき

       •   それが他の予約語 (case, for, in を除く) の直後のトークンのとき

       •   それがコマンドの最初のトークンではないが、複合コマンドの中で予約語として扱われるべきトークンであるとき

       トークンが # で始まる場合、その #
       から行末まではコメントと見なされます。コマンドの解釈においてコメントは完全に無視されます。

   ク
       空白や上記の区切り記号・予約語などを通常の文字と同じように扱うには、適切な引用符でクォートする必要があります。引用符は、それ自体をクォートしない限り通常の文字としては扱われません。シェルでは以下の三種類の引用符が使えます。

       •   バックスラッシュ (\) は直後の一文字をクォートします。

           例外として、バックスラッシュの直後に改行がある場合、それは改行をクォートしているのではなく、行の連結と見なされます。バックスラッシュと改行が削除され、バックスラッシュがあった行とその次の行が元々一つの行であったかのように扱われます。

       •   二つの一重引用符 (')
           で囲んだ部分では、全ての文字は通常の文字と同じように扱われます。改行を一重引用符で囲むこともできます。通常は一重引用符を一重引用符で囲むことはできませんが、ドル一重引用符内でエスケープすれば一重引用符を一重引用符でクォートできます。

       •   二つの二重引用符 (")
           で囲んだ部分も一重引用符で囲んだ部分と同様にクォートされますが、いくつか例外があります。二重引用符で囲んだ部分では、パラメータ展開・コマンド置換・数式展開が通常通り解釈されます。またバックスラッシュは
           $, `, ", \
           の直前にある場合および行の連結を行う場合にのみ引用符として扱われ、それ以外のバックスラッシュは通常の文字と同様に扱われます。

       ド

           一重引用符で囲まれた部分の直前に $ が付いている場合、その $' と '
           で囲まれた間の部分では以下のエスケープ記法が認識されます。それ以外の点では二つの
           ' で囲まれた通常のクォートと同様です。

           \", \', \\
               それぞれ ", ', \ そのものを表します。
               このようにエスケープされた '
               はドル一重引用符の終わりとはみなされません。

           \a, \b, \e, \f, \n, \r, \t, \v
               順に、アラート
               (ベル)・バックスペース・エスケープ・フォームフィード・改行・キャリッジリターン・水平タブ・垂直タブの文字を表します。

           \c
               直後にある文字に対応する制御文字を表します。例えば \cA は
               Ctrl-A によって入力される SOH
               制御文字を表します。この記法ではヌル文字 (Ctrl-@, \c@)
               はサポートされません。また FS 制御文字 (Ctrl-\)
               を表すにはバックスラッシュ自体もエスケープする必要があります
               (\c\ ではなく \c\\ のように)。

           \x
               直後に続く 1 桁または 2
               桁の十六進数によって指定された値の文字を表します。 例えば \x20
               は十六進法で 20 の値を持つ文字に変換されます。

           \0, \1, \2, ..., \377
               直後に続く 1～3
               桁の八進数によって指定された値の文字を表します。 値は 8
               ビット以内に収まる必要があります。

           上記以外のバックスラッシュ記法はエラーとみなされ、当該部分の文字は
           ? に置換されます。

               注

               十六進数または八進数のエスケープ記法で表される値は、ワイド文字のコードポイントとして解釈されます。この動作は、値を生のバイトとして扱うことを要求する
               POSIX には準拠していません。

   エ
       コマンドを構成する各トークンは、それが予め登録されたエイリアスの名前に一致するかどうか調べられます。一致するものがあれば、そのトークンはそのエイリアスの内容に置き換えられて、その後コマンドの解析が続けられます。これをエイリアス置換といいます。

       エイリアスの名前に引用符を含めることはできないので、引用符を含むトークンはエイリアス置換されません。また、予約語やコマンドを区切る記号もエイリアス置換されません。

       エイリアスには通常のエイリアスとグローバルエイリアスの二種類があります。通常のエイリアスは、コマンドの最初のトークンにのみ一致します。グローバルエイリアスはコマンド内の全てのトークンが一致の対象です。グローバルエイリアスは
       POSIX 規格にはない拡張機能です。

       通常のエイリアスで置換された部分の最後の文字が空白の場合、特例としてその直後のトークンにも通常のエイリアスの置換が行われます。

       エイリアス置換の結果がさらに別のエイリアスに一致して置換される場合もあります。しかし、同じエイリアスに再び一致することはありません。

       エイリアスを登録するには alias 組込みコマンドを、登録を削除するには
       unalias 組込みコマンドを使用します。

   単
       最初のトークンが予約語でないコマンドは、単純コマンドです。単純コマンドは単純コマンドの実行のしかたに従って実行されます。

       単純コマンドの初めのトークンが 名前=値
       の形式になっている場合は、それは変数代入と見なされます。ただしここでの名前は、一文字以上のアルファベット・数字または下線
       (_)
       で、かつ最初が数字でないものです。変数代入ではない最初のトークンはコマンドの名前と解釈されます。それ以降のトークンは
       (たとえ変数代入の形式をしていたとしても) コマンドの引数と解釈されます。

       名前=(トークン列)
       の形になっている変数代入は、配列の代入となります。括弧内には任意の個数のトークンを書くことができます。またこれらのトークンは空白・タブだけでなく改行で区切ることもできます。

   パ
       パイプラインは、一つ以上のコマンド
       (単純コマンド、複合コマンド、または関数定義) を記号 |
       で繋いだものです。

       二つ以上のコマンドからなるパイプラインの実行は、パイプラインに含まれる各コマンドをそれぞれ独立したサブシェルで同時に実行することで行われます。この時、各コマンドの標準出力は次のコマンドの標準入力にパイプで受け渡されます。最初のコマンドの標準入力と最後のコマンドの標準出力は元のままです。

       Pipe-fail
       オプションが無効な時は、最後のコマンドの終了ステータスがパイプラインの終了ステータスになります。有効な時は、終了ステータスが
       0
       でなかった最後のコマンドの終了ステータスがパイプラインの終了ステータスになります。全てのコマンドの終了ステータスが
       0 だった時は、パイプラインの終了ステータスも 0 になります。

       パイプラインの先頭には、記号 !
       を付けることができます。この場合、パイプラインの終了ステータスが逆転します。つまり、最後のコマンドの終了ステータスが
       0 のときはパイプラインの終了ステータスは 1 になり、それ以外の場合は 0
       になります。

       Korn シェルでは構文 !(...) は POSIX
       で定義されていない独自のパス名展開パターンと見做されます。POSIX
       準拠モードでは ! と (
       の二つのトークンは一つ以上の空白で区切る必要があります。

           注

           最後のコマンドの終了ステータスがパイプラインの終了ステータスになるため、パイプラインの実行が終了するのは少なくとも最後のコマンドの実行が終了した後です。しかしそのとき他のコマンドの実行が終了しているとは限りません。また、最後のコマンドの実行が終了したらすぐにパイプラインの実行が終了するとも限りません。(シェルは、他のコマンドの実行が終わるまで待つ場合があります)

           注

           POSIX
           規格では、パイプライン内の各コマンドはサブシェルではなく現在のシェルで実行してもよいことになっています。

   And/or リ
       And/or リストは一つ以上のパイプラインを記号 && または ||
       で繋いだものです。

       And/or リストの実行は、and/or
       リストに含まれる各パイプラインを条件付きで実行することで行われます。最初のパイプラインは常に実行されます。それ以降のパイプラインの実行は、前のパイプラインの終了ステータスによります。

       •   二つのパイプラインが &&
           で繋がれている場合、前のパイプラインの終了ステータスが 0
           ならば後のパイプラインが実行されます。

       •   二つのパイプラインが ||
           で繋がれている場合、前のパイプラインの終了ステータスが 0
           でなければ後のパイプラインが実行されます。

       •   それ以外の場合は、and/or
           リストの実行はそこで終了し、それ以降のパイプラインは実行されません。

       最後に実行したパイプラインの終了ステータスが and/or
       リストの終了ステータスになります。

       構文上、and/or リストの直後には原則として記号 ; または & が必要です
       (コマンドの区切りと非同期コマンド参照)。

   コ
       シェルが受け取るコマンドの全体は、and/or リストを ; または &
       で区切ったものです。行末、 ;; または ) の直前にある ;
       は省略できますが、それ以外の場合は and/or リストの直後には必ず ; と &
       のどちらかが必要です。

       And/or リストの直後に ; がある場合は、その and/or
       リストは同期的に実行されます。すなわち、その and/or
       リストの実行が終わった後に次の and/or リストが実行されます。And/or
       リストの直後に & がある場合は、その and/or
       リストは非同期的に実行されます。すなわち、その and/or
       リストの実行を開始した後、終了を待たずに、すぐさま次の and/or
       リストの実行に移ります。非同期な and/or
       リストは常にサブシェルで実行されます。また終了ステータスは常に 0 です。

       ジョブ制御を行っていないシェルにおける非同期な and/or
       リストでは、標準入力が自動的に /dev/null
       にリダイレクトされるとともに、SIGINT と SIGQUIT を受信したときの動作が
       『無視』
       に設定されこれらのシグナルを受けてもプログラムが終了しないようにします。

       ジョブ制御を行っているかどうかにかかわらず、非同期コマンドの実行を開始するときにシェルはそのコマンドのプロセス
       ID
       を記憶します。シェルが対話モードの場合、コマンドのジョブ番号とプロセス
       ID が標準エラーに出力されます。プロセス ID は特殊パラメータ !
       の値から知ることもできます。非同期コマンドの状態や終了ステータスは jobs
       や wait 組込みコマンドで知ることができます。

   複
       複合コマンドは、より複雑なプログラムの制御を行う手段を提供します。

       グ

           グルーピングを使うと、複数のコマンドを一つのコマンドとして扱うことができます。

           通常のグルーピングの構文
               { コマンド...; }

           サブシェルのグルーピングの構文
               (コマンド...)

           { と }
           は予約語なので、他のコマンドのトークンとくっつけて書いてはいけません。一方
           ( と )
           は特殊な区切り記号と見なされるので、他のトークンとくっつけて書くことができます。

           通常のグルーピング構文 ({ と } で囲む) では、コマンドは
           (他のコマンドと同様に)
           現在のシェルで実行されます。サブシェルのグルーピング構文 (( と )
           で囲む) では、括弧内のコマンドは新たなサブシェルで実行されます。

           POSIX
           準拠モードでは括弧内に少なくとも一つのコマンドが必要ですが、非
           POSIX 準拠モードではコマンドは一つもなくても構いません。

           グルーピングの終了ステータスは、グルーピングの中で実行された最後のコマンドの終了ステータスです。グルーピング内にコマンドが一つもない場合、グルーピングの終了ステータスはグルーピングの直前に実行されたコマンドの終了ステータスになります。

       If 文

           If
           文は条件分岐を行います。分岐の複雑さに応じていくつか構文のバリエーションがあります。

           If 文の基本構文
               if 条件コマンド...; then 内容コマンド...; fi

           Else がある場合
               if 条件コマンド...; then 内容コマンド...; else 内容コマンド...;
               fi

           Elif がある場合
               if 条件コマンド...; then 内容コマンド...; elif 条件コマンド...;
               then 内容コマンド...; fi

           Elif と else がある場合
               if 条件コマンド...; then 内容コマンド...; elif 条件コマンド...;
               then 内容コマンド...; else 内容コマンド...; fi

           If 文の実行では、どの構文の場合でも、if
           の直後にある条件コマンドがまず実行されます。条件コマンドの終了ステータスが
           0 ならば、条件が真であると見なされて then
           の直後にある内容コマンドが実行され、if
           文の実行はそれで終了します。終了ステータスが 0
           でなければ、条件が偽であると見なされます。ここで else も elif
           もなければ、if 文の実行はこれで終わりです。else がある場合は、else
           の直後の内容コマンドが実行されます。elif がある場合は、elif
           の直後の条件コマンドが実行され、その終了ステータスが 0
           であるかどうか判定されます。その後は先程と同様に条件分岐を行います。

           elif ...; then ...; は一つの if 文内に複数あっても構いません。

           If
           文全体の終了ステータスは、実行された内容コマンドの終了ステータスです。内容コマンドが実行されなかった場合
           (どの条件も偽で、else がない場合) は 0 です。

       While お

           While ループと until ループは単純なループ構文です。

           While ループの構文
               while 条件コマンド...; do 内容コマンド...; done

           Until ループの構文
               until 条件コマンド...; do 内容コマンド...; done

           非 POSIX 準拠モードでは 条件コマンド...; および 内容コマンド...;
           は省略可能です。

           While
           ループの実行ではまず条件コマンドが実行されます。そのコマンドの終了ステータスが
           0
           ならば、内容コマンドが実行されたのち、再び条件コマンドの実行に戻ります。この繰り返しは条件コマンドの終了ステータスが
           0 でなくなるまで続きます。

               注

               条件コマンドの終了ステータスが最初から 0
               でないときは、内容コマンドは一度も実行されません。

           Until ループは、ループを続行する条件が逆になっている以外は while
           ループと同じです。すなわち、条件コマンドの終了ステータスが 0
           でなければ内容コマンドが実行されます。

           While/until
           ループ全体の終了ステータスは、最後に実行した内容コマンドの終了ステータスです。(内容コマンドが存在しないか、一度も実行されなかったときは
           0)

       For ル

           For
           ループは指定されたそれぞれの単語について同じコマンドを実行します。

           For ループの構文
               for 変数名 in 単語...; do コマンド...; done

               for 変数名 do コマンド...; done

           in の直後の単語は一つもなくても構いませんが、do の直前の ;
           (または改行)
           は必要です。これらの単語トークンは予約語としては認識されませんが、&
           などの記号を含めるには適切なクォートが必要です。非 POSIX
           準拠モードでは コマンド...; がなくても構いません。

           POSIX 準拠モードでは、変数名はポータブルな (すなわち ASCII
           文字のみからなる) 名前でなければなりません。

           For
           ループの実行ではまず単語が単純コマンド実行時の単語の展開と同様に展開されます
           (in ...; がない構文を使用している場合は、in "$@";
           が省略されているものと見なされます)。続いて、展開で生成されたそれぞれの単語について順番に一度ずつ以下の処理を行います。

            1. 単語を変数名で指定した変数に代入する

            2. コマンドを実行する

           単語はローカル変数として代入されます (POSIX
           準拠モードが有効なときまたは for-local
           オプションが無効なときを除く)。

           展開の結果単語が一つも生成されなかった場合は、変数は作られずコマンドも一切実行されません。

           For
           ループ全体の終了ステータスは、最後に実行したコマンドの終了ステータスです。コマンドがあるのに一度も実行されなかったときは
           0 です。コマンドがない場合、for ループの終了ステータスは for
           ループの一つ前に実行されたコマンドの終了ステータスになります。

           変数が読み取り専用の場合、for ループの実行は 0
           でない終了ステータスで中断されます。

       Case 文

           Case
           文は単語に対してパターンマッチングを行い、その結果に対応するコマンドを実行します。

           Case 文の構文
               case 単語 in caseitem... esac

           Caseitem の構文
               (パターン) コマンド... ;;

               (パターン) コマンド... ;&

               (パターン) コマンド... ;|

               (パターン) コマンド... ;;&

           case と in
           の間の単語はちょうど一トークンでなければなりません。この単語トークンは予約語としては認識されませんが、&
           や | などの記号を含めるには適切なクォートが必要です。in と esac
           の間には任意の個数の caseitem を置きます (0 個でもよい)。

           Caseitem の最初の ( は (最初のパターンが esac でない限り)
           省略できます。 Caseitem
           のパターンにはトークンを指定します。各トークンの間を |
           で区切ることで複数のトークンをパターンとして指定することもできます。

           Caseitem には任意の個数のコマンドを含めることができます (0
           個でもよい)。 Case 文の最後の caseitem が ;;
           で終端されている場合は、その ;; は省略できます。

           Case 文の実行では、まず単語が四種展開されます。その後、各 caseitem
           に対して順に以下の動作を行います。

            1. パターントークンを単語と同様に展開し、展開したパターンが展開した単語にマッチするかどうか調べます
               (パターンマッチング記法参照)。パターンとして指定されたトークンが複数ある場合はそれら各トークンに対してマッチするかどうか調べます
               (どれかのパターントークンがマッチしたらそれ以降のパターントークンは展開されません。Yash
               はトークンが書かれている順番にマッチするかどうかを調べますが、他のシェルもこの順序で調べるとは限りません)。

            2. マッチした場合は、直後のコマンドを実行します。その後の動作は
               caseitem の最後のトークンにより変わります。

               •   Caseitem が ;; で終わる (または ;; が省略されている)
                   場合、case 文の実行はそこで終了し、残りの caseitem
                   は無視されます。

               •   Caseitem が ;& で終わる場合、次の caseitem
                   の処理に進みます。ただしパターンの展開やマッチングは行わず、コマンドが直ちに実行されます。

               •   Caseitem が ;| または ;;& で終わる場合、後続の caseitem
                   の処理を継続します。

            3. マッチしなかった場合は、次の caseitem の処理に移ります。

           Case
           文全体の終了ステータスは、実行した最後のコマンドの終了ステータスです。コマンドが実行されなかった場合
           (caseitem
           が一つもないか、どのパターンもマッチしなかったか、最後にマッチしたパターンの後のコマンドが空の場合)
           は、終了ステータスは 0 です。

           ;| と ;;& は POSIX 準拠モードでは使用できない拡張機能です。

       二

           二重ブラケットコマンドは test
           コマンドに近い動作をする構文です。ブラケットに囲まれた式を展開して評価します。

           二重ブラケットコマンド構文
               [[ 式 ]]

           式は単一の原子式とすることも原子式や演算子の組み合わせとすることもできます。式の構文解析は、コマンドの実行時ではなく構文解析時に行われます。演算子
           (原子式の演算子もそうでないものも)
           はクォートしてはなりません。クォートすると通常の単語と見なされます。

           コマンドが実行されるとき、被演算子となる単語は四種展開されます。ブレース展開・単語分割・パス名展開は行われません。

           二重ブラケットコマンドでは test
           コマンドと同様に以下の原子式が使用できます:

           単項原子式
               -b, -c, -d, -e, -f, -G, -g, -h, -k, -L, -N, -n, -O, -o, -p, -r,
               -S, -s, -t, -u, -w, -x, -z

           二項原子式
               -ef, -eq, -ge, -gt, -le, -lt, -ne, -nt, -ot, -veq, -vge, -vgt,
               -vle, -vlt, -vne, ===, !==, =~, <, >

           さらに、文字列を比較するための三つの二項原子式が使用できますが、test
           コマンドとは動作が異なります: = および ==
           原子式は右辺をパターンとして扱い、左辺がそれにマッチするかどうかを判定します。
           != 原子式は同様の判定を行い、逆の結果を返します。

           原子式の被演算子となる単語が ]]
           であるか他の演算子と紛らわしい場合は、クォートする必要があります。

               注

               将来新しい種類の原子式が導入される可能性があります。ハイフンで始まる単語は全てクォートすることをお勧めします。

               注

               <= および >=
               二項原子式は二重ブラケットコマンド内においては正しく構文解析できないため使用できません。

           以下の演算子を使用して原子式を組み合わせることができます
           (ここでは演算子の結合順位が高い順に示します):

           ( 式 )
               式を括弧で囲むと演算子の優先順位を変更できます。

           ! 式
               感嘆符は式の結果を反転します。

           式 && 式
               二重アンパサンドは連言 (論理積)
               を表します。両辺が共に真である時、全体も真となります。左辺が先に展開・判定されます。左辺が真である場合のみ右辺が展開・判定されます。

           式 || 式
               二重縦棒は選言 (論理和)
               を表します。両辺が共に偽である時、全体も偽となります。左辺が先に展開・判定されます。左辺が偽である場合のみ右辺が展開・判定されます。

               注

               二重ブラケットコマンドでは、test コマンドの様に -a および -o
               を連言・選言演算子として使用することはできません。

           二重ブラケットコマンドの終了ステータスは、式が真ならば 0、偽ならば
           1、展開エラーやその他の理由で判定が行えない場合は 2 です。

               注

               二重ブラケットコマンドは bash, ksh, mksh, zsh
               にもありますが、POSIX
               にはない拡張機能です。シェルによって多少動作が異なります。移植性を高めるには二重ブラケットコマンドよりも
               test コマンドを使用することをお勧めします。

   関
       関数定義コマンドは、関数を定義します。

       関数定義コマンドの構文
           関数名 ( ) 複合コマンド

           function 関数名 複合コマンド

           function 関数名 ( ) 複合コマンド

       予約語 function
       を用いない一つ目の形式では、関数名には引用符などの特殊な記号を含めることはできません。予約語
       function
       を用いる二つ目または三つ目の形式では、関数名は実行時に四種展開されます。(POSIX
       準拠モードでは、予約語 function
       を用いる形式の関数定義は使えません。また関数名はポータブルな (すなわち
       ASCII 文字のみからなる) 名前でなければなりません。)

       関数定義コマンドを実行すると、指定した関数名の関数が複合コマンドを内容として定義されます。

       関数定義コマンドに対して直接リダイレクトを行うことはできません。関数定義コマンドの最後にあるリダイレクトは、関数の内容である複合コマンドに対するリダイレクトと見なされます。例えば
       func() { cat; } >/dev/null と書いた場合、リダイレクトされるのは func()
       { cat; } ではなく { cat; } です。

       関数定義コマンドの終了ステータスは、関数が正しく定義された場合は
       0、そうでなければ非 0 です。

パ
       パラメータとは、パラメータ展開で値に置き換えられるデータを言います。パラメータには位置パラメータ・特殊パラメータ・変数の三種類があります。

   位
       位置パラメータは 1
       以上の自然数によって識別されるパラメータです。例えば位置パラメータが三つある場合、それらは順に
       1, 2, 3 という名称で識別されます。位置パラメータの個数は特殊パラメータ
       # で取得できます。また全ての位置パラメータを表す特殊パラメータとして *
       と @ があります。

       位置パラメータは、シェルの起動時に、シェルのコマンドライン引数を元に初期化されます
       (起動時のコマンドライン引数参照)。引数のうち、位置パラメータの値として与えられたオペランドが順に一つずつ位置パラメータとなります。

       シェルのコマンド実行中に関数が呼び出されるとき、位置パラメータはその関数の呼び出しに対する引数に変更されます。すなわち、関数の実行中は位置パラメータによって関数の引数を参照できます。関数呼び出しの直前の位置パラメータの値は保存されており、関数の実行が終了する際に元の値に戻ります。

       位置パラメータは、set や shift
       などの組込みコマンドによって変更できます。

       0 は位置パラメータとは見なされません (特殊パラメータの一つです)。

   特
       特殊パラメータは一文字の記号によって識別されるパラメータです。特殊パラメータにはユーザが明示的に値を代入することはできません。

       Yash では以下の特殊パラメータが利用可能です。

       0
           このパラメータの値は、シェルの起動時に与えられたシェルの実行ファイルの名称またはスクリプトファイルの名称です。(起動時のコマンドライン引数参照)

       #
           このパラメータの値は、現在の位置パラメータの個数を表す 0
           以上の整数です。

       $
           このパラメータの値は、シェル自身のプロセス ID
           を表す正の整数です。この値はサブシェルにおいても変わりません。

       -
           このパラメータの値は、現在シェルで有効になっているオプションの文字をつなげたものです。この値には、シェルの起動時にコマンドライン引数で指定できる一文字のオプションのうち現在有効になっているものが全て含まれます。Set
           組込みコマンドでオプションを変更した場合は、その変更がこのパラメータの値にも反映されます。

       ?
           このパラメータの値は、最後に終了したパイプラインの終了ステータスを表す
           0 以上の整数です。

       !
           このパラメータの値は、最後に開始した非同期コマンドもしくは最後に再開したジョブのプロセス
           ID です。

       *
           このパラメータの値は、現在の位置パラメータの値です。位置パラメータが一つもない場合、このパラメータの値は空文字列です。位置パラメータが複数ある場合、このパラメータの値は全ての位置パラメータの値を連結したものです。各位置パラメータの値の間は以下に従って区切られます。

           •   変数 IFS が存在し、その値が空でない場合、各位置パラメータは変数
               IFS の値の最初の文字で区切られます。

           •   変数 IFS
               が存在し、その値が空の場合、各位置パラメータは間に何も置かずに連結されます。

           •   変数 IFS
               が存在しない場合、各位置パラメータは空白文字で区切られます。

           このパラメータの展開結果に対して単語分割が行われる場合、値はまず元の位置パラメータに一致するように分割されさらに変数
           IFS の値に従って分割されます。この最初の分割は IFS
           が空文字列でも行います。

       @
           このパラメータは、パラメータ *
           と同様に現在の全ての位置パラメータを表します。ただし、このパラメータが二重引用符によるクォートの中で展開される場合の扱いがパラメータ
           *
           と異なります。この場合、結果は各位置パラメータに正確に一致するように単語分割されます。また位置パラメータが一つもない場合、このパラメータは展開後の単語には残りません。(よって、引用符の中であるにもかかわらず、展開結果は一つの単語になるとは限りません。)

           例えば位置パラメータが一つもないとき、コマンドライン echo 1 "$@" 2
           は echo、1、2 という三つの単語に展開されます。位置パラメータが 1、2
           2、3 の三つのとき、コマンドライン echo "$@" は echo、1、2 2、3
           という四つの単語に展開され、コマンドライン echo "a$@b" は
           echo、a1、2 2、3b という四つの単語に展開されます。

   変
       変数とはユーザが自由に代入可能なパラメータです。各変数は名前で区別され、それぞれが文字列の値を持ちます。

       変数の名前は、英数字と下線 (_)
       から構成されます。ただし変数名の頭文字を数字にすることはできません。環境によってはこれ以外の文字も変数名に使用できます。

       シェルが扱う変数のうち、エクスポートの対象となっているものは環境変数といいます。これらの変数はシェルが外部コマンドを起動する際に外部コマンドに渡されます。シェルが起動されたときにシェルを起動したプログラムから渡された変数は自動的に環境変数になります。

       変数は、単純コマンドによって代入できます。また typeset
       組込みコマンドなどでも変数に代入することができます。変数を削除するには
       unset 組込みコマンドを使います。

       シ

           以下の名前の変数は、yash の実行において特別な意味を持っています。

           CDPATH
               この変数は cd
               組込みコマンドで移動先ディレクトリを検索するために使われます。

           COLUMNS
               この変数は端末ウィンドウの横幅 (文字数)
               を指定します。この変数が設定されている場合、デフォルトの横幅ではなくこの変数の値で指定された横幅が行編集で使われます。

           COMMAND
               POST_PROMPT_COMMAND
               変数が実行される間、この変数は直前に入力されたコマンドを示します。
               POST_PROMPT_COMMAND の実行が終わるとこの変数は消去されます。

           COMMAND_NOT_FOUND_HANDLER
               シェルが実行しようとしたコマンドが見つからなかったとき、この変数の値がコマンドとして実行されます。不明なコマンドを実行したときに何か別のコマンドを実行させたい時に便利です。単純コマンドの実行を参照。

               この機能は POSIX 準拠モードでは働きません。

           DIRSTACK
               この配列変数はディレクトリスタックの実装に使われています。pushd
               組込みコマンドでディレクトリを移動したとき、前のディレクトリを覚えておくためにそのパス名がこの配列に入れられます。この配列の内容を変更することは、ディレクトリスタックの内容を直接変更することになります。

           ECHO_STYLE
               この変数は echo 組込みコマンドの挙動を指定します。

           ENV
               POSIX
               準拠モードで対話モードのシェルが起動されたとき、この変数の値で示されるパスのファイルが初期化スクリプトとして読み込まれます
               (シェルの初期化処理参照)。

           FCEDIT
               Fc
               組込みコマンドでコマンドを編集する際、この変数の値で示されたエディタがコマンドの編集に使われます。

           HANDLED
               この変数は COMMAND_NOT_FOUND_HANDLER
               変数の値が実行された後に、コマンドが見つからなかったことをエラーとするかどうかを指示します。単純コマンドの実行を参照。

           HISTFILE
               コマンド履歴を保存するファイルのパスを指定します。

           HISTRMDUP
               コマンド履歴の重複をチェックする個数を指定します。履歴にコマンドを追加する際、既に履歴にあるコマンドのうちここで指定した個数のコマンドが新しく追加されるコマンドと同じかどうかをチェックします。同じコマンドが既に履歴にあれば、それは履歴から削除されます。

               例えばこの変数の値が 1
               のときは、履歴に追加されるコマンドが一つ前のコマンドと同じならばそれは削除されます。それより古い履歴のコマンドは、(履歴に追加されるコマンドと同じでも)
               削除されません。もしこの変数の値が HISTSIZE
               変数の値と同じなら、履歴の中で重複するコマンドはすべて削除されます。あるいはもしこの変数の値が
               0 なら、重複する履歴は一切削除されません。

           HISTSIZE
               コマンド履歴に保存される履歴項目の個数を指定します。

           HOME
               ユーザのホームディレクトリのパスを指定します。チルダ展開や cd
               組込みコマンドの動作に影響します。

           IFS
               この変数は単語分割の区切りを指定します。シェルの起動時にこの変数の値は空白文字・タブ・改行の三文字に初期化されます。

           LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY,
           LC_NUMERIC, LC_TIME
               これらの変数はシェルが動作するロケールを指定します。シェルが読み書きするファイルのエンコーディングやエラーメッセージの内容などはこの変数で指定されたロケールに従います。

               LC_CTYPE
               変数の値はシェルの起動時にのみ反映されます。シェルの実行中にこの変数を変更してもシェルのロケールは変わりません
               (シェルが非 POSIX 準拠モードで対話モードの場合を除く)。

           LINENO
               この変数の値は、現在シェルが読み込んで実行しているファイルにおける、現在実行中のコマンドのある行番号を示します。(対話モードでは、コマンドを入力して実行するたびに行番号は
               1 に戻ります)

               一度この変数に代入したり変数を削除したりすると、この変数を用いて行番号を取得することはできなくなります。

           LINES
               この変数は端末ウィンドウの行数を指定します。この変数が設定されている場合、デフォルトの行数ではなくこの変数の値で指定された行数が行編集で使われます。

           MAIL
               この変数はメールチェックの対象となるファイルのパスを指定します。

           MAILCHECK
               この変数はメールチェックを行う間隔を秒単位で指定します。この変数の値はシェルの起動時に
               600 に初期化されます。

           MAILPATH
               この変数はメールチェックの対象となるファイルのパスを指定します。

           NLSPATH
               POSIX
               によるとこの変数の値はロケール依存のメッセージデータファイルのパスを指示することになっていますが、yash
               では使用していません。

           OLDPWD
               Cd
               組込みコマンドなどで作業ディレクトリを変更したときに、変更前の作業ディレクトリパスがこの変数に設定されます。この変数はデフォルトでエクスポート対象になります。

           OPTARG
               Getopts
               組込みコマンドで引数付きのオプションを読み込んだとき、その引数の値がこの変数に設定されます。

           OPTIND
               この変数の値は、getopts
               組込みコマンドで次に読み込むオプションのインデックスを表します。シェルの起動時にこの変数は
               1 に初期化されます。

           PATH
               この変数は、コマンドの検索時にコマンドのありかを示すパスを指定します。

           POST_PROMPT_COMMAND
               POSIX
               準拠モードでない対話モードのシェルにおいて、シェルがコマンドを一行読み込むたびに、この変数の値がコマンドとして解釈・実行されます。詳細はプロンプトを参照してください。

           PPID
               この変数の値は、シェルの親プロセスのプロセス ID
               を表す正の整数です。この変数はシェルの起動時に初期化されます。この変数の値はサブシェルにおいても変わりません。

           PROMPT_COMMAND
               POSIX
               準拠モードでない対話モードのシェルにおいて、シェルが各コマンドのプロンプトを出す直前に、この変数の値がコマンドとして解釈・実行されます。これは、プロンプトを出す直前に毎回
               eval -i -- "${PROMPT_COMMAND-}"
               というコマンドが実行されるのと同じですが、このコマンドの実行結果は次のコマンドでの
               ? 特殊パラメータの値には影響しません。

           PS1
               この変数の値は、対話モードのシェルが出力する標準のコマンドプロンプトを指定します。この値の書式についてはプロンプトの項を参照してください。

               この変数はシェルの起動時に実効ユーザ ID が 0 かどうかによって $
               と #  のどちらかに初期化されます。

           PS1P
               この変数の値は、対話モードのシェルがコマンドを読み込む際に、推定されたコマンドを表示するフォントの書式を指定します。この値の書式についてはプロンプトの項を参照してください。

           PS1R
               この変数の値は、対話モードのシェルがコマンドを読み込む際に、入力されるコマンドの右側に表示されるプロンプトを指定します。この値の書式についてはプロンプトの項を参照してください。

           PS1S
               この変数の値は、対話モードのシェルがコマンドを読み込む際に、入力されるコマンドを表示するフォントの書式を指定します。この値の書式についてはプロンプトの項を参照してください。

           PS2
               この変数の値は、対話モードのシェルが出力する補助的なコマンドプロンプトを指定します。この値の書式についてはプロンプトの項を参照してください。
               この変数はシェルの起動時に >  に初期化されます。

           PS2P
               この変数は PS1P 変数と同様ですが、プロンプトとして PS1
               変数ではなく PS2 変数の値が使用されるときに使用されます。

           PS2R
               この変数は PS1R 変数と同様ですが、プロンプトとして PS1
               変数ではなく PS2 変数の値が使用されるときに使用されます。

           PS2S
               この変数は PS1S 変数と同様ですが、プロンプトとして PS1
               変数ではなく PS2 変数の値が使用されるときに使用されます。

           PS4
               Xtrace
               オプションが有効なとき、この変数の値が各トレース出力の前に出力されます。ただし出力の前にこの変数の値に対してパラメータ展開、コマンド置換、数式展開を行います。また
               POSIX 準拠モードでなければ、PS1
               変数と同様に、バックスラッシュで始まる特殊な記法が利用できます。

               この変数はシェルの起動時に +  に初期化されます。

           PS4S
               この変数は PS1S 変数と同様ですが、プロンプトとして PS1
               変数が使用されるときではなく、トレース出力の際に PS4
               変数の値が使用されるときに使用されます。この変数を使うとトレース出力のフォントの書式を変更することができます。

           PWD
               この変数の値は現在の作業ディレクトリの絶対パスを表します。この変数はシェルの起動時に正しいパスに初期化され、cd
               組込みコマンドなどで作業ディレクトリを変更する度に再設定されます。この変数はデフォルトでエクスポート対象になります。

           RANDOM
               この変数は乱数を取得するために使用できます。この変数の値は 0
               以上 32768 未満の一様分布乱数になっています。

               この変数に非負整数を代入すると乱数を生成する種を再設定できます。

               一度この変数を削除すると、この変数を用いて乱数を取得することはできなくなります。またシェルが
               POSIX
               準拠モードで起動された場合、この変数で乱数を取得することはできません。

           TERM
               この変数は対話モードのシェルが動作している端末の種類を指定します。ここで指定された端末の種類に従って行編集機能は端末を制御します。この変数の効力を得るためには変数がエクスポートされている必要があります。

           XDG_CONFIG_HOME
               この変数はシェルの初期化ファイルの場所を指定するために使われます。
               値が定義されていない場合は $HOME/.config が使われます。

           YASH_AFTER_CD
               この変数の値は、cd 組込みコマンドや pushd
               組込みコマンドで作業ディレクトリが変更された後にコマンドとして解釈・実行されます。これは、作業ディレクトリが変わった後に毎回
               eval -i -- "${YASH_AFTER_CD-}"
               というコマンドが実行されるのと同じです。

           YASH_LOADPATH
               ドット組込みコマンドで読み込むスクリプトファイルのあるディレクトリを指定します。PATH
               変数と同様に、コロンで区切って複数のディレクトリを指定できます。この変数はシェルの起動時に、yash
               に付属している共通スクリプトのあるディレクトリ名に初期化されます。

           YASH_LE_TIMEOUT
               この変数は行編集機能で曖昧な文字シーケンスが入力されたときに、入力文字を確定させるためにシェルが待つ時間をミリ秒単位で指定します。行編集を行う際にこの変数が存在しなければ、デフォルトとして
               100 ミリ秒が指定されます。

           YASH_PS1, YASH_PS1P, YASH_PS1R, YASH_PS1S, YASH_PS2, YASH_PS2P,
           YASH_PS2R, YASH_PS2S, YASH_PS4, YASH_PS4S
               POSIX 準拠モードではないとき、これらの変数は名前に YASH_
               が付かない PS1 等の変数の代わりに優先して使われます。POSIX
               準拠モードではこれらの変数は無視されます。プロンプトで yash
               固有の記法を使用する場合はこれらの変数を使用すると POSIX
               準拠モードで yash
               固有の記法が解釈されずに表示が乱れるのを避けることができます。

           YASH_VERSION
               この変数はシェルの起動時にシェルのバージョン番号に初期化されます。

       配

           配列とは、一つの変数に複数の値 (文字列)
           を持たせたものです。一つの配列の複数の値は位置パラメータと同様に 1
           以上の自然数で識別されます。

           配列は、単純コマンドによって代入できます。また array
           組込みコマンドなどでも配列に代入することができます。配列を削除するには変数と同様に
           unset 組込みコマンドを使います。

           配列を配列のままエクスポートすることはできません。配列をエクスポートしようとすると、配列の各値をコロンで区切って繋いだ一つの文字列の値を持つ変数としてエクスポートされます。

           POSIX 準拠モードでは配列は使えません。

単
       コマンドを構成する各単語は、そのコマンドが実行されるときに展開されます。展開とは単語に含まれるパラメータやパターンを処理して具体的な文字列値に置き換えることです。展開には以下の七種類があります。

        1. チルダ展開

        2. パラメータ展開

        3. コマンド置換

        4. 数式展開

        5. ブレース展開

        6. 単語分割

        7. パス名展開

       特に最初の四つ (チルダ展開・パラメータ展開・コマンド置換・数式展開)
       を四種展開といいます。これらは単語内に現れた順に展開されます。
       単語のリストを一度に展開しようとしている場合は、四種展開の後でブレース展開・単語分割・パス名展開がこの順に行われます。

   チ
       チルダ展開は、~
       で始まる単語を特定のパス名に置き換える展開です。単語の先頭にある ~
       から最初の / まで (/ がない場合は単語全体)
       が指定されたパス名に変換されます。ただし、置き換えられる部分が一文字でもクォートされている場合は、チルダ展開は行われません。

       展開される内容は、置き換えられる部分の書式によって以下のように決まります。

       ~
           単なる ~ は、HOME 変数の値に置き換えられます。

       ~ユーザ名
           ~
           の後にユーザ名が書かれている場合は、そのユーザのホームディレクトリのパス名に置き換えられます。

       ~+
           ~+ は、PWD 変数の値に置き換えられます。

       ~-
           ~- は、OLDPWD 変数の値に置き換えられます。

       ~+n, ~-n
           この n は 0
           以上の整数でなければなりません。この形式のチルダ展開は、+n または
           -n
           で指定されるディレクトリスタック内のパスの一つに展開されます。(dirs
           組込みコマンド参照)

       変数代入の値に対してチルダ展開が行われる際、値がコロンで区切ってある場合は、コロンで区切ってある各部分をそれぞれ単語とみなしてチルダ展開します。例えば
       HOME 変数の値が /home/foo のとき、

           VAR=~/a:~/b:~/c

       は

           VAR=/home/foo/a:/home/foo/b:/home/foo/c

       と等価です。

       チルダ展開に失敗した場合
       (指定されたパス名が何らかの原因で得られなかった場合) の動作は POSIX
       では規定されていませんが、yash
       では何事もなかったかのように処理を続行します
       (置き換えられるはずだった部分はそのまま残され、エラーメッセージなどは出ません)。

       POSIX 準拠モードでは ~ と ~ユーザ名 の形式の展開のみが有効です。

   パ
       パラメータ展開は、単語の一部をパラメータの値に置き換える展開です。

       よく使われる単純なパラメータ展開の形式は ${パラメータ名}
       です。これはパラメータ名で指定されたパラメータの値に展開されます。さらに、以下の場合にはパラメータ名を囲む括弧を省略して
       $パラメータ名 のように書くこともできます。

       •   パラメータ名が特殊パラメータの場合

       •   パラメータ名が一桁の位置パラメータの場合

       •   パラメータ名が変数名で、直後に変数名の一部として誤解される恐れのある文字がない場合。例えば
           ${path}-name という単語は $path-name と書くこともできますが、
           ${path}name を $pathname と書くことはできません。

       パラメータ名として特殊パラメータでも位置パラメータでも変数名でもないものを指定した場合は、構文エラーになります。(Yash
       以外のシェルでは構文エラーではなく展開エラーになるものもあります)

       シェルの unset
       オプションが無効な場合、パラメータ名に存在しない変数を指定すると展開エラーになります。Unset
       オプションが有効な場合は、存在しない変数は空文字列に展開されます。

       より複雑なパラメータ展開の形式では、パラメータの値を加工することができます。パラメータ展開の一般形は以下の通りです。

       パラメータ展開
           ${ 前置詞 パラメータ名 インデックス 加工指定 }

       ここでは便宜上パラメータ名やインデックスの周りに空白を入れましたが、実際には空白を入れてはいけません。パラメータ名以外の部分はいずれも省略可能です。

       前

           前置詞としてパラメータ名の直前に記号 #
           を置くことができます。この場合、このパラメータ展開はいま展開しようとしている値の文字数を表す整数に展開されます。展開しようとしているのが配列変数の場合、各要素がそれぞれ文字数を表す整数に置き換えられます。

       パ

           パラメータ名には、特殊パラメータ・位置パラメータ・変数を指定することができます。この場合、パラメータ展開は指定されたパラメータの値に展開されます。指定したパラメータ名が配列変数の場合、配列の各要素が特殊パラメータ
           @ の場合と同様に単語分割されます (インデックス [*]
           が指定された場合を除く)。

           パラメータ名としてパラメータ展開・コマンド置換・数式展開を指定することもできます。これは特に展開の入れ子と言います。この場合、パラメータ展開は内側の展開の展開結果に展開されます。なお、内側のパラメータ展開の括弧
           { } は省略できません。また展開の入れ子は POSIX
           準拠モードでは使えません。

       イ

           インデックスは展開する値の一部を抜き出すのに使います。インデックスは以下の書式をしています。

           インデックス
               [単語1]

               [単語1,単語2]

           ここでの単語1および単語2は通常のトークンと同様に解釈されますが、,
           と ]
           で強制的に区切られます。また空白やタブはトークンの区切りとはみなしません。

           インデックスは、以下のように解釈されます。

            1. まず、インデックスに含まれる単語1・単語2に対してパラメータ展開・コマンド置換・数式展開を行います。

            2. インデックスが [単語1] の書式をしていて、単語1の上記展開結果が
               *、@、# のいずれかの場合は、インデックスの解釈は終了です。

            3. 単語1と単語2の上記展開結果を数式とみなして、数式展開と同様に計算します。計算の結果得られる整数がインデックスとなります。数式展開の結果が整数でない場合は展開エラーです。単語2がない形式でインデックスを指定している場合は、単語2は単語1と同じ整数を指定しているものとみなされます。

           パラメータ名が配列変数の場合または特殊パラメータ * または @
           の場合、インデックスは配列の要素または位置パラメータの一部を指定しているものとみなされます。パラメータ名が上記以外の場合は、パラメータの値の一部を指定しているものとみなされます。インデックスで選択された配列の要素またはパラメータの値の一部のみが、パラメータ展開の結果として展開結果に残ります。インデックスによる選択について以下の規則が適用されます。

           •   インデックスの整数が負数のときは、要素または文字を最後から数えるものとみなされます。例えばインデックス
               [-2,-1] は配列の最後の二つの要素 (またはパラメータの値の最後の
               2 文字) を選択します。

           •   インデックスの整数が存在しない要素または文字を指示している場合でも、エラーにはなりません。例えば配列の要素数が
               4 のときにインデックス [3,5] が与えられたときは 3
               番目以降の全ての要素が選択され、インデックス [5,7]
               が与えられた時はどの要素も選択されません。

           •   インデックスの整数の一方が 0 ならば、(もう一方が何であれ)
               展開結果には何も残りません。

           インデックスが [単語1] の書式をしていて、単語1の展開結果が *、@、#
           のいずれかだった場合は、パラメータは以下のように処理されます。

           *
               パラメータ名が配列変数の場合、特殊パラメータ *
               と同様に配列の全要素を単語分割または連結します。パラメータ名が特殊パラメータ
               * または @
               の場合、同様に位置パラメータを単語分割・連結します。それ以外の場合はインデックス
               [1,-1] と同様です。

           @
               インデックス [1,-1] と同様です。

           #
               パラメータ名が配列変数の場合、このパラメータ展開は配列の要素数を表す整数に展開されます。パラメータ名が特殊パラメータ
               * または @
               の場合、このパラメータ展開は位置パラメータの個数を表す整数に展開されます。それ以外の場合、このパラメータ展開はいま展開しようとしている値の文字数を表す整数に展開されます。

           パラメータ展開にインデックスが指定されていない場合は、インデックスとして
           [@] が指定されたものとみなされます。インデックスはPOSIX
           準拠モードでは一切使えません。

           例

           以下のコマンドは文字列 ABC を出力します:

               var='123ABC789'
               echo "${var[4,6]}"

           例

           以下のコマンドは文字列 2 3 4 を出力します:

               set 1 2 3 4 5
               echo "${*[2,-2]}"

           例

           以下のコマンドは文字列 2 3 4 を出力します:

               array=(1 2 3 4 5)
               echo "${array[2,-2]}"

       加

           加工指定はパラメータの値を加工します。加工された後の値がパラメータ展開の結果として展開されます。加工指定には以下の形式があります。

           -単語
               パラメータ名が存在しない変数を指示している場合は、このパラメータ展開は単語に展開されます。(Unset
               オプションが無効な時でもエラーになりません)

           +単語
               パラメータ名が存在する変数を指示している場合は、このパラメータ展開は単語に展開されます。(Unset
               オプションが無効な時でもエラーになりません)

           =単語
               パラメータ名が存在しない変数を指示している場合は、単語の展開結果がその変数に代入された後、このパラメータ展開はその値に展開されます。変数以外のものに対して代入しようとすると展開エラーになります。(Unset
               オプションが無効な時でもエラーになりません)

           ?単語
               パラメータ名が存在しない変数を指示している場合は、エラーメッセージとして単語を標準エラーに出力します。(単語がない場合はデフォルトのエラーメッセージが出ます)

           :-単語, :+単語, :=単語, :?単語
               これらは上記の -、+、=、?
               と単語の組み合わせの加工指定と同様ですが、単語を使用する条件が異なります。先頭に
               : が付かないものでは 『変数が存在するかどうか』
               で判定されますが、: が付くものでは
               『変数が存在し、その値が空文字列でないかどうか』
               で判定されます。

           #単語
               単語をパターンとして見たとき、それがいま展開しようとしている値の先頭部分にマッチするならば、そのマッチする部分を削除します。結果として、このパラメータ展開はマッチしなかった残りの部分に展開されます。マッチの仕方が複数通りある場合はできるだけ短くマッチさせます。

           ##単語
               この加工指定は #単語
               と同様ですが、マッチの仕方が複数通りある場合はできるだけ長くマッチさせる点が異なります。

           %単語
               この加工指定は #単語
               と同様ですが、値の先頭部分ではなく末尾部分にマッチさせる点が異なります。

           %%単語
               この加工指定は %単語
               と同様ですが、マッチの仕方が複数通りある場合はできるだけ長くマッチさせる点が異なります。

           /単語1/単語2
               単語1をパターンとして見たとき、それがいま展開しようとしている値の一部にマッチするならば、そのマッチする部分を単語2に置き換えます。結果として、このパラメータ展開はマッチした部分を単語2に置き換えた値に展開されます。マッチする箇所が複数ある場合は、最初の箇所が選ばれます。マッチの仕方が複数通りある場合はできるだけ長くマッチさせます。

               この加工指定は POSIX 準拠モードでは使えません。

           /#単語1/単語2
               この加工指定は /単語1/単語2
               と同様ですが、いま展開しようとしている値の先頭部分にしかマッチしない点が異なります。

           /%単語1/単語2
               この加工指定は /単語1/単語2
               と同様ですが、いま展開しようとしている値の末尾部分にしかマッチしない点が異なります。

           //単語1/単語2
               この加工指定は /単語1/単語2
               と同様ですが、マッチする箇所が複数ある場合は最初の箇所だけではなく全ての箇所を単語2に置き換える点が異なります。

           :/単語1/単語2
               この加工指定は /単語1/単語2
               と同様ですが、いま展開しようとしている値全体にマッチする場合しか対象としない点が異なります。

           いずれの形式においても、加工指定に含まれる単語は
           (それが使用されるときのみ) 四種展開されます。

           展開しようとしているパラメータ名が配列変数または特殊パラメータ @
           または *
           の場合、加工指定は配列の各要素または各位置パラメータに対してそれぞれ作用します。

   コ
       コマンド置換は、指定されたコマンドを実行してその出力をコマンドラインに展開します。コマンド置換の書式は以下の通りです。

       コマンド置換
           $(コマンド)

           `コマンド`

       コマンド置換では、コマンドがサブシェルで実行されます。このときコマンドの標準出力がパイプを通じてシェルに送られます。結果として、コマンド置換はコマンドの出力結果に置き換えられます。ただし、コマンドの出力の末尾にある改行は除きます。

       $( と )
       で囲んだコマンド置換のコマンドは、コマンド置換の入れ子やリダイレクトなどを考慮して予め解析されます。従って、$(
       と )
       の間には基本的に通常通りコマンドを書くことができます。ただし、数式展開との混同を避けるため、中のコマンドが
       ( で始まる場合はコマンドの最初に空白を挿し挟んでください。

       `
       で囲むコマンド置換では、コマンド置換の入れ子などは考慮せずに、コマンドの中に最初に
       (バックスラッシュでクォートしていない) `
       が現れたところでコマンド置換の終わりとみなされます。`
       で囲んだコマンド置換の中に ` で囲んだコマンド置換を書く場合は、内側の `
       をバックスラッシュでクォートする必要があります。その他、コマンドの一部として
       `
       を入れたいときは、(それがコマンド内部で一重または二重引用符でクォートされていても)
       バックスラッシュでクォートする必要があります。コマンドの中ではバックスラッシュは
       $・`・バックスラッシュ・改行の直前にある場合のみ引用符として扱われます。また、`
       で囲んだコマンド置換が二重引用符の中で使われる場合は、コマンドの中に現れる二重引用符もバックスラッシュでクォートする必要があります。これらのバックスラッシュはコマンドが解析される前に削除されます。

       $( と )
       で囲んだコマンド置換の中のコマンドは、そのコマンド置換を含むコマンドを解析する時に一緒に解析されます
       (POSIX 準拠モードを除く)。` で囲んだコマンド置換の中のコマンドは、POSIX
       準拠モードであるかどうかに関わらず、そのコマンド置換が実行される時に毎回解析されます。

   数
       数式展開は、文字列を数式として解釈して、その計算結果を表す数値に展開します。数式展開の書式は以下の通りです。

       数式展開
           $((式))

       数式展開では、まず式に対してパラメータ展開・コマンド置換・(入れ子の)
       数式展開が行われます。その結果得られた文字列を以下のように数式として解釈し、その計算結果を表す数値に展開されます。

       Yash では、数式の中で整数 (C 言語の long 型) と浮動小数点数 (C 言語の
       double 型) を扱うことができます。ただし POSIX
       準拠モードでは浮動小数点数は使えません。整数同士の演算の結果は整数に、浮動小数点数を含む演算の結果は浮動小数点数になります。

       数式では C 言語と (ほぼ) 同様に以下の演算子が使えます。

        1. ( )

        2. ++ -- (後置演算子)

        3. ++ -- + - ~ ! (前置演算子)

        4. * / %

        5. + - (二項演算子)

        6. << >>

        7. < <= > >=

        8. == !=

        9. &

       10. ^

       11. |

       12. &&

       13. ||

       14. ? : (三項演算子)

       15. = *= /= %= += -= <<= >>= &= ^= |=

       ++ および -- 演算子は POSIX 準拠モードでは使えません。

       原子式としては整数リテラル・浮動小数点数リテラル・変数が使用できます。数リテラルの書式は
       C 言語に準じます。0 で始まる整数リテラルは八進数、0x
       で始まる整数リテラルは十六進数とみなされます。浮動小数点数リテラルでは指数表記も使えます
       (例えば 1.23×106 は
       1.23e+6)。変数の値が計算で使われるとき、その値が数値でない場合はエラーになります。Unset
       オプションが有効ならば未定義の変数は 0 とみなします。

       POSIX 準拠モードでは、変数は必ず数値として解釈されます。 POSIX
       準拠モードでないときは、計算で使われる変数のみが数値として解釈され、他の変数はそのまま残ります。

           set +o posixly-correct
           foo=bar
           echo $((0 ? foo : foo)) # 「bar」を出力
           echo $((foo + 0))       # エラー

       C 言語で結果が定義されていない数式は展開エラーになります。

   ブ
       ブレース展開は、ブレース ({ })
       で囲んだ部分をいくつかの単語に分割します。ブレース展開は brace-expand
       オプションが有効な時のみ行われます。ブレース展開には二種類の形式があります。

       カンマ区切りのブレース展開
           {単語1,単語2,...,単語n}

       連続した数値のブレース展開
           {始点..終点}

           {始点..終点..差分}

       一つ目の形式は、ブレースで囲んだ部分を一つ以上のカンマ (,)
       で区切ったものです。区切られたそれぞれの部分がブレース展開の前後の部分と結合されて、それぞれ単語として展開されます。例えば
       a{1,2,3}b は a1b、a2b、a3b という三つの単語に展開されます。

       二つ目の形式は {始点..終点} または {始点..終点..差分}
       です。始点・終点・差分は全て整数である必要があります。この形式のブレース展開では、始点から終点までの各整数がブレース展開の前後の部分と結合されて、それぞれ単語として展開されます。差分は整数の間隔を指定します。例えば
       a{1..3}b は a1b、a2b、a3b という三つの単語に展開され、a{1..7..2}b は
       a1b、a3b、a5b、a7b
       という四つの単語に展開されます。始点が終点より大きい場合は整数は降順に展開されます。

       複数のブレース展開を組み合わせたり、入れ子にしたりすることもできます。ブレースをブレース展開としてでなく通常の文字として扱うには、ブレースをクォートしてください。またカンマを区切りとしてでなく通常の文字として扱うには、カンマをクォートしてください。

       ブレース展開では展開エラーは発生しません。ブレース展開が正しくできない場合は、単にそれはブレース展開ではなかったものとして、そのまま残されます。

           注

           Yash
           ではブレース展開は四種展開の後、単語分割の前に行われます。これは
           POSIX の規定とは異なります。POSIX
           ではブレース展開は他の展開の前に行うこととされています。

   単
       単語分割は、展開の結果をいくつかの単語に分割します。

       単語分割で分割の対象となるのは、パラメータ展開・コマンド置換・数式展開で展開された結果の部分だけです。また、二重引用符によるクォートの中で展開された部分は、(特殊パラメータ
       @ の展開を除いて) 分割の対象となりません。

       単語分割は IFS 変数の値に従って行われます。IFS
       変数が存在しない場合は、空白文字・タブ・改行の三文字が IFS
       変数の値として使われます。

       IFS 変数の値に含まれている文字を IFS 文字といいます。IFS
       文字のうち空白文字またはタブまたは改行であるものを IFS
       空白類といいます。IFS 空白類以外の IFS 文字を IFS 非空白類といいます。

       分割は以下の規則に従って行われます。

        1. 分割は、分割の対象となる展開結果の部分の中で、IFS
           文字が現れる箇所で行われます。以下このような箇所を分割点と呼びます。複数の
           IFS
           文字が連続して現れる場合は、それらをまとめて一つの分割点とします。

        2. 分割点に IFS 非空白類が含まれている場合、その分割点に含まれる IFS
           空白類はすべて無視されます。そして分割点に含まれる各 IFS
           非空白類の前後で単語が分割されます。

        3. 分割点に IFS 非空白類が含まれていない (分割点が IFS
           空白類だけからなる)
           場合、その分割点の前後で単語が分割されます。ただし、このような分割点が元の単語の先頭または末尾にある場合を除きます。

        4. いずれの場合も、分割点は単語分割後の単語には残りません。

       最後に、以下の条件がすべて成り立つならば、分割された最後の単語が結果から削除されます。

       •   empty-last-field オプションが無効

       •   分割結果が複数の単語である

       •   最後の単語が空文字列である

           注

           IFS 変数の値が空文字列の場合は、単語は一切分割されません。

   パ
       パス名展開は、単語をパターンとみなしてファイルを検索し、パターンにマッチする実在のファイルへのパス名に展開します。
       パス名展開は glob オプションが無効な時は行われません。

       パス名展開においてパターンがマッチするには、検索の対象となるディレクトリの読み込み権限が必要です。検索しようとしたディレクトリがシェルにとって読み込み可能でなければ、シェルはそのディレクトリは空であるとみなします。

       以下のオプションがパス名展開の結果に影響します。

       null-glob
           マッチするファイルがない時、通常 (このオプションが無効な時)
           はパターンはそのまま残りますが、このオプションが有効な時はパターンは削除され何も残りません。

       case-glob
           通常 (このオプションが有効な時)
           は、大文字と小文字を区別してマッチングを行いますが、このオプションが無効な時は大文字と小文字を区別せずマッチングを行います。

       dot-glob
           通常 (このオプションが無効な時) は、* や ?
           などのワイルドカードやブラケット記法で始まるパターンはピリオドで始まるファイル名にマッチしません。しかしこのオプションが有効な時はこのような制約は解除されます。

       mark-dirs
           このオプションを有効にすると、マッチしたファイルの種類がディレクトリの場合に展開されるパス名の最後に
           / が付きます。

       extended-glob
           このオプションを有効にすると、パス名展開における拡張機能 (後述)
           が使えるようになります。

       パス名展開ではエラーは発生しません。マッチするファイルがない場合またはパターンが不正な場合は、展開は行われずパターンはそのまま残ります
       (null-glob オプションが有効な時を除く)。

       ファイルの検索とパターンマッチングは /
       で区切られたパス名の構成要素ごとに行われます。ワイルドカードやブラケット記法を全く含まない構成要素はパターンとはみなされず、検索とマッチングは行われません。従って、case-glob
       オプションが無効な時、/*/foo と /*/fo[o]
       の展開結果が異なる可能性があります (前者では foo
       の部分がパターンとはみなされないので、例えば /bar/FOO
       というファイルがあってもマッチしません。)。

       パ

           Extended-glob
           オプションが有効な時は、以下の特殊なパターンが使えるようになります。

           **
               指定されたディレクトリツリーに対し再帰的に検索を行います。すなわち、指定されたディレクトリと、そのサブディレクトリ、さらにそのサブディレクトリなどに対し検索を行います。ただし名前がピリオドで始まるディレクトリは検索の対象になりません。例えば
               dir/**/file というパターンは、dir/file や dir/foo/file や
               dir/a/b/c/file など、dir ディレクトリの中にある全ての file
               ファイルへのパスに展開されます。

               この特殊なパターンは、 foo/bar/**
               のようにパターン全体の最後にある場合には効果がありません。

           .**
               **
               パターンと同様ですが、名前がピリオドで始まるディレクトリも含めて検索する点が異なります。

           ***
               **
               パターンと同様ですが、検索の中でディレクトリへのシンボリックリンクが見つかった場合、そのディレクトリの中も検索の対象に含める点が異なります。

           .***
               ***
               パターンと同様ですが、名前がピリオドで始まるディレクトリも含めて検索する点が異なります。

パ
       パターンマッチング記法は特定の文字列の集合を表すパターンの書式と意味の定義です。ある文字列があるパターンの表す文字列の集合に含まれる時、その文字列はそのパターンにマッチするといいます。文字列がパターンに当てはまるかどうかは、以下に示す定義に従って判定されます。

   通
       クォートしてある文字および以下に示す特殊な意味を持つ文字以外のすべての文字は、通常の文字として扱われます。パターンに含まれる通常の文字は、その文字自身に当てはまります。

       例えば abc というパターンは abc
       という文字列に当てはまります。(そしてこれ以外の文字列には一切当てはまりません)

   一
       文字 ? は任意の一文字に当てはまります。

       例えば a?c というパターンは aac、abc、a;c など、a で始まり c
       で終わる任意の 3 文字の文字列に当てはまります。

   複
       文字 *
       は任意の文字列に当てはまります。ここでいう任意の文字列には空文字列も含まれます。
       例えば a*c というパターンは ac、abc、a;xyz;c など、a で始まり c
       で終わる任意の文字列に当てはまります。

   ブ
       括弧 [ と ]
       で囲まれた部分はブラケット記法とみなされます。ただし、括弧の間には少なくとも一文字挟まれている必要があります。括弧の間にある文字は以下に示すブラケット記法のための特殊なパターン
       (ブラケット記法パターン)
       として解釈されます。ブラケット記法は、括弧の間にあるブラケット記法パターンが示す文字のどれか一つに当てはまります。

       最初の括弧 [ の直後に記号 !
       がある場合、ブラケット記法に当てはまる文字と当てはまらない文字とが逆転します
       (そしてこの ! はブラケット記法パターンの一部とはみなされません)。Yash
       では [ の直後に ^
       がある場合も同様に当てはまる文字と当てはまらない文字とが逆転します
       (が、他のシェルでは ^ の扱いが異なることもあります)。

       最初の括弧 [ の直後 (あるいは上述の ! または ^ がある場合はその直後)
       に括弧 ]
       がある場合は、それはブラケット記法の終わりを示す括弧としてではなくブラケット記法パターンの一部とみなされます。ブラケット記法パターンの解釈はクォートの処理の後に行われるので、クォートによってブラケット記法パターン内の文字を通常の文字として扱わせることはできません。

       パターンの中に [
       が含まれていても、それが正しいブラケット記法の形式になっていない場合は、その
       [ はブラケット記法ではなく通常の文字として扱われます。

   (ブ
       以下に示す特殊な意味を持つ記号以外の文字はすべて通常の文字として扱われます。通常の文字はその文字自身を表します。

       例えば [abc] というブラケット記法は a、b、c
       のどれかの文字に当てはまります。従って a[abc]c というパターンは
       aac、abc、acc という三つの文字列に当てはまります
       (そしてこれ以外の文字列には当てはまりません)。

   範
       二つの文字 (または照合シンボル) をハイフン (-)
       でつないだものは範囲指定とみなされます。範囲指定は、その二つの文字と照合順序上その間にある全ての文字を表します。照合順序とは文字を辞書順に並べるためにロケールデータに定義される文字の順序関係です。使用中のロケールに定義されている照合順序に従って二つの文字の間にある文字が決まります。

       ハイフンの後に ] を置いた場合は、この ]
       はブラケット記法の終わりを示す括弧とみなされ、ハイフンは通常の文字として扱われます。

       例えば [1-5] というブラケット記法は 1、2、3、4、5
       という五つの文字のどれか一つに当てはまります。

   照
       照合シンボルを用いることで複数の文字からなる照合要素を一つの文字として扱うことができます。(照合要素とは複数の文字をまとめて一つの文字として扱うことができるようにするために考えられた、より一般的な文字の概念です。パターンマッチングにおいて全ての文字は実際には照合要素として扱われています。)
       照合シンボルは括弧 [. .]
       の中に照合要素を挟んだものとして表します。括弧内に書ける照合要素は使用中のロケールデータにおいて照合要素として登録されているものに限ります。

       例えば従来スペイン語では 『ch』
       という二文字を合わせて一文字として扱っていました。この二文字の組み合わせが照合要素としてロケールに登録されているならば、[[.ch.]df]
       というブラケット記法は ch、d、f のどれかに当てはまります。もしここで
       [chdf] というブラケット記法を使うと、これは c、h、d、f
       のどれかに当てはまり、ch には当てはまりません。

   等
       等価クラスを用いることで、ある文字と等価であるとみなされる文字を指定することができます。等価クラスは括弧
       [= =]
       の中に文字を挟んだものとして表します。括弧の間には照合シンボルのように複数の文字からなる照合要素を書くこともできます
       (上記参照)。等価クラスは、括弧で挟んだ文字そのものの他に、その文字と同じ第一等価クラスに属する全ての文字を表します。どの文字が第一等価クラスに属するかの定義は使用中のロケールデータに従います。

       例えばロケールデータにおいて a, à, á, â, ã, ä の 6
       文字が同じ第一等価クラスに属すると定義されているとき、[[=a=]]
       というブラケット記法はこれら六つの文字のどれか一つに当てはまります。[[=à=]]
       や [[=á=]] も同様です。

   文
       文字クラスは特定の種類の文字の集合を表します。文字クラスは括弧 [: :]
       の間に文字クラスの名前を囲んだものとして表します。文字クラスの名前としては、以下に挙げる共通の文字クラスの他に、使用中のロケールで定義された独自の文字クラスが使用できます。いずれの文字クラスの場合も、文字クラスにどの文字が含まれるのかは使用中のロケールにおける文字クラスの定義に従います。

       [:lower:]
           小文字の集合

       [:upper:]
           大文字の集合

       [:alpha:]
           アルファベットの集合 ([:lower:] と [:upper:] を含む)

       [:digit:]
           十進法の数字の集合

       [:xdigit:]
           十六進法の数字の集合

       [:alnum:]
           アルファベットと数字の集合 ([:alpha:] と [:digit:] を含む)

       [:blank:]
           空白文字の集合 (改行を含まない)

       [:space:]
           空白文字の集合 (改行等を含む)

       [:punct:]
           句読点等の集合

       [:print:]
           表示可能な文字の集合

       [:cntrl:]
           制御文字の集合

       例えば [[:lower:][:upper:]]
       というブラケット記法は一文字の小文字または大文字に当てはまります。

リ
       リダイレクトはコマンドのファイル記述子を変更する機能です。リダイレクトを使用すると、コマンドの標準入力や標準出力を通常とは異なるファイルに繋ぎ換えた状態でコマンドを実行することができます。

       リダイレクトはコマンド (単純コマンドまたは複合コマンド)
       にリダイレクト演算子を付することで行います。単純コマンドでは
       (他のトークンとくっつかない限り)
       どこでもリダイレクト演算子を置くことができます。複合コマンドではコマンドの最後にリダイレクト演算子を付けます。

       リダイレクトはコマンドの実行が始まる前に処理されます。一つのコマンドに複数のリダイレクトがある場合は、リダイレクト演算子が書いてある順序で処理されます。オペランドなしの
       exec
       組込みコマンドを実行する場合を除き、リダイレクトは対象となっているコマンドに対してのみ働きます。すなわち、対象のコマンドの実行が終わるとリダイレクトによって変更されたファイル記述子は元の状態に戻ります。

       リダイレクト演算子は、< または > で始まります。<
       で始まるリダイレクト演算子はデフォルトでは標準入力 (ファイル記述子 0)
       に作用します。> で始まるリダイレクト演算子はデフォルトでは標準出力
       (ファイル記述子 1)
       に作用します。どちらの種類の演算子でも、演算子の直前に非負整数を指定することでデフォルト以外のファイル記述子に作用させることができます
       (このとき整数と演算子との間に一切空白などを入れてはいけません。また整数をクォートしてもいけません)。

       リダイレクト演算子の直前に置かれた {名前}
       の形式のトークンは、将来の拡張のために予約されています。現在のところ、このようなトークンは構文エラーになります。

   フ
       最もよく使われるリダイレクトは、ファイルへのリダイレクトです。

       入力のリダイレクト
           < トークン

       出力のリダイレクト
           > トークン

           >| トークン

           >> トークン

       入出力のリダイレクト
           <> トークン

       リダイレクトに含まれるトークンは四種展開されます。対話シェルではさらにパス名展開も行われます
       (パス名展開の結果が一つのファイルでなければエラーです)。トークンの展開結果がリダイレクト対象のファイル名として使われます。

       入力のリダイレクトでは標準入力が対象ファイルからの読み込み専用ファイル記述子に置き換えられます。対象ファイルを開くことができなければエラーになります。

       出力のリダイレクトでは標準出力が対象ファイルへの書き込み専用ファイル記述子に置き換えられます。対象ファイルが存在しなければ空の通常ファイルが作成されます。対象ファイルが既にある場合はそのファイルが開かれます。ただし演算子の種類によって以下のように挙動が異なります。

       •   演算子 >|
           では、対象ファイルが存在しそれが通常のファイルの場合、ファイルを開く際にファイルの内容を空にします。

       •   演算子 > は、clobber オプションが有効ならば演算子 >|
           と同じです。しかし clobber
           オプションが無効ならば、対象ファイルが存在しそれが通常のファイルの場合、エラーになります。

       •   演算子 >>
           では、ファイルを追記モードで開きます。ファイルへの書き込みは常にファイルの末尾へ追記する形で行われます。

       入出力のリダイレクトでは標準入力が対象ファイルへの読み書き両用ファイル記述子に置き換えられます。対象ファイルが存在しなければ空の通常ファイルが作成されます。

       ソ

           ファイルのリダイレクトにおいて、対象ファイル名が
           /dev/tcp/ホスト名/ポート または /dev/udp/ホスト名/ポート
           の形式をしていて、そのファイルを開くことができない場合、ファイル名に含まれるホスト名とポートに対して通信を行うためのソケットが開かれます。

           /dev/tcp/ホスト名/ポート
           が対象の場合はストリーム通信ソケットを、/dev/udp/ホスト名/ポート
           が対象の場合はデータグラム通信ソケットを開きます。典型的には、前者は
           TCP を、後者は UDP をプロトコルとして使用します。

           ソケットリダイレクトはどのリダイレクト演算子を使っているかにかかわらず常に読み書き両用のファイル記述子を開きます。

           ソケットリダイレクトは POSIX 規格にはない yash
           の独自拡張です。ただし、bash にも同様の機能があります。

   フ
       ファイル記述子の複製のリダイレクトでは、既存のファイル記述子をコピーしたり閉じたりできます。

       ファイル記述子の複製
           <& トークン

           >& トークン

       トークンはファイルのリダイレクトの場合と同様に展開されますが、これはファイル名ではなくファイル記述子として解釈されます。すなわち、トークンの展開結果はファイル記述子を表す非負整数となる必要があります。

       演算子 <&
       はトークンの展開結果で示されたファイル記述子を標準入力に複製します。演算子
       >&
       はトークンの展開結果で示されたファイル記述子を標準出力に複製します。演算子の直前に非負整数を指定することで、複製先のファイル記述子を変更できます。

       トークンの展開結果が非負整数ではなくハイフン (-)
       となった場合は、ファイル記述子を複製する代わりに閉じます。演算子 <&
       では標準入力が、演算子 >&
       では標準出力がデフォルトで閉じられますが、演算子の直前に非負整数を指定することで、閉じるファイル記述子を変更できます。

       POSIX 準拠モードでは、<&
       で複製するファイル記述子は読み込み可能でなければならず、>&
       で複製するファイル記述子は書き込み可能でなければなりません。

   ヒ
       ヒアドキュメント・ヒアストリングを使うとコマンドに直接テキストを渡すことができます。

       ヒアドキュメント
           << トークン

           <<- トークン

       ヒアストリング
           <<< トークン

       ヒアドキュメント・ヒアストリングでは、標準入力がヒアドキュメント・ヒアストリングの内容を読み込み可能なファイル記述子に置き換えられます。

       ヒアドキュメント演算子 (<< または <<-)
       がコマンド中に現れると、その演算子のある行の次の行からはヒアドキュメントの内容とみなされます。ヒアドキュメントの内容の部分は、シェルのコマンドとしては解釈されません。演算子の後にあるトークンはヒアドキュメントの内容の終わりを表します。(トークンでは展開は行われませんが、クォートは認識されます。)
       演算子のある行より後の行でトークンだけからなる行が現れた時点でヒアドキュメントの内容は終わりだと判断されます。終わりを表す行はヒアドキュメントの内容には含まれません。演算子
       <<-
       を使っている場合は、ヒアドキュメントの内容の各行頭にあるタブはすべて削除されます。このときトークンの前にタブがあっても
       (その行に他の余計な文字がなければ)
       ヒアドキュメントの内容の終わりとして認識します。

       一行のコマンドに複数のリダイレクト演算子がある場合は、リダイレクトの内容は順番に処理されます。すなわち、その行の次の行からは最初のリダイレクトの内容として扱われ、その内容が終わったら、その次の行からは次のリダイレクトの内容として扱われます。最後のリダイレクトの内容が終わったら、その次の行からは再びコマンドとして解釈されます。

       リダイレクトの内容は基本的に単なる文字列として扱われます。内容に含まれる空白やタブ、その他の記号はそのままコマンドに渡されます。ただし、トークンが全くクォートされていない場合は、ヒアドキュメントの内容はパラメータ展開・コマンド置換・数式展開され、$,
       `, ", \
       の直前にある場合および行の連結を行う場合にのみバックスラッシュを引用符として扱えます。

       ヒアストリングでは、演算子の後にあるトークンはファイルのリダイレクトの場合と同様に展開されます。この展開結果がヒアストリングの内容となります。ただしヒアストリングの内容の末尾には自動的に改行が付きます。

       ヒアストリングは POSIX 規格にはない yash の独自拡張ですが、bash, ksh,
       zsh にも同様の機能があります。

   パ
       パイプリダイレクトを用いるとプロセス間通信に利用可能なパイプを開くことができます。

       パイプリダイレクト
           >>| トークン

       トークンはファイルのリダイレクトの場合と同様に展開されますが、これはファイル名ではなくファイル記述子として解釈されます。すなわち、トークンの展開結果はファイル記述子を表す非負整数となる必要があります。

       パイプリダイレクトはパイプを開きます。標準出力 (演算子 >>|
       の直前に非負整数を指定している場合はその値のファイル記述子)
       がパイプに書きこむためのファイル記述子になります。またトークンの展開結果で示されたファイル記述子がパイプから読み込むためのファイル記述子になります。

       パイプリダイレクトは POSIX 規格にはない yash の独自拡張です。

   プ
       プロセスリダイレクトを用いると別のコマンドの入力または出力を受け渡せるパイプを開くことができます。

       プロセスリダイレクト
           <(サブコマンド...)

           >(サブコマンド...)

       プロセスリダイレクトでは、サブコマンドがサブシェルで実行されます。このとき、<(サブコマンド...)
       の形式のプロセスリダイレクトでは、サブコマンドの標準出力がこのコマンドの標準入力に渡るようパイプが開かれます。>(サブコマンド...)
       の形式のプロセスリダイレクトでは、このコマンドの標準出力がサブコマンドの標準入力に渡るようパイプが開かれます。

       プロセスリダイレクトは POSIX 規格にはない yash の独自拡張です。Bash と
       zsh
       にはプロセスリダイレクトと同様の構文を用いるプロセス置換という機能がありますが、プロセスリダイレクトとプロセス置換の挙動は異なっており、互換性はありません。

コ
       この節ではコマンドがどのように実行されるかを説明します。

   単
       単純コマンドは以下の手順に従って実行されます。

        1. 単純コマンドに含まれる、変数代入とリダイレクト以外のトークンを全て展開します。展開エラーが発生した場合は、この単純コマンドの実行は中止されます
           (このとき単純コマンドの終了ステータスは非 0 です)。

           通常、トークンには全ての種類の展開が行われます。しかし、コマンドが宣言ユーティリティの場合は代入形式のトークンは四種展開のみが行われます。

           以下、展開の結果得られた最初の単語をコマンド名、それ以外の単語をコマンド引数と呼びます。得られた単語が一つの場合は、コマンド引数は存在しません。得られた単語が一つもない場合は、コマンド名もコマンド引数も存在しません。

        2. コマンド名が存在する場合、単純コマンドに対するリダイレクトを実行します。リダイレクトに含まれるトークンの展開はここで行われます。リダイレクトエラーが発生した場合は、この単純コマンドの実行は中止されます
           (このとき単純コマンドの終了ステータスは非 0
           です)。リダイレクトに含まれるトークンの展開時のエラーはリダイレクトエラーに含まれます。

               注
               Yash
               以外のシェルではリダイレクトの実行タイミングが異なることがあります。POSIX
               では、コマンド名が存在しない場合または特殊組込みである場合にリダイレクトと代入のどちらを先に行うか規定されていません。

        3. 単純コマンドに含まれる変数代入を実行します
           (配列の代入を含む)。それぞれの変数代入について、値が展開され、指定された名前の変数に代入されます。代入エラーが発生した場合は、この単純コマンドの実行は中止されます
           (このとき単純コマンドの終了ステータスは非 0
           です)。代入される値の展開時のエラーは代入エラーに含まれます。

           •   コマンド名が存在しないか、あるいはコマンド名が特殊組込みを示している場合は、変数代入は恒久的です。すなわち、代入の結果はこの単純コマンドの実行が終わった後もそのまま残ります。

           •   それ以外の場合は、変数代入は一時的です。すなわち、代入の効果はこの単純コマンドの実行中のみ有効で、実行が終わった後に代入は取り消されます。

           コマンド名が指定された場合または all-export
           オプションが有効な場合は、代入される変数は自動的にエクスポート対象になります。

               注
               Yash
               以外のシェルでは代入の動作が異なることがあります。特殊組込みまたは関数では変数はエクスポート対象にならないかもしれません。また関数の実行終了後も変数が残るかもしれません。

        4. コマンド名が存在しない場合は、サブシェルでリダイレクトを実行し、そこで単純コマンドの実行を終了します。リダイレクトエラーが発生した場合、単純コマンドの終了ステータスは非
           0
           になります。代入の途中でコマンド置換が行われた時は、最後のコマンド置換のコマンドの終了ステータスが単純コマンドの終了ステータスになります。それ以外の場合、終了ステータスは
           0 になります。

        5. 後述のコマンドの検索の仕方に従って実行すべきコマンドを特定し、そのコマンドを実行します。

           •   コマンドが外部コマンドの場合は、コマンドはサブシェルで exec
               システムコールを呼び出すことにより実行されます。コマンド名とコマンド引数が起動するコマンドに渡されます。またエクスポート対象となっている変数が環境変数としてコマンドに渡されます。

           •   コマンドが組込みコマンドの場合は、コマンド引数を引数として組込みコマンドが実行されます。例外的に、任意組込みコマンドの場合は、POSIX
               準拠モードにおいてはコマンドは実行されません。

           •   コマンドが関数の場合は、その関数の内容が実行されます。コマンド引数が関数の引数として渡されます。

           実行したコマンドの終了ステータスがこの単純コマンドの終了ステータスになります。コマンドが見つからなかった場合は、コマンドは実行されず終了ステータスは
           127
           になります。コマンドが見つかったが起動に失敗した場合は、終了ステータスは
           126
           になります。コマンドが起動されたがシグナルによって中断された場合は、終了ステータスはそのシグナルの番号に
           384 を足した数になります。POSIX
           準拠モードで任意組込みコマンドが実行されなかった場合は、終了ステータスは
           127 になります。

               注
               POSIX
               ではコマンドがシグナルによって中断された場合の終了ステータスは
               128 より大きな数としか定められていないので、yash
               以外のシェルでは終了ステータスが異なることがあります。
           非 POSIX 準拠モードにおいてコマンドが見つからなかったとき、コマンド
           eval -i -- "${COMMAND_NOT_FOUND_HANDLER-}"
           が実行されます。ただしこのとき位置パラメータはコマンド名とコマンド引数に一時的に置き換えられます。またこのコマンドの実行中に定義されたローカル変数はこのコマンドの終了時に削除されます。このコマンドの実行時には
           HANDLED
           ローカル変数が空文字列を値としてあらかじめ定義されます。このコマンドの実行後にこの変数の値が空文字列でなくなっていれば、このコマンドの終了ステータスがこの単純コマンドの終了ステータスとなり、コマンドが見つからなかったことはエラーとはみなされません。

       宣

           宣言ユーティリティは予めシェル内で定義されている特殊なコマンド名であり、通常とは異なる単語展開動作を行います。単純コマンドが宣言ユーティリティである場合、代入形式のトークンは代入と同様に展開されます。

           宣言ユーティリティはコマンドが読み込まれる時に認識されます。(コマンドが実行される時ではありません。)
           そのため、単語が展開された結果が宣言ユーティリティの名前になる場合でもそれは宣言ユーティリティとしては認識されません。

               注

               Yash
               以外のシェルでは、単語展開の結果に応じて宣言ユーティリティが認識され、その後に続く他のトークンの展開方法に反映されるものもあります。

           Yash では以下の組込みコマンドが宣言ユーティリティとなります:

            1. export

            2. local

            3. readonly

            4. typeset

           また、command 組込みは command
           に続くトークンが宣言ユーティリティである場合に宣言ユーティリティとして認識されます。

       コ

           単純コマンドで実行すべきコマンドは、展開で得られたコマンド名に基づいて以下の手順で特定されます。

            1. コマンド名にスラッシュ (/)
               が含まれている場合は、それが実行すべき外部コマンドへのパス名であると特定されます。

            2. コマンド名が特殊組込みコマンドならば、その組込みコマンドが実行すべきコマンドとして特定されます。

            3. コマンド名と同じ名前の関数が存在すれば、その関数が実行すべきコマンドとして特定されます。

            4. コマンド名が必須組込みコマンドまたは任意組込みコマンドならば、その組込みコマンドが実行すべきコマンドとして特定されます。

            5. コマンド名が拡張組込みコマンドならば、その組込みコマンドが実行すべきコマンドとして特定されます。(POSIX
               準拠モードのときを除く)

            6. PATH
               変数の値に従って、実行すべき外部コマンドを検索しそのパス名を特定します。

               PATH 変数の値は、いくつかのディレクトリのパス名をコロン (:)
               で区切ったものとみなされます
               (空のパス名はシェルの作業ディレクトリを表しているものとみなします)。それらの各ディレクトリについて順に、ディレクトリの中にコマンド名と同じ名前の実行可能な通常のファイルがあるか調査します。そのようなファイルがあれば、そのファイルが実行すべき外部コマンドとして特定されます
               (ただし、コマンド名と同じ名前の代替組込みコマンドがあれば、代わりにその組込みコマンドが実行すべきコマンドとして特定されます)。どのディレクトリにもそのようなファイルが見つからなければ、実行すべきコマンドは見つからなかったものとみなされます。

           外部コマンドの検索が成功しパス名が特定できた場合、そのパス名が絶対パスならば、シェルはそのパス名を記憶し、再び同じコマンドを実行する際に検索の手間を省きます。ただし、再びコマンドを実行しようとした際に、記憶しているパス名に実行可能ファイルが見当たらない場合は、検索をやり直します。シェルが記憶しているパス名は
           hash 組込みコマンドで管理できます。

   シ
       シェルは、入力が終わりに達して全てのコマンドを解釈・実行し終えた時や、exit
       組込みコマンドを実行したときなどに終了します。シェルの終了ステータスは、シェルが最後に実行したコマンドの終了ステータスになります
       (一つもコマンドを実行しなかったときは 0)。ただし、終了ステータスから
       384
       を引いた数がシグナルの番号である場合は、シェルはそのシグナルを自分自身に送りなおすことで終了します。

       Trap
       組込みコマンドでシェル終了時のハンドラが登録されている場合は、シェルが終了する直前にそのハンドラが実行されます。ただしこのハンドラ内で実行したコマンドはシェルの終了ステータスには影響しません。

       対話モードでないシェルの実行中に下記エラーが発生した場合、シェルは直ちに終了します。このときシェルの終了ステータスは非
       0 です。

       •   文法エラーのためコマンドを解釈できないとき (シェルの初期化中を除く)

       •   POSIX
           準拠モードで、特殊組込みコマンドの実行中にエラーが発生したとき

       •   POSIX
           準拠モードで、特殊組込みコマンドに対してリダイレクトエラーが発生したとき

       •   単純コマンドで代入エラーが発生したとき

       •   展開エラーが発生したとき (シェルの初期化中を除く)

           注

           Yash
           はそうではありませんが、コマンドの検索において実行すべきコマンドが見つからなかったときに直ちに終了するようなシェルもあります。

   関
       関数は一つの複合コマンドを単純コマンドのように呼び出せるようにする機構です。関数は関数定義コマンドによって定義でき、単純コマンドによって実行できます。関数を削除するには
       unset 組込みコマンドを使います。

       Yash
       には、シェルの起動時に最初から定義されている関数は一つもありません。

       関数の実行は、関数の内容である複合コマンドを実行することによって行われます。関数の実行中は、関数の引数が位置パラメータになります。それまでの位置パラメータは一時的に使えなくなりますが関数の実行が終わった時に元の位置パラメータに戻ります。

       ロ

           ローカル変数とは、関数の実行中にだけ有効な一時的な変数です。ローカル変数は
           typeset 組込みコマンドを使って作ることができます。また for
           ループの実行時に暗黙的に作られることもあります。関数の実行中に作られたローカル変数は関数の実行が終わった時に削除され、ローカル変数を作る前の元の変数の状態に戻ります。

           関数内で定義したローカル変数は、関数の実行に先立って定義してあった同名の他の変数を隠蔽します。隠蔽された変数は、関数の実行が終わってローカル変数がなくなるまで使えなくなります。

           関数の実行中でないときにローカル変数を作ることはできません。ローカル変数を作ろうとしても、通常の変数になります。

   コ
       シェルは実行時に以下の情報を保持します。

       •   作業ディレクトリ

       •   開いているファイル記述子

       •   ファイル作成マスク (umask)

       •   受信時の挙動が 『無視』 に設定されたシグナルの集合 (trap)

       •   環境変数

       •   リソース制限 (ulimit)

       これらの情報はシェルが起動されたときに元のプログラムからシェルに受け継がれます。そしてシェルが起動する外部コマンドやサブシェルにもシェルから受け継がれます。

       これらの情報は所定の組込みコマンド等を使って変更可能です。

       サ

           サブシェルは、実行中のシェルのプロセスのコピーです。サブシェルは括弧
           ( ) で囲んだグルーピングやパイプラインで使われます。

           サブシェルはシェルのプロセスのコピーであるため、上記の情報の他にシェルで定義された関数やエイリアスなどの情報も元のシェルから受け継ぎます。ただし、

           •   Trap 組込みコマンドで登録したトラップの設定は、(受信時の挙動が
               『無視』 のものを除き) サブシェルではすべて解除されます。(注)

           •   サブシェルでは対話モードとジョブ制御は解除され、元のシェルのジョブの情報は受け継がれません。

           サブシェルは元のシェルとは独立しているため、サブシェルでの作業ディレクトリの変更や変数代入は元のシェルに影響しません。

               注

               Yash 以外のシェルでは、サブシェル内で実行されるコマンドが trap
               組込みコマンドのみの場合にはトラップの設定を解除しないものもあります。

対
       対話モードは、利用者が直接シェルを操作することを意図したモードです。シェルの起動時に
       -i オプションを指定した場合
       (その他対話モードが有効になる条件が満たされている場合)、シェルは対話モードになります。シェルが起動した後は、そのシェルの対話モードのオン・オフを切り替えることはできません。

       対話モードが有効な時......

       •   シェルの初期化時に初期化スクリプトを読み込んで実行します。

       •   コマンドを読み込む際にメールチェックを行い、プロンプトを表示します。ジョブ制御が有効ならジョブの状態変化も表示します。端末の種類によっては行編集が使えます。

       •   実行したコマンドは自動的にコマンド履歴に登録されます。

       •   非同期コマンドの実行を開始するとき、そのジョブ番号とプロセス ID
           を標準エラーに出力します。

       •   実行したコマンドが SIGINT/SIGPIPE
           以外のシグナルによって中断されたとき、シェルはそのことを示す警告メッセージを標準エラーに出力します。

       •   ファイルのリダイレクトの対象ファイルを指示するトークンに対してパス名展開を行います。

       •   コマンド解釈・実行時に文法エラーや展開エラーが発生してもシェルは終了しません。(シェルの終了を参照)

       •   SIGINT, SIGTERM, SIGQUIT シグナルを受けても、シェルは終了しません。

       •   シグナル受信時の挙動がシェルの起動時に最初から 『無視』
           に設定されていても trap
           組込みコマンドでシグナル受信時の挙動を変更できます。

       •   特殊パラメータ - の値に i が含まれます。

       •   シェル実行中に LC_CTYPE
           変数の値が変わった時、それを直ちにシェルのロケール情報に反映します。(POSIX
           準拠モードを除く)

       •   Exec オプションが無効な時でもコマンドを実行します。

       •   Ignore-eof オプションが効果を発揮します。

       •   Exit
           組込みコマンドでシェルを終了しようとした時、停止しているジョブがあれば、シェルは警告を表示してすぐには終了しません。このときは続けざまにもう一度
           exit
           コマンドを実行すると本当にシェルを終了させることができます。シェルへの入力が終わりに達した場合も同様です。

       •   Suspend
           組込みコマンドでシェルを停止させようとした時、シェルがセッションリーダーならエラーを出力して停止しません。

       •   ドット組込みコマンドで読み込むスクリプトファイルが見つからなくても、シェルは終了しません。

       •   Exec
           組込みコマンドでコマンドの実行に失敗したときでもシェルは終了しません。

       •   Wait
           組込みコマンドで待っているジョブが終了したとき、そのことを示すメッセージを出力します。(ジョブ制御が有効な時のみ。POSIX
           準拠モードを除く)

       •   Read 組込みコマンドが二行目以降を読むときプロンプトを出します。

   プ
       対話モードでは、シェルはコマンドの入力を読み取る直前にプロンプトを標準エラーに出力します。プロンプトの内容は
       PS1
       変数で指定します。ただし、複数行にわたるコマンドを読み取る際、二行目以降の読み取りには
       PS1 ではなく PS2 変数の値がプロンプトとして表示されます。

       プロンプトの表示の際には、まず PS1 (または PS2)
       変数の値がパラメータ展開・コマンド置換・数式展開で展開されます (ただし
       POSIX
       によればパラメータ展開だけが行われることになっています)。この展開後の値は以下の通り解釈され、その結果がプロンプトとして標準エラーに出力されます。

       POSIX 準拠モードでは、値に含まれる !
       はこれから入力しようとしているコマンドの履歴番号に変換されます。感嘆符そのものをプロンプトに表示させるには
       !!
       と二つ続けて書きます。これ以外の文字はプロンプトにそのまま表示されます。

       POSIX
       準拠モードでないときは、バックスラッシュで始まる以下の記法が解釈されます。これらの記法以外の文字はそのままプロンプトに表示されます。

       \a
           ベル文字 (ASCII コード番号 7)

       \e
           エスケープ文字 (ASCII コード番号 27)

       \j
           現在シェルが抱えているジョブの数

       \n
           改行文字 (ASCII コード番号 10)

       \r
           復帰文字 (ASCII コード番号 13)

       \!
           これから入力しようとしているコマンドの履歴番号

       \$
           シェルの実効ユーザ ID が 0 のときは #、それ以外の時は $。

       \\
           バックスラッシュ (\)

       \[, \]
           この二つの記法は、実際には端末に表示されないプロンプトの一部分を指示するのに使います。\[
           と \]
           で囲んだ部分は、行編集がプロンプトの文字数を計算する際に、文字数に数えられません。端末に表示されないエスケープシーケンスなどをプロンプトに含める際は、その部分を
           \[ と \]
           で囲んでください。この指定を怠ると、行編集の表示が乱れることがあります。

       \fフォント指定.
           行編集を使用している場合、この記法は端末のフォントの表示を変更するための特殊な文字の羅列に変換されます
           (端末が対応している場合のみ)。行編集を使用していない場合や端末が対応していない場合は、この記法は単に無視されます。フォント指定の部分にはフォントの種類を指定するための以下の文字を指定します。

           k
               文字の色を黒にする

           r
               文字の色を赤にする

           g
               文字の色を緑にする

           y
               文字の色を黄にする

           b
               文字の色を青にする

           m
               文字の色をマゼンタにする

           c
               文字の色をシアンにする

           w
               文字の色を白にする

           K
               背景の色を黒にする

           R
               背景の色を赤にする

           G
               背景の色を緑にする

           Y
               背景の色を黄にする

           B
               背景の色を青にする

           M
               背景の色をマゼンタにする

           C
               背景の色をシアンにする

           W
               背景の色を白にする

           t
               文字または背景の色を明るくする
               (上記の文字・背景の色を変更する文字の直後でのみ有効)

           d
               文字と背景の色を標準状態に戻す

           s
               文字を目立たせる

           u
               文字に下線を引く

           v
               文字の色を反転させる

           b
               文字を点滅させる

           i
               文字の色を暗くする

           o
               文字を太く目立たせる

           x
               文字を見えなくする

           D
               色と装飾を標準状態に戻す

           文字と背景の色は最終的に端末によって決まるため、実際にはここで指定した色と異なる色で表示されることがあります。

       入力するコマンドの右側に表示されるプロンプトを指定することもできます
       (右プロンプト)。PS1/PS2 変数に対応する右プロンプトは PS1R/PS2R
       変数で指定します。

       また、プロンプトのフォントだけでなく、入力するコマンドのフォントを変えることもできます。PS1S
       (または PS2S)
       変数に上述のフォントを指定するシーケンスを指定することで、コマンド入力時のコマンドのフォントが変わります。
       コマンドライン推定を使用している場合は、推定された部分のフォントを PS1P
       (または PS2P) 変数で変えられます。

       POSIX 準拠モードでないときは、上記の変数は名前に YASH_ を付けた名前
       (例えば YASH_PS1) で定義することもできます。これにより、POSIX
       準拠モードとは異なるプロンプトを使い分けることができます。

       POSIX 準拠モードでないときは、以下の変数が評価されます。

       •   プロンプトを出す前に PROMPT_COMMAND
           変数の値がコマンドとして実行されます。

       •   コマンドが一行分入力されるたびに POST_PROMPT_COMMAND
           変数の値がコマンドとして実行されます。実行中は入力されたコマンドが
           COMMAND
           変数に代入されます。この変数の値を変更することで実行されるコマンドを改変することもできます。変数を削除するとコマンドは実行されません。

   コ
       コマンド履歴は実行したコマンドを記録し後で再び実行することのできる機能です。対話モードでシェルが読み込んだコマンドは自動的にコマンド履歴に記録されます。履歴に記録したコマンドは行編集で呼び出して再実行することができます。また
       fc・history
       組込みコマンドで履歴のコマンドを再実行したり編集したりすることもできます。

       コマンドは行単位で履歴に記録されます。空白以外の文字を一切含まない行は履歴には記録されません。また
       hist-space
       オプションが有効なときは空白で始まる行は履歴に記録されません。

       コマンド履歴の内容は HISTFILE
       変数で指定されるファイルに保存されます。対話モードのシェルの起動後に履歴関連の機能が初めて使用されるとき、HISTFILE
       変数の値をファイル名とみなしてファイルを開きます。既にファイルに履歴データが保存されている場合は、それが読み込まれます。ファイルが存在しないか内容が履歴データではない場合は、新しい履歴ファイルに初期化されます。HISTFILE
       変数が存在しない場合やファイルを開くことができない場合は履歴はファイルに保存されませんが、履歴機能自体は使用できます。

       シェルが記録するコマンドの数は HISTSIZE
       変数で指定します。履歴の件数がこの変数の値を超えると順次古いデータから削除されます。この変数が存在しない場合または値が自然数でない場合は、履歴は
       500 件まで記録されます。

       HISTFILE および HISTSIZE
       変数は履歴機能が初めて使用されるときにのみ参照され、それ以降は変数を再設定しても履歴機能の動作に影響しません。履歴機能が利用されるときというのは、具体的には以下のタイミングです。

       •   Fc または history 組込みコマンドを実行したとき

       •   行編集を使用してコマンドを入力するとき
           (履歴データを行編集の中で使わなくても履歴機能は使われます)

       •   入力したコマンドが履歴に登録されるとき

       このため HISTFILE および HISTSIZE
       変数は原則としてシェルの起動時に読み込まれる初期化スクリプトの中で設定する必要があります。

       複数のシェルプロセスが同じ履歴ファイルを使用している場合、これらのシェルは一つの履歴データを共有します。このとき例えばあるシェルプロセスで実行したコマンドを別のシェルプロセスで実行することができます。同じ履歴を使用しているシェルの間で
       HISTSIZE が異なっていると履歴が正しく共有されないので、HISTSIZE
       の値は統一するようにしてください。

       Yash
       は独自の形式の履歴ファイルを使用しているため、履歴ファイルを他の種類のシェルと共用することはできません。

       履歴に同じコマンドを記録する無駄を解消するため、HISTRMDUP
       変数を使用することができます。新しくコマンドを履歴に記録しようとする際、すでに同じコマンドが最近の
       $HISTRMDUP
       件の履歴データの中に記録されていれば、その既に記録されているコマンドは履歴から削除されます。

   メ
       対話モードのシェルには、電子メールが届いたらそれを知らせる機能があります。これは所定のファイルの更新日時を調べて、更新日時が変わっていたらメッセージを表示するというものです。受信したメールのデータが保存されるファイルをチェック対象として指定しておくことで、メールを受信したときにメッセージが表示されるようになります。

       ファイル更新のチェックはシェルがプロンプトを出す直前に行います。チェックを行う間隔を
       MAILCHECK
       変数で指定することができます。この変数で指定した秒数が経過するごとに、シェルはプロンプトを出す直前にチェックを行います。この変数の値が
       0
       になっている場合は、プロンプトを出す直前に毎回チェックを行います。また変数の値が
       0 以上の整数でない場合は、チェックは一切行いません。

       更新日時をチェックする対象のファイルは MAIL
       変数で指定します。この変数にチェックしたいファイルのパス名を指定しておくと、シェルはそのファイルの更新日時をチェックします。ファイルの更新日時が前回チェックしたときと変わっていたら、新着メールを知らせるメッセージを標準エラーに出力します。(ただしファイルが空のときはメッセージは出ません
       (POSIX 準拠モードのときを除く))

       複数のファイルをチェックの対象にしたい場合やメッセージを自分で指定したい場合は、MAIL
       変数の代わりに MAILPATH 変数を使うことができます。MAILPATH
       変数が設定されている場合は、MAIL 変数の設定は無視されます。MAILPATH
       変数の値には、一つ以上のファイルのパス名をコロン (:)
       で区切って指定することができます。シェルは毎回のチェックでそれぞれのファイルの更新日時を調べ、ファイルが更新されていたらメッセージを表示します。メッセージを自分で指定するには、パス名の直後にパーセント
       (%)
       を置き、続けて表示させたいメッセージを置きます。それぞれのファイルごとに異なるメッセージを指定することができます。(パーセントをパス名とメッセージとの区切りではなくパス名の一部としたい場合はパーセントをバックスラッシュでクォートしてください)
       パーセントの後に指定されたメッセージは、表示の前にパラメータ展開されます。

       例えば MAILPATH 変数の値が /foo/mail%New mail!:/bar/mailbox%You've got
       mail:/baz/mail\%data だとすると、ファイル /foo/mail が更新されたときは
       New mail! が、/bar/mailbox が更新されたときは You've got mail
       が、/baz/mail%data
       が更新されたときはデフォルトのメッセージが表示されます。

ジ
       ジョブ制御とは、複数のコマンドを同時に実行し、必要に応じてそれらを中断・再開させる機能です。シェルは、オペレーティングシステムが提供する端末の機能やプロセスグループ管理機構などを用いて、ジョブ制御を実現します。

       ジョブ制御が有効な時......

       •   シェルが起動する各サブシェルは、シェルのプロセスグループ ID
           とは異なるプロセスグループ ID
           が割り当てられます。ただし、同じパイプライン内のサブコマンドは共通のプロセスグループ
           ID を持ちます。このようなプロセスグループをジョブと呼びます。

           •   例外的に、コマンド置換やプロセスリダイレクトのために起動されたサブシェルはシェルと同じプロセスグループに属します。

       •   シェルがジョブを起動しそのジョブのプロセスが終了するのを待っている間にそのプロセスのどれかが停止した場合、シェルは
           (ジョブが終了したときと同様に)
           次のコマンドの処理に移ります。このときシェルはジョブが停止したことを覚えているので、後でジョブを再開させることができます。

           •   このとき、シェルが対話モードの場合、シェルが読み込んだがまだ実行していないコマンドは破棄され、次のプロンプトが表示されます。

       •   ジョブが同期的に実行される場合、そのジョブの実行中はそのジョブのプロセスグループが端末のフォアグラウンドプロセスグループになります。ジョブの実行が終了
           (または停止) すると、再びシェルがフォアグラウンドになります。

       •   シェルが対話モードの場合、プロンプトを出す前に毎回コマンド jobs -n
           を実行するのと同様にしてジョブの状態変化を報告します。

       •   非同期コマンドの標準入力が自動的に /dev/null
           にリダイレクトされません。

       •   SIGTTIN, SIGTTOU, SIGTSTP
           シグナルを受けても、シェルは停止しません。コマンド置換やプロセスリダイレクトのために起動されたサブシェルは
           SIGTSTP シグナルを受けても停止しません。

       •   特殊パラメータ - の値に m が含まれます。

       •   Wait
           組込みコマンドで待っているジョブが終了したとき、そのことを示すメッセージを出力します。(対話モードの時のみ。POSIX
           準拠モードを除く)

       ジョブ制御が無効な時、シェルが起動する各プロセスはシェルと同じプロセスグループに属しますが、実行した非同期コマンドはそれぞれジョブ制御の対象となっていないジョブとして扱います。

       ここでジョブ制御に関連する組込みコマンドを簡単に紹介します。

       jobs
           現在シェルが管理しているジョブを表示します。

       fg および bg
           ジョブをフォアグラウンドまたはバックグラウンドで実行します。主に停止したジョブを再開させるのに使います。

       wait
           ジョブが終了するまで待ちます。

       disown
           ジョブの存在を忘れます。

       kill
           プロセスにシグナルを送ります。

       対話モードでジョブ制御が有効な時、シェルはプロンプトを出す直前にジョブの状態変化を報告します。これ以外のタイミングで状態変化を報告してほしい場合は、以下のオプションを指定することができます。

       notify
           タイミングにかかわらず、ジョブの状態が変化したら直ちにそれを報告します。

       notify-le
           行編集を行っている最中にジョブの状態が変化したら直ちにそれを報告します。

       シェルが管理しているジョブは以下のタイミングで削除されます。

       •   ジョブの実行が終了した後、そのことを jobs
           組込みコマンドで表示したとき

       •   Wait 組込みコマンドでジョブの終了を待ったとき

       •   Disown 組込みコマンドでジョブを削除したとき

       対話シェルが自動的にジョブの状態変化を報告するときにはジョブは削除されません。

   ジ
       いくつかの組込みコマンドでは、操作対象のジョブを指定するためにジョブ ID
       という以下のような記法を用います。

       %, %%, %+
           現在のジョブ

       %-
           前のジョブ

       %n
           ジョブ番号が n のジョブ (n は自然数)

       %文字列
           ジョブ名が文字列で始まるジョブ

       %?文字列
           ジョブ名が文字列を含むジョブ

       現在のジョブ及び前のジョブとは、シェルが特定の方法で選んだジョブのことで、fg
       組込みコマンドなどでジョブを選択しやすくするために用意されています。現在のジョブと前のジョブは以下の規則を満たすように選ばれます。

       •   停止中のジョブがある場合は、現在のジョブはその中から選ばれます。

       •   現在のジョブ以外に停止中のジョブがある場合は、前のジョブはその中から選ばれます。

       •   現在のジョブと前のジョブは異なるジョブになるように選ばれます。ジョブが一つしかないときはそれが現在のジョブになり、前のジョブはなくなります。

       •   現在のジョブが終了したときは、前のジョブが現在のジョブになります。これ以外に現在のジョブが変更される場合は、元の現在のジョブは前のジョブになります。

       •   フォアグラウンドで実行していたジョブが停止したときは、そのジョブは現在のジョブになります。

       Yash
       には、現在のジョブを選択する方針を指示するためにいくつかのオプションが用意されています。ただしこれらのオプションよりも上記の規則のほうが優先します。

       cur-async
           新しく非同期コマンドを起動したとき、それは現在のジョブになります。

       cur-bg
           Bg
           組込みコマンドでジョブを再開したとき、そのジョブは現在のジョブになります。

       cur-stop
           実行中のジョブが停止したとき、そのジョブは現在のジョブになります。

       これらの規則・オプションに反しない限り、一度選ばれた現在のジョブ・前のジョブはずっと現在のジョブ・前のジョブのままです。

       POSIX
       は現在のジョブ・前のジョブの選択方法を細かく定めていないため、他のシェルでは選び方が異なることがあります。

組
       組込みコマンドとはシェルに内蔵されたコマンドです。組込みコマンドは外部のプログラムを起動することなくシェル自身によって実行されます。

   組
       Yash の組込みコマンドは以下の種類に分けられます。

       特殊組込みコマンドは最も重要な種類の組込みコマンドで、他の組込みコマンドとは異なる性質をいくつか持っています。まず、特殊組込みコマンドは対応する外部コマンドの存在に関係なく常に実行されます。また特殊組込みコマンドにおける変数代入の結果はコマンドの実行が終わった後も残ります。さらに
       POSIX
       準拠モードでは、特殊組込みコマンドを実行する単純コマンド内でエラーが起きた場合、シェルが対話モードでなければシェルは直ちに非
       0 の終了ステータスで終了します。

       必須組込みコマンドと任意組込みコマンドは外部コマンドの存在に関係なく実行される点では特殊組込みコマンドと同様ですが、関数で上書き可能な点が異なります。
       必須組込みコマンドは常に利用可能ですが、任意組込みコマンドは POSIX
       では名前しか定義されていないため POSIX 準拠モードでは使えません。

       拡張組込みコマンドは POSIX
       で言及されていないコマンドです。任意組込みコマンドと同様に、POSIX
       準拠モードが無効の時は外部コマンドに関係なく使用できますが、POSIX
       準拠モードが有効な時は拡張組込みコマンドは存在しないものとして扱われます。

       代替組込みコマンドは PATH
       変数の検索で見つかった外部コマンドの代わりに実行される組込みコマンドです。外部コマンドを起動するオーバーヘッドを回避して実行速度を向上します。

   コ
       ここでは組込みコマンドの引数に関する一般的な規則について説明します。Yash
       の組込みコマンドの引数の指定・解釈の仕方は、他に断りがない限りこの規則に従います。

       コマンドの引数は、オプションとオペランドの二種類に分けられます。オプションはハイフン
       (-)
       で始まる引数で、主にコマンドの動作を変更するのに使われます。オプションの中にはそれに対応する引数をとるものもあります。オペランドはオプション以外の引数で、主にコマンドが処理を行う対象を指定するのに使われます。

       一つのコマンドに複数のオプションを与える場合、原則としてそれらのオプションの順序はコマンドの動作に影響しません。しかしオペランドの順序には意味があります。

       オプションには一文字のオプションと長いオプションとがあります。一文字のオプションは英数字一文字によって識別されるオプションです。長いオプションはもっと長い文字列によって識別されるオプションです。POSIX
       規格は一文字のオプションについてしか規定していないため、POSIX
       準拠モードでは長いオプションは使えません。

       一文字のオプションは、一つのハイフンと一文字の英数字からなります。例えば
       -a
       は一文字のオプションです。引数をとるオプションでは、コマンドに与えられた引数の並びの中でそのオプションの直後に位置している引数がそのオプションに対する引数とみなされます。

       例

       Set 組込みコマンドにおいて、-m は引数をとらない一文字のオプション、-o
       は引数をとる一文字のオプションです。

       •   set -o errexit -m

       •   set -oerrexit -m

       この二つの例では、errexit が -o オプションに対する引数となります。

       上の二つ目の例では、-o
       オプションとそれに対する引数が一つのコマンドライン引数になっています。POSIX
       はこのような書き方は避けなければならないと定めており、POSIX
       に従うアプリケーションは必ず一つ目の例のようにオプションとそれに対する引数を別々のコマンドライン引数として与えなければなりません。しかし
       yash はどちらの指定の仕方も受け付けるようになっています。

       引数をとらない複数の一文字のオプションは、一つにまとめて書くことができます。例えば
       -a, -b, -c という三つのオプションは -abc と書けます。

       長いオプションは、二つのハイフンとオプション名を表す文字列からなります。例えば
       --long-option
       は長いオプションです。オプション名は他と紛らわしくない限り末尾を省略できます。例えば他に
       --long で始まる長いオプションがなければ、--long-option は --long
       と省略できます。引数をとるオプションでは、一文字のオプションの場合と同様に、オプションの直後にあるコマンドライン引数がそのオプションに対する引数とみなされます。あるいは、オプション名の後に等号
       (=) で区切って直接引数を与えることもできます。

       例

       Fc 組込みコマンドにおいて、--quiet
       は引数をとらない長いオプション、--editor
       は引数をとる長いオプションです。

       •   fc --editor vi --quiet

       •   fc --editor=vi --quiet

       この二つの例では、vi が --editor オプションに対する引数となります。

       オプション (およびオプションに対する引数)
       以外の引数は、全てオペランドとみなされます。POSIX
       は、オペランドは全てオプションより後に書かなければならないと定めています。そのため
       POSIX 準拠モードでは、最初のオペランドより後にある引数は
       (たとえそれがオプションであるように見えても)
       全てオペランドとして解釈します。POSIX
       準拠モードでないときは、オペランドの後にオプションを書いても構いません。

       POSIX 準拠モードであるかどうかにかかわらず、ハイフン二つからなる引数
       (--)
       はオプションとオペランドとの区切りとして使えます。この区切り以降の全てのコマンドライン引数はオペランドとして解釈されるため、ハイフンで始まるオペランドを正しく指定できます。

       例

       •   set -a -b -- -c -d

       この例では、-a と -b がオプションで、-c と -d
       がオペランドとなります。区切り (--)
       自体はオプションでもオペランドでもありません。

       POSIX 準拠モードであるかどうかにかかわらず、ハイフン一つからなる引数
       (-) は常にオペランドとみなされます。

行
       行編集機能は、対話モードのシェルにコマンドを入力する際に使える、コマンドの簡易編集機能です。行編集機能は、コマンドを編集するための簡単なエディタとして働きます。行編集機能はコマンド履歴とも連携しており、fc
       コマンドを使ってエディタを起動する代わりに行編集で直接コマンドを編集・再実行できます。

       行編集には複数の編集モードがあり、モードごとにキー操作の割り当てが異なります。行編集の有効・無効を切り替えたりモードを選択したりするには、set
       組込みコマンドで編集モードに対応するオプションを設定します。あるモードに対応するオプションを有効にすると、そのモードの行編集が有効になります
       (同時に他のモードのオプションは自動的に無効になります)。現在有効になっているモードのオプションを無効にすると、行編集は無効になります。現在
       yash が搭載している編集モードは vi 風と emacs
       風の二種類で、それぞれ対応するオプションは -o vi と -o emacs です。

       シェルが対話モードで起動したとき、標準入力と標準エラーがともに端末ならば、vi
       風行編集が自動的に有効になります。

       行編集は、標準入力と標準エラーがともに端末のときだけ使えます。この条件が満たされていないときは、行編集は働きません。行編集が働くとき、シェルは
       termios
       インタフェースを使用して端末の入出力モードを一時的に変更し、terminfo
       インタフェースを使用して入力されたキーの判別などを行います。

   行
       行編集を有効にし編集モードを選択するオプションとして、以下のオプションが
       set 組込みコマンドで設定できます。

       vi
           Vi 風編集モードを有効にします

       emacs
           Emacs 風編集モードを有効にします

       この他に、行編集に関わるものとして以下のオプションが設定できます。

       le-always-rp
           このオプションが無効な時は、長いコマンドを入力してコマンドが右プロンプトに達すると、右プロンプトは見えなくなります。このオプションが有効な時は、右プロンプトは見えなくなる代わりに下に移動します。

       le-comp-debug
           補完を行う際にデバッグ用の情報を出力します

       le-conv-meta
           Terminfo データベースで得られた情報を無視し、入力の 8
           ビット目を常に meta-key フラグとみなします。

       le-no-conv-meta
           Terminfo データベースで得られた情報を無視し、入力の 8
           ビット目を他のビットと同様に扱います。

           Le-conv-meta オプションと le-no-conv-meta
           オプションは片方しか有効にできません
           (片方を有効にするともう片方は自動的に無効になります)。どちらも無効な時は
           terminfo データベースの情報に従って 8 ビット目を meta-key
           とみなすかどうか判断します。

       le-predict
           コマンドライン推定を有効にします

       le-predict-empty
           コマンドライン推定とこのオプションが有効な時、まだ何も入力されていないコマンドラインでも推定結果を表示します。

       le-prompt-sp
           このオプションが有効な時、シェルはプロンプトを出力する前に、プロンプトが必ず行頭に来るようにカーソルを移動するための特殊な文字列を出力します。

           このオプションは最初から有効になっています。

       le-visible-bell
           シェルが警告を発する際、警告音を鳴らす代わりに端末を点滅させます。

       le-trim-right
           このオプションが無効な時、右プロンプトは端末右端から 1
           マス空けて表示されます。このオプションを有効にすると右プロンプトを右端に付けて表示します。

   編
       Vi 風編集モードは vi に似たキー操作で編集を行う編集モードです。Vi
       風編集モードでは、挿入モードとコマンドモードの二つのモードを適宜切り替えて編集を行います。編集が始まるときはモードは必ず挿入モードになっています。挿入モードでは入力した文字が基本的にそのままバッファに挿入されます。コマンドモードでは入力した文字はカーソルを移動したり文字を消去したりするコマンドとして解釈されます。

       Emacs 風編集モードは emacs
       に似たキー操作で編集を行う編集モードです。入力した文字は基本的にそのままバッファに挿入されますが、コマンドとして解釈される一部のキー操作が
       vi 風編集モードの挿入モードと異なります。

       これらのモードの他に、コマンドの検索の際に用いる検索モードが vi 風と
       emacs 風とそれぞれにあります。

   行
       行編集中に入力された文字は全て以下の行編集コマンドのいずれかとして解釈されます。コマンドとキーの対応は
       bindkey 組込みコマンドで変更できます (検索モードを除く)。

       以下の一覧には各コマンドに対応するキー入力の初期設定も示してあります。なお、
       『vi-insert』 は vi 風編集モードの挿入モードを、 『vi-command』 は vi
       風編集モードのコマンドモードを、 『vi-search』 は vi
       風編集モードの検索モードを、 『emacs』 は emacs 風編集モードを、
       『emacs-search』 は emacs 風編集モードの検索モードを示します。

       コマンドの中には引数を指定することでその動作を変更できるものがあります。例えば
       forward-char
       コマンドは通常はカーソルを一文字分前に移動しますが、引数を指定するとその引数の文字数分だけカーソルを移動します。引数は、目的のコマンドの直前に
       digit-argument コマンドを使うことで指定できます。

       基

           noop
               何も行いません。

               vi-command
                   \^[

           alert
               警告音を発しまたは端末を点滅させます。

           self-insert
               入力した文字を現在のカーソルの位置に挿入します。(エスケープシーケンスによるエスケープの対象となる文字は挿入できません)

               コマンドライン推定が有効な場合、推定された部分は無視します。Accept-prediction
               コマンドも参照。

               vi-insert, emacs
                   \\

           insert-tab
               タブを現在のカーソルの位置に挿入します。

               emacs
                   \^[\^I

           expect-verbatim
               このコマンドの直後に入力する一文字を現在のカーソル位置に挿入します。このコマンドを使うと
               self-insert コマンドで入力できない文字も入力できます (ナル文字
               '\0' を除く)。

               vi-insert, vi-search, emacs-search
                   \^V

               emacs
                   \^Q, \^V

           digit-argument
               このコマンドは数字またはハイフンの入力に対してのみ有効です。入力した数字を次のコマンドへの引数として受け付けます
               (ハイフンの場合は符号を反転します)。

               Digit-argument
               コマンドを連続して使うことで複数桁の引数を指定できます。例えば
               vi 風編集モードのコマンドモードで 12l
               と入力すると、forward-char コマンドに引数 12
               を与えたことになります (すなわちカーソルが左に 12
               文字分移動します)。

               vi-command
                   1, 2, 3, 4, 5, 6, 7, 8, 9

               emacs
                   \^[0, \^[1, \^[2, \^[3, \^[4, \^[5, \^[6, \^[7, \^[8, \^[9,
                   \^[-,

           bol-or-digit
               引数がない場合は beginning-of-line
               コマンドと同じように、引数がある場合は digit-argument
               コマンドと同じように動作します。

               vi-command
                   0

           accept-line
               行編集を終了し、現在のバッファの内容をシェルへの入力として与えます。行の末尾には自動的に改行が付け加わります。

               vi-insert, vi-command, emacs
                   \^J, \^M, \et

               emacs-search
                   \^M, \et

           abort-line
               行編集を中止し、空の入力をシェルに与えます。

               vi-insert, vi-command, vi-search, emacs, emacs-search
                   \!, \^C

           eof
               シェルに入力の終わりを知らせます
               (これによりシェルは終了します)。

           eof-if-empty
               バッファが空ならば、行編集を終了し、シェルに入力の終わりを知らせます
               (これによりシェルは終了します)。バッファが空でなければ、alert
               コマンドと同じ動作をします。

               vi-insert, vi-command
                   \#, \^D

           eof-or-delete
               バッファが空ならば、行編集を終了し、シェルに入力の終わりを知らせます
               (これによりシェルは終了します)。バッファが空でなければ、delete-char
               コマンドと同じ動作をします。

               emacs
                   \#, \^D

           accept-with-hash
               引数が与えられていないかバッファの最初の文字が #
               でなければ、バッファの最初に #
               を挿入します。そうでなければバッファの最初の #
               を削除します。いずれの場合も、その後 accept-line
               コマンドと同じ動作をします。

               vi-command
                   #

               emacs
                   \^[#

           accept-prediction
               Accept-line
               コマンドと同様に行編集を終了しますが、推定された部分も含めたコマンドを入力として扱います。

           setmode-viinsert
               編集モードを vi 風編集モードの挿入モードに変更します。

               vi-command
                   i, \I

           setmode-vicommand
               編集モードを vi 風編集モードのコマンドモードに変更します。

               vi-insert
                   \^[

           setmode-emacs
               編集モードを emacs 風編集モードに変更します。

           expect-char, abort-expect-char
               これは find-char コマンドなどを実装するために yash
               内部で使われているコマンドで、直接使用しても意味はありません。

           redraw-all
               行編集のプロンプトやバッファを端末に表示しなおします。
               引数を与えた場合は端末の表示もクリアします。

               vi-insert, vi-command, vi-search, emacs, emacs-search
                   \^L

           clear-and-redraw-all
               端末の表示をクリアし、行編集のプロンプトやバッファを端末に表示しなおします。
               引数を与えた場合は端末の表示をクリアせずに表示しなおします。

       移

           移動コマンドはカーソルを移動させるコマンドです。ほとんどの移動コマンドは引数を与えることでそのコマンドを引数の回数だけ実行するのと同じように動作させられます。例えば
           forward-char コマンドに引数 4 を与えると、カーソルを 4
           文字先に進めます。

           以下、bigword
           とは一文字以上の連続した空白でない文字をいい、semiword
           とは一文字以上の連続した空白でも句読点でもない文字をいい、emacsword
           とは一文字以上の連続した英数字をいいます。また viword
           とは以下のいずれかをいいます

           •   一文字以上の連続した英数字または下線 (_)

           •   一文字以上の連続した、英数字でも下線でも空白でもない文字

           以下に移動コマンドの一覧を示します。

           forward-char
               カーソルを次の文字に移動します。

               vi-insert
                   \R

               vi-command
                   l, (space), \R

               emacs
                   \R, \^F

           backward-char
               カーソルを前の文字に移動します。

               vi-insert
                   \L

               vi-command
                   h, \B, \L, \?, \^H

               emacs
                   \L, \^B

           forward-bigword
               カーソルを次の bigword に移動します。

               vi-command
                   W

           end-of-bigword
               カーソルを bigword の終わりまで移動します。

               vi-command
                   E

           backward-bigword
               カーソルを前の bigword に移動します。

               vi-command
                   B

           forward-semiword
               カーソルを次の semiword に移動します。

           end-of-semiword
               カーソルを semiword の終わりまで移動します。

           backward-semiword
               カーソルを前の semiword に移動します。

           forward-viword
               カーソルを次の viword に移動します。

               vi-command
                   w

           end-of-viword
               カーソルを viword の終わりまで移動します。

               vi-command
                   e

           backward-viword
               カーソルを前の viword に移動します。

               vi-command
                   b

           forward-emacsword
               カーソルを次の emacsword に移動します。

               emacs
                   \^[f, \^[F

           backward-emacsword
               カーソルを前の emacsword に移動します。

               emacs
                   \^[b, \^[B

           beginning-of-line
               カーソルをバッファの先頭に移動します。

               vi-insert, vi-command
                   \H

               emacs
                   \H, \^A

           end-of-line
               カーソルをバッファの末尾に移動します。

               vi-insert
                   \E

               vi-command
                   $, \E

               emacs
                   \E, \^E

           go-to-column
               カーソルをバッファ内の n 文字目に移動します。ただし n
               は引数です (引数が与えられていない場合は 1)。

               vi-command
                   |

           first-nonblank
               カーソルをバッファ内の最初の空白でない文字に移動します。

               vi-command
                   ^

           find-char
               このコマンドの直後に入力した文字がある位置までカーソルを進めます。

               vi-command
                   f

               emacs
                   \^]

           find-char-rev
               このコマンドの直後に入力した文字がある位置までカーソルを戻します。

               vi-command
                   F

               emacs
                   \^[\^]

           till-char
               このコマンドの直後に入力した文字がある位置の直前までカーソルを進めます。

               vi-command
                   t

           till-char-rev
               このコマンドの直後に入力した文字がある位置の直後までカーソルを戻します。

               vi-command
                   T

           refind-char
               前回実行した find-char, find-char-rev, till-char, till-char-rev
               コマンドを再実行します。

               vi-command
                   ;

           refind-char-rev
               前回実行した find-char, find-char-rev, till-char, till-char-rev
               コマンドを、カーソルの進む向きを逆にして再実行します。

               vi-command
                   ,

       編

           編集コマンドはバッファの内容を変更するコマンドです。ほとんどの編集コマンドは引数を与えることでそのコマンドを引数の回数だけ実行するのと同じように動作させられます。

           名前に 『kill』
           が付くコマンドで削除した文字列はキルリングという場所に保管され、後で
           put などのコマンドでバッファに戻すことができます。

           以下に編集コマンドの一覧を示します。

           delete-char
               カーソルのところにある文字を削除します。引数を与えた場合は
               kill-char コマンドと同じ動作をします。

               vi-insert, emacs
                   \X

           delete-bigword
               カーソルのところにある bigword を削除します。引数を与えた場合は
               kill-bigword コマンドと同じ動作をします。

           delete-semiword
               カーソルのところにある semiword
               を削除します。引数を与えた場合は kill-semiword
               コマンドと同じ動作をします。

           delete-viword
               カーソルのところにある viword を削除します。引数を与えた場合は
               kill-viword コマンドと同じ動作をします。

           delete-emacsword
               カーソルのところにある emacsword
               を削除します。引数を与えた場合は kill-emacsword
               コマンドと同じ動作をします。

           backward-delete-char
               カーソルの前にある文字を削除します。引数を与えた場合は
               backward-kill-char コマンドと同じ動作をします。

               vi-insert, emacs
                   \B, \?, \^H

           backward-delete-bigword
               カーソルの前にある bigword を削除します。引数を与えた場合は
               backward-kill-bigword コマンドと同じ動作をします。

           backward-delete-semiword
               カーソルの前にある semiword を削除します。引数を与えた場合は
               backward-kill-semiword コマンドと同じ動作をします。

               vi-insert
                   \^W

           backward-delete-viword
               カーソルの前にある viword を削除します。引数を与えた場合は
               backward-kill-viword コマンドと同じ動作をします。

           backward-delete-emacsword
               カーソルの前にある emacsword を削除します。引数を与えた場合は
               backward-kill-emacsword コマンドと同じ動作をします。

           delete-line
               バッファの内容を全て削除します。

           forward-delete-line
               カーソル以降の全ての文字を削除します。

           backward-delete-line
               カーソルより前の全ての文字を削除します。

               vi-insert
                   \$, \^U

           kill-char
               カーソルのところにある文字を削除し、キルリングに保管します。

               vi-command
                   x, \X

           kill-bigword
               カーソルのところにある bigword
               を削除し、キルリングに保管します。

           kill-semiword
               カーソルのところにある semiword
               を削除し、キルリングに保管します。

           kill-viword
               カーソルのところにある viword
               を削除し、キルリングに保管します。

           kill-emacsword
               カーソルのところにある emacsword
               を削除し、キルリングに保管します。

               emacs
                   \^[d, \^[D

           backward-kill-char
               カーソルの前にある文字を削除し、キルリングに保管します。

               vi-command
                   X

           backward-kill-bigword
               カーソルの前にある bigword を削除し、キルリングに保管します。

               emacs
                   \^W

           backward-kill-semiword
               カーソルの前にある semiword を削除し、キルリングに保管します。

           backward-kill-viword
               カーソルの前にある viword を削除し、キルリングに保管します。

           backward-kill-emacsword
               カーソルの前にある emacsword を削除し、キルリングに保管します。

               emacs
                   \^[\B, \^[\?, \^[\^H

           kill-line
               バッファの内容を全て削除し、キルリングに保管します。

           forward-kill-line
               カーソル以降の全ての文字を削除し、キルリングに保管します。

               emacs
                   \^K

           backward-kill-line
               カーソルより前の全ての文字を削除し、キルリングに保管します。

               emacs
                   \$, \^U, \^X\B, \^X\?

           put-before
               最後にキルリングに保管した文字列をカーソルの直前に挿入します。カーソルは挿入した文字列の最後の文字のところに移動します。

               vi-command
                   P

           put
               最後にキルリングに保管した文字列をカーソルの直後に挿入します。カーソルは挿入した文字列の最後の文字のところに移動します。

               vi-command
                   p

           put-left
               最後にキルリングに保管した文字列をカーソルの直前に挿入します。カーソルは挿入した文字列の直後に移動します。

               emacs
                   \^Y

           put-pop
               このコマンドは put-before, put, put-left, put-pop
               コマンドの直後にだけ使えます。このコマンドは直前のコマンドでキルリングから挿入した文字列を削除し、代わりにその文字列の前にキルリングに保管した文字列を挿入します。

               emacs
                   \^[y, \^[Y

           undo
               直前の編集コマンドを取り消し、バッファの内容を前の状態に戻します。

               vi
                   u

               emacs
                   \^_, \^X\$, \^X\^U

           undo-all
               全ての編集コマンドを取り消し、バッファの内容を初期状態に戻します。

               vi
                   U

               emacs
                   \^[\^R, \^[r, \^[R

           cancel-undo
               undo, undo-all
               による編集コマンドの取り消しを取り消し、バッファの内容を復元します。

               vi
                   \^R

           cancel-undo-all
               undo, undo-all
               による編集コマンドの取り消しを全て取り消し、バッファの内容を復元します。

           redo
               直前の編集コマンドを繰り返します。

               vi-command
                   .

       補

           complete
               現在のカーソル位置で補完を行います。補完候補が複数ある場合はその一覧を表示します。

           complete-next-candidate
               補完候補の一覧を既に表示している場合は一覧の中から次の候補を選択します。それ以外の場合は
               complete コマンドと同じ動作をします。

               vi-insert, emacs
                   \^I

           complete-prev-candidate
               補完候補の一覧を既に表示している場合は一覧の中から前の候補を選択します。それ以外の場合は
               complete コマンドと同じ動作をします。

               vi-insert, emacs
                   \bt

           complete-next-column
               補完候補の一覧を既に表示している場合は一覧の中から次の列の最初の候補を選択します。それ以外の場合は
               complete コマンドと同じ動作をします。

           complete-prev-column
               補完候補の一覧を既に表示している場合は一覧の中から前の列の最初の候補を選択します。それ以外の場合は
               complete コマンドと同じ動作をします。

           complete-next-page
               補完候補の一覧を既に表示している場合は一覧の中から次のページの最初の候補を選択します。それ以外の場合は
               complete コマンドと同じ動作をします。

           complete-prev-page
               補完候補の一覧を既に表示している場合は一覧の中から前のページの最初の候補を選択します。それ以外の場合は
               complete コマンドと同じ動作をします。

           complete-list
               現在のカーソル位置で補完を行います。引数を指定しない場合、補完候補の一覧を表示します。引数を指定すると、その番号の候補で補完内容を確定します。

               emacs
                   \^[?, \^[=

           complete-all
               現在のカーソル位置で補完を行い、カーソル位置にある単語をすべての補完候補で置き換えます。

               emacs
                   \^[*

           complete-max
               現在のカーソル位置で補完を行い、各補完候補の最長共通先頭部分をカーソル位置に挿入します。

           complete-max-then-list
               一回目はまず complete-max
               コマンドと同様に共通部分を挿入します。二回目以降は complete
               コマンドと同様に候補の一覧を表示します。

           complete-max-then-next-candidate
               一回目はまず complete-max
               コマンドと同様に共通部分を挿入します。二回目以降は
               complete-next-candidate コマンドと同様に候補を選択します。

           complete-max-then-prev-candidate
               一回目はまず complete-max
               コマンドと同様に共通部分を挿入します。二回目以降は
               complete-prev-candidate コマンドと同様に候補を選択します。

           clear-candidates
               補完候補の一覧を消去します。

       Vi 固

           vi-replace-char
               カーソルのところにある文字を、このコマンドの直後に入力した文字に置き換えます。

               vi-command
                   r

           vi-insert-beginning
               カーソルをバッファの先頭に移動したのち、setmode-viinsert
               コマンドと同じ動作をします。

               vi-command
                   I

           vi-append
               カーソルを次の文字に移動したのち、setmode-viinsert
               コマンドと同じ動作をします。

               vi-command
                   I

           vi-append-to-eol
               カーソルをバッファの末尾に移動したのち、setmode-viinsert
               コマンドと同じ動作をします。

               vi-command
                   A

           vi-replace
               Setmode-viinsert
               コマンドと同じ動作をしますが、同時に上書きモードを有効にします。上書きモードでは、self-insert
               コマンドは文字を挿入する代わりにカーソルのところにある文字を置き換えます。上書きモードは編集モードを変更するまで有効です。

               vi-command
                   R

           vi-switch-case
               このコマンドの直後には移動コマンドを入力する必要があります。移動コマンドが動かしたカーソルの範囲にある文字の大文字と小文字を入れ替えます。

           vi-switch-case-char
               カーソルのところにある文字の大文字と小文字を入れ替えて、カーソルを次の文字に移動します。

               vi-command
                   ~

           vi-yank
               このコマンドの直後には移動コマンドを入力する必要があります。移動コマンドが動かしたカーソルの範囲にある文字をキルリングに保管します。

               vi-command
                   y

           vi-yank-to-eol
               カーソルの位置からバッファの末尾までにある文字をキルリングに保管します。

               vi-command
                   Y

           vi-delete
               このコマンドの直後には移動コマンドを入力する必要があります。移動コマンドが動かしたカーソルの範囲にある文字を削除し、キルリングに保管します。

               vi-command
                   d

           vi-delete-to-eol
               カーソルの位置からバッファの末尾までにある文字を削除し、キルリングに保管します。

               vi-command
                   D

           vi-change
               このコマンドの直後には移動コマンドを入力する必要があります。移動コマンドが動かしたカーソルの範囲にある文字を削除し、その後編集モードを
               vi 風編集モードの挿入モードに変更します。

               vi-command
                   c

           vi-change-to-eol
               カーソルの位置からバッファの末尾までにある文字を削除し、その後編集モードを
               vi 風編集モードの挿入モードに変更します。

               vi-command
                   C

           vi-change-line
               バッファの内容を全て削除し、その後編集モードを vi
               風編集モードの挿入モードに変更します。

               vi-command
                   S

           vi-yank-and-change
               Vi-change
               コマンドと同様ですが、削除した文字列はキルリングに補完されます。

           vi-yank-and-change-to-eol
               Vi-change-to-eol
               コマンドと同様ですが、削除した文字列はキルリングに補完されます。

           vi-yank-and-change-line
               Vi-change-line
               コマンドと同様ですが、削除した文字列はキルリングに補完されます。

           vi-substitute
               カーソルのところにある文字を削除しキルリングに保管した後、編集モードを
               vi 風編集モードの挿入モードに変更します。

               vi-command
                   s

           vi-append-last-bigword
               コマンド履歴の中で最も新しいコマンドにおける最後の bigword
               を、空白文字に続けてカーソルの位置の直後に挿入します。引数 n
               を与えたときは最後の bigword の代わりに n 番目の bigword
               を挿入します。その後、setmode-viinsert
               コマンドと同じ動作をします。

               vi-command
                   _

           vi-exec-alias
               このコマンドの直後に入力した文字を c とすると、_c
               という名前のエイリアスの内容をシェルへの入力とみなして行編集コマンドとして解釈・実行します。

               vi-command
                   @

           vi-edit-and-accept
               エディタとして vi
               を起動し、バッファの内容を編集させます。エディタが終了すると編集後の内容をバッファに反映した後
               accept-line
               コマンドと同じ動作をします。ただしエディタの終了ステータスが 0
               でないときは何も行いません。

               vi-command
                   v

           vi-complete-list
               Complete-list
               コマンドと同様ですが、候補を確定したとき編集モードを vi
               風編集モードの挿入モードに変更します。

               vi-command
                   =

           vi-complete-all
               Complete-all
               コマンドと同様ですが、単語を置き換えた後、編集モードを vi
               風編集モードの挿入モードに変更します。

               vi-command
                   *

           vi-complete-max
               Complete-max
               コマンドと同様ですが、候補を挿入した後、編集モードを vi
               風編集モードの挿入モードに変更します。

               vi-command
                   \\

           vi-search-forward
               順方向の履歴検索を開始します。編集モードを vi
               風編集モードの検索モードに変更します。

               vi-command
                   ?

           vi-search-backward
               逆方向の履歴検索を開始します。編集モードを vi
               風編集モードの検索モードに変更します。

               vi-command
                   /

       Emacs 固

           emacs-transpose-chars
               カーソルの前にある文字を右に移動します。

               emacs
                   \^T

           emacs-transpose-words
               カーソルの前にある emacsword を右に移動します。

               emacs
                   \^[t, \^[T

           emacs-downcase-word
               カーソルの後にある emacsword を小文字に変換します。

               emacs
                   \^[l, \^[L

           emacs-upcase-word
               カーソルの後にある emacsword を大文字に変換します。

               emacs
                   \^[u, \^[U

           emacs-capitalize-word
               カーソルの後にある emacsword をキャピタライズします
               (各単語の頭文字だけ大文字にする)。

               emacs
                   \^[c, \^[u

           emacs-delete-horizontal-space
               カーソルの前後にある空白を削除します。引数を与えるとカーソルの前にある空白を削除します。

               emacs
                   \^[\\

           emacs-just-one-space
               カーソルの前後にある空白の個数を一つに調整します。引数を与えるとその引数の数だけ空白を残します。

               emacs
                   \^[ (エスケープの後に空白文字)

           emacs-search-forward
               順方向の履歴検索を開始します。編集モードを emacs
               風編集モードの検索モードに変更します。

               emacs
                   \^S

           emacs-search-forward-current
               emacs-search-forward
               と同様ですが、現在のバッファの内容をそのまま検索キーワードとして入力済みの状態にします。

           emacs-search-backward
               順方向の履歴検索を開始します。編集モードを emacs
               風編集モードの検索モードに変更します。

               emacs
                   \^R

           emacs-search-backward-current
               emacs-search-backward
               と同様ですが、現在のバッファの内容をそのまま検索キーワードとして入力済みの状態にします。

       コ

           oldest-history
               コマンド履歴の中で最も古いコマンドに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルの位置は変わりません。

           newest-history
               コマンド履歴の中で最も新しいコマンドに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルの位置は変わりません。

           return-history
               コマンド履歴のどのコマンドにも対応しない新規バッファに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルの位置は変わりません。

           oldest-history-bol
               コマンド履歴の中で最も古いコマンドに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルはバッファの先頭に移動します。

               vi-command
                   G

           newest-history-bol
               コマンド履歴の中で最も新しいコマンドに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルはバッファの先頭に移動します。

           return-history-bol
               コマンド履歴のどのコマンドにも対応しない新規バッファに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルはバッファの先頭に移動します。

               vi-command
                   g

           oldest-history-eol
               コマンド履歴の中で最も古いコマンドに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルはバッファの末尾に移動します。

               emacs
                   \^[<

           newest-history-eol
               コマンド履歴の中で最も新しいコマンドに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルはバッファの末尾に移動します。

           return-history-eol
               コマンド履歴のどのコマンドにも対応しない新規バッファに移動します。引数を与えるとそれを履歴番号とみなしてその番号のコマンドに移動します。カーソルはバッファの末尾に移動します。

               emacs
                   \^[>

           next-history
               コマンド履歴の中で次のコマンドに移動します。カーソルの位置は変わりません。

           prev-history
               コマンド履歴の中で前のコマンドに移動します。カーソルの位置は変わりません。

           next-history-bol
               コマンド履歴の中で次のコマンドに移動します。カーソルはバッファの先頭に移動します

               vi-command
                   j, +, \D, \^N

           prev-history-bol
               コマンド履歴の中で前のコマンドに移動します。カーソルはバッファの先頭に移動します

               vi-command
                   k, -, \U, \^P

           next-history-eol
               コマンド履歴の中で次のコマンドに移動します。カーソルはバッファの末尾に移動します

               vi-insert, emacs
                   \D, \^N

           prev-history-eol
               コマンド履歴の中で前のコマンドに移動します。カーソルはバッファの末尾に移動します

               vi-insert, emacs
                   \U, \^P

           search-again
               最後に行ったコマンド履歴検索をもう一度行います。

               vi-command
                   n

           search-again-rev
               最後に行ったコマンド履歴検索を方向を逆にしてもう一度行います。

               vi-command
                   N

           search-again-forward
               最後に行ったコマンド履歴検索を順方向にもう一度行います。

           search-again-backward
               最後に行ったコマンド履歴検索を逆方向にもう一度行います。

           beginning-search-forward
               コマンド履歴を順方向に検索し、バッファの先頭から現在のカーソル位置までの間にある文字列が同じ次のコマンドに移動します。カーソル位置は変わりません。

           beginning-search-backward
               コマンド履歴を逆方向に検索し、バッファの先頭から現在のカーソル位置までの間にある文字列が同じ前のコマンドに移動します。カーソル位置は変わりません。

       コ

           srch-self-insert
               入力した文字を検索用バッファに挿入します。(エスケープシーケンスによるエスケープの対象となる文字は挿入できません)

               vi-search, emacs-search
                   \\

           srch-backward-delete-char
               検索用バッファの最後の一文字を削除します。検索用バッファが空の場合は:

               •   vi 風編集モードでは srch-abort-search
                   コマンドと同じ動作をします。

               •   emacs 風編集モードでは alert コマンドと同じ動作をします。

               vi-search, emacs-search
                   \B, \?, \^H

           srch-backward-delete-line
               検索用バッファの内容を全て削除します。

               vi-search, emacs-search
                   \$, \^U

           srch-continue-forward
               現在表示している暫定検索結果の次の結果を順方向に探します。

               emacs-search
                   \^S

           srch-continue-backward
               現在表示している暫定検索結果の次の結果を逆方向に探します。

               emacs-search
                   \^R

           srch-accept-search
               検索を終了し、現在表示している暫定検索結果を確定します。検索結果に移動します。

               vi-search
                   \^J, \^M, \et

               emacs-search
                   \^J, \^[

           srch-abort-search
               検索を中止し、検索を開始する前の状態に戻ります。

               vi-search
                   \^[

               emacs-search
                   \^G

   エ
       Bindkey
       コマンドで行編集のキー設定を表示・設定する際、ファンクションキーなどの特殊なキーはエスケープシーケンスで表わします。エスケープシーケンスは全てバックスラッシュ
       (\)
       で始まります。またバックスラッシュそのものもエスケープの対象です。エスケープシーケンスに対するキーの割り当ては以下の通りです。

       \\
           バックスラッシュ (\)

       \B
           Backspace

       \D
           ↓矢印キー

       \E
           End

       \H
           Home

       \I
           Insert (Insert-char, Enter-insert-mode)

       \L
           ←矢印キー

       \N
           Page-down (Next-page)

       \P
           Page-up (Previous-page)

       \R
           →矢印キー

       \U
           ↑矢印キー

       \X
           Delete

       \!
           INTR

       \#
           EOF

       \$
           KILL

       \?
           ERASE

       \^@
           Ctrl + @

       \^A, \^B, ..., \^Z
           Ctrl + A, Ctrl + B, ..., Ctrl + Z

           ※ Ctrl + I は Tab、Ctrl + J は Newline、Ctrl + M は Carriage-return
           です。

       \^[
           Ctrl + [ (Escape)

       \^\
           Ctrl + \

       \^]
           Ctrl + ]

       \^^
           Ctrl + ^

       \^_
           Ctrl + _

       \^?
           Ctrl + ? (Delete)

       \F00, \F01, ..., \F63
           F0, F1, ..., F63

       \a1
           キーパッドの左上キー

       \a3
           キーパッドの右上キー

       \b2
           キーパッドの中央キー

       \bg
           Beginning

       \bt
           Back-tab

       \c1
           キーパッドの左下キー

       \c3
           キーパッドの右下キー

       \ca
           Clear-all-tabs

       \cl
           Close

       \cn
           Cancel

       \co
           Command

       \cp
           Copy

       \cr
           Create

       \cs
           Clear-screen または erase

       \ct
           Clear-tab

       \dl
           Delete-line

       \ei
           Exit-insert-mode

       \el
           Clear-to-end-of-line

       \es
           Clear-to-end-of-screen

       \et
           Enter (Send)

       \ex
           Exit

       \fd
           Find

       \hp
           Help

       \il
           Insert-line

       \ll
           Home-down

       \me
           Message

       \mk
           Mark

       \ms
           マウスイベント

       \mv
           Move

       \nx
           Next-object

       \on
           Open

       \op
           Options

       \pr
           Print (Copy)

       \pv
           Previous-object

       \rd
           Redo

       \re
           Resume

       \rf
           Ref (Reference)

       \rh
           Refresh

       \rp
           Replace

       \rs
           Restart

       \sf
           Scroll-forward (Scroll-down)

       \sl
           Select

       \sr
           Scroll-backward (Scroll-up)

       \st
           Set-tab

       \su
           Suspend

       \sv
           Save

       \ud
           Undo

       \SE
           Shift + End

       \SH
           Shift + Home

       \SI
           Shift + Insert

       \SL
           Shift + ←矢印キー

       \SR
           Shift + →矢印キー

       \SX
           Shift + Delete

       \Sbg
           Shift + Beginning

       \Scn
           Shift + Cancel

       \Sco
           Shift + Command

       \Scp
           Shift + Copy

       \Scr
           Shift + Create

       \Sdl
           Shift + Delete-line

       \Sel
           Shift + End-of-line

       \Sex
           Shift + Exit

       \Sfd
           Shift + Find

       \Shp
           Shift + Help

       \Smg
           Shift + Message

       \Smv
           Shift + Move

       \Snx
           Shift + Next

       \Sop
           Shift + Options

       \Spr
           Shift + Print

       \Spv
           Shift + Previous

       \Srd
           Shift + Redo

       \Sre
           Shift + Resume

       \Srp
           Shift + Replace

       \Ssu
           Shift + Suspend

       \Ssv
           Shift + Save

       \Sud
           Shift + Undo

       INTR, EOF, KILL, ERASE の四つは stty
       コマンドなどで設定される端末の特殊文字です。一般的な環境では、INTR は
       Ctrl + C に、EOF は Ctrl + D に、KILL は Ctrl + U に、ERASE は Ctrl + H
       または Ctrl + ?
       に設定されています。これら四つは他のキー入力よりも優先して認識されます。

   コ
       行編集でコマンドを入力している途中で Tab
       キーを押すことで、コマンドの名前やオプション、引数を補完することができます。コマンド名やファイル名を途中まで打ち込んだところで
       Tab
       キーを押すと、その名前に一致するコマンド名やファイル名の一覧が現れます。さらに続けて
       Tab
       キーを押すと、入力したい名前を一覧の中から選ぶことができます。(一致する名前が一つしかない場合は、一覧は現れず、直接名前がコマンドラインに入力されます。)

       補完の対象となる名前に * や ?
       などの文字が入っている場合は、そのパターンに一致する名前全てがコマンドラインに展開されます。(一覧による選択はできません)

       標準状態では、コマンド名を入力しているときはコマンド名が、コマンドの引数を入力しているときはファイル名が補完されます。しかし補完を行う関数
       (補完関数) を定義することで補完内容を変更することができます。

       補

           シェルを起動してから初めて補完を行おうとしたとき、コマンド . -AL
           completion/INIT を実行するのと同様にして、ファイル completion/INIT
           をロードパスから読み込みます。ファイルが見つからない場合は、そのまま補完動作を続けます。(この処理は主にシェルに付属している補完関数を読み込むためのものですが、ロードパス内に自分で用意したファイルを置いておくことで代わりにそれを読み込ませることもできます。)

           補完は、対象に応じて以下のように行います。

           コマンド名
               関数 completion//command
               が定義されている場合は、それを補完関数として実行します。定義されていない場合は、入力中の単語をコマンド名として補完します。

           コマンドの引数
               関数 completion//argument
               が定義されている場合は、それを補完関数として実行します。定義されていない場合は、入力中の単語をファイル名として補完します。

           この他、チルダ展開におけるユーザ名やパラメータ展開におけるパラメータ名を入力しているときは、ユーザ名やパラメータ名が常に補完されます。(補完のしかたを変更することはできません)

           補完関数は普通の関数と同様に (位置パラメータなしで)
           実行されます。ただし、補完関数の実行時には以下のローカル変数が自動的に設定されます。

           IFS
               空白文字・タブ・改行の三文字 (シェル起動時のデフォルト)

           WORDS
               既に入力されているコマンド名とコマンドの引数を含む配列です。コマンド名を補完しようとしているときは、この配列は空になります。

           TARGETWORD
               現在補完を行おうとしている、途中まで入力されたコマンド名またはコマンドの引数です。

           補完関数の中で complete
           組込みコマンドを実行することで、補完候補が生成されます。シェルは補完関数実行中に生成された補完候補を用いて補完を行います。

           補完関数の実行中は、端末に対して入出力を行ってはなりません
           (端末の表示が乱れてしまいます)。スムーズな補完を行うために、補完の実行中に長い時間のかかる処理を行うのは避けてください。

           補完の実行中は、POSIX 準拠モードと err-return
           オプションが強制的に解除されます。また err-exit
           オプションは無視され、トラップは実行されません。

   コ
       コマンドライン推定は実験的な機能です。Le-predict
       オプションが有効なとき、行編集で入力したコマンドの部分に続けて入力されそうなコマンド文字列を推定します。

       例えば、あなたは既に一度 ls Documents
       というコマンドを実行したとします。次にあなたが ls Doc
       と打ったとき、シェルはカーソルの直後に uments
       と表示します。入力しようとしているコマンドがこの通りなら、コマンドを打ち続ける代わりにカーソルを右に動かす
       (forward-char コマンドを始めどの移動コマンドでも構いません)
       ことでコマンドを入力できます。最後の s
       の後ろまでカーソルを動かした後、accept-line
       コマンドでコマンドを実行できます。あるいは、カーソルを動かさなくても
       accept-prediction
       コマンドを使えば推定されたコマンドを直接実行できます。

       打ったコマンドと推定されたコマンドの部分を区別するために、PS1S および
       PS1P 変数を設定してコマンドのフォントの表示を変更することができます。

       カーソルを右に動かしたとき、カーソルを動かした位置までの部分は実際に打ったのと同様に取り扱われます。しかしその後カーソルを左に戻しても入力を取り消したことにはなりません。推定機能を使っているかどうかに関係なく、backward-delete-char
       などのコマンドで文字を削除する必要があります。

       コマンドの推定はカーソルが入力中のコマンドの末尾にあるときのみ機能します。

       デフォルトでは、コマンドを打ち始めると推定が行われます。Le-predict-empty
       オプションを有効にするとコマンドを一文字も入力する前から推定されたコマンドが表示されます。

       推定アルゴリズムはコマンド履歴に基づいてコマンドを推定します。より新しい履歴はより確率が高いと判断します。また複数行に亘るコマンドの出現パターンも考慮します。確率が十分に高いと判断した部分のみを推定結果として表示するため、推定結果は必ずしも完全なコマンドにはなりません。

POSIX 準
       Yash は基本的に POSIX.1-2024
       のシェルの規定に従って動作しますが、利便性や分かりやすさのために POSIX
       の規定とは異なる動作をする点もあります。そのため標準状態の yash は
       POSIX の規定するシェルとして供するには向きません。POSIX
       準拠モードを有効にすると、yash はできる限り POSIX
       の規定通りに動作するようになります。POSIX
       準拠シェルとしての互換性が必要な場面では、POSIX
       準拠モードを有効にしてください。

       シェルの起動時の起動時の名前が sh ならばシェルは自動的に POSIX
       準拠モードになります。また起動時に -o posixlycorrect
       オプションが指定されている場合も POSIX
       準拠モードになります。また起動後は、set -o posixlycorrect
       を実行することで POSIX 準拠モードを有効にできます。

       POSIX 準拠モードを有効にすると、yash は POSIX
       の規定にできるだけ従うようになるだけでなく、POSIX
       が未定義や未規定と定めている場合のほとんどをエラーにするようになります。すなわち、yash
       独自の拡張機能の多くは使えなくなります。具体的には、POSIX
       準拠モードを有効にすると以下のような挙動の変化があります。

       •   シェルの起動時の初期化で読み込むスクリプトファイルが異なります。

       •   シェルが -c オプションで起動された場合、構文エラー時に yash -c
           の代わりに sh -c をファイル名として表示します。

       •   グローバルエイリアスの置換を行いません。

       •   複合コマンドのグルーピングや if
           文の内容が空の場合エラーになります。

       •   For ループで展開した単語は for-local
           オプションに関係なくグローバル変数として代入します。変数名はポータブルな
           (すなわち ASCII の範囲内の) 文字しか使えません。

       •   Case 文の caseitem を ;| または ;;& で区切ることはできません。

       •   予約語 ! の直後に空白を置かずに ( を置くことはできません。

       •   二重ブラケットコマンドは使えません。

       •   予約語 function
           を用いる形式の関数定義構文は使えません。関数名はポータブルな
           (すなわち ASCII の範囲内の) 文字しか使えません。

       •   単純コマンドでの配列の代入はできません。

       •   シェル実行中に LC_CTYPE
           変数の値が変わっても、それをシェルのロケール情報に反映しません。

       •   RANDOM 変数は使えません。

       •   LINENO, OLDPWD, OPTARG, OPTIND, PWD
           の各変数は読み取り専用にできません。

       •   チルダ展開で ~ と ~ユーザ名 以外の形式の展開が使えません。

       •   パラメータ展開の入れ子はできません。またインデックスおよび単語2のある加工指定は使用できません。

       •   $( と )
           で囲んだコマンド置換に含まれるコマンドは、コマンド置換が実行される時に毎回解析されます。

       •   数式展開で小数ならびに ++ および --
           演算子が使えません。数値でない変数は常にエラーになります。

       •   リダイレクトの対象を示すトークンは次のリダイレクトのファイル記述子を示す整数と紛らわしくないようにしなければなりません。

       •   リダイレクトを伴う複合コマンドの直後に } や fi
           などの予約語を置くことはできません。

       •   ファイルのリダイレクトで、パス名展開の結果が何もない場合、すぐにはエラーにせず、パス名展開を行わなかったときと同様に扱います。

       •   <& および >&
           リダイレクト演算子の対象となるファイル記述子はそれぞれ読み込み可能および書き込み可能でなければなりません。

       •   ソケットリダイレクト・ヒアストリング・パイプリダイレクト・プロセスリダイレクトは使用できません。

       •   単純コマンドの実行時、コマンドが見つからなくても
           COMMAND_NOT_FOUND_HANDLER 変数の値は実行しません。

       •   任意組込みコマンドおよび拡張組込みコマンドは実行できません。

       •   いくつかの組込みコマンドで特定のオプションが使えなくなるなど挙動が変わります。特に、長いオプションは使えなくなります。

       •   対話モードでないとき、特殊組込みコマンドのオプションやオペランドの使い方が間違っているとシェルは直ちに終了します。また特殊組込みコマンドで代入エラーやリダイレクトエラーが発生したときも直ちに終了します。

       •   対話モードのプロンプトを出す前後に PROMPT_COMMAND 変数および
           POST_PROMPT_COMMAND 変数の値を実行しません。PS1 変数・PS2 変数・PS4
           変数の値の解釈の仕方が違います。YASH_PS1 など YASH_
           で始まる名前のプロンプト変数は使用されません。

       •   メールチェックにおいて、ファイルが更新されている場合はファイルが空でも新着メールメッセージを出力します。

よ
   Unicode (非
       Unicode 文字を使えるようにするにはロケール環境変数の設定が必要です。

       既に環境変数があなたの使用したいロケールに合わせて設定されている場合は、特に何もする必要はありません。現在の設定を確認するには、locale
       コマンドを使用してください。

           $ locale
           LANG=ja_JP.utf8
           LC_CTYPE="ja_JP.utf8"
           LC_NUMERIC="ja_JP.utf8"
           LC_TIME="ja_JP.utf8"
           LC_COLLATE="ja_JP.utf8"
           LC_MONETARY="ja_JP.utf8"
           LC_MESSAGES="ja_JP.utf8"
           LC_PAPER="ja_JP.utf8"
           LC_NAME="ja_JP.utf8"
           LC_ADDRESS="ja_JP.utf8"
           LC_TELEPHONE="ja_JP.utf8"
           LC_MEASUREMENT="ja_JP.utf8"
           LC_IDENTIFICATION="ja_JP.utf8"
           LC_ALL=

       この例の locale
       コマンドの出力結果は、各ロケール設定カテゴリーについて、言語が日本語、地域が日本、エンコーディングが
       UTF-8 に設定されていることを示しています。

       現在の設定が自分の使いたいロケール設定に合っていない場合は、LC_ALL
       変数を以下の様に設定してください。

           export LC_ALL=ja_JP.utf8

       この例とは異なる言語・地域・エンコーディングの設定を使いたい場合は、設定値を変える必要があります。詳しくは、お使いのオペレーティングシステムの説明書を参照してください。

       Yash を起動する度に同じ設定を自動的に適用するには、上記のコマンドを
       $XDG_CONFIG_HOME/yash/rc か $XDG_CONFIG_HOME/yash/profile
       に書いてください。 従来のファイルパス ~/.yashrc および ~/.yash_profile
       も引き続きサポートされています。

       上記の設定をしてもなお Unicode
       文字が正しく入力できない場合は、以下の行編集に関する項目を読んでください。

   行
       まず、echo $TERM
       を実行して出力される値が正常かどうか調べてください。値が xterm
       なら、おそらくどんな環境でも最低限の機能は使えるはずです。
       xterm-16color などの色が使えるバージョンや、rxvt や vt100
       などの他の端末機種も大概は動きます。利用可能な全ての値を列挙するには
       toe コマンドを使用してください。
       お使いの端末機種に合った値を設定するのが理想ですが、yash
       を実行しようとしている環境がその端末機種に対応していない場合はうまく動かないかもしれません。その場合は、export
       TERM=xterm などを実行して TERM の値を変えてみてください。

       行編集自体は動いているが Unicode (非 ASCII)
       文字の入力に問題がある場合は、set -o le-no-conv-meta を実行して
       le-no-conv-meta オプションを有効にしてみてください。

構
       ここにプログラミング言語としてのシェルの構文定義を示します。

           注

           以下に示す構文の一部は POSIX 準拠モードでは使用できません。

   ト
       入力ソースコードの文字列はまずトークンに分割されます。トークンはソースコード内のより先に現れるトークンができるだけ長くなるように分割します。一つ以上の空白
       (blank) 文字の連なりはトークンを分割します。

       Yash に存在する演算子トークンは以下の通りです:

       & && ( ) ; ;; | || < << <& <( <<- <<< <> > >> >& >( >>| >| (改行)

           注

           他の一般的なプログラミング言語とは異なり、改行演算子は空白ではなくトークンとして扱われます。

       空白ではなく演算子トークンの一部でもない文字は単語 (word)
       トークンとなります。単語は以下の解析表現文法によって解析されます。

       Word
           (WordElement / !SpecialChar .)+

       WordElement
           \ . /

           ' (!' .)* ' /

           " QuoteElement* " /

           Parameter /

           Arithmetic /

           CommandSubstitution

       QuoteElement
           \ ([$`"\] / <改行>) /

           Parameter /

           Arithmetic /

           CommandSubstitutionQuoted /

           ![`"\] .

       Parameter
           $ [@*#?-$! [:digit:]] /

           $ PortableName /

           $ ParameterBody

       PortableName
           ![0-9] [0-9 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_]+

       ParameterBody
           { ParameterNumber? (ParameterName / ParameterBody / $ ParameterBody
           / Arithmetic / CommandSubstitution) ParameterIndex?
           ParameterMatch?  }

       ParameterNumber
           # ![}+=:/%] !([-?#] !})

       ParameterName
           [@*#?-$!] /

           [[:alnum:] _]+

       ParameterIndex
           [ ParameterIndexWord (, ParameterIndexWord)?  ]

       ParameterIndexWord
           (WordElement / !["'],] .)+

       ParameterMatch
           :? [-+=?] ParameterMatchWord /

           (# / ## / % / %%) ParameterMatchWord /

           (:/ / / [#%/]?)  ParameterMatchWordNoSlash (/ ParameterMatchWord)?

       ParameterMatchWord
           (WordElement / !["'}] .)*

       ParameterMatchWordNoSlash
           (WordElement / !["'/}] .)*

       Arithmetic
           $(( ArithmeticBody* ))

       ArithmeticBody
           \ . /

           Parameter /

           Arithmetic /

           CommandSubstitution /

           ( ArithmeticBody ) /

           ![`()] .

       CommandSubstitution
           $( CompleteProgram ) /

           ` CommandSubstitutionBody* `

       CommandSubstitutionQuoted
           $( CompleteProgram ) /

           ` CommandSubstitutionBodyQuoted* `

       CommandSubstitutionBody
           \ [$`\] /

           !` .

       CommandSubstitutionBodyQuoted
           \ [$`\`] /

           !` .

       SpecialChar
           [|&;<>()`\"' [:blank:]] / <改行>

       この文法における終端記号の集合は、yash
       を実行する環境が扱える任意の文字の集合 (実行文字集合) です
       (ただしナル文字 '\0' を除く)。

       厳密には、上記の文法定義は完全な解析表現文法ではありません。CommandSubstitution
       (Quoted) のルールが構文定義の非終端記号である CompleteProgram
       に依存しているためです。

       ト

           単語トークンが生成された後、単語はさらに IO_NUMBER
           トークン・予約語・名前・代入・通常の単語のどれかに分類されます。通常の単語以外の分類は、その単語が現れる文脈においてその分類のトークンが現れ得る場合のみ採用されます。予約語の一覧と予約語が認識される文脈の要件は、トークンの解析と予約語を参照してください。

           トークンが数字のみから構成されていて直後に < または >
           が続くとき、それは IO_NUMBER トークンとなります。

           代入 (assignment) トークンは名前 (name) とそれに続く =
           で始まるトークンです:

           AssignmentWord
               AssignmentPrefix Word

           AssignmentPrefix
               Name =

           Name
               ![[:digit:]] \[[:alnum:] _]+

       コ

           コメントは #
           で始まり、次の改行文字の直前まで続きます。コメントは空白と同様に扱われ、トークンの一部にはなりません。コメントを開始する
           #
           は、トークンの始まりの位置にあるときのみ有効です。それ以外の位置にある
           # は単に単語トークンの一部と見做されます。

           Comment
               # (!<改行> .)*

   構
       トークンが分割された後、その結果であるトークンの並びは以下に示す文脈自由文法によって解析されます。(以下、*
       と + と ? は正規表現と同様の意味を持ちます)

       CompleteProgram
           NL* | CompoundList

       CompoundList
           NL* AndOrList ((; | & | NL) CompleteProgram)?

       AndOrList
           Pipeline ((&& | ||) NL* Pipeline)*

       Pipeline
           !?  Command (| NL* Command)*

       Command
           CompoundCommand Redirection* |

           FunctionDefinition |

           SimpleCommand

       CompoundCommand
           Subshell |

           Grouping |

           IfCommand |

           ForCommand |

           WhileCommand |

           CaseCommand |

           DoubleBracketCommand |

           FunctionCommand

       Subshell
           ( CompoundList )

       Grouping
           { CompoundList }

       IfCommand
           if CompoundList then CompoundList (elif CompoundList then
           CompoundList)* (else CompoundList)?  fi

       ForCommand
           for Name ((NL* in Word*)? (; | NL) NL*)?  do CompoundList done

       WhileCommand
           (while | until) CompoundList do CompoundList done

       CaseCommand
           case Word NL* in NL* CaseList?  esac

       CaseList
           CaseItem (;; NL* CaseList)?

       CaseItem
           (?  Word (| Word)* ) CompleteProgram

       DoubleBracketCommand
           [[ Ors ]]

       Ors
           Ands (|| Ands)*

       Ands
           Nots (&& Nots)*

       Nots
           !* Primary

       Primary
           (-b | -c | -d | -e | -f | -G | -g | -h | -k | -L | -N | -n | -O |
           -o | -p | -r | -S | -s | -t | -u | -w | -x | -z) Word |

           Word (-ef | -eq | -ge | -gt | -le | -lt | -ne | -nt | -ot | -veq |
           -vge | -vgt | -vle | -vlt | -vne | = | == | === | =~ | != | !== | <
           | >) Word |

           ( Ors ) |

           Word

       FunctionCommand
           function Word (( ))?  NL* CompoundCommand Redirection*

       FunctionDefinition
           Name ( ) NL* CompoundCommand Redirection*

       SimpleCommand
           (Assignment | Redirection) SimpleCommand? |

           Word (Word | Redirection)*

       Assignment
           AssignmentWord |

           AssignmentPrefix( NL* (Word NL*)* )

       Redirection
           IO_NUMBER?  RedirectionOperator Word |

           IO_NUMBER?  <( CompleteProgram ) |

           IO_NUMBER?  >( CompleteProgram )

       RedirectionOperator
           < | <> | > | >| | >> | >>| | <& | >& | << | <<- | <<<

       NL
           <改行>

       ルール Primary では、Word トークンは ]]
       に一致してはなりません。また、Primary が Word
       トークンで始まる場合にはその Word
       は同ルールで認められている単項演算子に一致してはなりません。

       ルール SimpleCommand では、Word トークンはそれが Assignment
       の始まりとは解釈できない場合にのみ採用されます。

       ルール Assignment では、AssignmentPrefix と (
       の間に空白を置くことはできません。

       上記の文法定義にはヒアドキュメントの内容とその終わりを表す行の解析のための規則は含まれていません。それらは対応するリダイレクト演算子の後にある最初の改行
       (NL) トークンが解析された直後に解析されます。

       エ

           単語はエイリアス置換の対象となります。

           •   単語が SimpleCommand の Word
               として解析されようとした時に、通常のエイリアス及びグローバルエイリアスを対象として置換が試みられます。

           •   置換結果が空白文字 (blank)
               で終わるエイリアス置換の次に単語トークンがある場合、その単語も通常のエイリアス及びグローバルエイリアスを対象として置換が試みられます。

           •   その他の単語は、グローバルエイリアスのみを対象として置換が試みられます。(POSIX
               準拠モードを除く)

           予約語に分類されたトークンはエイリアス置換の対象からは除外されます。

ALIAS 組
       Alias 組込みコマンドはエイリアスを設定・表示します。

   構
       •   alias [-gp] [エイリアス名[=値]...]

   説
       Alias
       コマンドはエイリアスをオペランドに従って設定または表示します。表示は、コマンド
       (の一部)
       として解釈可能な形式で標準出力に出力します。オペランドを一つも与えない場合、alias
       コマンドは現在設定されている全てのエイリアスを表示します。

   オ
       -g, --global
           このオプションを指定した場合、設定するエイリアスはグローバルエイリアスになります。このオプションを指定しない場合、設定するエイリアスは通常のエイリアスになります。

       -p, --prefix
           このオプションは表示の書式を選択します。このオプションを指定した場合、alias
           コマンドとそのコマンドライン引数全てを表示します。このオプションを指定しない場合、alias
           コマンドに渡すオペランドだけを表示します。

   オ
       エイリアス名
           表示するエイリアスの名前です。

       エイリアス名=値
           設定するエイリアスの名前とその内容です。

   終
       エラーがない限り alias コマンドの終了ステータスは 0 です。

   補
       Yash
       でエイリアスの名前として使えない文字は、空白文字・タブ・改行、および
       =$<>\'"`;&|()#
       の各文字です。エイリアスの内容にはすべての文字が使えます。

       Alias コマンドは必須組込みコマンドです。

       POSIX にはオプションに関する規定はありません。よってオプションは POSIX
       準拠モードでは使えません。

ARRAY 組
       Array 組込みコマンドは配列の表示や操作を行います。

   構
       •   array

       •   array 配列名 [値...]

       •   array -d 配列名 [インデックス...]

       •   array -i 配列名 インデックス [値...]

       •   array -s 配列名 インデックス 値

   説
       オプションもオペランドも指定せずに実行すると、array
       コマンドは全ての配列の定義を (コマンドとして解釈可能な形式で)
       標準出力に出力します。

       オプションを指定せずに配列名と値を与えて実行すると、array
       コマンドはその配列の内容を指定された値に設定します。

       -d (--delete) オプションを指定して実行すると、array
       コマンドは指定した配列の指定したインデックスにある要素を削除します。配列の要素数は削除した要素の分だけ少なくなります。存在しない要素のインデックスを指定したときは無視します。

       -i (--insert) オプションを指定して実行すると、array
       コマンドは指定した配列の指定したインデックスにある要素の直後に指定した値を要素として追加します。配列の要素数は追加した要素の分だけ増えます。インデックス
       として 0
       を指定すると配列の先頭に要素を追加します。インデックスとして配列の要素数より大きな数を指定すると配列の末尾に要素を追加します。

       -s (--set) オプションを指定して実行すると、array
       コマンドは指定した配列の指定したインデックスにある要素の値を指定した値に変更します。

   オ
       -d, --delete
           配列の要素を削除します。

       -i, --insert
           配列に要素を挿入します。

       -s, --set
           配列の要素を変更します。

   オ
       配列名
           表示または操作する配列の名前です。

       インデックス
           配列の要素を指定する自然数です。インデックスは最初の要素から順に 1,
           2, 3, ... と割り振られます。

       値
           配列の要素となる文字列です。

   終
       エラーがない限り array コマンドの終了ステータスは 0 です。

   補
       POSIX には array コマンドに関する規定はありません。 Yash
       ではこれを拡張組込みコマンドとして実装しています。

       array 配列名 [値...] の形式の array コマンドは変数代入を用いて
       配列名=(値...) と書くこともできます。

BG 組
       Bg 組込みコマンドはジョブをバックグラウンドで実行します。

   構
       •   bg [ジョブ...]

   説
       Bg コマンドはジョブをバックグラウンドで実行します。ジョブには SIGCONT
       シグナルが送られ、ジョブが停止している場合は再開されます。

       ジョブの実行を再開する前に bg
       コマンドはジョブの名前を標準出力に出力します。

       Bg コマンドはジョブ制御が有効な時しか使えません。

   オ
       ジョブ
           実行するジョブのジョブ ID。

           ジョブを複数指定することもできます。何も指定しないと現在のジョブを実行します。

           非 POSIX 準拠モードではジョブ ID の先頭の % は省略できます。

   終
       エラーがない限り bg コマンドの終了ステータスは 0 です。

   補
       Bg コマンドは必須組込みコマンドです。

       POSIX は指定したジョブが既に実行中の場合は bg
       コマンドは何もしないと規定していますが、yash の bg
       コマンドはジョブが実行中かどうかにかかわらず SIGCONT
       シグナルを送信します。

BINDKEY 組
       Bindkey
       組込みコマンドは行編集におけるキーバインド設定を表示・設定します。

   構
       •   bindkey -aev [キー [コマンド]]

       •   bindkey -l

   説
       -l (--list) オプションを付けて実行すると、bindkey
       コマンドはキーバインド設定で利用可能な行編集コマンドの一覧を標準出力に出力します。

       他のオプションを付けて実行すると、bindkey
       コマンドはキーバインド設定の表示または設定を行います。

       •   オペランドとしてキー・コマンドを与えない場合、現在のキーバインド設定の内容を
           (コマンドとして解釈可能な形式で) 標準出力に出力します。

       •   キーのみを与えると、そのキーに対する現在の設定だけを出力します。

       •   キーとコマンドを両方与えると、そのキーを入力したときに実行するコマンドを指定したコマンドに設定します。

   オ
       -a, --vi-command
           Vi
           風編集モードのコマンドモードにおけるキーバインドを表示・設定します。

       -e, --emacs
           Emacs 風編集モードにおけるキーバインドを表示・設定します。

       -v, --vi-insert
           Vi 風編集モードの挿入モードにおけるキーバインドを表示・設定します。

   オ
       キー
           表示・設定する対象のキー入力シーケンスです。このオペランドの値にはバックスラッシュで始まるエスケープシーケンスが利用できます。

       コマンド
           設定する行編集コマンドです。ハイフン一つ (-)
           を指定すると、指定したキーに対する設定を削除します。

   終
       エラーがない限り bindkey コマンドの終了ステータスは 0 です。

   補
       Bindkey コマンドは任意組込みコマンドです。 POSIX では bindkey
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

BREAK 組
       Break 組込みコマンドは実行中のループを中断します。

   構
       •   break [深さ]

       •   break -i

   説
       -i (--iteration) オプションを付けずに実行すると、break
       コマンドは現在実行中の for ループまたは while ループまたは until
       ループを中断します。多重ループの中で実行した場合、内側から数えて深さ番目のループを中断します。深さが指定されていないときは、最も内側のループを中断します
       (深さ =
       1)。指定された深さが実際に実行している多重ループの深さより大きい場合は最も外側のループを中断します。

       -i (--iteration) オプションを付けて実行すると、break
       コマンドは現在実行中の反復実行を中断します。

   オ
       -i, --iteration
           ループではなく反復実行を中断します。

   オ
       深さ
           内側から何番目のループを中断するのかを指定する 1 以上の自然数です。

   終
       ループの中断に成功すると終了ステータスは 0
       です。反復実行の中断に成功すると break
       コマンドの直前に実行されたコマンドの終了ステータスが break
       コマンドの終了ステータスになります。

   補
       Break コマンドは特殊組込みコマンドです。

       POSIX にはオプションに関する規定はありません。よってオプションは POSIX
       準拠モードでは使えません。

       POSIX では、break
       コマンドを構文的に取り囲んでいないループの扱いを規定していません。例えば以下のような場合が該当します:

       •   ループの中で関数が実行され、その中で break コマンドが実行される

       •   ループの実行中にトラップが実行され、その中で break
           コマンドが実行される

       Yash では、このようなループは break の対象に出来ません。

CD 組
       Cd 組込みコマンドはシェルの作業ディレクトリを変更します。

   構
       •   cd [-L|-P [-e]] [ディレクトリ]

   説
       Cd
       コマンドはシェルの作業ディレクトリをオペランドで指定したディレクトリに変更します。

       新しい作業ディレクトリに応じて PWD 変数の値が再設定されるとともに、前の
       PWD 変数の値が OLDPWD 変数に設定されます。新しい PWD の値は . や ..
       のディレクトリ成分を含みません (POSIX 準拠モードで新しいパスが /..
       で始まる場合を除く)。

       指定したディレクトリが相対パスの場合 (最初が . または ..
       で始まるものを除く)、コマンドの検索における PATH
       変数の検索と同様にして、CDPATH
       変数の値にあるコロンで区切った各ディレクトリ内に指定したディレクトリがあるかどうか調べます。ディレクトリが見つかった場合は、そのディレクトリが新しい作業ディレクトリになります。見つからなかった場合は、ディレクトリは現在の作業ディレクトリからの相対パスとなります。

       CDPATH
       変数の検索で新しい作業ディレクトリが見つかった場合またはディレクトリとして
       -
       が指定された場合は新しい作業ディレクトリのパスを標準出力に出力します。

       作業ディレクトリの変更に成功した場合、YASH_AFTER_CD
       変数が設定されていればその値がコマンドとして解釈・実行されます (非
       POSIX 準拠モード時)。

   オ
       -L, --logical
           ディレクトリパスに含まれるシンボリックリンクを解決せずに新しい作業ディレクトリを決定します。新しい
           PWD
           変数の値にはシンボリックリンクになっているパス名コンポーネントがそのまま残ります。

       -P, --physical
           ディレクトリパスに含まれるシンボリックリンクを解決します。新しい
           PWD 変数の値はシンボリックリンクを含みません。

       -e, --ensure-pwd
           このオプションは -P (--physical)
           オプションと一緒に指定する必要があります。
           作業ディレクトリが変更された後に、PWD
           変数に設定すべき新しい作業ディレクトリパスが特定できない場合、このオプションが指定されていると、終了ステータスが
           1
           になります。このオプションが指定されていない場合は、終了ステータスが
           0 になります。

       --default-directory=ディレクトリ
           ディレクトリオペランドが与えられていない場合は、代わりにこのオプションで指定したディレクトリを新しい作業ディレクトリとします。

       -L (--logical) オプションと -P (--physical)
       オプションの両方を指定した場合、後に指定したほうを優先します。どちらも指定していない場合は、-L
       を指定したものとみなします。

   オ
       ディレクトリ
           新しい作業ディレクトリのパス名です。絶対パスまたは元の作業ディレクトリからの相対パスで指定します。

           この値がハイフン一つ (「-」) の場合、OLDPWD
           変数の値が指定されたものとみなします。このオペランドが与えられていない場合、HOME
           変数の値が指定されたものとみなします (--default-directory
           オプションを指定した場合を除く)。

   終
       •   作業ディレクトリを正しく変更できた場合、終了ステータスは 0
           です。ただし、以下の場合は終了ステータスは 1 になります:

           •   PWD または OLDPWD 変数が読み取り専用のため更新できなかった場合

           •   -P オプションと -e オプションが指定されていて、PWD
               変数に設定すべき新しい作業ディレクトリパスが特定できなかった場合

       •   内部で呼び出される chdir
           システムコールがエラーを返した場合、終了ステータスは 2 です。

       •   -L オプションが有効で、新しいディレクトリパス名に ..
           が含まれていて、それが存在しないディレクトリを指している場合、終了ステータスは
           3 です。

       •   HOME または OLDPWD
           が未定義もしくは空文字列であるためにディレクトリが解決できなかった場合、終了ステータスは
           4 です。

       •   コマンドライン引数が不正な場合またはディレクトリが空文字列の場合、終了ステータスは
           5 です。

       終了ステータスが 2 以上の場合、作業ディレクトリは変更されません。

   補
       Cd コマンドは必須組込みコマンドです。

       POSIX には YASH_AFTER_CD 変数および --default-directory=...
       オプションに関する規定はありません。

       YASH_AFTER_CD 変数の実行結果は cd
       コマンドの終了ステータスには影響しません。

コ
       コロン組込みコマンドは何も行わない組込みコマンドです。

   構
       •   : [引数...]

   説
       コロンコマンドは何も行いません。コマンドライン引数は一切無視します。

   終
       コロンコマンドの終了ステータスは 0 です。

   補
       コロンコマンドは特殊組込みコマンドです。

       引数の展開とリダイレクトは他のコマンドと同様に行います。

       True
       コマンドはコロンコマンドと同様に何も行いませんが、コロンコマンドは特殊組込みコマンドであるのに対し
       true コマンドは代替組込みコマンドです。

COMMAND 組
       Command
       組込みコマンドはコマンドを実行します。またコマンドの種類を特定します。

   構
       •   command [-befp] コマンド [引数...]

       •   command -v|-V [-abefkp] コマンド...

   説
       -v (--identify) オプションならびに -V (--verbose-identify)
       オプションを付けずに実行すると、command
       コマンドは与えられたコマンドを与えられた引数で実行します。コマンドの実行の仕方は単純コマンドの実行の最後のステップに準じますが、コマンドの検索では外部コマンド・組込みコマンド・関数の内オプションで指定したものしか検索しません。またコマンドが特殊組込みコマンドの場合、コマンドのオプションやオペランドの使い方が間違っていたりリダイレクトエラーや代入エラーが起きたりしてもシェルは終了しません。

       -v (--identify) オプションまたは -V (--verbose-identify)
       オプションを付けて実行すると、command
       コマンドは与えられたコマンドの種類とパスを特定しそれを標準出力に出力します。コマンドはエイリアスや関数であっても構いません。

       -v (--identify)
       オプションを付けて実行したときの出力は以下のようになります。

       •   コマンドの検索の結果見つかったコマンドおよびその他の外部コマンドは、その絶対パスを出力します。

       •   コマンドの検索によらず実行される組込みコマンドや関数は、単にその名前を出力します。

       •   予約語は、単にその名前を出力します。

       •   エイリアスは、コマンドとして実行可能な形式でその名前と値を出力します。

       •   コマンドが見つからなかった場合は、何も出力しません。(終了ステータスが非
           0 になります)

       -V (--verbose-identify)
       オプション使用時は、出力の形式が人間にとってより読みやすくなります。

   オ
       -a, --alias
           コマンドとしてエイリアスを検索の対象にします。 -v (--identify)
           または -V (--verbose-identify)
           オプションと一緒に使う必要があります。

       -b, --builtin-command
           コマンドとして組込みコマンドを検索の対象にします。

       -e, --external-command
           コマンドとして外部コマンドを検索の対象にします。

       -f, --function
           コマンドとして関数を検索の対象にします。

       -k, --keyword
           コマンドとして予約語を検索の対象にします。 -v (--identify) または
           -V (--verbose-identify) オプションと一緒に使う必要があります。

       -p, --standard-path
           コマンドの検索において、PATH
           変数の代わりに、標準のコマンドをすべて含むようなシステム固有のデフォルトパスを用いて外部コマンドを検索します。

       -v, --identify
           与えられたコマンドの種類とパスを特定し、簡単な形式で標準出力に出力します。

       -V, --verbose-identify
           与えられたコマンドの種類とパスを特定し、人間にとって読みやすい形式で標準出力に出力します。

       -a (--alias), -b (--builtin-command), -e (--external-command), -f
       (--function), -k (--keyword)
       オプションのどれも指定しなかった場合は、以下のオプションを指定したものとみなします。

       -v (--identify) あるいは -V (--verbose-identify)
       オプションを指定していないとき
           -b -e

       -v (--identify) または -V (--verbose-identify)
       オプションを指定しているとき
           -a -b -e -f -k

   オ
       コマンド
           実行するまたは種類を特定するコマンドの名前です。

       引数...
           実行するコマンドに渡すコマンドライン引数です。

   終
       -v (--identify) あるいは -V (--verbose-identify)
       オプションを指定していないとき
           実行したコマンドの終了ステータス

       -v (--identify) または -V (--verbose-identify)
       オプションを指定しているとき
           エラーがない限り 0

   補
       Command コマンドは必須組込みコマンドです。

       POSIX に規定のあるオプションは -p, -v, -V
       だけです。これ以外のオプションは POSIX 準拠モードでは使えません。また
       POSIX 準拠モードでは -v または -V
       オプションを使用するときコマンドはちょうど一つしか指定できません。

       POSIX は -v オプションと -V
       オプションを同時に指定することを認めていません。Yash
       ではこれら二つのオプションを両方指定すると最後に指定したものが有効になります。

COMPLETE 組
       Complete
       組込みコマンドはコマンドライン補完において補完候補を生成します。この組込みコマンドは補完関数の実行中にだけ使えます。

   構
       •   complete [-A パターン] [-R パターン] [-T] [-P 接頭辞] [-S 接尾辞]
           [-abcdfghjkuv] [[-O] [-D 説明] 単語...]

   説
       補完関数の中でこの組込みコマンドを実行すると、complete
       コマンドは指定した引数に従って補完候補を生成します。どのオプション・オペランドで候補を生成するにせよ、実際に生成される候補は現在補完しようとしている
       (コマンドライン上に途中まで入力された) 単語に一致するものに限られます。

   オ
       -A パターン, --accept=パターン
           このオプションを指定すると、指定したパターンにマッチする候補だけを生成します。このオプションは複数回指定できます
           (指定した全てのパターンにマッチする候補だけを生成します)。

       -D 説明, --description=説明
           このオプションを指定すると、このオプションで指定した説明が補完の際に候補の説明として表示されます。

       -O, --option
           生成する候補をコマンドのオプションとみなすようにします。候補を画面上に一覧表示する際に自動的に先頭にハイフンを付加します。

       -P 接頭辞, --prefix=接頭辞
           このオプションで指定する接頭辞は現在補完しようとしている単語の接頭辞になっていなければなりません。このオプションを指定すると、候補生成の際にこのオプションで指定した接頭辞を無視してマッチングを行います。例えば補完しようとしている単語が
           file:///home/user/docume であり、この URL
           をファイル名として補完したいとしましょう。この場合は、complete -P
           file:// -f とすると URL から file:// を除いた残りの
           /home/user/docume
           の部分に対してファイル名としての補完候補が生成されます。

       -R パターン, --reject=パターン
           このオプションを指定すると、指定したパターンにマッチする候補を生成しません。このオプションは複数回指定できます
           (指定したパターンの少なくとも一つにマッチする候補を全て除外します)。

       -S 接尾辞, --suffix=接尾辞
           生成した各候補の末尾に接尾辞を付加します。

       -T, --no-termination
           通常は、補完が終わった後に次の単語をすぐ入力できるように、補完した単語の直後に空白を自動的に挿入しますが、このオプションを指定したときは空白を挿入しません。

       補

           -a, --alias
               エイリアス (--normal-alias --global-alias に同じ)

           --array-variable
               配列

           --bindkey
               Bindkey コマンドで利用可能な行編集コマンド

           -b, --builtin-command
               組込みコマンド (--special-builtin --mandatory-builtin
               --elective-builtin --extension-builtin --substitutive-builtin
               に同じ)

           -c, --command
               コマンド (--builtin-command --external-command --function
               に同じ)

           -d, --directory
               ディレクトリ

           --dirstack-index
               ディレクトリスタックのインデックス

           --elective-builtin
               任意組込みコマンド

           --executable-file
               実行可能ファイル

           --extension-builtin
               拡張組込みコマンド

           --external-command
               外部コマンド

           -f, --file
               ファイル (ディレクトリ含む)

           --finished-job
               終了したジョブのジョブ ID

           --function
               関数

           --global-alias
               グローバルエイリアス

           -g, --group
               (ファイルのパーミッションなどにおける) グループ

           -h, --hostname
               ホスト名

           -j, --job
               ジョブ ID

           -k, --keyword
               シェルの予約語

           --mandatory-builtin
               必須組込みコマンド

           --normal-alias
               通常の (グローバルでない) エイリアス

           --regular-builtin
               後方互換性のために残されている古いオプション。
               --extension-builtin --substitutive-builtin に同じ。

           --running-job
               実行中のジョブのジョブ ID

           --scalar-variable
               (配列を除いた通常の) 変数

           --semi-special-builtin
               後方互換性のために残されている古いオプション。
               --mandatory-builtin --elective-builtin に同じ。

           --signal
               シグナル

           --special-builtin
               特殊組込みコマンド

           --stopped-job
               停止中のジョブのジョブ ID

           --substitutive-builtin
               代替組込みコマンド

           -u, --username
               ユーザのログイン名

           -v, --variable
               変数

           -d (--directory) オプションを指定せずに -f (--file)
           オプションを指定した場合、-S ... (--suffix=...)
           オプションの指定の有無にかかわらず、ディレクトリ名を表す補完候補には接尾辞としてスラッシュが付き、候補の直後には空白が入りません
           (-S / -T を指定したときと同じ動作)。

           ジョブ ID の補完は先頭の %
           を除いた部分に対して行われるので、補完しようとしている単語が既に %
           を含んでいる場合は % を接頭辞として指定してください。

   オ
       Complete
       コマンドのオペランドは、各オペランドがそれぞれ補完候補として扱われます。指定したオペランドのうち、現在補完しようとしている単語に合うものが補完候補となります。

   終
       候補が少なくとも一つ生成できた場合は、終了ステータスは 0
       です。新たな候補が一つも生成できなかったときは、終了ステータスは 1
       です。その他のエラーの場合は 2 以上の終了ステータスになります。

   補
       Complete コマンドは任意組込みコマンドです。 POSIX では complete
       コマンドの動作は規定されていません。 POSIX 準拠モードが有効な場合でも、
       補完関数の実行時には POSIX 準拠モードが一時的に無効になるため、complete
       コマンドを使用できます。

CONTINUE 組
       Continue 組込みコマンドは実行中のループの次の繰り返しに処理を移します。

   構
       •   continue [深さ]

       •   continue -i

   説
       -i (--iteration) オプションを付けずに実行すると、continue
       コマンドは現在実行中の for ループまたは while ループまたは until
       ループの繰り返しを中断し、直ちに次の繰り返しを開始します (while/until
       ループについては、ループの実行条件の判定からやり直します)。多重ループの中で実行した場合、内側から数えて深さ番目のループに対してこの動作を行います。深さが指定されていないときは、最も内側のループに対してこの動作を行います
       (深さ =
       1)。指定された深さが実際に実行している多重ループの深さより大きい場合は最も外側のループに対してこの動作を行います。

       -i (--iteration) オプションを付けて実行すると、continue
       コマンドは現在実行中の反復実行の現在のコマンドの実行を中断し、直ちに次のコマンドの実行を開始します。

   オ
       -i, --iteration
           ループではなく反復実行に対して作用します。

   オ
       深さ
           内側から何番目のループに作用するのかを指定する 1 以上の自然数です。

   終
       -i (--iteration) オプションが指定されていないとき、continue
       コマンドの処理が成功すると終了ステータスは 0 です。-i (--iteration)
       オプションが指定されているとき、continue コマンドの処理が成功すると
       continue コマンドの直前に実行されたコマンドの終了ステータスが continue
       コマンドの終了ステータスになります。

   補
       Continue コマンドは特殊組込みコマンドです。

       POSIX にはオプションに関する規定はありません。よってオプションは POSIX
       準拠モードでは使えません。

       POSIX では、continue
       コマンドを構文的に取り囲んでいないループの扱いを規定していません。例えば以下のような場合が該当します:

       •   ループの中で関数が実行され、その中で continue コマンドが実行される

       •   ループの実行中にトラップが実行され、その中で continue
           コマンドが実行される

       Yash では、このようなループは continue の対象に出来ません。

DIRS 組
       Dirs 組込みコマンドはディレクトリスタックの内容を表示します。

   構
       •   dirs [-cv] [インデックス..]

   説
       ディレクトリスタックとは、作業ディレクトリの変更の履歴をとる仕組みです。Pushd
       コマンドで作業ディレクトリを変更すると、元の作業ディレクトリがディレクトリスタックに追加されます。Popd
       コマンドを使うと、ディレクトリスタックに保存してある元の作業ディレクトリに戻ることができます。Dirs
       コマンドを使うと、ディレクトリスタックの内容を表示することができます。ディレクトリスタックの内容は
       DIRSTACK 配列と PWD
       変数に保存されます。これらの値を変更すると、ディレクトリスタックの動作に影響します。

       ディレクトリスタックに保存してあるディレクトリはインデックスで区別します。インデックスは
       -v (--verbose) オプションを付けて dirs
       コマンドを実行することで知ることができます。インデックスは正号 (+)
       または負号 (-) の付いた整数の形で表わします。整数は pushd
       コマンドでディレクトリスタックに追加した順に振られます。例えばインデックス
       +0 は現在の作業ディレクトリに対応します。インデックス +1
       は最後に追加したディレクトリで、インデックス +2
       はその一つ前に追加したディレクトリに対応します。インデックス -0
       は最初に 追加したディレクトリ、インデックス -1
       はその次に追加したディレクトリに対応します。

       -c (--clear) オプションを付けずに実行すると、dirs
       コマンドは現在のディレクトリスタックの要素を一つずつ標準出力に出力します。
       -c (--clear) オプションを付けて実行すると、dirs
       コマンドはディレクトリスタックのインデックス +0
       以外の要素をすべて削除します。

   オ
       -c, --clear
           ディレクトリスタックの要素を
           (現在の作業ディレクトリに対応するものを除いて) すべて削除します。

       -v, --verbose
           ディレクトリスタックの要素のインデックスも出力します。

   オ
       インデックス
           表示するディレクトリスタックの要素のインデックスです。インデックスを一つも指定しないときは、全ての要素をインデックス
           +0 のものから順に表示します。

   終
       エラーがない限り dirs コマンドの終了ステータスは 0 です。

   補
       Dirs コマンドは任意組込みコマンドです。 POSIX では dirs
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

DISOWN 組
       Disown 組込みコマンドはジョブを削除します。

   構
       •   disown [-a] [ジョブ...}

   説
       Disown
       コマンドはシェルが管理しているジョブを削除します。削除したジョブはジョブ制御の対象から外れますが、ジョブを構成するコマンドの実行は継続します。

   オ
       -a, --all
           全てのジョブを削除します。

   オ
       ジョブ
           削除するジョブのジョブ ID。

           複数指定することもできます。何も指定しないと現在のジョブを削除します。非
           POSIX 準拠モードではジョブ ID の先頭の % は省略できます。

   終
       エラーがない限り disown コマンドの終了ステータスは 0 です。

   補
       Disown コマンドは任意組込みコマンドです。 POSIX では disown
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

ド
       ドット組込みコマンドはテキストファイルを開いて、その内容をコマンドとして解釈し実行します。

   構
       •   . [-AL] ファイル名 [引数...]

   説
       ドットコマンドは与えられたファイル名のファイルを開き、その内容をコマンドとして解釈し現在のコマンド実行環境で実行します。

       ファイル名に続けて引数が与えられているときは、関数の実行の時と同様に、コマンドの実行前に引数が位置パラメータに設定され、実行後に元の位置パラメータに戻ります。

       ファイル名にスラッシュ (/)
       が一つも入っていない場合は、コマンドの検索のときと同様に PATH
       変数の検索を行い、開くべきファイルを探します。ただしファイルは読み込み可能でさえあれば実行可能である必要はありません。検索の結果ファイルが見つかれば、そのファイルの内容を解釈・実行します。ファイルが見つからなかった場合、POSIX
       準拠モードでは直ちにエラーになります。POSIX
       準拠モードでないときは現在の作業ディレクトリのファイルを開くことを試みます。

   オ
       -A, --no-alias
           ファイルを読み込んで実行する際、エイリアス展開を行いません。

       -L, --autoload
           ファイル名がスラッシュを含んでいるかどうかにかかわらず、PATH
           変数の代わりに YASH_LOADPATH
           変数を検索して開くべきファイルを探します。ファイル名は現在の作業ディレクトリからの相対パス名とはみなしません。

       ドットコマンドでは、最初のオペランドより後にあるコマンドライン引数は全てオペランドとして解釈します。

   オ
       ファイル名
           読み込むファイルのパス名です。

       引数...
           ファイルの内容を実行している間に位置パラメータに設定する文字列です。

   終
       ドットコマンドの終了ステータスは、ファイルから読み込んで実行した最後のコマンドの終了ステータスです。ファイルの内容に一つもコマンドが入っていなかったときは終了ステータスは
       0
       です。ファイルが見つからなかったり開けなかったりしたときは終了ステータスは非
       0 です。

   補
       ドットコマンドは特殊組込みコマンドです。

       シェルが対話モードでないとき、読み込むべきファイルが見つからなかったり開けなかったりするとシェルは直ちに終了します。

       POSIX にはオプションに関する規定はありません。よってオプションは POSIX
       準拠モードでは使えません。

       POSIX
       には引数オペランドによって位置パラメータを変更できることについての規定はありません。よって
       POSIX 準拠モードでは引数オペランドを与えるとエラーになります。

ECHO 組
       Echo 組込みコマンドはコマンドライン引数を標準出力に出力します。

   構
       •   echo [文字列...]

       Echo
       コマンドはコマンドライン引数を全てオペランドとして解釈します。オプションは、以下に述べる例外を除いて一切解釈しません。オプションはオペランドより前に置く必要があります。Echo
       コマンドでは構文エラーは絶対に起きません。

   説
       Echo
       コマンドは与えられたコマンドライン引数と改行を標準出力に出力します。引数がない場合は改行だけを出力します。引数が複数ある場合はそれぞれを空白文字で区切って出力します。

       エ

           Echo コマンドに与える引数では、後述の ECHO_STYLE 変数と -e
           オプションの指定によって以下のエスケープシーケンスを使用することができます。

           \a
               ベル文字 (ASCII コード番号 7)

           \b
               バックスペース (ASCII コード番号 8)

           \c
               これ以降何も出力しない。

           \e
               エスケープ文字 (ASCII コード番号 27)

           \f
               フォームフィード (ASCII コード番号 12)

           \n
               改行文字 (ASCII コード番号 10)

           \r
               復帰文字 (ASCII コード番号 13)

           \t
               水平タブ (ASCII コード番号 9)

           \v
               垂直タブ (ASCII コード番号 11)

           \\
               バックスラッシュ

           \0xxx
               八進数 xxx (最大三桁) で表わされるコード番号の文字

           エスケープシーケンスが無効の時は、エスケープシーケンスは解釈せずにそのまま出力します。

       ECHO_STYLE 変

           Echo コマンドがオプションやエスケープシーケンスを解釈するかどうかは
           ECHO_STYLE 変数の値によります。以下に、この変数の値と echo
           コマンドの動作との対応を示します。

           SYSV, XSI
               オプションは一切解釈しません。常にエスケープシーケンスを解釈します。

           BSD
               -n
               オプションを解釈します。エスケープシーケンスは一切解釈しません。

           GNU
               -n, -e, -E オプションを解釈します。エスケープシーケンスは -e
               オプションを指定したときだけ解釈します。

           ZSH
               -n, -e, -E オプションを解釈します。エスケープシーケンスは -E
               オプションを指定しないかぎり解釈します。

           DASH
               -n
               オプションを解釈します。常にエスケープシーケンスを解釈します。

           RAW
               オプションもエスケープシーケンスも一切解釈しません。

           ECHO_STYLE 変数が設定されていないときは、値が SYSV または XSI
           の場合の動作をします。

   オ
       -n
           最後に改行を出力しないようにする。

       -e
           エスケープシーケンスを解釈するようにする。

       -E
           エスケープシーケンスを解釈せず、全ての文字をそのまま出力するようにする。

   終
       エラーがない限り echo コマンドの終了ステータスは 0 です。

   補
       POSIX には ECHO_STYLE
       変数およびオプションに関する規定はありません。POSIX では、-n
       オプションが指定されたときまたは引数にバックスラッシュが含まれている場合の動作を規定していません。可搬性のあるシェルスクリプトを書くには、echo
       コマンドよりも printf コマンドの使用を推奨します。

       ECHO_STYLE
       変数のとれる値は主に他のシェルの実装を基に決めてありますが、これらの実装を
       yash が完全に模倣することを意図するものではありません。Zsh の echo
       組込みには単一のハイフンをオプションとオペランドの区切りとして解釈するという挙動がありますが、yash
       ではこのようなハイフンの使い方はできません。

EVAL 組
       Eval 組込みコマンドはオペランドをコマンドとして解釈して実行します。

   構
       •   eval [-i] [コマンド...]

       Eval コマンドでは、POSIX
       準拠モードであるかどうかにかかわらずオプションはオペランドより先に全て指定しなければなりません。最初のオペランドより後にあるコマンドライン引数は全てオペランドとして解釈します。

   説
       Eval
       コマンドは、与えられたオペランドをシェルのコマンドとして解釈し、現在のコマンド実行環境で実行します。

       -i (--iteration)
       オプションが指定されていないときは、コマンドをまとめて一度に解釈・実行します。複数のオペランドがある場合は、それらを順に連結して一つにしてから解釈・実行します
       (連結の際、各オペランド間に空白文字を一つずつ区切りとして挿入します)。

       -i (--iteration)
       オプションが指定されているときは、オペランドを順に一つずつ解釈・実行します。これを反復実行といいます。反復実行の途中で
       continue コマンドを -i
       オプション付きで実行した場合、コマンドの実行は中断され、eval
       コマンドに与えられた次のオペランドの解釈・実行に移ります。反復実行の途中で
       break コマンドを -i
       オプション付きで実行した場合、反復実行は中断され、この eval
       コマンドの実行は終了します。特殊パラメータ ?
       の値が反復実行の開始前に保存されます。オペランドを一つ解釈・実行するたびに特殊パラメータ
       ? の値は保存された値にもどります。

   オ
       -i, --iteration
           与えられたコマンドを順に反復実行します。

   オ
       コマンド
           コマンドとして解釈・実行する文字列です。

   終
       オペランドが一つもない場合またはオペランドの中にコマンドが一つも含まれていなかった場合、終了ステータスは
       0
       です。コマンドが一つ以上解釈・実行された場合、最後に実行したコマンドの終了ステータスが
       eval コマンドの終了ステータスになります。

   補
       Eval コマンドは特殊組込みコマンドです。

       POSIX にはオプションに関する規定はありません。よってオプションは POSIX
       準拠モードでは使えません。

EXEC 組
       Exec
       組込みコマンドはシェルのプロセスを別の外部コマンドに置き換えます。またシェルのプロセスに対してリダイレクトを実行します。

   構
       •   exec [-cf] [-a コマンド名] [コマンド [引数...]]

       Exec コマンドでは、POSIX
       準拠モードであるかどうかにかかわらずオプションはオペランドより先に全て指定しなければなりません。これは
       exec
       コマンドに対するオプションとコマンドに対するオプションを区別するために重要です。コマンドより後にある引数はすべて引数とみなされます。

   説
       Exec
       コマンドをコマンドを指定して実行すると、シェルは単純コマンドの実行の最後のステップと同様にしてコマンドを実行します。ただし、コマンドは必ず外部コマンドとしてみなされ、関数や組込みコマンドは無視します。そしてその外部コマンドはサブシェルではなく現在のコマンド実行環境で
       exec
       システムコールを呼び出すことで実行します。これにより、シェルのプロセスは新しく起動するコマンドに置き換わります。

       シェルが対話モードでないとき、コマンドの起動に失敗するとシェルは直ちに終了します。

       シェルが POSIX
       準拠モードではなくかつ対話モードのとき、停止中のジョブがあると、シェルは警告を表示し、コマンドを起動しません。一度
       exec
       が実行されると、シェルが持っているジョブの情報は失われるため、手動でシグナルを送ってジョブを再開または終了させなければならなくなります。警告を無視してコマンドを起動するには
       -f (--force) オプションを付けてください。

       コマンドなしで実行した場合 exec コマンドは何も行いませんが、この exec
       コマンドを実行する際に行ったリダイレクトの効果は現在のコマンド実行環境に残ります。

   オ
       -a コマンド名, --as=コマンド名
           コマンドの代わりにコマンド名をコマンド名としてコマンドに渡します。

       -c, --clear
           既存の環境変数をすべて削除した状態でコマンドを実行します。ただしこの
           exec
           コマンドを実行する際に行った変数代入の結果は環境変数としてコマンドに渡します。

       -f, --force
           警告を無視してコマンドを実行します。

   オ
       コマンド
           実行するコマンドです。

       引数...
           実行するコマンドに渡すコマンドライン引数です。

   終
       指定されたコマンドの起動に成功した場合、シェルのプロセスはそのコマンドのプロセスに置き換わってしまうので、終了ステータスはありません。

       実行しようとしたコマンドが見つからなかった場合、終了ステータスは 127
       です。コマンドが見つかったが実行できなかった場合、終了ステータスは 126
       です。コマンドを指定せずに exec
       コマンドを実行した場合、終了ステータスは 0 です。

   補
       Exec コマンドは特殊組込みコマンドです。

       POSIX にはオプションに関する規定はありません。よってオプションは POSIX
       準拠モードでは使えません。

EXIT 組
       Exit 組込みコマンドコマンドはシェルの実行を終了します。

   構
       •   exit [-f] [終了ステータス]

   説
       Exit コマンドは、このコマンドを実行したシェル (またはサブシェル)
       を終了します。

       停止しているジョブのある対話モードのシェルを終了しようとすると、シェルは警告を表示し、終了しません。-f
       (--force) オプションを付けて実行するか exit
       コマンドを二連続で実行すると警告を無視してシェルを終了します。

       シェル終了時のトラップが設定されている場合は、シェルが終了する前にそれが実行されます。

   オ
       -f, --force
           警告を無視してシェルを終了します。

   オ
       終了ステータス
           終了するシェルの終了ステータスを指定する 0 以上の自然数です。

           このオペランドが与えられていない場合は、exit
           コマンドの直前に実行されたコマンドの終了ステータスを用います
           (ただしトラップを実行中の場合はトラップに入る直前のコマンドの終了ステータス)。

           終了ステータスが 384
           より大きい場合、シェルは指定された終了ステータスで終了するのではなく、シグナルを送って終了しようとします。詳細はシェルの終了を参照してください。

   終
       Exit コマンドはシェルを終了するので、exit
       コマンドそのものの終了ステータスはありません。

       例外として、exit
       コマンドが警告を表示して、シェルを終了しなかった場合、exit
       コマンドの終了ステータスは非 0 です。

   補
       Exit コマンドは特殊組込みコマンドです。

       256 以上の終了ステータスは移植性のない拡張です。

       POSIX には -f (--force)
       オプションに関する規定はありません。よってこのオプションは POSIX
       準拠モードでは使えません。

       シェル終了時のトラップの実行中に exit
       コマンドを実行すると、再びトラップが実行されることはなくそのままシェルは終了します。このとき
       exit
       コマンドに終了ステータスが与えられていない場合は、もし終了時のトラップが設定されていなかった場合にシェルが返したろう終了ステータスでシェルは終了します。(シェルの終了も参照)

EXPORT 組
       Export 組込みコマンドはエクスポート対象の変数を表示・設定します。

   構
       •   export [-prX] [変数[=値]...]

   説
       Export コマンドは typeset コマンドに -gx
       オプションを付けたものと同じです。その他オプション・オペランド・終了ステータスは
       typeset コマンドと同様です。

   補
       Export コマンドは特殊組込みコマンドです。

       POSIX には export コマンドに関する規定はありますが、オプションは -p
       しか規定がありません。その他のオプションは POSIX
       準拠モードでは使えません。また POSIX は -p
       オプションをオペランドとともに使うことを認めていません。

FALSE 組
       False 組込みコマンドは何も行わずに非 0 の終了ステータスで終了します。

   構
       •   false

   説
       False コマンドは何も行いません。コマンドライン引数は一切無視します。

   終
       False コマンドの終了ステータスは非 0 です。

   補
       False コマンドは代替組込みコマンドです。

FC 組
       Fc
       組込みコマンドはコマンド履歴に記録されたコマンドを再実行・表示します。

   構
       •   fc [-qr] [-e エディタ] [始点 [終点]]

       •   fc -s[q] [前=後] [始点]

       •   fc -l[nrv] [始点 [終点]]

   説
       -l (--list) オプションを付けずに実行すると、fc
       コマンドはオペランドで指定したコマンド履歴のコマンドを再実行します。-s
       (--silent)
       オプションを付けていない場合、シェルはコマンドを再実行する前にエディタを起動し、コマンドを編集できるようにします。エディタが終了するとシェルは編集後のコマンドを実行します。-s
       (--silent)
       オプションを付けた場合、シェルはエディタを起動せず直接コマンドを再実行します。いずれの場合も、実行するコマンドは標準出力に出力しコマンド履歴に追加されます。

       -l (--list) オプションを付けて実行すると、fc
       コマンドはオペランドで指定した範囲のコマンド履歴を標準出力に出力します。標準では履歴内のコマンドの内容を履歴番号とともに表示しますが、-n
       (--no-numbers) および -v (--verbose)
       オプションにより出力形式を変更できます。

   オ
       -e エディタ, --editor=エディタ
           コマンドの編集に用いるエディタ。

           このオプションを指定しない場合、FCEDIT
           変数の値をエディタとして使用します。FCEDIT
           変数も設定されていない場合は、ed をエディタとして使用します。

       -l, --list
           コマンド履歴の内容を表示します。

       -n, --no-numbers
           コマンド履歴の内容を表示する際、履歴番号を省いてコマンドのみ表示します。

       -q, --quiet
           コマンドを実行する前にコマンドを出力しないようにします。

       -r, --reverse
           始点と終点を入れ替えます。

       -s, --silent
           コマンドを編集せずに直接再実行します。

       -v, --verbose
           コマンド履歴の内容を表示する際、コマンドの時刻も表示します。

   オ
       始点と終点
           始点と終点のオペランドは、再実行または表示するコマンドの範囲を指定します。始点あるいは終点に整数を指定すると、それは履歴番号とみなします。負の整数は最新の履歴から数えた番号となります。例えば
           -2
           は最後から二番目に履歴に登録されたコマンドを表します。整数以外の文字列を始点あるいは終点に指定すると、その文字列で始まる最新の履歴を指定しているものとみなします。

           Fc
           コマンドが再実行または表示するコマンドは、始点と終点で指定したコマンドとその間にある履歴のコマンドです。始点が終点より後のコマンドを指している場合、コマンドの順序は逆になります。

           始点または終点が与えられていない場合のデフォルト値は以下の表のとおりです。

           ┌─────┬─────────┬────────────┐
           │     │ -l あり │ -l なし    │
           ├─────┼─────────┼────────────┤
           │始点 │ -16     │ -1         │
           ├─────┼─────────┼────────────┤
           │終点 │ -1      │ 始点に同じ │
           └─────┴─────────┴────────────┘

       前=後
           前=後の形式のオペランドは、コマンドの一部を書き換えることを指示します。再実行するコマンドの中に前と同じ文字列がある場合は、その部分を後に置き換えて実行します。該当部分が複数ある場合は、最初のものだけを置き換えます。

   終
       コマンドを正しく再実行できた場合、fc
       コマンドの終了ステータスは再実行したコマンドの終了ステータスになります。-l
       (--list)
       オプションを指定した場合は、履歴が正しく出力できれば終了ステータスは 0
       です。

   補
       Fc コマンドは必須組込みコマンドです。

       POSIX には -q (--quiet) および -v (--verbose)
       オプションに関する規定はありません。よってこれらのオプションは POSIX
       準拠モードでは使えません。

       行編集の動作中は履歴の内容を変更することはできません。

FG 組
       Fg 組込みコマンドはジョブをフォアグラウンドで実行します。

   構
       •   fg [ジョブ...]

   説
       Fg コマンドはジョブをフォアグラウンドに移動し SIGCONT
       シグナルを送ります。これにより、ジョブが停止していた場合はフォアグラウンドで実行が再開されます。Fg
       コマンドはジョブの実行が終了するまで待機し、ジョブの終了ステータスを返します。

       ジョブの実行を再開する前に fg
       コマンドはジョブの名前を標準出力に出力します。 非 POSIX
       準拠モードではジョブの番号も出力されます。

       Fg コマンドはジョブ制御が有効な時しか使えません。

   オ
       ジョブ
           実行するジョブのジョブ ID。

           複数指定すると指定した順に一つずつジョブをフォアグラウンドで実行します。何も指定しないと現在のジョブを実行します。

           非 POSIX 準拠モードではジョブ ID の先頭の % は省略できます。

   終
       ジョブを正しく実行できた場合、fg コマンドの終了ステータスは (最後に)
       実行したジョブの終了ステータスです。エラーが発生した場合は終了ステータスは非
       0 です。

   補
       Fg コマンドは必須組込みコマンドです。

       POSIX 準拠モードではジョブは一つまでしか指定できません。

GETOPTS 組
       Getopts 組込みコマンドはコマンドライン引数のオプションを解析します。

   構
       •   getopts オプションリスト 変数名 [引数...]

   説
       Getopts
       コマンドは、オペランドで与えられたコマンドライン引数に含まれている一文字のオプションを解析します。Getopts
       コマンドを一回呼び出すたびにオプションが一つ解析され、そのオプションを表す一文字が変数名で指定した変数に代入されます。

       解析の対象となるオプションの種類もオペランドで指定します。オプションリストには受け付けるオプションの文字を並べて指定します。文字の後にコロン
       (:) を付けるとそのオプションは引数をとるものとみなします。例えば、-a,
       -b, -c の三種類のオプションを受け付け、さらにこれらのうち -b
       が引数をとる場合、オプションリストには ab:c を指定します。

       引数をとるオプションを解析したとき、その引数の値が OPTARG
       変数に代入されます。

       オプションリストで与えられていないオプションに出くわしたときまたは引数をとるオプションに引数が与えられていないときの動作は、オプションリストの最初の文字がコロン
       (:) であるかどうかで決まります。

       •   オプションリストの最初の文字がコロンの場合、そのオプションの文字が
           OPTARG 変数に代入され、変数名で指定した変数には ?
           (オプションリストで与えられていないオプションに出くわしたとき)
           または : (引数をとるオプションに引数が与えられていないとき)
           が代入されます。

       •   オプションリストの最初の文字がコロンでない場合、OPTARG
           変数は削除され、変数名で指定した変数には ?
           が代入されます。またこのとき標準エラーにエラーメッセージが出力されますが、それでも
           getopts コマンドの終了ステータスは 0 になります。

       Getopts
       コマンドは、実行するたびに一つずつオプションを解析します。全てのオプションを解析するには、毎回同じ引数で
       getopts
       コマンドを繰り返し実行する必要があります。シェルは、オプションをどこまで解析したかを覚えておくために、OPTIND
       変数を用います。全てのオプションを解析し終わるまでにこの変数を変更してはいけません。全てのオプションを解析し終わると、OPTIND
       変数には引数 (または位置パラメータ)
       の中で最初のオペランドに当たるもののインデックスが代入されます
       (オペランドがない場合は引数または位置パラメータの個数 + 1 になります)。

       異なる引数を解析させたい場合は、getopts
       コマンドに新しい引数を与える前に OPTIND 変数に 1 を代入してください。

   オ
       オプションリスト
           解析の対象となるオプションの文字の羅列です。

       変数名
           解析結果の値を代入する変数の名前です。

       引数s
           解析するコマンドライン引数です。

           このオペランドを指定しない場合は、位置パラメータを解析します。

   終
       引数の中にオプションが見つかった場合は、(それがオプションリストに含まれているかどうかにかかわらず)
       終了ステータスは 0
       です。全てのオプションを解析し終わった時は、終了ステータスは 1
       です。その他のエラーの場合は 2 です。

   使
           aopt=false bopt= copt=false
           while getopts ab:c opt
           do
             case $opt in
             a) aopt=true ;;
             b) bopt=$OPTARG ;;
             c) copt=true ;;
             \?) return 2 ;;
             esac
           done
           if $aopt;          then echo オプション -a が指定されました;       fi
           if [ -n "$bopt" ]; then echo オプション -b $bopt が指定されました; fi
           if $copt;          then echo オプション -c が指定されました;       fi
           shift $((OPTIND - 1))
           echo オペランドは $*

   補
       Getopts
       コマンドが解析するコマンドライン引数では、オプションは全てオペランドより前に指定してある必要があります。最初にオペランドが現れた時点で、getopts
       コマンドは解析を終了します。

       Getopts コマンドは必須組込みコマンドです。

       POSIX は、OPTIND 変数に 1
       以外の値を代入した場合の動作を規定していません。

       POSIX
       準拠モードでは、オプションリストに含まれるオプションは英数字でなければなりません。

HASH 組
       Hash 組込みコマンドは外部コマンドのパスを検索・表示します。

   構
       •   hash コマンド...

       •   hash -r [コマンド...]

       •   hash [-a]

       •   hash -d ユーザ名...

       •   hash -dr [ユーザ名...]

       •   hash -d

   説
       オプションを指定しない場合、hash
       コマンドはオペランドで指定した外部コマンドのパスを検索し、結果を記憶します
       (既に記憶している場合は再度検索・記憶します)。

       -r (--remove) オプションを指定している場合、hash
       コマンドはオペランドで指定した外部コマンドのパスに関する記憶を消去します。-r
       (--remove)
       オプションを指定しかつコマンドを指定しない場合、全ての記憶を消去します。

       -r (--remove)
       オプションを指定せずコマンドも指定しない場合、記憶しているパスの一覧を標準出力に出力します。

       -d (--directory) オプションを指定した場合、hash
       コマンドは外部コマンドのパスの代わりにユーザのホームディレクトリのパスを検索・記憶または表示します。記憶したパスはチルダ展開で使用します。

   オ
       -a, --all
           シェルが記憶している全てのパスを出力します。

           このオプションを指定しない場合、シェルが記憶しているパスのうち組込みコマンドに対するものは出力しません。

       -d, --directory
           外部コマンドのパスの代わりにユーザのホームディレクトリのパスを扱います。

       -r, --remove
           指定したコマンドまたはユーザ名に対するパスの記憶を消去します。

   オ
       コマンド
           パスを記憶・消去する外部コマンドの名前です。スラッシュを含むパスを指定することはできません。

       ユーザ名
           ホームディレクトリのパスを記憶・消去するユーザ名です。

   終
       エラーがない限り hash コマンドの終了ステータスは 0 です。

   補
       シェルは、外部コマンド (またはチルダ展開)
       を実行する際に自動的にコマンド (またはホームディレクトリ)
       のパスを記憶するので、通常はわざわざ hash
       コマンドを使ってパスを記憶させる必要はありません。

       PATH
       変数の値が変わった時は、記憶した外部コマンドのパスは自動的にすべて消去されます。

       POSIX が規定しているオプションは -r だけです。よって他のオプションは
       POSIX 準拠モードでは使えません。

       Hash コマンドは必須組込みコマンドです。

HELP 組
       Help 組込みコマンドは組込みコマンドに関する説明を表示します。

   構
       •   help [コマンド...]

   説
       Help
       組込みコマンドは、オペランドで指定した組込みコマンドに関する説明を出力します。

   オ
       コマンド
           説明を表示する組込みコマンドの名前です。

   終
       エラーがない限り help コマンドの終了ステータスは 0 です。

   補
       Help コマンドは任意組込みコマンドです。 POSIX では help
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

       Yash の多くの組込みコマンドでは、--help オプションを与えることで help
       コマンドの出力と同様の説明を表示させることができます。

HISTORY 組
       History 組込みコマンドはコマンド履歴を編集します。

   構
       •   history [-cF] [-d 項目] [-s コマンド] [-r ファイル] [-w ファイル]
           [個数]

   説
       History コマンドはコマンド履歴の内容を編集・表示します。

       オプションが指定してある場合、history
       コマンドはそのオプションに従ってコマンド履歴の内容を編集します。複数のオプションがある場合は指定した順に処理します。

       オペランドで個数が与えられている場合、history
       コマンドはコマンド履歴の内容をその個数だけ標準出力に出力します。出力の形式は
       fc コマンドに準じます。

       オプションもオペランドも与えられていない場合、history
       コマンドはコマンド履歴の内容を全て標準出力に出力します。

   オ
       -c, --clear
           コマンド履歴をすべて削除します。

       -d 項目, --delete=項目
           指定した項目をコマンド履歴から削除します。項目の指定の仕方は fc
           コマンドの始点・終点オペランドと同じです。

       -F, --flush-file
           履歴ファイルを再構築します。

       -r ファイル, --read=ファイル
           指定したファイルからコマンドを読み込み履歴に追加します。ファイルの内容は単なるテキストファイルとして解釈され、それぞれの行の内容が一つのコマンドとして追加されます。

       -s コマンド, --set=コマンド
           コマンド履歴の最後の項目を削除し、代わりに指定したコマンドを追加します。

       -w ファイル, --write=ファイル
           指定したファイルに現在のコマンド履歴の内容を全て書き出します。既にあるファイルの内容は消去します。履歴は単なるテキストとして一行ずつ書き出します。

   オ
       個数
           表示する履歴の個数です。

   終
       エラーがない限り history コマンドの終了ステータスは 0 です。

   補
       History コマンドは任意組込みコマンドです。 POSIX では history
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

       行編集の動作中は履歴の内容を変更することはできません。

JOBS 組
       Jobs 組込みコマンドはシェルが有しているジョブを表示します。

   構
       •   jobs [-lnprs] [ジョブ...]

   説
       Jobs コマンドはシェルが現在有しているジョブの名前や状態を表示します。

       標準では各ジョブについて以下の情報を一行ずつ表示します。

       •   ジョブ番号

       •   現在のジョブ・前のジョブを示す記号 (+ または -)

       •   状態

       •   コマンド名

   オ
       -l, --verbose
           ジョブを構成しているパイプラインの要素ごとにプロセス ID
           と状態とコマンド名を表示します。

       -n, --new
           状態が変化してからまだ一度も表示していないジョブだけを表示します。

       -p, --pgid-only
           ジョブのプロセスグループ ID だけを表示します。

       -r, --running-only
           実行中のジョブだけを表示します。

       -s, --stopped-only
           停止中のジョブだけを表示します。

   オ
       ジョブ
           表示するジョブのジョブ ID
           です。一つも指定しない場合は全てのジョブを表示します。

           非 POSIX 準拠モードではジョブ ID の先頭の % は省略できます。

   終
       エラーがない限り jobs コマンドの終了ステータスは 0 です。

   補
       Jobs コマンドは必須組込みコマンドです。

       POSIX で規定されているオプションは -l と -p だけです。従って POSIX
       準拠モードではこれ以外のオプションは使えません。また POSIX
       準拠モードでは、-l
       オプション指定時、プロセスごとではなくジョブごとに状態を表示します。

       Yash では、ジョブのプロセスグループ ID
       はジョブを構成するパイプラインの最初のコマンドのプロセス ID
       に一致します。

KILL 組
       Kill 組込みコマンドはプロセスにシグナルを送ります。

   構
       •   kill [-シグナル|-s シグナル|-n シグナル] プロセス...

       •   kill -l [-v] [シグナル...]

       Kill コマンドでは、POSIX
       準拠モードであるかどうかにかかわらずオプションはオペランドより先に全て指定しなければなりません。最初のオペランドより後にあるコマンドライン引数は全てオペランドとして解釈します。

   説
       -l オプションを付けずに実行すると、kill
       コマンドは指定したプロセスにシグナルを送信します。送信するシグナルの種類はシグナル指定オプションで指定します。シグナルの種類を指定しない場合は
       SIGTERM シグナルを送信します。

       -l オプションを付けて実行すると、kill
       コマンドは指定したシグナルに関する情報を標準出力に出力します。シグナルを指定しない場合は全てのシグナルに関する情報を表示します。

   オ
       シ

           -シグナル, -s シグナル, -n シグナル
               送信するシグナルを指定します。シグナルにはシグナル番号とシグナル名のどちらかを指定します。シグナル番号として
               0
               を指定すると、シグナルを送ることができるかどうかの判定だけを行い、実際にはシグナルを送信しません。シグナルを名前で指定する際は、大文字と小文字の区別はありません。

           シグナル指定オプションは一度に一つまでしか使えません。

       他

           -l
               シグナルに関する情報を表示します。

           -v
               シグナルに関する情報をより詳しく表示します。-v
               オプションを指定していない場合は単にシグナル名を出力しますが、指定している場合はシグナル番号・シグナル名・シグナルの簡単な説明を出力します。

               このオプションを指定したときは同時に -l
               も指定してあるとみなします。

   オ
       プロセス
           シグナルを送信するプロセスをプロセス ID・プロセスグループ
           ID・ジョブ ID のいずれかで指定します。プロセスグループ ID
           を指定するときは、先頭に負号 (-) を付けます。プロセスとして 0
           を指定すると、シェルプロセスが属するプロセスグループを指定したものとみなします。プロセスとして
           -1 を指定すると、全てのプロセスにシグナルを送信します。

       シグナル
           情報を表示するシグナルの名前または番号です。シグナルによって中断したコマンドの終了ステータスを指定することもできます。

   終
       エラーがない限り kill コマンドの終了ステータスは 0
       です。一つ以上のプロセスにシグナルを送ることができた場合、他にシグナルを送れなかったプロセスがあったとしても終了ステータスは
       0 になります。

   補
       Kill コマンドは必須組込みコマンドです。

       負数に見えるコマンドライン引数の扱いには注意が必要です。例えば kill -1
       -2 では -1 がシグナル指定オプション、-2 がオペランドとなるので、番号 1
       のシグナルをプロセスグループ 2 に送信します。kill — -1 -2 や kill -TERM
       -1 -2 では -1 と -2 はどちらもオペランドになります。

       POSIX には -v および -n
       オプションに関する規定はありません。よってこれらのオプションは POSIX
       準拠モードでは使えません。また POSIX は -s
       オプションの引数としてシグナル番号を指定することを認めていません。POSIX
       はシグナルのオペランドとしてシグナルの名前を指定することを認めていません。

       POSIX は、シグナル名は INT や QUIT のように最初の SIG
       を除いた形で指定しなければならないと規定しています。非 POSIX
       準拠モードの yash では、拡張として SIG を付けた形でも指定できます。

LOCAL 組
       Local 組込みコマンドはローカル変数を表示・設定します。

   構
       •   local [-rxX] [name[=value]...]

   説
       Local コマンドは typeset コマンドと同じですが -f (--functions) および
       -g (--global) オプションは使えません。

   補
       Local コマンドは任意組込みコマンドです。 POSIX では local
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

POPD 組
       Popd
       組込みコマンドはディレクトリスタックからディレクトリを削除し、シェルの作業ディレクトリを戻します。

   構
       •   popd [インデックス]

   説
       Popd
       コマンドはディレクトリスタックからオペランドで指定したインデックスの要素を削除します。インデックス
       +0 の要素を削除した場合は、新たにインデックス +0
       の要素となったディレクトリにシェルの作業ディレクトリを変更し、そのディレクトリ名を標準出力に出力します。

   オ
       インデックス
           削除するディレクトリスタックの要素のインデックスです。省略すると +0
           を指定したものとみなします。

   終
       Popd コマンドの終了ステータスは、cd
       コマンドの終了ステータスに加えて以下の値があります。

       •   DIRSTACK 変数が読み取り専用または空の場合は 4。

       •   インデックスが範囲外の場合は 4。

   補
       ディレクトリスタックに要素が一つしかない場合はそれ以上要素を削除できないので、エラーになります。

       Popd コマンドは任意組込みコマンドです。 POSIX では popd
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

PRINTF 組
       Printf 組込みコマンドはオペランドを整形して出力します。

   構
       •   printf 書式 [値...]

   説
       Printf
       コマンドはオペランドで指定した書式に従って値を整形し、標準出力に出力します。Echo
       コマンドとは異なり、出力の最後には自動的に改行は付きません。

       書式の指定の仕方は C 言語の printf 関数とよく似ています。書式の中では %
       で始まる変換指定と \
       で始まるエスケープシーケンスを使用できます。書式に含まれる変換指定とエスケープ以外の文字はそのまま出力します。

       変

           変換指定はパーセント記号 (%) から始まります。

           %%
           以外の変換指定は、対応する値をとります。変換指定は、値を特定の形式に整形して出力します。デフォルトでは変換指定と値は与えられた順番に対応付けられますが、変換指定に位置を含めることで任意の順序で対応させることもできます。値が余った場合は、全ての値を処理し終わるまで書式の整形・出力を繰り返します。値が足りない場合は、空文字列
           (文字列に関する変換指定の場合) または 0
           (数値に関する変換指定の場合)
           を仮定します。値が一つも与えられていない場合は、書式は一度だけ出力されます。

           利用可能な変換指定は以下の通りです。

           %d, %i
               整数の値を (符号付き) 十進整数として出力します。

           %u
               整数の値を (符号なし) 十進非負整数として出力します。

           %o
               整数の値を (符号なし) 八進非負整数として出力します。

           %x
               整数の値を小文字の (符号なし) 十六進非負整数として出力します。

           %X
               整数の値を大文字の (符号なし) 十六進非負整数として出力します。

           %f
               実数の値を小文字の (符号付き) 小数として出力します。

           %F
               実数の値を大文字の (符号付き) 小数として出力します。

           %e
               実数の値を小文字の (符号付き) 指数表記小数で出力します。

           %E
               実数の値を大文字の (符号付き) 指数表記小数で出力します。

           %g
               値の大きさや精度に応じて %f と %e
               のどちらかの形式で出力します。

           %G
               値の大きさや精度に応じて %F と %E
               のどちらかの形式で出力します。

           %c
               文字列の値の最初の文字を出力します。

           %s
               文字列の値をそのまま出力します。

           %b
               文字列の値を、エスケープシーケンスを解釈しながら出力します。ここで使えるエスケープシーケンスは
               echo コマンドで使えるエスケープシーケンスと同じです。

           %%
               パーセント記号 (%) を出力します。

           %g と %G では、小数の指数部が -5 以上精度以下の時に %f または %F
           を、それ以外の時に %e または %E を使用します。

           %% 以外の変換指定では、最初の %
           の直後に位置・変換指定フラグ・フィールド幅・精度をこの順で指定できます。これらを指定することで出力の形式を細かく調整できます。

           位置は、正の整数 (十進法) の直後に $ を置いたものの形で指定します。
           この整数は、オペランドで指定された値の中から何番目の値を使用するかを指定します。
           例えば、書式が %2$d %1$d の場合、2 番目の値が最初に、1
           番目の値が次に出力されます。

           複数の変換指定で同じ位置を指定することもできます。

           ある変換指定がある位置の値を使用する場合、その位置より前の値は他の変換指定から使われない限り無視されます。

           指定できる変換指定フラグは以下の通りです。フラグを複数指定しても構いません。

           マイナス (-)
               このフラグを指定すると、指定したフィールド幅の中で値を左に寄せて出力します。このフラグを指定しない場合、値は右に寄ります。

           プラス (+)
               数値の符号 (正号または負号) を必ず出力します。

           空白文字 ( )
               出力する数値に符号 (正号または負号)
               が付かない場合は、符号の代わりに空白文字を出力します。

           #
               値を別形式で出力します。 変換指定が %o
               の場合、出力する八進数の先頭に必ず一桁以上の 0
               が付くように、必要に応じて 0 を付加します。 変換指定が %x
               (または %X) の場合、値が 0 でなければ数値の先頭に 0x (または
               0X) を付加します。 変換指定が %e, %E, %f, %F, %g, %G
               の場合、小数点の後に数字がない場合でも小数点を省略しないようにします。また変換指定が
               %g, %G の場合、小数点の後に 0 以外の数字がない場合でも 0
               を省略しないようにします。

           ゼロ (0)
               変換指定が %d, %i, %u, %o, %x, %X, %e, %E, %f, %F, %g, %G
               の場合、出力が指定したフィールド幅いっぱいになるまで数値の先頭に
               0 を付加します。

               マイナスフラグが指定されている場合、このフラグは無視されます。

               変換指定が %d, %i, %u, %o, %x, %X
               で、精度が指定されている場合、このフラグは無視されます。

           フィールド幅は、先頭に 0 の付かない十進整数の形で指定します。

           フィールド幅は出力の最低バイト数を指示します。出力のバイト数がフィールド幅に満たないときは、バイト数がフィールド幅に一致するまで空白文字を付加します。

           精度は、ピリオド (.)
           の直後に十進整数を置いたものの形で指定します。ピリオドの後に整数がなければ、0
           が指定してあるものとみなします。

           変換指定が %d, %i, %u, %o, %x, %X
           の場合、精度は出力の最低桁数を指示します。数値が最低桁数に満たない場合は最低桁数に達するまで先頭に
           0 を付加します。精度が指定されていない場合、精度は 1 とみなします。

           変換指定が %e, %E, %f, %F
           の場合、精度は小数点以降の桁数を指示します。精度が指定されていない場合、精度は
           6 とみなします。

           変換指定が %g, %G
           の場合、精度は数値の最大有効桁数を指示します。精度が指定されていない場合、精度は
           6 とみなします。

           変換指定が %s, %b
           の場合、精度は出力する文字列の最大バイト数を指示します。精度が指定されていない場合、精度は無限大とみなします。

           変換指定 %f にゼロフラグを指定し、フィールド幅に 8、精度に 3
           を指定する場合、最終的な変換指定は %08.3f
           となります。この変換指定に対して値 12.34 を与えると、出力は
           0012.340 となります。

       エ

           書式の中で使えるエスケープシーケンスは以下の通りです。

           \a
               ベル文字 (ASCII コード番号 7)

           \b
               バックスペース (ASCII コード番号 8)

           \f
               フォームフィード (ASCII コード番号 12)

           \n
               改行文字 (ASCII コード番号 10)

           \r
               復帰文字 (ASCII コード番号 13)

           \t
               水平タブ (ASCII コード番号 9)

           \v
               垂直タブ (ASCII コード番号 11)

           \\
               バックスラッシュ

           \"
               二重引用符

           \'
               一重引用符 (アポストロフィー)

           \xxx
               八進数 xxx (最大三桁) で表わされるコード番号の文字

   オ
       書式
           出力する文字列の書式です。

       値
           変換指定が出力する値 (数値または文字列) です。

           数値を値として指定する際、一重または二重引用符の後に何か文字を置いたものを指定することで、その文字のコード番号を数値として指定できます。例えば
           3 という文字のコード番号が 51 ならば、 printf '%d' '"3' は 51
           を出力します。

   終
       エラーがない限り printf コマンドの終了ステータスは 0 です。

   補
       POSIX では、マルチバイト文字の扱いについて厳密に定義していません。%s
       変換指定で精度を指定した場合や、%c
       変換指定を使用する場合、値にマルチバイト文字が含まれていると適切な出力が得られないかもしれません。Yash
       では、マルチバイト文字は全てワイド文字に変換してから処理するので、マルチバイト文字の一部のバイトだけが出力されるようなことはありません。

       シェルが非 POSIX 準拠モードで、システム上で 『long double』
       浮動小数点数が使用可能な場合は、実数の変換指定は 『long double』
       で処理されます。それ以外の場合は 『double』 で処理されます。

       POSIX
       では、位置を含む変換指定と含まない変換指定を混在させることはできません。
       このような書式を使用すると、シェルの種類やバージョンによって値の選択順序が変わったりエラーになったりする可能性があります。

PUSHD 組
       Pushd
       組込みコマンドはディレクトリスタックにディレクトリを追加し、シェルの作業ディレクトリをそのディレクトリに変更します。

   構
       •   pushd [-L|-P [-e]] [ディレクトリ]

   説
       Pushd コマンドは cd
       コマンドと同様に、シェルの作業ディレクトリをオペランドで指定したディレクトリに変更します。作業ディレクトリの変更に成功すると、新しい作業ディレクトリをディレクトリスタックに追加します。

   オ
       Cd コマンドで使えるオプションに加えて以下のオプションが pushd
       コマンドで使えます。

       --remove-duplicates
           新しい作業ディレクトリが既にディレクトリスタックに入っている場合は、元々入っていた要素を削除して重複をなくします。

   オ
       ディレクトリ
           新しい作業ディレクトリのパス名です。絶対パスまたは元の作業ディレクトリからの相対パスで指定します。

           この値がハイフン一つ (-) の場合、OLDPWD
           変数の値が指定されたものとみなします。

           この値が符号付き整数の場合、その整数をディレクトリスタックの要素のインデックスとみなして、その要素が表すディレクトリが指定されたものとみなします
           (指定された要素はディレクトリスタックから削除されます)。

           このオペランドが与えられていない場合、インデックス +1
           が指定されたものとみなします (--default-directory
           オプションを指定した場合を除く)。

   終
       Pushd コマンドの終了ステータスは、cd
       コマンドの終了ステータスに加えて以下の値があります。

       •   DIRSTACK 変数が読み取り専用の場合は 1。

       •   PWD 変数が未設定の場合は 4。

       •   ディレクトリが符号付き整数であり、そのインデックスが範囲外の場合は
           4。

       •   ディレクトリおよび --default-directory=...
           オプションが指定されておらず、ディレクトリスタックが空の場合は 4。

   補
       Pushd コマンドは任意組込みコマンドです。 POSIX では pushd
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

PWD 組
       Pwd 組込みコマンドはシェルの現在の作業ディレクトリを表示します。

   構
       •   pwd [-L|-P]

   説
       Pwd
       コマンドはシェルの現在の作業ディレクトリを絶対パスで標準出力に出力します。

   オ
       -L, --logical
           PWD 変数の値が現在の作業ディレクトリの絶対パスで、中に . や ..
           を含んでいなければ、それを出力します。それ以外の場合は -P
           を指定した場合と同様に出力します。

       -P, --physical
           現在の作業ディレクトリの絶対パスを、中にシンボリックリンクを含まないかたちで出力します。

       -L (--logical) オプションと -P (--physical)
       オプションの両方を指定した場合、後に指定したほうを優先します。どちらも指定していない場合は、-L
       を指定したものとみなします。

   終
       エラーがない限り pwd コマンドの終了ステータスは 0 です。

   補
       Pwd コマンドは代替組込みコマンドです。

READ 組
       Read 組込みコマンドは標準入力から行を読み込み変数に代入します。

   構
       •   read [-Aer] [-d 行区切り] [-P|-p プロンプト] 変数名...

   説
       Read
       コマンドは標準入力から一行の文字列を読み込み、それを変数に代入します。

       -r (--raw-mode)
       オプションを付けると、行内のバックスラッシュは通常の文字と同様に扱われます。

       -r (--raw-mode)
       オプションを付けない場合、読み込んだ文字列の中のバックスラッシュ (\)
       は引用符として働きます。バックスラッシュが行末にあるときは行の連結を行います。対話モードのシェルが
       2 行目以降を読み込むとき、標準入力が端末ならば PS2
       変数の値がプロンプトとして出力されます。

       通常、入力行は改行文字まで読み込まれます。-d (--delimiter)
       オプションを指定すると、改行文字の代わりに指定された行区切り文字まで読み込みます。行区切り文字は
       1 文字である必要があります。

       読み込んだ文字列は、単語分割によって分割します。分割後の各文字列が、それぞれオペランドで指定された変数の値に順に設定されます。指定された変数の数より分割結果のほうが多い場合は、最後の変数に残りの分割結果の全てが入ります。分割結果の数より指定された変数のほうが多い場合は、余った変数には空文字列が入ります。

   オ
       -A, --array
           最後に指定した変数を配列にします。分割後の各文字列が配列の要素として設定されます。

       -d 行区切り, --delimiter=行区切り
           改行文字の代わりに指定された行区切り文字まで読み込みます。

       -e, --line-editing
           読み込みに行編集を使用します。

           行編集が有効になるには以下の条件が全て満たされている必要があります:

           •   シェルが対話モードである。

           •   vi または emacs オプションが有効になっている。

           •   標準入力と標準エラーが端末である。

           •   行区切りが改行文字である。

       -P, --ps1
           シェルが対話モードで標準入力が端末ならば、(最初の) 行を読み込む前に
           PS1 変数をプロンプトとしてを表示します。

       -p プロンプト, --prompt=プロンプト
           シェルが対話モードで標準入力が端末ならば、(最初の)
           行を読み込む前にプロンプトを表示します。

       -r, --raw-mode
           読み込んだ文字列の中のバックスラッシュを引用符として扱わないようにします。

   オ
       変数名
           読み込んだ文字列を格納する変数の名前です。

   終
       行を正常に読み込んだ場合は終了ステータスは 0 です。
       入力の終わりに達した場合は 1
       です。この場合はそれまでに読み込んだ文字列が変数に代入されます。
       変数が読み取り専用の場合は 2 です。 標準入力が読み込めない場合は 3
       です。 コマンドライン引数に構文エラーがある場合は 4 です。

   補
       Read コマンドは必須組込みコマンドです。

       POSIX では -d と -r オプションのみが規定されています。他のオプションは
       POSIX 準拠モードでは使えません。 終了ステータスは 0 と 1 だけが POSIX
       で固定されています。他のエラーの場合はシェルによって終了ステータスが異なります。

       PS1 変数をプロンプトとして表示する際、PS1R および PS1S
       変数も使用されます。 PS2 についても同様です。

READONLY 組
       Readonly
       組込みコマンドは読み取り専用の変数または関数を表示・設定します。

   構
       •   readonly [-pxX] [変数[=値]...]

       •   readonly -f[p] [変数...]

   説
       Readonly コマンドは typeset コマンドに -gr
       オプションを付けたものと同じです。その他オプション・オペランド・終了ステータスは
       typeset コマンドと同様です。

   補
       readonly コマンドは特殊組込みコマンドです。

       POSIX には readonly コマンドに関する規定はありますが、オプションは -p
       しか規定がありません。その他のオプションは POSIX
       準拠モードでは使えません。また POSIX は -p
       オプションをオペランドとともに使うことを認めていません。

       POSIX 準拠モードでは以下の変数は読み取り専用にできません:

       •   LINENO

       •   OLDPWD

       •   OPTARG

       •   OPTIND

       •   PWD

RETURN 組
       Return
       組込みコマンドは現在実行中の関数またはスクリプトの実行を終了します。

   構
       •   return [-n] [終了ステータス]

   説
       -n (--no-return) オプションを付けずに return
       コマンドを実行すると、以下のうち当てはまる動作を行います:

       •   関数の実行中の場合は、その関数の実行を終了します。

       •   ドットコマンドでファイルを開いてコマンドを実行している途中の場合は、そのファイルの読み込み・実行を終了します。

       •   シェルの初期化スクリプトを実行中の場合は、そのスクリプトの実行を終了します。

       •   トラップを実行中の場合は、そのトラップの実行を終了します。(ただし他のシグナルに関するトラップの実行が控えている場合はそれらは通常通り実行されます。)

       •   これ以外の場合は、(対話モードのときを除いて) シェルは終了します。

       -n (--no-return) オプションを付けて return コマンドを実行すると、return
       コマンドはただ単にオペランドで指定されている終了ステータスを返します。

   オ
       -n, --no-return
           コマンドの実行を中断しません。

   オ
       終了ステータス
           Return コマンドの終了ステータスを指定する 0 以上の自然数です。

           このオペランドが与えられていない場合は、return
           コマンドの直前に実行されたコマンドの終了ステータスを用います
           (ただしトラップを実行中の場合はトラップに入る直前のコマンドの終了ステータス)。

   終
       Return コマンドの終了ステータスはオペランドで与えられた値です。Return
       コマンドの終了ステータスは return
       コマンドが終了する関数・ドットコマンド・初期化スクリプト・シェル自身の終了ステータスにもなります。

   補
       Return コマンドは特殊組込みコマンドです。

       256 以上の終了ステータスは移植性のない拡張です。

       POSIX では関数あるいはドットコマンドの実行中以外における return
       コマンドの動作を定めていません。

       POSIX には -n (--no-return)
       オプションに関する規定はありません。よってこのオプションは POSIX
       準拠モードでは使えません。

SET 組
       Set
       組込みコマンドはシェルのオプションの設定と位置パラメータの変更を行います。

   構
       •   set [オプション...] [オペランド...]

       •   set -o

       •   set +o

       Set コマンドでは、POSIX
       準拠モードであるかどうかにかかわらずオプションはオペランドより先に全て指定しなければなりません。最初のオペランドより後にあるコマンドライン引数は全てオペランドとして解釈します。

   説
       コマンドライン引数を一切与えずに set
       コマンドを実行すると、現在シェルに設定されている全ての変数の一覧をアルファベット順で
       (コマンドとして解釈可能な形式で) 標準出力に出力します。

       -o
       を唯一のコマンドライン引数として与えた場合は現在のシェルのオプション設定を一覧にして標準出力に出力します。+o
       を唯一のコマンドライン引数として与えた場合も同様ですが、この場合はコマンドとして解釈可能な形式で出力します。

       これ以外の場合は、set
       コマンドは以下のようにシェルのオプションの設定と位置パラメータの変更のどちらかまたは両方の動作を行います。

   オ
       オプションが一つ以上与えられている場合、set
       コマンドはそれらの有効・無効を切り替えます。通常の形式でオプションを与えると、そのオプションは有効になります。オプションの先頭のハイフン
       (-) の代わりにプラス (+)
       を付けて指定すると、そのオプションは無効になります。例えば -m や -o
       monitor や --monitor はシェルのジョブ制御を有効にし、逆に +m や +o
       monitor や ++monitor はジョブ制御を無効にします。

       長いオプションの名前に含まれる英数字以外の文字は無視され、大文字と小文字の区別はありません。例えば
       --Le-Comp-Debug は --lecompdebug
       に同じです。また長いオプションの名前の先頭に no
       を付けることで、オプションの有効・無効を逆転することができます。例えば
       --noallexport は ++allexport に同じく、また ++nonotify は --notify
       に同じです。

       オプションは以下に挙げる形式で指定することができます:

       •   長いオプション (例: --allexport)

       •   引数としてオプション名を指定した -o オプション (例: -o allexport)

       •   一文字のオプション (例: -a)

       ただし全てのオプションが一文字のオプションで指定できるわけではありません。

       利用可能なオプションは以下のとおりです:

       all-export (-a)
           このオプションが有効な時、変数に代入をするとその変数は自動的にエクスポート対象になります。

       brace-expand
           このオプションはブレース展開を有効にします。

       case-glob
           このオプションが有効な時、パス名展開におけるパターンマッチングは大文字と小文字を区別して行います。このオプションはシェルの起動時に最初から有効になっています。

       clobber (+C)
           このオプションを無効にすると、 >
           演算子によるリダイレクトで既存のファイルを上書きすることはできなくなります。このオプションはシェルの起動時に最初から有効になっています。

       cur-async, cur-bg, cur-stop
           これらのオプションは現在のジョブの選択の仕方に影響します。(ジョブ
           ID
           参照)。これらのオプションはシェルの起動時に最初から有効になっています。

       dot-glob
           このオプションが有効な時、パス名展開においてファイル名の先頭のピリオドを特別に扱いません。

       emacs
           このオプションは emacs 風行編集を有効にします。

       empty-last-field
           このオプションが有効な時、単語分割で最後の単語が空になっても削除しません。

       err-exit (-e)
           このオプションが有効な時、実行したパイプラインの終了ステータスが 0
           でなければ、シェルは直ちに終了します。ただし、以下の抑止条件に当てはまる場合を除きます。

           •   そのコマンドが if 文の分岐や while/until
               文のループ条件の判定に使われる場合

           •   パイプラインの先頭に ! が付いている場合

           •   パイプラインがサブシェルグルーピング以外の単独の複合コマンドから構成される場合

       err-return
           このオプションは err-exit オプションと同様ですが、終了ステータスが
           0 でないときにシェルが終了する代わりに return
           組込みコマンドが発動します。 Err-exit
           オプションと異なり、抑止条件は関数・サブシェルグルーピング・スクリプトファイルの中では無視されます。

       exec (+n)
           このオプションが無効な時、シェルはコマンドの解釈だけを行い、実際にはコマンドを実行しません。このオプションはシェルスクリプトの文法チェックをするのに便利です。このオプションはシェルの起動時に最初から有効になっています。対話モードでは、このオプションに関わらずコマンドは常に実行されます。

       extended-glob
           このオプションはパス名展開における拡張機能を有効にします。

       for-local
           For
           ループが関数の中で実行されるとき、このオプションが有効ならばループの変数はローカル変数として代入されます。このオプションはシェルの起動時に最初から有効になっています。POSIX
           準拠モードではこのオプションに関係なく for
           ループの変数は通常の変数として代入されます。

       glob (+f)
           このオプションが有効なときはシェルはパス名展開を行います。このオプションはシェルの起動時に最初から有効になっています。

       hash-on-def (-h)
           このオプションが有効なとき関数を定義すると、直ちにその関数内で使われる各コマンドの
           PATH 検索を行いコマンドのパス名を記憶します。

       hist-space
           このオプションが有効な時は空白で始まる行はコマンド履歴に自動的に追加しません。

       ignore-eof
           このオプションが有効な時、対話モードのシェルに EOF (入力の終わり)
           が入力されてもシェルはそれを無視してコマンドの読み込みを続けます。これにより、誤って
           Ctrl-D を押してしまってもシェルは終了しなくなります。

       le-always-rp, le-comp-debug, le-conv-meta, le-no-conv-meta, le-predict,
       le-predict-empty, le-prompt-sp, le-visible-bell, le-trim-right
           これらのオプションは行編集の動作に影響します。行編集のオプションを参照してください。

       mark-dirs
           このオプションが有効な時、パス名展開の展開結果においてディレクトリを表すものの末尾にスラッシュを付けます。

       monitor (-m)
           このオプションはジョブ制御を有効にします。シェルを対話モードで起動したときこのオプションは自動的に有効になります。

       notify (-b)
           このオプションが有効な時は、バックグラウンドのジョブの実行状態が変化するとシェルは直ちにそれを標準エラーに報告します。このオプションは
           notifyle オプションより優先します。

       notify-le
           このオプションは notify
           オプションとほぼ同じですが、行編集を行っている最中のみジョブの状態変化を報告します。

       null-glob
           このオプションが有効な時、パス名展開でマッチするパス名がないとき元のパターンは残りません。

       pipe-fail
           このオプションが有効な時、パイプラインの全てのコマンドの終了ステータスが
           0 の時のみパイプラインの終了ステータスが 0 になります。

       posixly-correct
           このオプションは POSIX 準拠モードを有効にします。

       trace-all
           このオプションは、補助コマンド実行中も x-trace
           オプションを機能させるかどうかを指定します。補助コマンドとは、
           COMMAND_NOT_FOUND_HANDLER、 POST_PROMPT_COMMAND、
           PROMPT_COMMAND、および YASH_AFTER_CD
           変数の値として定義され、特定のタイミングで解釈・実行されるコマンドです。
           このオプションはシェルの起動時に最初から有効になっています。

       unset (+u)
           このオプションが有効な時、パラメータ展開で存在しない変数を展開すると空文字列に展開され、数式展開で存在しない変数を使用すると
           0
           とみなされます。オプションが無効な時、存在しない変数を使用するとエラーになります。このオプションはシェルの起動時に最初から有効になっています。

       verbose (-v)
           このオプションが有効な時、シェルは読み込んだコマンドをそのまま標準エラーに出力します。

       vi
           このオプションは vi
           風行編集を有効にします。対話モードが有効で標準入力と標準エラーがともに端末ならばこのオプションはシェルの起動時に自動的に有効になります。

       x-trace (-x)
           このオプションが有効な時、コマンドを実行する前に展開の結果を標準エラーに出力します。この出力は、各行頭に
           PS4 変数の値を展開した結果を付けて示されます。 Trace-all
           オプションも参照してください。

   オ
       Set
       コマンドにオペランドが与えられている場合またはオプションとオペランドを区切るハイフン二つ
       (--, コマンドの引数の構文参照)
       がコマンドライン引数に入っている場合は、現在の位置パラメータは削除され、与えられたオペランドがそれぞれ新しく位置パラメータになります。ハイフン二つが与えられていてかつオペランドがない場合は位置パラメータはなくなります。

   終
       オプションの指定が間違っている場合を除き、set
       コマンドの終了ステータスは 0 です。

   補
       Set コマンドは特殊組込みコマンドです。

       POSIX 規格に定義されているオプションは限られています。規格の定義では、

       •   --allexport などの長いオプションは使えません。

       •   オプション名に no を付けてオプションを無効にすることはできません。

       •   オプション名に大文字や英字でない記号は使えません。

       規格に定義されているオプションは以下のとおりです:

       •   -a, -o allexport

       •   -e, -o errexit

       •   -m, -o monitor

       •   -C, -o noclobber

       •   -n, -o noexec

       •   -f, -o noglob

       •   -b, -o notify

       •   -u, -o nounset

       •   -v, -o verbose

       •   -x, -o xtrace

       •   -h

       •   -o ignoreeof

       •   -o nolog

       •   -o vi

       Yash は nolog オプションをサポートしていません。 このオプションは古い
       Korn
       シェルで関数定義をコマンド履歴に登録しないようにする機能がありましたが、現在ほとんどのシェルではサポートされていません。

       Yash の hash-on-def オプションの動作は、POSIX.1-2001
       に基づいています。既存の多くのシェルはこのオプションを異なる動作で実装しており、POSIX.1-2024
       ではこのオプションの動作は規定されなくなりました。

SHIFT 組
       Shift
       組込みコマンドは位置パラメータまたは配列の要素のいくつかを削除します。

   構
       •   shift [-A 配列名] [個数]

   説
       Shift
       コマンドは位置パラメータまたは配列の要素のうち最初のいくつかを削除します。削除するパラメータ・要素の数はオペランドで指定します。

   オ
       -A 配列, --array=配列
           位置パラメータではなく配列の最初の要素を削除します。

   オ
       個数
           削除する位置パラメータまたは配列の要素の個数を指示する整数です。

           実際の位置パラメータ・要素の個数より大きい数を指定するとエラーになります。省略すると
           1
           を指定したものとみなします。負数を指定すると最初ではなく最後の位置パラメータまたは配列要素を削除します。

   終
       エラーがない限り shift コマンドの終了ステータスは 0 です。

   補
       Shift コマンドは特殊組込みコマンドです。

       位置パラメータの個数は特殊パラメータ #
       によって知ることができます。配列の要素の個数は ${配列[#]}
       によって知ることができます。

       POSIX には -A (--array)
       オプションに関する規定はありません。よってこのオプションは POSIX
       準拠モードでは使えません。

       POSIX 準拠モードでは負の個数は指定できません。

SUSPEND 組
       Suspend 組込みコマンドはシェルを停止 (サスペンド) します。

   構
       •   suspend [-f]

   説
       Suspend
       コマンドはシェルプロセスが属するプロセスグループ内のすべてのプロセスに対して
       SIGSTOP シグナルを送信します。これにより、シグナルを送られた各プロセス
       (シェル自身を含む) は停止 (サスペンド)
       状態になります。停止状態になったプロセスは SIGCONT
       シグナルを受信すると実行を再開します。

       シェルが対話モードで、さらにシェルプロセスのプロセスグループ ID
       がセッションリーダーのプロセス ID に等しいときは、-f (--force)
       オプションを付けない限りシェルは警告を表示し、シグナルを送信しません。これはシェルが停止した後実行を再開させることができなくなってしまうのを未然に防ぐためです。

   オ
       -f, --force
           警告を無視してシェルを停止します。

   終
       Suspend コマンドの終了ステータスは、SIGSTOP
       シグナルをシェルに正しく送信できたときは 0、それ以外なら非 0 です。

   補
       Suspend コマンドは任意組込みコマンドです。 POSIX では suspend
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

TEST 組
       Test 組込みコマンドは引数で指定した内容の判定を行います。

   構
       •   test 判定式

       •   [ 判定式 ]

       Test
       コマンドはオプションとオペランドとを区別しません。コマンドライン引数は全て判定式として解釈します。コマンドが
       [ の名前で実行された時は、判定式の後に ] が必要です。

   説
       Test コマンドは引数で与えられた判定式を評価し、結果が真ならば 0
       の終了ステータスを、偽ならば 1
       の終了ステータスで終了します。判定式は何種類かの演算子とそれに対する被演算子とからなります。

       ファイルに関する判定を行う単項演算子は以下の通りです。指定したファイルがシンボリックリンクの場合、そのシンボリックリンクが指している先のファイルについて判定を行います
       (-h, -L 演算子を除く)。

       -b ファイル
           ファイルがブロックスペシャルファイルかどうか

       -c ファイル
           ファイルがキャラクタスペシャルファイルかどうか

       -d ファイル
           ファイルがディレクトリかどうか

       -e ファイル
           ファイルが存在するかどうか

       -f ファイル
           ファイルが通常のファイルかどうか

       -G ファイル
           ファイルのグループ ID がシェルの実効グループ ID に等しいかどうか

       -g ファイル
           ファイルの set-group-ID ビットが設定されているかどうか

       -h ファイル
           -L ファイル に同じ

       -k ファイル
           ファイルの sticky ビットが設定されているかどうか

       -L ファイル
           ファイルがシンボリックリンクかどうか

       -N ファイル
           ファイルの最終変更日時が最終アクセス日時より後かどうか

       -O ファイル
           ファイルのユーザ ID がシェルの実効ユーザ ID に等しいかどうか

       -p ファイル
           ファイルが FIFO (名前付きパイプ) かどうか

       -r ファイル
           ファイルが読み込み可能かどうか

       -S ファイル
           ファイルがソケットかどうか

       -s ファイル
           ファイルサイズが空でないかどうか

       -u ファイル
           ファイルの set-user-ID ビットが設定されているかどうか

       -w ファイル
           ファイルが書き込み可能かどうか

       -x ファイル
           ファイルが実行可能かどうか

       ファイル記述子に関する判定を行う単項演算子は以下の通りです。

       -t ファイル記述子
           ファイル記述子が端末かどうか (ファイル記述子は 0
           以上の自然数で指定します)

       文字列に関する判定を行う単項演算子は以下の通りです。

       -n 文字列
           文字列が空文字列でないかどうか

       -z 文字列
           文字列が空文字列かどうか

       シェルのオプションに関する判定を行う単項演算子は以下の通りです。

       -o ?オプション
           オプションが正しいオプション名であるかどうか

       -o オプション
           オプションが正しいオプション名であり、かつオプションが有効に設定されているかどうか

       ファイルに関する判定を行う二項演算子は以下の通りです
       (存在しないファイルは他のファイルより古いとみなします)。

       ファイル1 -nt ファイル2
           ファイル1の更新時刻がファイル2より新しいかどうか

       ファイル1 -ot ファイル2
           ファイル1の更新時刻がファイル2より古いかどうか

       ファイル1 -ef ファイル2
           二つのファイルが互いのハードリンクであるかどうか

       文字列に関する判定を行う二項演算子は以下の通りです。

       文字列1 = 文字列2, 文字列1 == 文字列2
           二つの文字列が同じかどうか

       文字列1 != 文字列2
           二つの文字列が異なるかどうか

       以下の二項演算子は現在のロケールの辞書式順序に従って文字列を比較します。

       文字列1 === 文字列2
           二つの文字列が同じかどうか

       文字列1 !== 文字列2
           二つの文字列が異なるかどうか

       文字列1 < 文字列2
           文字列1 が 文字列2 よりも順序が手前かどうか

       文字列1 <= 文字列2
           文字列1 が 文字列2 よりも順序が手前または同じかどうか

       文字列1 > 文字列2
           文字列1 が 文字列2 よりも順序が後かどうか

       文字列1 >= 文字列2
           文字列1 が 文字列2 よりも順序が後または同じかどうか

       パターンマッチングを行う二項演算子は以下の通りです。

       文字列 =~ パターン
           拡張正規表現パターンが文字列(の一部)にマッチするかどうか

       整数に関する判定を行う二項演算子は以下の通りです。

       v1 -eq v2
           v1 と v2 が等しいかどうか

       v1 -ne v2
           v1 と v2 が異なるかどうか

       v1 -gt v2
           v1 が v2 よりも大きいかどうか

       v1 -ge v2
           v1 が v2 以上かどうか

       v1 -lt v2
           v1 が v2 よりも小さいかどうか

       v1 -le v2
           v1 が v2 以下かどうか

       バージョン番号を表す文字列に関する判定を行う二項演算子は以下の通りです。文字列のバージョン番号としての比較のしかたは後述します。

       v1 -veq v2
           v1 と v2 が等しいかどうか

       v1 -vne v2
           v1 と v2 が異なるかどうか

       v1 -vgt v2
           v1 が v2 よりも大きいかどうか

       v1 -vge v2
           v1 が v2 以上かどうか

       v1 -vlt v2
           v1 が v2 よりも小さいかどうか

       v1 -vle v2
           v1 が v2 以下かどうか

       判定式が空の場合、結果は偽とみなします。判定式が (演算子の付いていない)
       文字列一つの場合、その文字列が空文字列でないかどうかを判定します。

       複

           他の判定式を組み合わせてより複雑な判定式を作る演算子は以下の通りです。

           ! 判定式
               判定式が偽かどうか (判定式の真偽を逆転します)

           ( 判定式 )
               判定式が真かどうか (判定式の構文上の優先順位を高くします)

           判定式1 -a 判定式2
               二つの判定式が両方とも真かどうか

           判定式1 -o 判定式2
               二つの判定式の少なくとも片方が真かどうか

           ただし、括弧と -a と -o
           は非推奨です。代わりにコマンドの文法を活用することをお勧めします。

               # こうではなく
               [ 1 -eq 1 -a -t = 1 -o ! foo ]

               # こうすべきです
               [ 1 -eq 1 ] && [ -t = 1 ] || ! [ foo ]

       バ

           文字列のバージョン番号としての比較は、基本的には現在のロケール情報に従った辞書式順序で行います。ただし、連続する数字は一つの自然数として比較します。また数字とそれ以外の文字との比較では常に数字の方が大きいとみなします。

           例えば、0.1.2-3 と 00.001.02-3 は等しく、0.2.1 と 0.10.0
           とでは後者の方が大きいと判定されます。

   終
       Test コマンドの終了ステータスは、判定式の評価結果が真ならば 0、偽ならば
       1
       です。判定式の構文に誤りがある場合その他のエラーが発生したときは、終了ステータスは
       2 です。

   補
       複雑な判定式は誤って解釈されることがあるので避けることをお勧めします。例えば
       [ 1 -eq 1 -a -t = 1 -a ! foo ] は [ 1 -eq 1 ] && [ -t = 1 ] && ! [ foo
       ] のようにコマンドを分けると式がより明確になります。

       POSIX は、エラーが発生した場合の終了ステータスを 『2 以上』
       と定めています。また POSIX には以下の演算子の規定はありません: -G, -k,
       -N, -O, -nt, -ot, -ef, ==, ===, !==, <, <=, >, >=, =~, -veq, -vne,
       -vgt, -vge, -vlt, -vle, -a, -o 及び括弧。 POSIX
       準拠モードでは二項演算子 -a および -o ならびに括弧は使用できません。

TIMES 組
       Times 組込みコマンドはシェルとシェルが起動したコマンドが消費した CPU
       時間を表示します。

   構
       •   times

   説
       Times コマンドはシェルプロセスとその子プロセスが消費した CPU
       時間を標準出力に出力します。一行目にシェルプロセス自身がユーザモードおよびシステムモードで消費した
       CPU 時間をそれぞれ表示します。二行目にシェルの全ての子孫プロセス
       (親プロセスが wait していないものを除く)
       がユーザモードおよびシステムモードで消費した CPU
       時間をそれぞれ表示します。

   終
       エラーがない限り times コマンドの終了ステータスは 0 です。

   補
       Times コマンドは特殊組込みコマンドです。

TRAP 組
       Trap 組込みコマンドはシェルがシグナルを受信したときの動作を設定します。

   構
       •   trap

       •   trap 動作 シグナル...

       •   trap シグナル番号 [シグナル...]

       •   trap -p [シグナル...]

   説
       Trap コマンドはシェルプロセスがシグナルを受信したときの動作 (トラップ)
       を表示または設定します。

       オペランドに動作とシグナルを指定して trap
       コマンドを実行すると、シェルがシグナルを受信した際に指定した動作を行うようになります。最初のオペランドがシグナル番号の場合、それと残りのシグナルに対する動作は、動作として
       - が指定されたときと同様に標準の動作に設定されます。

       -p (--print)
       オプションを指定した場合またはオペランドを一つも指定していない場合は、trap
       コマンドは現在のトラップの設定状況をコマンドとして解釈可能な形式で標準出力に出力します。シグナルが与えられているときはそのシグナルに関する設定を出力します。シグナルなしで
       -p
       オプションを使用した場合、全てのシグナルの設定を出力します。シグナルを指定せず
       -p
       オプションも使用しない場合、標準以外の動作が設定された全てのシグナルを出力します。ただし、特定の状況では
       trap コマンドは現在の設定ではなく以前の設定を表示します
       (下記補足参照)。

   オ
       -p, --print
           現在のトラップの設定を表示します。

   オ
       動作
           シグナルを受信した際の動作を指定します。動作がハイフン一つ (-)
           ならば、シェルはシステムで規定された標準の動作を行います。動作が空文字列ならば、シェルはシグナルを無視します。それ以外の値を指定すると、シェルはこのオペランドをコマンドとみなして、シグナル受信時にこれを解釈・実行します
           (コマンドの実行中にシグナルを受信したときは、コマンドが終了した後にトラップを実行します)。

       シグナル
           動作の対象となるシグナルです。シグナルはシグナル番号とシグナル名のどちらかで指定します。

           シグナルとして 0 または EXIT
           を指定すると、これはシェルの終了時に発生する仮想のシグナルを指定しているとみなします。この仮想のシグナルに対して設定された動作は、シェルが正常終了する直前に実行されます。

       シグナル番号
           シグナルと同様ですが、シグナルを番号で指定します。

   終
       トラップが正しく設定または表示されたときは終了ステータスは 0
       です。エラーがあると終了ステータスは非 0 です。

   補
       Trap コマンドは特殊組込みコマンドです。

       POSIX は、シグナル名は INT や QUIT のように最初の SIG
       を除いた形で大文字で指定しなければならないと規定しています。Yash
       では、拡張として SIG
       を付けた形でも指定できますし、シグナル名の大文字と小文字を区別しません
       (このような拡張は POSIX でも認められています)。

       出

           Trap コマンドが出力したトラップの設定を変数に保存しておき、後で
           eval
           コマンドでそれを実行することで元のトラップの設定を復活させることができます。

               saved_trap=$(trap)
               trap '...' INT
               eval "$saved_trap"

           ただし、このテクニックの挙動には裏があります。Trap
           コマンドの出力を変数に保存するためにコマンド置換を使用しますが、コマンド置換はサブシェルで実行されます。サブシェルの開始時にトラップの設定は解除されるため、本来ならばサブシェル内の
           trap
           コマンドは何も出力せず、結果として変数にはトラップが保存されないことになります。

           この問題を回避するため、POSIX
           は以下のうちどちらかの挙動を執ることをシェルに求めています。

           •   コマンド置換の中身がただ一つの trap
               コマンドである場合は、そのコマンド置換を実行するサブシェルの開始時にトラップ設定を解除しない。

           •   サブシェルの開始時にトラップ設定を解除する際に、以前の設定を憶えておく。サブシェル内で
               trap
               コマンドがトラップ設定を出力する際、まだそのサブシェル内で別の
               trap
               コマンドがトラップ設定を変更していなければ、憶えておいた以前の設定を出力する。

           Yash は二つ目の選択肢に従います。

TRUE 組
       True 組込みコマンドは何も行わずに 0 の終了ステータスで終了します。

   構
       •   true

   説
       True コマンドは何も行いません。コマンドライン引数は一切無視します。

   終
       True コマンドの終了ステータスは 0 です。

   補
       True コマンドは代替組込みコマンドです。

       コロンコマンドは true コマンドと同様に何も行いませんが、true
       コマンドは代替組込みコマンドであるのに対しコロンコマンドは特殊組込みコマンドです。

TYPE 組
       Type 組込みコマンドはコマンドの種類を特定します。

   構
       •   type [-abefkp] [コマンド...]

   説
       Type コマンドは command コマンドに -V
       オプションを付けたものと同じです。その他オプション・オペランド・終了ステータスは
       command コマンドと同じです。

   補
       POSIX では、type コマンドと command
       コマンドとの関係について規定していません。従って他のシェルの type
       コマンドは command コマンドに -V
       オプションを付けたものとは異なる動作をすることがあります。また POSIX は
       type コマンドのオプションを規定していません。

       POSIX 準拠モードでは少なくとも一つコマンドを指定する必要があります。

       Type コマンドは必須組込みコマンドです。

TYPESET 組
       Typeset 組込みコマンドは変数または関数を表示・設定します。

   構
       •   typeset [-gprxX] [変数[=値]...]

       •   typeset -f[pr] [関数...]

   説
       -f (--functions) オプションを付けずに実行すると、typeset
       コマンドは変数を出力または設定します。-f (--functions)
       オプションを付けて実行すると、typeset
       コマンドは関数を出力または設定します。

       -p (--print) オプションを付けて実行すると、typeset
       コマンドはオペランドで指定した変数または関数を標準出力に出力します。-p
       (--print) オプションを付けずに実行すると、typeset
       コマンドはオペランドで指定した変数または関数を設定します。オペランドを一つも与えずに実行すると、-p
       (--print) オプションの有無にかかわらず typeset
       コマンドは全ての変数または関数を出力します (このとき -g (--global)
       オプションがあれば本当にすべての変数を、そうでないときはローカル変数だけを出力します)。

   オ
       -f, --functions
           変数ではなく関数を表示または設定します。

       -g, --global
           このオプションを指定すると、新しく変数を作成する場合その変数をグローバル変数とします。すなわち変数は関数の実行が終わっても残ります。このオプションを指定しない場合、設定する変数はローカル変数になります。

           オペランドがない場合は、このオプションを指定していると全ての変数を出力します。このオプションを指定していないとローカル変数だけ出力します。

       -p, --print
           変数または関数の定義を (コマンドとして解釈可能な形式で)
           出力します。

       -r, --readonly
           設定する変数・関数を読み取り専用にします。読み取り専用の変数・関数は、値を変更したり削除したりできなくなります。

           変数・関数を出力する際は、読み取り専用の変数・関数だけ出力します。

       -x, --export
           設定する変数をエクスポート対象にします。

           変数を出力する際は、エクスポート対象の変数だけ出力します。

       -X, --unexport
           設定する変数をエクスポート対象から外します。

   オ
       変数
           出力または設定する変数の名前です。

           変数が既に存在する場合、変数の値は変わりません。存在しない変数を指定した場合、変数は存在するがその値は存在しない状態になります
           (このような変数はパラメータ展開では存在しない変数として扱います)。

       変数=値
           設定する変数の名前とその値です。

           指定した値が変数の値として設定されます。この形式のオペランドでは、-p
           (--print)
           オプションを指定したときでもこの変数は出力ではなく設定されます。

       関数
           出力または設定する関数の名前です。存在しない関数を指定することはできません。

   終
       エラーがない限り typeset コマンドの終了ステータスは 0 です。

   補
       既にローカル変数が存在する場合、それを無視してグローバル変数を新しく作ることはできません
       (-g (--global)
       オプションを指定していても既存のローカル変数が再設定されます)。

       Typeset コマンドは任意組込みコマンドです。 POSIX では typeset
       コマンドの動作は規定されていません。 このコマンドは POSIX
       準拠モードでは使えません。

       Export コマンドは typeset コマンドに -gx
       オプションを付けたものと同じです。Readonly コマンドは typeset
       コマンドに -gr オプションを付けたものと同じです。Local コマンドは
       typeset と同じですが -f (--functions) および -g (--global)
       オプションは使えません。

ULIMIT 組
       Ulimit 組込みコマンドはシェルプロセスのリソース制限を表示・設定します。

   構
       •   ulimit -a [-H|-S]

       •   ulimit [-H|-S] [-efilnqrstuvx] [値]

   説
       Ulimit コマンドはシェルプロセスのリソース制限値を表示または設定します。

       -a (--all) オプションを付けて実行すると、ulimit
       コマンドは全ての種類のリソースについて現在の制限値を一覧形式で標準出力に出力します。-a
       (--all)
       オプションを付けないで実行すると、一種類のリソースについて制限値を表示または設定します。オペランドで値を指定している場合、その値に制限値を設定します。値を指定していない場合は現在の制限値を標準出力に出力します。表示・設定するリソースの種類はオプションで指定します。設定したリソースの制限値はシェルが起動する各コマンドに受け継がれます。

       リソースの各種類について、ハードリミットとソフトリミットの二種類の制限値があります。ソフトリミットがハードリミットを超えることはできません。またハードリミットを緩めるには専用の権限が必要です。

       -H (--hard) オプションを指定している場合、ulimit
       コマンドはハードリミットを表示または設定します。-S (--soft)
       オプションを指定している場合、ulimit
       コマンドはソフトリミットを表示または設定します。どちらのオプションも指定してない場合、ulimit
       コマンドはソフトリミットのみを表示するかまたはハードリミットとソフトリミットの両方を設定します。

   オ
       -H, --hard
           ハードリミットを表示または設定します。

       -S, --soft
           ソフトリミットを表示または設定します。

       -a, --all
           全種類のリソース制限値を表示します。

       以下のオプションは表示・設定するリソースの種類を指定します。これらのオプションがどれも与えられていないときは、-f
       が与えられたものとみなします。(表示・設定可能なリソースの種類はシステムによって異なります)

       -c, --core
           プロセスが強制終了させられたときにできるコアファイルのサイズの限界
           (512 バイト単位)

       -d, --data
           プロセスが使用できるデータセグメント領域のサイズの限界
           (キロバイト単位)

       -e, --nice
           スケジューリング優先度 (nice 値) の限界

       -f, --fsize
           プロセスが作成できるファイルのサイズの限界 (512 バイト単位)

       -i, --sigpending
           プロセスの処理待ちシグナルの個数の限界

       -l, --memlock
           RAM 上にロック可能なメモリサイズの限界 (キロバイト単位)

       -m, --rss
           プロセスの resident set (RAM 上に存在する仮想ページ) の数の限界
           (キロバイト単位)

       -n, --nofile
           プロセスが使用できるファイル記述子の最大値 + 1

       -q, --msgqueue
           POSIX メッセージキューのサイズの限界

       -r, --rtprio
           リアルタイムスケジューリングの優先度の限界

       -s, --stack
           プロセスが使用できるスタック領域のサイズの限界 (キロバイト単位)

       -t, --cpu
           プロセスが使用できる CPU 時間の限界 (秒単位)

       -u, --nproc
           プロセスが起動できる子プロセスの個数の限界

       -v, --as
           プロセスが使用できるメモリ領域全体のサイズの限界 (キロバイト単位)

       -x, --locks
           プロセスがロックできるファイルの個数の限界

   オ
       値
           設定するリソース制限値です。

           値は基本的に 0 以上の自然数で指定しますが、自然数の代わりに
           hard、soft、unlimited
           のいずれかの文字列を指定することもできます。これらの文字列はそれぞれ現在のハードリミットの値、現在のソフトリミットの値、無制限を表します。

   終
       リソース制限値が正しく出力または設定できたときは、終了ステータスは 0
       です。エラーがあると終了ステータスは非 0 です。

   補
       POSIX が規定しているオプションは -f だけです。また POSIX
       はオペランドの値として自然数しか規定していません。

       Ulimit コマンドは必須組込みコマンドです。

UMASK 組
       Umask
       組込みコマンドはシェルプロセスのファイルモード作成マスクを表示・設定します。

   構
       •   umask マスク

       •   umask [-S]

   説
       オペランドが与えられていないとき、umask
       コマンドはシェルプロセスの現在のファイルモード作成マスクを標準出力に出力します。-S
       (--symbolic)
       オプションで出力の形式を指定できます。出力はオペランドとして再利用可能な形式になっています。

       オペランドが与えられているとき、umask
       コマンドはシェルプロセスのファイルモード作成マスクを与えられたオペランドの値に設定します。

   オ
       -S, --symbolic
           このオプションが指定されているときは、記号形式でファイルモード作成マスクを出力します。このオプションが指定されていないときは、数値形式で出力します。

   オ
       マスク
           このオペランドが与えられているときは、umask
           コマンドはファイルモード作成マスクをこの値に設定します。値は以下に述べる数値形式と記号形式のどちらかで与えます。

       数

           数値形式は 0
           以上の八進整数でマスクを指定します。これは以下の各モードを表す自然数のいくつかの和です。

           0400
               ユーザの読み取り権限

           0200
               ユーザの書き込み権限

           0100
               ユーザの実行権限

           0040
               グループの読み取り権限

           0020
               グループの書き込み権限

           0010
               グループの実行権限

           0004
               その他の読み取り権限

           0002
               その他の書き込み権限

           0001
               その他の実行権限

       記

           記号形式は以下のような書式の記号列でマスクし

           記号列は一つ以上の節をカンマ (,) で区切ったものです。
           節は対象の列と一つ以上の動作からなります。

           対象には以下の記号をいくつでも指定できます。

           u
               ユーザ

           g
               グループ

           o
               その他

           a
               ユーザ・グループ・その他の全て

           対象が一つも指定されていない場合は a
           が指定されているものとみなします。

           動作は以下の演算子と権限の組み合わせです。
           演算子は以下のどれかです。

           =
               対象に対する設定を権限にします。

           +
               対象に対する設定に権限を加えます。

           -
               対象に対する設定から権限を除きます。

           権限は以下のどれかです。

           r
               読み取り権限

           w
               書き込み権限

           x
               実行権限

           X
               実行権限 (元々実行権限が設定されていた場合のみ)

           s
               Set-user-ID, Set-group-ID

           u
               現在のユーザの値

           g
               現在のグループの値

           o
               現在のその他の値

           r, w, x, X, s の記号同士は一度に組み合わせて指定できます。

           例えば umask u=rwx,go+r-w
           を実行すると、ユーザの読み取り権限と書き込み権限と実行権限をマスクしないようにし、グループとその他の読み取り権限をマスクしないようにし、グループとその他の書き込み権限をマスクするようにします。

   終
       ファイルモード作成マスクが正しく出力または設定できたときは、終了ステータスは
       0 です。エラーがあると終了ステータスは非 0 です。

   補
       Ulimit コマンドは必須組込みコマンドです。

       POSIX は -S
       オプションを指定しなかった場合の出力形式が必ずしも数値形式であるとは規定していません。

UNALIAS 組
       Unalias 組込みコマンドはエイリアスを削除します。

   構
       •   unalias エイリアス名...

       •   unalias -a

   説
       Unalias コマンドはオペランドで指定したエイリアスを削除します。

   オ
       -a, --all
           全てのエイリアスを削除します。

   オ
       エイリアス名
           削除するエイリアスの名前です。

   終
       エラーがない限り unalias コマンドの終了ステータスは 0
       です。存在しないエイリアスをオペランドで指定した場合はエラーになります。

   補
       Unalias コマンドは必須組込みコマンドです。

UNSET 組
       Unset 組込みコマンドは変数または関数を削除します。

   構
       •   unset [-fv] [名前...]

   説
       Unset コマンドはオペランドで指定した名前の変数または関数を削除します。

       元々存在しない変数・関数を削除しようとしても、何も起こりません
       (エラーにはなりません)。

   オ
       -f, --functions
           関数を削除します。

       -v, --variables
           変数を削除します。

       -f (--functions) オプションと -v (--variables)
       オプションの両方を指定した場合、後に指定したほうを優先します。どちらも指定していない場合は、-v
       を指定したものとみなします。

   オ
       名前
           削除する変数または関数の名前です。

   終
       エラーがない限り unset コマンドの終了ステータスは 0 です。

   補
       Unset コマンドは特殊組込みコマンドです。

       POSIX では、-f と -v
       のどちらのオプションも指定されていない場合、指定した名前の変数がない場合はかわりにその名前の関数を削除してよいと規定しています。

       POSIX 準拠モードでは少なくとも一つ名前を指定する必要があります。

WAIT 組
       Wait 組込みコマンドはバックグラウンドのジョブが終了するのを待ちます。

   構
       •   wait [ジョブ...]

   説
       Wait コマンドは実行中のバックグラウンドジョブが終了するのを待ちます。
       Wait
       コマンドはジョブ制御が有効でないときでも非同期コマンドの終了を待つのに使えます。

       Wait
       コマンドの実行中にシェルがシグナルを受信した場合、そのシグナルに対しトラップが設定してあればそのトラップを直ちに実行し
       wait コマンドはそのまま終了します。またジョブ制御が有効な場合、シェルが
       SIGINT シグナルを受信すると wait コマンドは中断されます。

       シェルが対話モードで、ジョブ制御が有効で、非 POSIX
       準拠モードのとき、ジョブが終了または停止した時にジョブの状態を出力します。

   オ
       ジョブ
           終了を待つジョブ・非同期コマンドのジョブ ID またはプロセス ID
           です。

       ジョブを何も指定しないとシェルが有する全てのジョブ・非同期コマンドの終了を待ちます。

       存在しないジョブ・非同期コマンドを指定すると、終了ステータス 127
       で既に終了したジョブを指定したものとみなし、エラーにはしません。

   終
       ジョブが一つも与えられておらず、シェルが全てのジョブ・非同期コマンドの終了を正しく待つことができた場合、終了ステータスは
       0
       です。ジョブが一つ以上与えられているときは、最後のジョブの終了ステータスが
       wait コマンドの終了ステータスになります。

       Wait
       コマンドがシグナルによって中断された場合、終了ステータスはそのシグナルを表す
       128 以上の整数です。その他の理由で wait
       コマンドがジョブの終了を正しく待つことができなかった場合、終了ステータスは
       1 以上 126 以下です。

   補
       Wait コマンドは必須組込みコマンドです。

       非同期コマンドのプロセス ID
       は非同期コマンドを実行した直後に特殊パラメータ !
       の値を見ることで知ることができます。ジョブ制御が有効なときは jobs
       コマンドでプロセス ID を調べることもできます。

著
       渡
           著者.

  2.59                            2025-05-13                           YASH(1)
