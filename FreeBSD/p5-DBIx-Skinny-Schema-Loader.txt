DBIx::Skinny::Schema::Loader(3)            User Contributed Perl Documentation


NAME
       DBIx::Skinny::Schema::Loader - Schema loader for DBIx::Skinny

SYNOPSIS
       Run-time schema loading:

         package Your::DB::Schema;
         use base qw/DBIx::Skinny::Schema::Loader/;

         __PACKAGE__->load_schema;

         1;

       Preloaded schema:

       Given a the following source code as publish_schema.pl:

         use DBIx::Skinny::Schema::Loader qw/make_schema_at/;
         print make_schema_at(
           'Your::DB::Schema',
           {
             # options here
           },
           [ 'dbi:SQLite:test.db', '', '' ]
         );

       you can execute

           $ perl publish_schema.pl > Your/DB/Schema.pm

       to create a static schema class.

DESCRIPTION
       DBIx::Skinny::Schema::Loader is schema loader for DBIx::Skinny.  It can
       dynamically load schema at run-time or statically publish them.

       It supports MySQL and SQLite, and PostgreSQL.

METHODS
   connect( $dsn, $user, $pass, $connect_options )
   connect( { dsn => ..., username => ..., password => ..., connect_options =>
       ... } )
       Probably no need for public use.

       Instead, invoke concrete db driver class named
       "DBIx::Skinny::Schema::Loader::DBI::XXXX".

   load_schema
       Dynamically load the schema

         package Your::DB::Schema;
         use base qw/DBIx::Skinny::Schema::Loader/;

         __PACKAGE__->load_schema;

         1;

       "load_schema" refers to "connect info" in your Skinny class.  When your
       schema class is named "Your::DB::Schema", Loader considers "Your::DB"
       as a Skinny class.

       "load_schema" executes "install_table" for all tables, automatically
       setting primary key and columns.

       Also the sections "how loader find primary keys" and "additional
       settings for load_schema".

   make_schema_at( $schema_class, $options, $connect_info )
       Return schema file content as a string. This function is exportable.

         use DBIx::Skinny::Schema::Loader qw/make_schema_at/;
         print make_schema_at(
             'Your::DB::Schema',
             {
               # options here
             },
             [ 'dbi:SQLite:test.db', '', '' ]
         );

       $schema_class is schema class name that you want publish.

       $options are described in the "options of make_schema_at" section.

       $connect_info is ArrayRef or HashRef. If it is an arrayref, it contains
       dsn, username, password to connect to the database. If it is an
       hashref, it contains same parameters as DBIx::Skinny->new(\%opts).

HOW LOADER FINDS PRIMARY KEYS
       surely primary key defined at DB, use it as PK.

       in case of primary key is not defined at DB, Loader find PK following
       logic.  1. if table has only one column, use it 2. if table has column
       'id', use it

ADDITIONAL SETTINGS FOR load_schema
       Here is how to use additional settings:

         package Your::DB::Schema;
         use base qw/DBIx::Skinny::Schema::Loader/;

         use DBIx::Skinny::Schema;  # import schema functions

         install_utf8_columns qw/title content/;

         install_table books => schema {
           trigger pre_insert => sub {
             my ($class, $args) = @_;
             $args->{ created_at } ||= DateTime->now;
           };
         };

         __PACKAGE__->load_schema;

         1;

       'use DBIx::Skinny::Schema' works to import schema functions.  you can
       write instead of it, 'BEGIN { DBIx::Skinny::Schema->import }' because
       'require DBIx::Skinny::Schema' was done by Schema::Loader.

       You might be concerned that calling install_table without pk and
       columns doesn't work. However, DBIx::Skinny allows "install_table" to
       be called twice or more.

OPTIONS OF make_schema_at
   before_template
       insert your custom template before install_table block.

         my $tmpl = << '...';
         # custom template
         install_utf8_columns qw/title content/;
         ...

         install_table books => schema {
           trigger pre_insert => sub {
             my ($class, $args) = @_;
             $args->{ created_at } ||= DateTime->now;
           }
         }

         print make_schema_at(
             'Your::DB::Schema',
             {
                 before_template => $tmpl,
             },
             [ 'dbi:SQLite:test.db', '', '' ]
         );

       then you get content inserted your template before install_table block.

   after_template
       after_template works like before_template mostly.  after_template
       inserts template after install_table block.

         print make_schema_at(
             'Your::DB::Schema',
             {
                 before_template => $before,
                 after_template  => $after,
             },
             [ 'dbi:SQLite:test.db', '', '' ]
         );

       there are more detailed example in $before_template section.

       you can use both before_template and after_template all together.

   template
       DEPRECATED. this option is provided for backward compatibility.

       you can use before_template instead of this.

   table_template
       use your custom template for install_table.

         my $table_template = << '...';
         install_table [% table %] => schema {
             pk qw/[% pk %]/;
             columns qw/[% columns %]/;
             trigger pre_insert => $created_at;
         };

         ...

         print make_schema_at(
             'Your::DB::Schema',
             {
                 table_template => $table_template,
             },
             [ 'dbi:SQLite:test.db', '', '' ]
         );

       your schema's install_table block will be

         install_table books => schema {
             pk 'id';
             columns qw/id author_id name/;
             tritter pre_insert => $created_at;
         };

       "make_schema_at" replaces some following variables.  [% table %]   ...
       table name [% pk %]      ... primary keys joined by a space [% columns
       %] ... columns joined by a space

   ignore_rules
       you can exclude tables that matching any rules declared in ignore_rules
       from the schema.

         ignore_rules => [ qr/rs$/, qr/^no/ ],

LAZY SCHEMA LOADING
       if you write Your::DB class without setup sentence,

         package MyApp::DB;
         use DBIx::Skinny;
         1;

       you should not call "load_schema" in your class file.

         package MyApp::DB::Schema;
         use base qw/DBIx::Skinny::Schema::Loader/;
         1;

       call load_schema with dsn manually in your app.

         my $db = MyApp::DB->new;
         my $connect_info = {
             dsn      => $dsn,
             username => $user,
             password => $password,
         };
         $db->connect($connect_info);
         $db->schema->load_schema($connect_info);

AUTHOR
       Ryo Miyake <ryo.studiom {at} gmail.com>

SEE ALSO
       DBIx::Skinny, DBIx::Class::Schema::Loader

AUTHOR
       Ryo Miyake  "<ryo.studiom __at__ gmail.com>"

LICENSE
       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

perl v5.40.2                      2012-11-18   DBIx::Skinny::Schema::Loader(3)
