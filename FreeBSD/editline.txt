EDITLINE(3)            FreeBSD Library Functions Manual            EDITLINE(3)

NAME
     editline – command-line editing library with history

LIBRARY
     library “libeditline”

SYNOPSIS
     #include <editline.h>

     char *
     readline(const, char, *prompt);

     void
     add_history(const, char, *line);

     int
     read_history(const, char, *filename);

     int
     write_history(const, char, *filename);

DESCRIPTION
     editline is a library that provides n line-editing interface with
     history.  It is intended to be functionally equivalent with the readline
     library provided by the Free Software Foundation, but much smaller.  The
     bulk of this manual page describes the basic user interface.  More APIs,
     both native and for readline compatibility , are also available.  See the
     editline.h header file for details.

     The readline() function displays the given prompt on stdout, waits for
     user input on stdin and then returns a line of text with the trailing
     newline removed.  The data is returned in a buffer allocated with
     malloc(3), so the space should be released with free(3) when the calling
     program is done with it.

     Each line returned is automatically saved in the internal history list,
     unless it happens to be equal to the previous line.  This is configurable
     if you are building editline from source, i.e. if you would rather like
     to call add_history() manually.

     The read_history() and write_history() functions can be used to load and
     store the history of your application.  Note: these APIs do not do any
     tilde or environment variable expansion of the given filename.

   User Interface
     A program that uses this library provides a simple emacs-like editing
     interface to its users.  A line may be edited before it is sent to the
     calling program by typing either control characters or escape sequences.
     A control character, shown as a caret followed by a letter, is typed by
     holding down the control key while the letter is typed.  For example, ^A
     is a control-A.  An escape sequence is entered by typing the escape key
     followed by one or more characters.  The escape key is abbreviated as
     ESC.  Note that unlike control keys, case matters in escape sequences;
     ESC F is not the same as ESC f.

     An editing command may be typed anywhere on the line, not just at the
     beginning.  In addition, a return may also be typed anywhere on the line,
     not just at the end.

     Most editing commands may be given a repeat count, n, where n is a
     number.  To enter a repeat count, type the escape key, the number, and
     then the command to execute.  For example, ESC 4 ^f moves forward four
     characters.  If a command may be given a repeat count then the text [n]
     is given at the end of its description.

     The following control characters are accepted:

     ^A        Move to the beginning of the line
     ^B        Move left (backwards) [n]
     ^D        Delete character [n]
     ^E        Move to end of line
     ^F        Move right (forwards) [n]
     ^G        Ring the bell
     ^H        Delete character before cursor (backspace key) [n]
     ^I        Complete filename (tab key); see below
     ^J        Done with line (return key)
     ^K        Kill to end of line (or column [n])
     ^L        Redisplay line
     ^M        Done with line (alternate return key)
     ^N        Get next line from history [n]
     ^P        Get previous line from history [n]
     ^R        Search backward (forward if [n]) through history for text;
               prefixing the string with a caret (^) forces it to match only
               at the beginning of a history line
     ^T        Transpose characters
     ^V        Insert next character, even if it is an edit command
     ^W        Wipe to the mark
     ^X^X      Exchange current location and mark
     ^Y        Yank back last killed text
     ^[        Start an escape sequence (escape key)
     ^]c       Move forward to next character c
     ^?        Delete character before cursor (delete key) [n]

     The following escape sequences are provided:

     ESC ^H    Delete previous word (backspace key) [n]
     ESC DEL   Delete previous word (delete key) [n]
     ESC SP    Set the mark (space key); see ^X^X and ^Y above
     ESC .     Get the last (or [n]'th) word from previous line
     ESC ?     Show possible completions; see below
     ESC <     Move to start of history
     ESC >     Move to end of history
     ESC b     Move backward a word [n]
     ESC d     Delete word under cursor [n]
     ESC f     Move forward a word [n]
     ESC l     Make word lowercase [n]
     ESC m     Toggle if 8bit chars display normally or with an M- prefix
     ESC u     Make word uppercase [n]
     ESC y     Yank back last killed text
     ESC v     Show library version
     ESC w     Make area up to mark yankable
     ESC nn    Set repeat count to the number nn
     ESC C     Read from environment variable $C, where C is an uppercase
               letter

     The editline library has a small macro facility.  If you type the escape
     key followed by an uppercase letter, C, then the contents of the
     environment variable $C are read in as if you had typed them at the
     keyboard.  For example, if the variable $L contains the following:

           ^A^Kecho '^V^[[H^V^[[2J'^M

     Then typing ESC L will move to the beginning of the line, kill the entire
     line, enter the echo command needed to clear the terminal (if your
     terminal is like a VT-100), and send the line back to the shell.

     The editline library also does filename completion.  Suppose the root
     directory has the following files in it:

           bin  vmunix
           core vmunix.old

     If you type rm /v and then the tab key, editline will then finish off as
     much of the name as possible by adding munix.  Because the name is not
     unique, it will then beep.  If you type the escape key and a question
     mark, it will display the two choices.  If you then type a period and a
     tab, the library will finish off the filename for you:

           rm /v[TAB] munix .[TAB] old

     The tab key is shown by [TAB] and the automatically-entered text is shown
     in italics, or underline.

USAGE
     To include editline in your program, call it as you do any other function
     and link your program with -leditline.

   Example
     The following brief example lets you enter a line and edit it, then
     displays it.

           #include <stdio.h>
           #include <stdlib.h>
           #include <editline.h>

           int main(void)
           {
                   char *p;

                   while ((p = readline("CLI> "))) {
                           puts(p);
                           free(p);
                   }

                   return 0;
           }

AUTHORS
     The original editline library was posted to comp.sources.unix newsgroup
     by created by Simmule R. Turner and Rich Salz in 1992.  It now exists in
     several forks: Debian, Minix, Heimdal, Festival speech tools, Mozilla,
     Google Gadgets for Linux, and many other places.  The original manual
     page was made by David W. Sanderson.

     This version was originally based on the Minix 2 sources, but has since
     evolved to include patches from all relevant forks.  It is currently
     maintained by Joachim Nilsson at GitHub,
     ⟨http://github.com/troglobit/editline⟩

BUGS
     Does not handle multiple lines or unicode characters well.

FreeBSD 14.1-RELEASE           February 23, 2020          FreeBSD 14.1-RELEASE
