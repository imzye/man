ZML(3)                User Contributed Perl Documentation               ZML(3)


NAME
       ZML - A simple, fast, and easy to read binary data storage format.

VERSION
       Version 1.0.0

SYNOPSIS
       The error handling is unified between all methods. If $object->{error}
       is ever defined after a function is ran there has been an error. A
       description of the error can be found in $object->{errorString}. The
       error string is always defined, but set to "" when there is no error.
       The error is blanked after each run.

           use ZML;

           my $zml = ZML->new();
           my $zmlstring="a=0\nb=1\n 2\n";
           if ($zml->error){
               print "Parsing the string failed with a error, ".$zml->{error}.
                               ", ".$zml->{errorString}."\n";
           };
           ...

METHODS
   new
       Creates a new ZML object.

               my $ZMLobject=$ZML->new;

   addVar
       This adds a new meta variable for a variable. Two values are required
       for it.

       The first variable is the name of the variable being added.

       The second is the meeta data. This can contain any character.

               $ZMLobject->addVar("some/variable", "whatever");

   addComment
       This adds a new comment for a variable. Three values are required for
       it.

       The first variable is the name of the variable the comment is being
       added for.

       The second is the name of the comment. This also has to be a legit
       variable name.

       The third is the comment. This can contain any character.

               $ZMLobject->addComment("some/variable", "comment/variable","Some fragging comment.");

   addMeta
       This adds a new meta variable for a variable. Three values are required
       for it.

       The first variable is the name of the variable the meta variable is
       being added for.

       The second is the meta variable. This also has to be a legit variable
       name.

       The third is the meeta data. This can contain any character.

               $ZMLobject->addMeta("some/variable", "meta/variable","whatever");

   clearComment
       This removes a meta variable. Two values are required.

       The first is the variable name.

               $ZMLobject->clearComment("some/variable");

   clearMeta
       This removes a meta. Two values are required.

       This removes all meta values for a variable.

               $ZMLobject->clearMeta("some/variable");

   delVar
       This removes a variable. The only variable required is the name of the
       variable.

               $ZMLobject->delVar("some/variable");

   delMeta
       This removes a meta variable. Two values are required.

       The first is the variable name.

       The second is the meta variable.

               $ZMLobject->delMeta("some/variable", "meta variable");

   delComment
       This removes a comment name. Two values are required.

       The first is the variable name.

       The second is the comment name.

               $ZMLobject->delMeta("some/variable", "comment name");

   getVar
       Gets a value of a variable.

               my @variables=$zml->getVar("some variable");

   getMeta
       Gets a value for a meta variable.

               my @variables=$zml->getVar("some variable", "some meta variable");

   getComment
       Gets the value for a comment

               my @variables=$zml->getComment("some variable", "some comment name");

   keysVar
       This gets a array containing the names of the variables.

               my @variables=$zml->keysVar();

   keysMeta
       This gets a list of variables with metas.

               my @variables=$zml->keysMeta();

   keysComment
       This gets a list of comments.

               my @variables=$zml->keysComment();

   keysMetaVar
       This gets a list of variables for a meta. It required one variable,
       which is the name of the meta to get the meta variables for.

               my @variables=$zml->keysMetaVar("some variable");

   keysCommentVar
       This gets a list of comments for a variable. It requires one arguement,
       which is the variable to get the comments for.

               my @variables=$zml->keysCommentVar("some variable");

   keyRegexDelComment
       This searches a the comments for a match and removes it.

       It requires two arguements. The first arguement is the regexp used to
       match the variable. The second is a regexp to match a name.

               #checks every meta for any meta variable matching /^monkey/
               my %removed=keyRegexDelComment("", "^monkey")

               #prints the removed
               my @removedA=keys(%removed)
               my $removedInt=0;
               while(defined($removedA[$removedInt])){
                       my $mvInt=0;
                       while(defined($removed{$removedA[$removedInt]})){
                               print $removed{$removedA[$removedInt]}[$mvInt]."\n";

                               $mvInt++;
                       };

                       $removedInt++;
               };

   keyRegexDelMeta
       This searches a the metas for a match and removes it.

       It requires two arguements. The first arguement is the regexp used to
       match the meta. The second is the regexp used to match the meta
       variable.

               #checks every meta for any meta variable matching /^monkey/
               my %removed=keyRegexDelMeta("", "^monkey")

               #prints the removed
               my @removedA=keys(%removed)
               my $removedInt=0;
               while(defined($removedA[$removedInt])){
                       my $mvInt=0;
                       while(defined($removed{$removedA[$removedInt]})){
                               print $removed{$removedA[$removedInt]}[$mvInt]."\n";

                               $mvInt++;
                       };

                       $removedInt++;
               };

   keyRegexDelVar
       This searches a the variables for a match and removes it.

       It requires one arguement, which is the regex to use.

       It returns a array of removed variables.

               #remove any variables starting with the word monkey
               my @removed=keyRegexDelVar("^monkey")

   parse
       This parses a string in the ZML format. The only variable it requires
       is the string that contains the data.

   string
       This function creates a string out of a the object.

               my $string=$zml->string;

   valRegexDelComment
       This searches the comments for ones that have a value matching the
       regex.

       It requires one arguement, which is the regex to use.

       It returns a array of removed variables.

               #removes any variable in which the value matches /^monkey/
               my %removed=keyRegexDelMeta("^monkey")

               #prints the removed
               my @removedA=keys(%removed)
               my $removedInt=0;
               while(defined($removedA[$removedInt])){
                       my $mvInt=0;
                       while(defined($removed{$removedA[$removedInt]})){
                               print $removed{$removedA[$removedInt]}[$mvInt]."\n";

                               $mvInt++;
                       };

                       $removedInt++;
               };

   valRegexDelMeta
       This searches the variables for ones that have a value matching the
       regex.

       It requires one arguement, which is the regex to use.

       It returns a array of removed variables.

               #removes any variable in which the value matches /^monkey/
               my %removed=keyRegexDelMeta("^monkey")

               #prints the removed
               my @removedA=keys(%removed)
               my $removedInt=0;
               while(defined($removedA[$removedInt])){
                       my $mvInt=0;
                       while(defined($removed{$removedA[$removedInt]})){
                               print $removed{$removedA[$removedInt]}[$mvInt]."\n";

                               $mvInt++;
                       };

                       $removedInt++;
               };

   valRegexDelVar
       This searches the variables for ones that have a value matching the
       regex.

       It requires one arguement, which is the regex to use.

       It returns a array of removed variables.

               #remove any variables starting with the word monkey
               my @removed=valRegexDelVar("^monkey")

   varNameCheck
       This checks a variable name to see if it is legit. It requires one
       variable, which the name of the variable. It returns two values.

       The first is a integer which represents the of the error. If it is
       false, there is no error.

       The second return is the string that describes the error.

               my ($legit, $errorString)=varNameCheck($name);

ZML FORMAT
       There is no whitespace.

       A line starting with a " " is a continuation of the last variable.

       A line starting with ## indicates it is a comment.

       A line starting with a #! indicates it is a meta.

       Any line not starting with a /^#/ or " " is a variable.

   comments
       A line starting with ## indicates it is a comment, as stated above.

       It is broken down into three parts, variable, comment name, and the
       value. Each is sperated by a "=". Any thing after the second "=" is
       considered to be part of the  value.

   meta
       A line starting with #! indicates it is a comment, as stated above.

       It is broken down into three parts, meta, meta variable, and data. Each
       is sperated by a "=". The first field is the meta. The second is the
       meta variable. The third is the value.

   variable
       Any line not starting with a /^#/ or " " is a variable, as stated
       above.

       It is broken down into two parts seperated by a "=". Any thing after
       the "=" is considered part of the value.

   multi-line data
       Any line matching /^ / is considered to be a continuation of the last
       value section of the value part of the variable. When a string is
       created s/\n/\n /g is ran over the value to transform it to a storable
       state.

variable naming
       A variable name is considered non-legit if it matches any of the
       following regexs.

               /,/
               /\/\./
               /\/\//
               /\.\.\//
               /\/\.\./
               /^\.\//
               /\/$/
               /^\//
               /\n/
               /=/

ERROR HANDLING/CODES
       This module uses Error::Helper for error handling. Below are the error
       codes returned by the error method.

   1
       The variable name matches /\/\./.

   2
       The variable name matches /\/\//.

   3
       The variable name matches /\.\.\//.

   4
       The variable name matches /\/\.\./.

   5
       The variable name matches /^\.\//.

   6
       The variable name matches /\/$/.

   7
       The variable name matches  /^\//.

   8
       The variable name matches /\n/.

   9
       The variable name matches /=/.

   10
       Undefined variable.

   11
       This means the variable name matches /,/.

AUTHOR
       Zane C. Bowers-Hadley, "<vvelox at vvelox.net>"

BUGS
       Please report any bugs or feature requests to "bug-zml at rt.cpan.org",
       or through the web interface at
       <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=ZML>.  I will be
       notified, and then you'll automatically be notified of progress on your
       bug as I make changes.

SUPPORT
       You can find documentation for this module with the perldoc command.

           perldoc ZML

       You can also look for information at:

       •   RT: CPAN's request tracker

           <http://rt.cpan.org/NoAuth/Bugs.html?Dist=ZML>

       •   AnnoCPAN: Annotated CPAN documentation

           <http://annocpan.org/dist/ZML>

       •   CPAN Ratings

           <http://cpanratings.perl.org/d/ZML>

       •   Search CPAN

           <http://search.cpan.org/dist/ZML>

COPYRIGHT & LICENSE
       Copyright 2012 Zane C. Bowers-Hadley, all rights reserved.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

perl v5.40.2                      2012-05-24                            ZML(3)
