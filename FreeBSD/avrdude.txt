AVRDUDE(1)              FreeBSD General Commands Manual             AVRDUDE(1)

NAME
     avrdude – driver program for ``simple'' Atmel AVR MCU programmer

SYNOPSIS
     avrdude -p partno [-b baudrate] [-r] [-B bitclock] [-c programmer-id]
             [-C config-file] [-N] [-A] [-D] [-e] [-E exitspec[,exitspec]]
             [-F] [-i delay] [-l logfile] [-n] [-O] [-P port] [-r] [-q]
             [-T cmd] [-t] [-U memory:op:filename:filefmt] [-v]
             [-x extended_param] [-V]

DESCRIPTION
     Avrdude is a program for downloading code and data to Atmel AVR
     microcontrollers.  Avrdude supports Atmel's STK500 programmer, Atmel's
     AVRISP and AVRISP mkII devices, Atmel's STK600, Atmel's JTAG ICE (mkI,
     mkII and 3, the latter two also in ISP mode), programmers complying to
     AppNote AVR910 and AVR109 (including the Butterfly), as well as a simple
     hard-wired programmer connected directly to a ppi(4) or parport(4)
     parallel port, or to a standard serial port.  In the simplest case, the
     hardware consists just of a cable connecting the respective AVR signal
     lines to the parallel port.

     The MCU is programmed in serial programming mode, so, for the ppi(4)
     based programmer, the MCU signals ‘/RESET’, ‘SCK’, ‘SDI’ and ‘SDO’ of the
     AVR's SPI interface need to be connected to the parallel port; older
     boards might use the labels MOSI for SDO or MISO for SDI.  Optionally,
     some otherwise unused output pins of the parallel port can be used to
     supply power for the MCU part, so it is also possible to construct a
     passive stand-alone programming device.  Some status LEDs indicating the
     current operating state of the programmer can be connected, and a signal
     is available to control a buffer/driver IC 74LS367 (or 74HCT367).  The
     latter can be useful to decouple the parallel port from the MCU when in-
     system programming is used.

     A number of equally simple bit-bang programming adapters that connect to
     a serial port are supported as well, among them the popular Ponyprog
     serial adapter, and the DASA and DASA3 adapters that used to be supported
     by uisp(1).  Note that these adapters are meant to be attached to a
     physical serial port.  Connecting to a serial port emulated on top of USB
     is likely to not work at all, or to work abysmally slow.

     If you happen to have a Linux system with at least 4 hardware GPIOs
     available (like almost all embedded Linux boards) you can do without any
     additional hardware - just connect them to the SDO, SDI, RESET and SCK
     pins on the AVR and use the linuxgpio programmer type. It bitbangs the
     lines using the Linux sysfs GPIO interface. Of course, care should be
     taken about voltage level compatibility. Also, although not strictly
     required, it is strongly advisable to protect the GPIO pins from
     overcurrent situations in some way. The simplest would be to just put
     some resistors in series or better yet use a 3-state buffer driver like
     the 74HC244. Have a look at https://kolev.info/blog/2013/01/06/avrdude-
     linuxgpio/ for a more detailed tutorial about using this programmer type.

     Under a Linux installation with direct access to the SPI bus and GPIO
     pins, such as would be found on a Raspberry Pi, the ``linuxspi''
     programmer type can be used to directly connect to and program a chip
     using the built in interfaces on the computer. The requirements to use
     this type are that an SPI interface is exposed along with one GPIO pin.
     The GPIO serves as the reset output since the Linux SPI drivers do not
     hold chip select down when a transfer is not occurring and thus it cannot
     be used as the reset pin. A readily available level translator should be
     used between the SPI bus/reset GPIO and the chip to avoid potentially
     damaging the computer's SPI controller in the event that the chip is
     running at 5V and the SPI runs at 3.3V. The GPIO chosen for reset can be
     configured in the avrdude configuration file using the reset entry under
     the linuxspi programmer, or directly in the port specification. An
     external pull-up resistor should be connected between the AVR's reset pin
     and Vcc. If Vcc is not the same as the SPI voltage, this should be done
     on the AVR side of the level translator to protect the hardware from
     damage.

     The -P portname option for this programmer defaults to
     /dev/spidev0.0:/dev/gpiochip0.

     Atmel's STK500 programmer is also supported and connects to a serial
     port.  Both, firmware versions 1.x and 2.x can be handled, but require a
     different programmer type specification (by now).  Using firmware version
     2, high-voltage programming is also supported, both parallel and serial
     (programmer types stk500pp and stk500hvsp).

     Wiring boards (e.g. Arduino Mega 2560 Rev3) are supported, utilizing
     STK500 V2.x protocol, but a simple DTR/RTS toggle is used to set the
     boards into programming mode.  The programmer type is ``wiring''.  Note
     that the -D option will likely be required in this case, because the
     bootloader will rewrite the program memory, but no true chip erase can be
     performed.

     Serial bootloaders that run a skeleton of the STK500 1.x protocol are
     supported via their own programmer type ``arduino''.  This programmer
     works for the Arduino Uno Rev3 or any AVR that runs the Optiboot
     bootloader.

     Urprotocol is a leaner version of the STK500 1.x protocol that is
     designed to be backwards compatible with STK500 v1.x, and allows
     bootloaders to be much smaller, e.g., as implemented in the urboot
     project https://github.com/stefanrueger/urboot. The programmer type
     ``urclock'' caters for these urboot programmers. Owing to its backward
     compatibility, bootloaders that can be served by the arduino programmer
     can normally also be served by the urclock programmer. This may require
     specifying the size of (to avrdude) unknown bootloaders in bytes using
     the -x bootsize=<n> option, which is necessary for the urclock programmer
     to enable it to protect the bootloader from being overwritten. If an
     unknown bootloader has EEPROM read/write capability then the option -x
     eepromrw informs avrdude -c urclock of that capability.

     The BusPirate is a versatile tool that can also be used as an AVR
     programmer.  A single BusPirate can be connected to up to 3 independent
     AVRs. See the section on extended parameters below for details.

     Atmel's STK600 programmer is supported in ISP and high-voltage
     programming modes, and connects through the USB.  For ATxmega devices,
     the STK600 is supported in PDI mode.  For ATtiny4/5/9/10 devices, the
     STK600 and AVRISP mkII are supported in TPI mode.

     The simple serial programmer described in Atmel's application note
     AVR910, and the bootloader described in Atmel's application note AVR109
     (which is also used by the AVR Butterfly evaluation board), are supported
     on a serial port.

     Atmel's JTAG ICE (mkI, mkII, and 3) is supported as well to up- or
     download memory areas from/to an AVR target (no support for on-chip
     debugging).  For the JTAG ICE mkII, JTAG, debugWIRE and ISP mode are
     supported, provided it has a firmware revision of at least 4.14
     (decimal).  JTAGICE3 also supports all of JTAG, debugWIRE, and ISP mode.
     See below for the limitations of debugWIRE.  For ATxmega devices, the
     JTAG ICE mkII is supported in PDI mode, provided it has a revision 1
     hardware and firmware version of at least 5.37 (decimal).  For ATxmega
     devices, the JTAGICE3 is supported in PDI mode.

     Atmel-ICE (ARM/AVR) is supported in all modes (JTAG, PDI for Xmega,
     debugWIRE, ISP, UPDI).

     Atmel's XplainedPro boards, using the EDBG protocol (CMSIS-DAP
     compatible), are supported using the "jtag3" programmer type.

     Atmel's XplainedMini boards, using the mEDBG protocol, are also supported
     using the "jtag3" programmer type.

     The AVR Dragon is supported in all modes (ISP, JTAG, HVSP, PP,
     debugWIRE).  When used in JTAG and debugWIRE mode, the AVR Dragon behaves
     similar to a JTAG ICE mkII, so all device-specific comments for that
     device will apply as well.  When used in ISP mode, the AVR Dragon behaves
     similar to an AVRISP mkII (or JTAG ICE mkII in ISP mode), so all device-
     specific comments will apply there.  In particular, the Dragon starts out
     with a rather fast ISP clock frequency, so the -B bitclock option might
     be required to achieve a stable ISP communication.  For ATxmega devices,
     the AVR Dragon is supported in PDI mode, provided it has a firmware
     version of at least 6.11 (decimal).

     The USBasp ISP, USBtinyISP, avrftdi and CH341A adapters are also
     supported, provided avrdude has been compiled with libusb support. USBasp
     ISP and USBtinyISP both feature simple firmware-only USB implementations,
     running on an ATmega8 (or ATmega88), or ATtiny2313, respectively. CH341A
     programmers connect directly to the AVR target. Their SPI bit clock is
     approximately 1.7 MHz and cannot be changed. As a consequence, the AVR
     target must have a CPU frequency of 6.8 MHz or more: factory-set AVR
     parts, which typically run on an internal oscillator between 1 MHz and
     1.6 MHz, cannot be programmed using -c ch341a. If libftdi has  has been
     compiled in avrdude, the avrftdi device adds support for many programmers
     using FTDI's 2232C/D/H and 4232H parts running in MPSSE mode, which hard-
     codes (in the chip) SCK to bit 1, SDO to bit 2, and SDI to bit 3. Reset
     is usually bit 4.

     The Atmel DFU bootloader is supported in both, FLIP protocol version 1
     (AT90USB* and ATmega*U* devices), as well as version 2 (Xmega devices).
     See below for some hints about FLIP version 1 protocol behaviour.

     The MPLAB(R) PICkit 4 and MPLAB(R) SNAP, are supported in JTAG, TPI, ISP,
     PDI and UPDI mode.  The Curiosity Nano board is supported in UPDI mode.
     It is dubbed “PICkit on Board”, thus the name pkobn_updi.

     SerialUPDI programmer implementation is based on Microchip's pymcuprog
     https://github.com/microchip-pic-avr-tools/pymcuprog utility, but it also
     contains some performance improvements included in Spence Konde's DxCore
     Arduino core https://github.com/SpenceKonde/DxCore.  In a nutshell, this
     programmer consists of simple USB->UART adapter, diode and couple of
     resistors. It uses serial connection to provide UPDI interface.  See the
     texinfo documentation for more details and known issues.

     The jtag2updi programmer is supported, and can program AVRs with a UPDI
     interface.  Jtag2updi is just a firmware that can be uploaded to an AVR,
     which enables it to interface with avrdude using the jtagice mkii
     protocol via a serial link.  https://github.com/ElTangas/jtag2updi

     The Micronucleus bootloader is supported for both protocol version V1 and
     V2. As the bootloader does not support reading from flash memory, use the
     -V option to prevent AVRDUDE from verifying the flash memory.  See the
     section on extended parameters for Micronucleus specific options.

     The Teensy bootloader is supported for all AVR boards.  As the bootloader
     does not support reading from flash memory, use the -V option to prevent
     AVRDUDE from verifying the flash memory.  See the section on extended
     parameters for Teensy specific options.

     Input files can be provided, and output files can be written in different
     file formats, such as raw binary files containing the data to download to
     the chip, Intel hex format, or Motorola S-record format.  There are a
     number of tools available to produce those files, like asl(1) as a
     standalone assembler, or avr-objcopy(1) for the final stage of the GNU
     toolchain for the AVR microcontroller.

     Provided libelf(3) was present when compiling avrdude, the input file can
     also be the final ELF file as produced by the linker.  The appropriate
     ELF section(s) will be examined, according to the memory area to write
     to.

     Avrdude can program the EEPROM and flash ROM memory cells of supported
     AVR parts.  Where supported by the serial instruction set, fuse bits and
     lock bits can be programmed as well.  These are implemented within
     avrdude as separate memory types and can be programmed using data from a
     file (see the -U option) or from terminal mode (see the dump and write
     commands).  It is also possible to read the chip (provided it has not
     been code-protected previously, of course) and store the data in a file.
     Finally, a ``terminal'' mode is available that allows one to
     interactively communicate with the MCU, and to display or program
     individual memory cells.  On some programmers some settings of the
     programmer itself can be examined and changed from within terminal mode
     as well; see the Terminal mode section.

   Options
     In order to control all the different operation modi, a number of options
     need to be specified to avrdude.

           -p partno
                   This option specifies the MCU connected to the programmer.
                   The MCU descriptions are read from the config file. To see
                   a list of currently supported MCUs use ? as partno, which
                   will print the part ids and official part names. In
                   connection with -v, this will also print a list of variant
                   part names followed by an optional colon, the package code
                   and some absolute maximum ratings. The part id, their
                   official part name, any of the full variant part names or
                   their initial part up to a dash can be used to specify a
                   part with the -p option. If -p ? is specified with a
                   specific programmer, see -c below, then only those parts
                   are output that the programmer expects to be able to
                   handle, together with the programming interface(s) that can
                   be used in that combination. In reality there can be
                   deviations from this list, particularly if programming is
                   directly via a bootloader.

                   The following parts need special attention:

                   AT90S1200   The ISP programming protocol of the AT90S1200
                               differs in subtle ways from that of other AVRs.
                               Thus, not all programmers support this device.
                               Known to work are all direct bitbang
                               programmers, and all programmers talking the
                               STK500v2 protocol.

                   AT90S2343   The AT90S2323 and ATtiny22 use the same
                               algorithm.

                   ATmega2560, ATmega2561
                               Flash addressing above 128 KB is not supported
                               by all programming hardware.  Known to work are
                               jtag2, stk500v2, and bit-bang programmers.

                   ATtiny11    The ATtiny11 can only be programmed in high-
                               voltage serial mode.

           -p wildcard/flags
                   Run developer options for MCUs that are matched by
                   wildcard. Whilst their main use is for developers some
                   flags can be of utility for users, e.g., avrdude -p m328p/S
                   outputs AVRDUDE's understanding of ATmega328P MCU
                   properties; for more information run avrdude -p x/h.

           -b baudrate
                   Override the RS-232 connection baud rate specified in the
                   respective programmer's entry of the configuration file or
                   defined by the default_baudrate entry in your user
                   configuration file ${HOME}/.config/avrdude/avrdude.rc or
                   ${HOME}/.avrduderc if no baudrate was defined for this
                   programmer.

           -r      Opens the serial port at 1200 baud and immediately closes
                   it, waits 400 ms for each -r on the command line and then
                   establishes communication with the programmer. This is
                   commonly known as a "1200bps touch", and is used to trigger
                   programming mode for certain boards like Arduino Leonardo,
                   Arduino Micro/Pro Micro and the Arduino Nano Every. Longer
                   waits, and therefore multiple -r options, are sometimes
                   needed for slower, less powerful hosts.

           -B bitclock
                   Specify the bit clock period for the JTAG, PDI, TPI, UPDI,
                   or ISP interface. The value is a floating-point number in
                   microseconds.  Alternatively, the value might be suffixed
                   with "Hz", "kHz" or "MHz" in order to specify the bit clock
                   frequency rather than a period. Some programmers default
                   their bit clock value to a 1 microsecond bit clock period,
                   suitable for target MCUs running at 4 MHz clock and above.
                   Slower MCUs need a correspondingly higher bit clock period.
                   Some programmers reset their bit clock value to the default
                   value when the programming software signs off, whilst
                   others store the last used bit clock value. It is
                   recommended to always specify the bit clock if read/write
                   speed is important.  You can use the 'default_bitclock'
                   keyword in your ${HOME}/.config/avrdude/avrdude.rc or
                   ${HOME}/.avrduderc file to assign a default value to keep
                   from having to specify this option on every invocation.

                   Note that some official Microchip programmers store the
                   bitclock setting and will continue to use it until a
                   different value is provided. This applies to "2nd gen"
                   programmers (AVRISPmkII, AVR Dragon, JTAG ICE mkII, STK600)
                   and "3rd gen"programmers (JTAGICE3, Atmel ICE, Power
                   Debugger). "4th gen" programmers (PICkit 4, MPLAB SNAP)
                   will store the last user-specified bitclock until the
                   programmer is disconnected from the computer.

           -c programmer-id
                   Use the programmer specified by the argument.  Programmers
                   and their pin configurations are read from the config file
                   (see the -C option).  New pin configurations can be easily
                   added or modified through the use of a config file to make
                   avrdude work with different programmers as long as the
                   programmer supports the Atmel AVR serial program method.
                   You can use the 'default_programmer' keyword in your
                   ${HOME}/.config/avrdude/avrdude.rc or ${HOME}/.avrduderc
                   file to assign a default programmer to keep from having to
                   specify this option on every invocation.  A full list of
                   all supported programmers is output to the terminal by
                   using ? as programmer-id.  If -c ? is specified with a
                   specific part, see -p above, then only those programmers
                   are output that expect to be able to handle this part,
                   together with the programming interface(s) that can be used
                   in that combination. In reality there can be deviations
                   from this list, particularly if programming is directly via
                   a bootloader.

           -c wildcard/flags
                   Run developer options for programmers that are matched by
                   wildcard. Whilst their main use is for developers some
                   flags can be of utility for users, e.g., avrdude -c
                   usbtiny/S shows AVRDUDE's understanding of usbtiny's
                   properties; for more information run avrdude -c x/h.

           -C config-file
                   Use the specified config file to load configuration data.
                   This file contains all programmer and part definitions that
                   avrdude knows about.  See the config file, located at
                   ${PREFIX}/etc/avrdude.conf, which contains a description of
                   the format.

                   If config-file is written as +filename then this file is
                   read after the system wide and user configuration files.
                   This can be used to add entries to the configuration
                   without patching your system wide configuration file. It
                   can be used several times, the files are read in same order
                   as given on the command line.

           -N      Do not load the personal configuration file that is usually
                   located at ~/.config/avrdude/avrdude.rc, ~/.avrduderc or in
                   the same directory as the avrdude executable

           -A      Disable the automatic removal of trailing-0xFF sequences in
                   file input that is to be programmed to flash and in AVR
                   reads from flash memory. Normally, trailing 0xFFs can be
                   discarded, as flash programming requires the memory be
                   erased to 0xFF beforehand.  -A should be used when the
                   programmer hardware, or bootloader software for that
                   matter, does not carry out chip erase and instead handles
                   the memory erase on a page level. Popular Arduino
                   bootloaders exhibit this behaviour; for this reason -A is
                   engaged by default when specifying -c arduino.

           -D      Disable auto erase for flash.  When the -U option with
                   flash memory is specified, avrdude will perform a chip
                   erase before starting any of the programming operations,
                   since it generally is a mistake to program the flash
                   without performing an erase first.  This option disables
                   that.  Auto erase is not used for ATxmega devices as these
                   devices can use page erase before writing each page so no
                   explicit chip erase is required.  Note however that any
                   page not affected by the current operation will retain its
                   previous contents.  Setting -D implies -A.

           -e      Causes a chip erase to be executed.  This will reset the
                   contents of the flash ROM and EEPROM to the value ‘0xff’,
                   and clear all lock bits.  Except for ATxmega devices which
                   can use page erase, it is basically a prerequisite command
                   before the flash ROM can be reprogrammed again.  The only
                   exception would be if the new contents would exclusively
                   cause bits to be programmed from the value ‘1’ to ‘0’.
                   Note that in order to reprogram EEPROM cells, no explicit
                   prior chip erase is required since the MCU provides an
                   auto-erase cycle in that case before programming the cell.

           -E exitspec[,exitspec]
                   By default, avrdude leaves the parallel port in the same
                   state at exit as it has been found at startup.  This option
                   modifies the state of the ‘/RESET’ and ‘Vcc’ lines the
                   parallel port is left at, according to the exitspec
                   arguments provided, as follows:

                   reset    The ‘/RESET’ signal will be left activated at
                            program exit, that is it will be held low, in
                            order to keep the MCU in reset state afterwards.
                            Note in particular that the programming algorithm
                            for the AT90S1200 device mandates that the
                            ‘/RESET’ signal is active before powering up the
                            MCU, so in case an external power supply is used
                            for this MCU type, a previous invocation of
                            avrdude with this option specified is one of the
                            possible ways to guarantee this condition.  reset
                            is supported by the linuxspi and flip2 programmer
                            options, as well as all parallel port based
                            programmers.

                   noreset  The ‘/RESET’ line will be deactivated at program
                            exit, thus allowing the MCU target program to run
                            while the programming hardware remains connected.
                            noreset is supported by the linuxspi and flip2
                            programmer options, as well as all parallel port
                            based programmers.

                   vcc      This option will leave those parallel port pins
                            active (i. e. high) that can be used to supply
                            ‘Vcc’ power to the MCU.

                   novcc    This option will pull the ‘Vcc’ pins of the
                            parallel port down at program exit.

                   d_high   This option will leave the 8 data pins on the
                            parallel port active.  (i. e. high)

                   d_low    This option will leave the 8 data pins on the
                            parallel port inactive.  (i. e. low)

                   Multiple exitspec arguments can be separated with commas.

           -F      Normally, avrdude tries to verify that the device signature
                   read from the part is reasonable before continuing.  Since
                   it can happen from time to time that a device has a broken
                   (erased or overwritten) device signature but is otherwise
                   operating normally, this options is provided to override
                   the check.  Also, for programmers like the Atmel STK500 and
                   STK600 which can adjust parameters local to the programming
                   tool (independent of an actual connection to a target
                   controller), this option can be used together with -t to
                   continue in terminal mode.  Moreover, the option allows to
                   continue despite failed initialization of connection
                   between a programmer and a target.

           -i delay
                   For bitbang-type programmers, delay for approximately delay
                   microseconds between each bit state change.  If the host
                   system is very fast, or the target runs off a slow clock
                   (like a 32 kHz crystal, or the 128 kHz internal RC
                   oscillator), this can become necessary to satisfy the
                   requirement that the ISP clock frequency must not be higher
                   than 1/4 of the CPU clock frequency.  This is implemented
                   as a spin-loop delay to allow even for very short delays.
                   On Unix-style operating systems, the spin loop is initially
                   calibrated against a system timer, so the number of
                   microseconds might be rather realistic, assuming a constant
                   system load while avrdude is running.  On Win32 operating
                   systems, a preconfigured number of cycles per microsecond
                   is assumed that might be off a bit for very fast or very
                   slow machines.

           -l logfile
                   Use logfile rather than stderr for diagnostics output.
                   Note that initial diagnostic messages (during option
                   parsing) are still written to stderr anyway.

           -n      No-write: disables writing data to the MCU whilst
                   processing -U (useful for debugging avrdude ). The terminal
                   mode continues to write to the device.

           -O      Perform a RC oscillator run-time calibration according to
                   Atmel application note AVR053.  This is only supported on
                   the STK500v2, AVRISP mkII, and JTAG ICE mkII hardware.
                   Note that the result will be stored in the EEPROM cell at
                   address 0.

           -P port
                   Use port to identify the connection through which the
                   programmer is attached. This can be a parallel, serial, spi
                   or linuxgpio connection. The programmer normally specifies
                   the connection type; in absence of a -P specification,
                   system-dependent default values default_parallel,
                   default_serial, default_spi, or default_linuxgpio from the
                   configuration file are used. If you need to use a different
                   port, use this option to specify the alternate port name.

                   If avrdude has been configured with libserialport support,
                   a serial port can be specified using a predefined serial
                   adapter type in avrdude.conf or .avrduderc, e.g., ch340 or
                   ft232r.  If more than one serial adapter of the same type
                   is connected, they can be distinguished by appending a
                   serial number, e.g., ft232r:12345678.  Note that the USB to
                   serial chip has to have a serial number for this to work.
                   Avrdude can check for leading and trailing serial number
                   matches as well.  In the above example, ft232r:1234 would
                   also result in a match, and so would ft232r:...5678.  If
                   the USB to serial chip is not known to avrdude, it can be
                   specified using the hexadecimal USB vendor ID, hexadecimal
                   product ID and an optional serial number, following the
                   serial number matching rules described above, e.g.,
                   usb:0x2341:0x0043 or usb:2341:0043:12345678.  To see a list
                   of currently plugged-in serial ports use -P ?s. In order to
                   see a list of all possible serial adapters known to avrdude
                   use -P ?sa.

                   On Win32 operating systems, the parallel ports are referred
                   to as lpt1 through lpt3, referring to the addresses 0x378,
                   0x278, and 0x3BC, respectively.  If the parallel port can
                   be accessed through a different address, this address can
                   be specified directly, using the common C language notation
                   (i.e., hexadecimal values are prefixed by ‘0x’ ).

                   For the JTAG ICE mkII and JTAGICE3, if avrdude has been
                   configured with libusb support, port can alternatively be
                   specified as usb[:serialno].  This will cause avrdude to
                   search the programmer on USB.  If serialno is also
                   specified, it will be matched against the serial number
                   read from any JTAG ICE mkII found on USB.  The match is
                   done after stripping any existing colons from the given
                   serial number, and right-to-left, so only the least
                   significant bytes from the serial number need to be given.

                   As the AVRISP mkII device can only be talked to over USB,
                   the very same method of specifying the port is required
                   there.

                   For the USB programmer "AVR-Doper" running in HID mode, the
                   port must be specified as avrdoper. Libhidapi support is
                   required on Unix and Mac OS but not on Windows. For more
                   information about AVR-Doper see
                   https://www.obdev.at/products/vusb/avrdoper.html.

                   For the USBtinyISP, which is a simplistic device not
                   implementing serial numbers, multiple devices can be
                   distinguished by their location in the USB hierarchy.  See
                   the respective Troubleshooting entry in the detailed
                   documentation for examples.

                   For the XBee programmer the target MCU is to be programmed
                   wirelessly over a ZigBee mesh using the XBeeBoot
                   bootloader.  The ZigBee 64-bit address for the target MCU's
                   own XBee device must be supplied as a 16-character
                   hexadecimal value as a port prefix, followed by the ‘@’
                   character, and the serial device to connect to a second
                   directly contactable XBee device associated with the same
                   mesh (with a default baud rate of 9600).  This may look
                   similar to: 0013a20000000001@/dev/tty.serial.

                   For diagnostic purposes, if the target MCU with an XBeeBoot
                   bootloader is connected directly to the serial port, the
                   64-bit address field can be omitted.  In this mode the
                   default baud rate will be 19200.

                   For programmers that attach to a serial port using some
                   kind of higher level protocol (as opposed to bit-bang style
                   programmers), port can be specified as net:host:port.  In
                   this case, instead of trying to open a local device, a TCP
                   network connection to (TCP) port on host is established.
                   Square brackets may be placed around host to improve
                   readability, for numeric IPv6 addresses (e.g.
                   net:[2001:db8::42]:1337).  The remote endpoint is assumed
                   to be a terminal or console server that connects the
                   network stream to a local serial port where the actual
                   programmer has been attached to.  The port is assumed to be
                   properly configured, for example using a transparent 8-bit
                   data connection without parity at 115200 Baud for a STK500.

                   Note: The ability to handle IPv6 hostnames and addresses is
                   limited to Posix systems (by now).

           -q      Disable (or quell) output of the progress bar while reading
                   or writing to the device.  Specify it more often for even
                   quieter operations.

           -s, -u  These options used to control the obsolete "safemode"
                   feature which is no longer present. They are silently
                   ignored for backwards compatibility.

           -T cmd  Run terminal line cmd when it is its turn in relation to
                   other -t interactive terminals -T terminal commands and -U
                   memory operations. Except for the simplest of terminal
                   commands the argument cmd will most likely need to be set
                   in quotes, see your OS shell manual for details. See below
                   for a detailed description of all terminal commands.

           -t      Tells avrdude to run an interactive terminal when it is its
                   turn in relation to other -t interactive terminals, -T
                   terminal commands and -U memory operations.

           -U memory:op:filename[:format]
                   Perform a memory operation as indicated  when it is its
                   turn in relation to other -t interactive terminals, -T
                   terminal commands and -U memory operations. The memory
                   field specifies the memory to operate on. The available
                   memory types are device-dependent, the actual configuration
                   can be viewed with the part command in terminal mode.
                   Typically, a device's memory configuration at least
                   contains the memories flash, eeprom, signature and lock,
                   which is sometimes known as lockbits.  The signature memory
                   contains the three device signature bytes, which should be,
                   but not always are, unique for the part. The lock memory of
                   one or four bytes typically details whether or not external
                   reading/writing of the flash memory, or parts of it, is
                   allowed. Parts will also typically have fuse bytes, which
                   are read/write memories for configuration of the device and
                   calibration memories that typically contain read-only
                   factory calibration values.

                   Classic devices may have the following memories in addition
                   to eeprom, flash, signature and lock:
                   calibration    One or more bytes of RC oscillator
                                  calibration data
                   efuse          Extended fuse byte
                   fuse           Fuse byte in devices that have only a single
                                  fuse byte
                   hfuse          High fuse byte
                   lfuse          Low fuse byte
                   lock           Lock byte
                   prodsig        Signature, calibration byte and serial
                                  number in a small read-only memory, which is
                                  only documented to be available for
                                  ATmega324PB, ATmega328PB, ATtiny102 and
                                  ATtiny104; programmers may or may not be
                                  able to read this memory
                   sigrow         Memory alias for prodsig
                   usersig        Three extra flash pages for firmware
                                  settings; this memory is not erased during a
                                  chip erase. Only some classic parts,
                                  ATmega(64|128|256|644|1284|2564)RFR2, have a
                                  usersig memory. Usersig is different to
                                  flash in the sense that it can neither be
                                  accessed with ISP serial programming nor
                                  written to by bootloaders; avrdude offers
                                  JTAG programming of classic-part usersig
                                  memories. As with all flash-type memories
                                  the -U option can only write 0-bits but not
                                  1-bits.  Hence, usersig needs to be erased
                                  before a file can be uploaded to this memory
                                  region, e.g., using -T "erase usersig" -U
                                  usersig:w:parameters.hex:i
                   io             Volatile register memory; it cannot be
                                  accessed by external programming methods
                                  only by bootloaders, which has limited use
                                  unless the bootloader jumps to the
                                  application directly, i.e., without a WDT
                                  reset
                   sram           Volatile RAM memory; like io it cannot be
                                  accessed by external programming

                   ATxmega devices have the following memories in addition to
                   eeprom, flash, signature and lock:
                   application  Application flash area
                   apptable     Application table flash area
                   boot         Boot flash area
                   fuse0        A.k.a. jtaguid: JTAG user ID for some devices
                   fuse1        Watchdog configuration
                   fuse6        Fault detection action configuration TC4/5 for
                                ATxmega E series parts
                   fuseN        Other fuse bytes of ATxmega devices, where N
                                is 2, 4 or 5, for system configuration
                   prodsig      The production signature row is a read-only
                                memory section for factory programmed data
                                such as the signature and calibration values
                                for oscillators or analogue modules; it also
                                contains a serial number that consists of the
                                production lot number, wafer number and wafer
                                coordinates for the part
                   sigrow       Memory alias for prodsig
                   usersig      Additional flash memory page that can be used
                                for firmware settings; this memory is not
                                erased during a chip erase
                   io           Volatile register memory; avrdude can read
                                this memory but not write to it using external
                                programming
                   sram         Volatile RAM memory; cannot be usefully
                                accessed by external programming

                   Modern 8-bit AVR devices have the following memories in
                   addition to eeprom, flash, signature and lock:
                   fuse0        A.k.a. wdtcfg: watchdog configuration
                   fuse1        A.k.a. bodcfg: brownout detection
                                configuration
                   fuse2        A.k.a. osccfg: oscillator configuration
                   fuse4        A.k.a. tcd0cfg (not all devices): timer
                                counter type D configuration
                   fuse5        A.k.a. syscfg0: system configuration 0
                   fuse6        A.k.a. syscfg1: system configuration 1
                   fuse7        A.k.a. append or codesize: either the end of
                                the application code section or the code size
                                in blocks of 256/512 bytes
                   fuse8        A.k.a. bootend or bootsize: end of the boot
                                section or the boot size in blocks of 256/512
                                bytes
                   fusea        A.k.a. pdicfg: configures/locks updi access;
                                it is the only fuse that consists of two bytes
                   fuses        A "logical" memory of up to 16 bytes
                                containing all fuseX of a part, which can be
                                used to program all fuses at the same time
                   osc16err     Two bytes typically describing the 16 MHz
                                oscillator frequency error at 3 V and 5 V,
                                respectively
                   osc20err     Two bytes typically describing the 20 MHz
                                oscillator frequency error at 3 V and 5 V,
                                respectively
                   osccal16     Two oscillator calibration bytes for 16 MHz
                   osccal20     Two oscillator calibration bytes for 20 MHz
                   prodsig      Read-only memory section for factory
                                programmed data such as the signature,
                                calibration values and serial number
                   sigrow       Memory alias for prodsig
                   sernum       Serial number with a unique ID for the part
                                (10 or 16 bytes)
                   tempsense    Temperature sensor calibration values
                   bootrow      Extra page of memory that is only accessible
                                by the MCU in bootloader code; UDPI can read
                                and write this memory only when the device is
                                unlocked; bootrow is not erased during chip
                                erase
                   userrow      Extra page of EEPROM memory that can be used
                                for firmware settings; this memory is not
                                erased during a chip erase
                   sib          Special system information block memory with
                                information about AVR family, chip revision
                                etc.
                   io           Volatile register memory; avrdude can program
                                this memory but this is of limited utility
                                because anything written to the io memory will
                                be undefined or lost after reset; writing to
                                individual registers in the terminal can still
                                be used, e.g., to test I/O ports
                   sram         Volatile RAM memory; can be read and written
                                but contents will be lost after reset

                   The op field specifies what operation to perform:

                   r        read device memory and write to the specified file

                   w        read data from the specified file and write to the
                            device memory

                   v        read data from both the device and the specified
                            file and perform a verify

                   The filename field indicates the name of the file to read
                   or write.  The format field is optional and contains the
                   format of the file to read or write.  Format can be one of:

                   i    Intel Hex

                   I    Intel Hex with comments on download and tolerance of
                        checksum errors on upload

                   s    Motorola S-record

                   r    raw binary; little-endian byte order, in the case of
                        the flash ROM data

                   e    ELF (Executable and Linkable Format)

                   m    immediate mode; actual byte values are specified on
                        the command line, separated by commas or spaces in
                        place of the filename field of the -U option.  This is
                        useful for programming fuse bytes without having to
                        create a single-byte file or enter terminal mode.

                   a    auto detect; valid for input only, and only if the
                        input is not provided at stdin.

                   d    decimal; this and the following formats generate one
                        line of output for the respective memory section,
                        forming a comma-separated list of the values. This can
                        be particularly useful for subsequent processing, like
                        for fuse bit settings.

                   h    hexadecimal; each value will get the string 0x
                        prepended.

                   o    octal; each value will get a 0 prepended unless it is
                        less than 8 in which case it gets no prefix.

                   b    binary; each value will get the string 0b prepended.

                   When used as input, the m, d, h, o and b formats will use
                   the same code for reading lists of numbers separated by
                   white space and/or commas. The read routine handles
                   decimal, hexadecimal, octal or binary numbers on a number-
                   by-number basis, and the list of numbers can therefore be
                   of mixed type. In fact the syntax, is the same as for data
                   used by the terminal write command, i.e., the file's input
                   data can also be 2-byte short integers, 4-byte long
                   integers or 8-byte long long integers, 4-byte floating
                   point numbers, 8-byte double precision numbers, C-type
                   strings with a terminating nul or C-like characters such as
                   ''.  Numbers are written as little endian to memory. When
                   using 0x hexadecimal or 0b binary input leading zeros are
                   used to determine the size of the integer, e.g., 0x002a
                   will occupy two bytes and write a 0x2a to memory followed
                   by 0x00, and 0x01234 will occupy 4 bytes. See the
                   description of the terminal write command for more details.

                   In absence of an explicit file format, the default is to
                   use auto detection for input files, and raw binary format
                   for output files. Note that if a filename contains a colon
                   as penultimate character the format field is no longer
                   optional since the last character would otherwise be
                   misinterpreted as format.

                   When reading any kind of flash memory area (including the
                   various sub-areas in Xmega devices), the resulting output
                   file will be truncated to not contain trailing 0xFF bytes
                   which indicate unprogrammed (erased) memory.  Thus, if the
                   entire memory is unprogrammed, this will result in an
                   output file that has no contents at all.  This behaviour
                   can be overridden with the -A option.

                   As an abbreviation, the form -U filename is equivalent to
                   specifying -U flash:w:filename:a.  This will only work if
                   filename does not have a pair of colons in it that sandwich
                   a single character as otherwise the first part might be
                   interpreted as memory, and the single character as memory
                   operation.

           -v      Enable verbose output.  More -v options increase verbosity
                   level.

           -V      Disable automatic verify check when uploading data with -U.

           -x extended_param
                   Pass extended_param to the chosen programmer implementation
                   as an extended parameter.  The interpretation of the
                   extended parameter depends on the programmer itself.  See
                   below for a list of programmers accepting extended
                   parameters or issue avrdude -x help ... to see the extended
                   options of the chosen programmer.

   Terminal mode
     In this mode, avrdude only initializes communication with the MCU, and
     then awaits user commands on standard input.  Commands and parameters may
     be abbreviated to the shortest unambiguous form.  Terminal mode provides
     a command history using readline(3), so previously entered command lines
     can be recalled and edited.

     The addr and len parameters of the dump, read, write, save and erase
     commands can be negative with the same syntax as substring computations
     in perl or python.  The table below details their meaning with respect to
     an example memory of size sz=0x800.

     addr    len  Memory interval     Comment
     ------------------------------------------------------------------------
     0/pos   pos  [addr, addr+len-1]  Note: len = end-start+1
     0/pos   neg  [addr, sz+len]      End is |len| bytes below memory size sz
       neg   pos  [sz+addr,           Start is |addr| bytes below memory size
                      sz+addr+len-1]
       neg   neg  [sz+addr, sz+len]   Combining above two cases
       any     0  empty set           No action
     0x700    12  [0x700, 0x70b]      Conventional use
      1024  -257  [0x400, 0x6ff]      Size of memory is 2048 or 0x800
      -512   512  [0x600, 0x7ff]      Last 512 bytes
      -256    -1  [0x700, 0x7ff]      Last 256 bytes
         0    49  [0, 48]             First 49 bytes
         0   -49  [0, 1999]           All but the last 48 = |len+1| bytes
         0    -1  [0, 0x7ff]          All memory without knowing its size

     The following commands are implemented for all programmers:

           dump memory addr len
                   Read from the specified memory interval (see above), and
                   display in the usual hexadecimal and ASCII form.

           dump memory addr
                   Read from memory addr as many bytes as the most recent dump
                   memory addr len command with this very memory had specified
                   (default 256 bytes), and display them.

           dump memory
                   Continue dumping the contents from the same memory where
                   the previous dump memory command left off.

           dump    Continue dumping from the memory and location where the
                   most recent dump command left off; if no previous dump
                   command has addressed a memory an error message will be
                   shown.

           dump memory addr ...
                   Read all bytes from the specified memory starting at
                   address addr, and display them (deprecated: use dump memory
                   addr -1).

           dump memory ...
                   Read all bytes from the specified memory, and display them
                   (deprecated: use dump memory 0 -1).

           read    Can be used as an alias for dump.

           write memory addr data[,] {data[,]}
                   Manually program the respective memory cells, starting at
                   address addr, using the data items provided.  The terminal
                   implements reading from and writing to flash, EEPROM,
                   bootrow and usersig type memories normally through a cache
                   and paged access functions.  All other memories are
                   directly written to without use of a cache. Some older
                   parts without paged access, depending on the programmer,
                   might also have flash and EEPROM directly accessed without
                   cache.

                   data can be binary, octal, decimal or hexadecimal integers,
                   floating point numbers or C-style strings and characters.
                   If nothing matches, data will be interpreted as the name of
                   a file containing data, which will be read and inserted at
                   this point. In order to force the interpretation of a data
                   item as file, e.g., when the file name would be understood
                   as a number otherwise, the file name can be given a :f
                   format specifier. In absence of a format suffix, the
                   terminal will try to auto-detect the file format.

                   For integers, an optional case-insensitive suffix specifies
                   the data size: HH 8 bit, H/S 16 bit, L 32 bit, LL 64 bit.
                   Suffix D indicates a 64-bit double, F a 32-bit float,
                   whilst a floating point number without suffix defaults to
                   32-bit float. Hexadecimal floating point notation is
                   supported. An ambiguous trailing suffix, e.g., 0x1.8D, is
                   read as no-suffix float where D is part of the mantissa;
                   use a zero exponent 0x1.8p0D to clarify.

                   An optional U suffix makes integers unsigned. Ordinary 0x
                   hexadecimal and 0b binary integers are always treated as
                   unsigned. +0x, -0x, +0b and -0b numbers with an explicit
                   sign are treated as signed unless they have a U suffix.
                   Unsigned integers cannot be larger than 2^64-1. If n is an
                   unsigned integer then -n is also a valid unsigned integer
                   as in C. Signed integers must fall into the [-2^63, 2^63-1]
                   range or a correspondingly smaller range when a suffix
                   specifies a smaller type.

                   Ordinary 0x hexadecimal and 0b binary integers with n
                   digits (counting leading zeros) use the smallest size of
                   one, two, four and eight bytes that can accommodate any n-
                   digit hexadecimal/binary integer. If an integer suffix
                   specifies a size explicitly the corresponding number of
                   least significant bytes are written, and a warning shown if
                   the number does not fit into the desired representation.
                   Otherwise, unsigned integers occupy the smallest of one,
                   two, four or eight bytes needed. Signed numbers are allowed
                   to fit into the smallest signed or smallest unsigned
                   representation: For example, 255 is stored as one byte as
                   255U would fit in one byte, though as a signed number it
                   would not fit into a one-byte interval [-128, 127]. The
                   number -1 is stored in one byte whilst -1U needs eight
                   bytes as it is the same as 0xFFFFffffFFFFffffU.

                   One trailing comma at the end of data items is ignored to
                   facilitate copy & paste of lists.

           write memory data
                   The start address addr may be omitted if the size of the
                   memory being written to is one byte.

           write memory addr len data[,] {data[,]} ...
                   The ellipsis ... form writes the data to the entire memory
                   intervall addressed by addr len and, if necessary, pads the
                   remaining space by repeating the last data item. The fill
                   write command does not write beyond the specified memory
                   area even if more data than needed were given.

           save memory {addr len} file[:format]
                   Save one or more memory segments to a file in a format
                   specified by the :format letter. The default is :r for raw
                   binary. Each memory segment is described by an address and
                   length pair. In absence of any memory segments the entire
                   memory is saved to the file. Only Motorola S-Record (:s)
                   and Intel Hex (:i or :I) formats store address information
                   with the saved data.  Avrdude cannot currently save ELF
                   file formats. All the other file formats lose the address
                   information and concatenate the chosen memory segments into
                   the output file. If the file name is - then avrdude writes
                   to stdout.

           erase   Perform a chip erase and discard all pending writes to
                   EEPROM and flash.  Note that EEPROM will be preserved if
                   the EESAVE fuse bit is set.

           erase memory
                   Erase the entire specified memory.

           erase memory addr len
                   Erase a section of the specified memory.

           flush   Synchronise with the device all pending writes to flash,
                   EEPROM, bootrow and usersig. With some programmer and part
                   combinations, flash (and sometimes EEPROM, too) looks like
                   a NOR memory, i.e., a write can only clear bits, never set
                   them. For NOR memories a page erase or, if not available, a
                   chip erase needs to be issued before writing arbitrary
                   data. Bootrow and usersig are generally unaffected by a
                   chip erase. When a memory looks like a NOR memory, either
                   page erase is deployed (e.g., with parts that have PDI/UPDI
                   interfaces), or if that is not available, both EEPROM and
                   flash caches are fully read in, a chip erase command is
                   issued and both EEPROM and flash are written back to the
                   device. Hence, it can take minutes to ensure that a single
                   previously cleared bit is set and, therefore, this routine
                   should be called sparingly.

           abort   Normally, caches are only ever actually written to the
                   device when using the flush command, at the end of the
                   terminal session after typing quit, or after EOF on input
                   is encountered. The abort command resets the cache
                   discarding all previous writes to the flash, EEPROM,
                   bootrow and usersig cache.

           config {<-f|-a|-v>}
                   Show all configuration properties of the part; these are
                   usually bitfields in fuses or lock bits bytes that can take
                   on values, which typically have a mnemonic name. Each part
                   has their own set of configurable items.  The option -f
                   groups the configuration properties by the fuses and lock
                   bits byte they are housed in, and shows the current value
                   of these memories as well. Config -a outputs an
                   initialisation script with all properties and all possible
                   respective assignments. The currently assigned mnemonic
                   values are the ones that are not commented out. The option
                   -v increases the verbosity of the output of the config
                   command.

           config {<-f|-v>} <property> {<-f|-v>}
                   Show the current value of the named configuration property.
                   Wildcards or initial strings are permitted (but not both),
                   in which case the current values of all matching properties
                   are displayed.

           config {<-f|-v>} <property>= {<-f|-v>}
                   Show all possible values of the named configuration
                   property (notice the trailing =). The one that is currently
                   set is the only one not commented out. As before, wildcards
                   or initial strings are permitted.

           config {<-f|-v>} <property>=<value> {<-f|-v>}
                   Modify the named configuration property to the given value.
                   The corresponding fuse or lock bits will be changed
                   immediately but the change will normally only take effect
                   the next time the part is reset, at which point the fuses
                   and lock bits are utilised. Value can either be a valid
                   integer or one of the symbolic mnemonics, if known.
                   Wildcards or initial strings are permitted for either the
                   property or the assigned mnemonic value, but an assignment
                   only happens if both the property and the name can be
                   uniquely resolved.

                   It is quite possible, as is with direct writing to the
                   underlying fuses and lock bits, to brick a part, i.e., make
                   it unresponsive to further programming with the chosen
                   programmer: here be dragons.

           factory reset
                   Resets the connected part to factory state as far as
                   possible (bootloaders, for example, cannot write fuses and
                   may not have a means to erase EEPROM). This command may
                   change the clock frequency F_CPU of the part after the next
                   MCU reset when the changed fuse values come into effect. As
                   such, this may require that future avrdude calls use a
                   different bit clock rate up to F_CPU/4 for the programmer
                   next time. Note that the command factory can be abbreviated
                   but the required argument reset needs to be spelled out in
                   full.

           regfile {<opts>}
                   regfile with no further argument displays the register file
                   of a part, i.e., all register names and their contents in
                   io memory, if possible: note that external programming
                   cannot read the registers of classic parts (ISP or TPI
                   interfaces).

                   Option -a displays the register I/O addresses in addition;
                   -m displays the register memory addresses used for lds/sts
                   opcodes instead of the I/O addresses. Option -s also shows
                   the size of the register in bytes whilst -v shows a
                   slightly expanded register explanation alongside each
                   register.

           regfile {<opts>} <reg> {<opts>}
                   regfile together with a register name reg shows all those
                   registers that are matched by reg. Wildcards or partial
                   strings are permitted but not both. Register names have the
                   form module.name or module.instance.name. If the provided
                   reg is a full, existing register name, e.g., porta.out then
                   that is the only register that is displayed even though
                   that might be a partial name of another register, eg,
                   porta.outdir. If the provided is the same as instance.name
                   or name then partial matching is no longer utilised and all
                   module registers with that exact instance.name or name are
                   shown. Partial matching can be forced through use of
                   wildcards, e.g., porta.out*

           regfile {<opts>} <reg>=<value> {<opts>}
                   This sets a single register addressed by reg to the given
                   value. Only external programming of modern parts (those
                   with UPDI interface) can read from and write to register io
                   memory, but as that memory is volatile, the contents will
                   be lost after reset.

           include [<opts>] <file>
                   Include contents of the named file as if it was typed. This
                   is useful for batch scripts, e.g., recurring initialisation
                   code for fuses. The include option -e prints the lines of
                   the file as comments before processing them; on a non-zero
                   verbosity level the line numbers are printed, too.

           sig     Display the device signature bytes.

           part    Display the current part information, including supported
                   programming modes, memory and variants tables. Use -m to
                   only print the memory table, and -v to only print the
                   variants table.

           verbose [level]
                   Change (when level is provided), or display the verbosity
                   level.  The initial verbosity level is controlled by the
                   number of -v options given on the commandline.

           quell [level]
                   Change (when level is provided), or display the quell
                   level. 1 is used to suppress progress reports.  2 or higher
                   yields in progressively quieter operations.  The initial
                   quell level is controlled by the number of -q options given
                   on the commandline.

           ?

           help    Give a short on-line summary of the available commands.

           quit    Leave terminal mode and thus avrdude.

           q       Can be used as an alias for quit.

           !<line>
                   Run the shell <line> in a subshell, e.g., !ls *.hex.
                   Subshell commands take the rest of the line as their
                   command. For security reasons, they must explictly be
                   enabled by putting allow_subshells = yes; into your
                   ${HOME}/.config/avrdude/avrdude.rc or ${HOME}/.avrduderc
                   file.

           # <comment>
                   Place comments onto the terminal line (useful for scripts).

     The terminal commands below may only be implemented on some specific
     programmers, and may therefore not be available in the help menu.

           pgerase memory addr
                   Erase one page of the memory specified.

           send b1 b2 b3 b4
                   Send raw instruction codes to the AVR device.  If you need
                   access to a feature of an AVR part that is not directly
                   supported by avrdude, this command allows you to use it,
                   even though avrdude does not implement the command. When
                   using direct SPI mode, up to 3 bytes can be omitted.

           spi     Enter direct SPI mode.  The pgmled pin acts as chip select.
                   Supported on parallel bitbang programmers, and partially by
                   USBtiny.

           pgm     Return to programming mode (from direct SPI mode).

           vtarg voltage
                   Set the target's supply voltage to voltage Volts.
                   Supported on the STK500 and STK600 programmer.

           varef [channel] voltage
                   Set the adjustable voltage source to voltage Volts.  This
                   voltage is normally used to drive the target's Aref input
                   on the STK500.  On the Atmel STK600, two reference voltages
                   are available, which can be selected by the optional
                   channel argument (either 0 or 1).  Supported on the STK500
                   and STK600 programmer.

           fosc freq[M|k]
                   Set the programming oscillator to freq Hz.  An optional
                   trailing letter M multiplies by 1E6, a trailing letter k by
                   1E3.  Supported on the STK500 and STK600 programmer.

           fosc off
                   Turn the programming oscillator off.  Supported on the
                   STK500 and STK600 programmer.

           sck period
                   Set the SCK clock period to period microseconds. Note that
                   some official Microchip programmers store the bitclock
                   setting and will continue to use it until a diferent value
                   is provided. See -B bitclock for more information.

           parms   Display programmer specific parameters.

   Default Parallel port pin connections
     (these can be changed, see the -c option)
     Pin number   Function
     2-5          Vcc (optional power supply to MCU)
     7            /RESET (to MCU)
     8            SCK (to MCU)
     9            SDO (to MCU)
     10           SDI (from MCU)
     18-25        GND

   DebugWIRE limitations
     The debugWIRE protocol is Atmel's proprietary one-wire (plus ground)
     protocol to allow an in-circuit emulation of the smaller AVR devices,
     using the ‘/RESET’ line.  DebugWIRE mode is initiated by activating the
     ‘DWEN’ fuse, and then power-cycling the target.  While this mode is
     mainly intended for debugging/emulation, it also offers limited
     programming capabilities.  Effectively, the only memory areas that can be
     read or programmed in this mode are flash ROM and EEPROM.  It is also
     possible to read out the signature.  All other memory areas cannot be
     accessed.  There is no chip erase functionality in debugWIRE mode;
     instead, while reprogramming the flash ROM, each flash ROM page is erased
     right before updating it.  This is done transparently by the JTAG ICE
     mkII (or AVR Dragon).  The only way back from debugWIRE mode is to
     initiate a special sequence of commands to the JTAG ICE mkII (or AVR
     Dragon), so the debugWIRE mode will be temporarily disabled, and the
     target can be accessed using normal ISP programming.  This sequence is
     automatically initiated by using the JTAG ICE mkII or AVR Dragon in ISP
     mode, when they detect that ISP mode cannot be entered.

   FLIP version 1 idiosyncrasies
     Bootloaders using the FLIP protocol version 1 experience some very
     specific behaviour.

     These bootloaders have no option to access memory areas other than Flash
     and EEPROM.

     When the bootloader is started, it enters a security mode where the only
     acceptable access is to query the device configuration parameters (which
     are used for the signature on AVR devices).  The only way to leave this
     mode is a chip erase.  As a chip erase is normally implied by the -U
     option when reprogramming the flash, this peculiarity might not be very
     obvious immediately.

     Sometimes, a bootloader with security mode already disabled seems to no
     longer respond with sensible configuration data, but only 0xFF for all
     queries.  As these queries are used to obtain the equivalent of a
     signature, avrdude can only continue in that situation by forcing the
     signature check to be overridden with the -F option.

     A chip erase might leave the EEPROM unerased, at least on some versions
     of the bootloader.

   Programmers accepting extended parameters
           JTAG ICE mkII

           JTAGICE3

           Atmel-ICE

           Power Debugger

           PICkit 4

           MPLAB SNAP

           AVR Dragon
                   When using the JTAG ICE mkII, JTAGICE3, Atmel-ICE, PICkit
                   4, MPLAB SNAP, Power Debugger or AVR Dragon in JTAG mode,
                   the following extended parameter is accepted:

                         jtagchain=UB,UA,BB,BA
                                 Setup the JTAG scan chain for UB units
                                 before, UA units after, BB bits before, and
                                 BA bits after the target AVR, respectively.
                                 Each AVR unit within the chain shifts by 4
                                 bits.  Other JTAG units might require a
                                 different bit shift count.

                         hvupdi  Power Debugger and PICkit 4 only
                                 High-voltage UPDI programming is used to
                                 enable a UPDI pin that has previously been
                                 set to RESET or GPIO mode. Use -xhvupdi to
                                 enable high-voltage UPDI initialization for
                                 targets that supports this.

                         vtarg=VALUE, vtarg
                                 Power Debugger only
                                 The voltage generator can be enabled by
                                 setting a target voltage.  The current set-
                                 voltage can be read by -xvtarg alone.

                         help    Show help menu and exit.

           PICkit 4

           MPLAB SNAP

                         mode=avr,pic
                                 Switch programmer to AVR or PIC mode, then
                                 exit: the PICkit 4 and MPLAB SNAP programmer
                                 can only be utilised by avrdude when in AVR
                                 mode. Use -xmode=avr for switching to AVR
                                 mode, or -xmode=pic for switching to PIC
                                 mode.

                         help    Show help menu and exit.

           Xplained Mini (ISP and UPDI)

                         suffer=VALUE, suffer
                                 The SUFFER register allows the user to modify
                                 the behavior of the on-board mEDBG.  The
                                 current state can be read by -xsuffer alone.

                                       Bit 7 ARDUINO:
                                               Adds control of extra LEDs when
                                               set to 0

                                       Bit 6..3:
                                               Reserved (must be set to 1)

                                       Bit 2 EOF:
                                               Agressive power-down, sleep
                                               after 5 seconds if no USB
                                               enumeration when set to 0

                                       Bit 1 LOWP:
                                               forc running the mEDBG at 1 MHz
                                               when bit set to 0

                                       Bit 0 FUSE:
                                               Fuses are safe-masked when bit
                                               sent to 1. Fuses are
                                               unprotected when set to 0

                         vtarg_switch=VALUE, vtarg_switch
                                 The on-board target voltage switch can be
                                 turned on or off by writing a 1 or a 0. The
                                 current state can be read by -xvtarg_switch
                                 alone.  Note that the target power switch
                                 will always be on after a power cycle.  Also
                                 note that the smaller Xplained Nano boards
                                 does not have a target power switch.

                         help    Show help menu and exit.

           Curiosity Nano

                         vtarg=VALUE, vtarg
                                 The generated on-board target voltage can be
                                 changed by specifying a new voltage.  The
                                 current set-voltage can be read by -xvtarg
                                 alone.

                         help    Show help menu and exit.

           STK500

           STK600

                         vtarg=VALUE, vtarg
                                 The generated on-board target voltage can be
                                 changed by specifying a new voltage.  The
                                 current set-voltage can be read by -xvtarg
                                 alone.

                         fosc=VALUE[MHz|M|kHz|k|Hz|H], fosc
                                 Set the programmable oscillator frequency.
                                 The current frequency can be read by -xfosc
                                 alone.

                         varef=VALUE, varef
                                 The generated on-board analog reference
                                 voltage can be changed by specifying a new
                                 reference voltage. The current reference
                                 voltage can be read by -xvaref alone.

                         varef[0,1]=VALUE, varef[0,1]
                                 STK600 only
                                 The generated on-board analog reference
                                 voltage for channel 0 or channel 1 can be
                                 changed by specifying a new reference
                                 voltage.  The current reference voltage can
                                 be read by -xvaref0 or -xvaref1 alone.

                         attemps[=<1..99>]
                                 STK500V1 only
                                 Specify how many connection retry attemps to
                                 perform before exiting.  Defaults to 10 if
                                 not specified.

                         xtal=VALUE[MHz|M|kHz|k|Hz|H]
                                 Defines the XTAL frequency of the programmer
                                 if it differs from 7.3728 MHz of the original
                                 STK500. Used by avrdude for the correct
                                 calculation of fosc and sck.

                         help    Show help menu and exit.

           AVR910

                         devcode=VALUE
                                 Override the device code selection by using
                                 VALUE as the device code.  The programmer is
                                 not queried for the list of supported device
                                 codes, and the specified VALUE is not
                                 verified but used directly within the ‘T’
                                 command sent to the programmer.  VALUE can be
                                 specified using the conventional number
                                 notation of the C programming language.

                         no_blockmode
                                 Disables the default checking for block
                                 transfer capability.  Use no_blockmode only
                                 if your AVR910 programmer creates errors
                                 during initial sequence.

                         help    Show help menu and exit.

           Arduino

                         attemps[=<1..99>]
                                 Specify how many connection retry attemps to
                                 perform before exiting.  Defaults to 10 if
                                 not specified.

                         help    Show help menu and exit.

           Urclock

                         showall
                                 Show all info for the connected part, then
                                 exit. The -xshow... options below can be used
                                 to assemble a bespoke response consisting of
                                 a subset (or only one item) of all available
                                 relevant information about the connected part
                                 and bootloader.

                         showid  Show a unique Urclock ID stored in either
                                 flash or EEPROM of the MCU, then exit.

                         id=<E|F>.<addr>.<len>
                                 Historically, the Urclock ID was a six-byte
                                 unique little-endian number stored in Urclock
                                 boards at EEPROM address 257. The location of
                                 this number can be set by the
                                 -xid=<E|F>.<addr>.<len> extended parameter. E
                                 stands for EEPROM and F stands for flash. A
                                 negative address addr counts from the end of
                                 EEPROM and flash, respectively. The length
                                 len of the Urclock ID can be between 1 and 8
                                 bytes.

                         showdate
                                 Show the last-modified date of the input file
                                 for the flash application, then exit. If the
                                 input file was stdin, the date will be that
                                 of the programming.  Date and filename are
                                 part of the metadata that the urclock
                                 programmer stores by default in high flash
                                 just under the bootloader; see also
                                 -xnometadata.

                         showfilename
                                 Show the input filename (or title) of the
                                 last flash writing session, then exit.

                         title=<string>
                                 When set, <string> will be used in lieu of
                                 the input filename. The maximum string length
                                 for the title/filename field is 254 bytes
                                 including terminating nul.

                         showapp
                                 Show the size of the programmed application,
                                 then exit.

                         showstore
                                 Show the size of the unused flash between the
                                 application and metadata, then exit.

                         showmeta
                                 Show the size of the metadata just below the
                                 bootloader, then exit.

                         showboot
                                 Show the size of the bootloader, then exit.

                         showversion
                                 Show bootloader version and capabilities,
                                 then exit.

                         showvector
                                 Show the vector number and name of the
                                 interrupt table vector used by the bootloader
                                 for starting the application, then exit. For
                                 hardware-supported bootloaders this will be
                                 vector 0 (Reset), and for vector bootloaders
                                 this will be any other vector number of the
                                 interrupt vector table or the slot just
                                 behind the vector table with the name
                                 VBL_ADDITIONAL_VECTOR.

                         showpart
                                 Show the part for which the bootloader was
                                 compiled, then exit.

                         bootsize=<size>
                                 Manual override for bootloader size. Urboot
                                 bootloaders put the number of used bootloader
                                 pages into a table at the top of the
                                 bootloader section, i.e., typically top of
                                 flash, so the urclock programmer can look up
                                 the bootloader size itself. In backward-
                                 compatibility mode, when programming via
                                 other bootloaders, this option can be used to
                                 tell the programmer the size, and therefore
                                 the location, of the bootloader.

                         vectornum=<arg>
                                 Manual override for vector number. Urboot
                                 bootloaders put the vector number used by a
                                 vector bootloader into a table at the top of
                                 flash, so this option is normally not needed
                                 for urboot bootloaders. However, it is useful
                                 in backward-compatibility mode (or when the
                                 urboot bootloader does not offer flash read).
                                 Specifying a vector number in these
                                 circumstances implies a vector bootloader
                                 whilst the default assumption would be a
                                 hardware-supported bootloader.

                         eepromrw
                                 Manual override for asserting EEPROM
                                 read/write capability. Not normally needed
                                 for urboot bootloaders, but useful for in
                                 backward-compatibility mode if the bootloader
                                 offers EEPROM read/write.

                         emulate_ce
                                 If an urboot bootloader does not offer a chip
                                 erase command it will tell the urclock
                                 programmer so during handshake. In this case
                                 the urclock programmer emulates a chip erase,
                                 if warranted by user command line options, by
                                 filling the remainder of unused flash below
                                 the bootloader with 0xff. If this option is
                                 specified, the urclock programmer will assume
                                 that the bootloader cannot erase the chip
                                 itself. The option is useful for backwards-
                                 compatible bootloaders that do not implement
                                 chip erase.

                         restore
                                 Upload unchanged flash input files and trim
                                 below the bootloader if needed. This is most
                                 useful when one has a backup of the full
                                 flash and wants to play that back onto the
                                 device. No metadata are written in this case
                                 and no vector patching happens either if it
                                 is a vector bootloader.  However, for vector
                                 bootloaders, even under the option -xrestore
                                 an input file will not be uploaded for which
                                 the reset vector does not point to the vector
                                 bootloader. This is to avoid writing an input
                                 file to the device that would render the
                                 vector bootloader not functional as it would
                                 not be reached after reset.

                         initstore
                                 On writing to flash fill the store space
                                 between the flash application and the
                                 metadata section with 0xff.

                         nofilename
                                 On writing to flash do not store the
                                 application input filename (nor a title).

                         nodate  On writing to flash do not store the
                                 application input filename (nor a title) and
                                 no date either.

                         nostore
                                 On writing to flash do not store metadata
                                 except the metadata code byte 0xff saying
                                 there are no metadata.  In particular, no
                                 data store frame is programmed.

                         nometadata
                                 Do not support any metadata. The full flash
                                 besides the bootloader is available for the
                                 application. If the application is smaller
                                 than the available space then a metadata code
                                 byte 0xff is stored nevertheless to indicate
                                 there are no further metadata available. In
                                 absence of -xnometadata, the default for the
                                 urclock programmer is to write as much
                                 metadata (filename, data and store
                                 information) as the size of the uploaded
                                 application and the other extended options
                                 allow. The subtle difference between
                                 -xnometadata and -xnostore is that the latter
                                 always explicitly stores in flash that no
                                 further metadata are available, so that a
                                 such prepared flash can always be queried
                                 with avrdude -xshowall. In contrast to this,
                                 it cannot be guaranteed that a -xshowall
                                 query on flash prepared with -xnometadata
                                 yields useful results.

                         delay=<n>
                                 Add a <n> ms delay after reset. This can be
                                 useful if a board takes a particularly long
                                 time to exit from external reset. <n> can be
                                 negative, in which case the default 120 ms
                                 delay after issuing reset will be shortened
                                 accordingly.

                         strict  Urclock has a faster, but slightly different
                                 strategy than -c arduino to synchronise with
                                 the bootloader; some stk500v1 bootloaders
                                 cannot cope with this, and they need the
                                 -xstrict option.

                         help    Show help menu and exit.

           buspirate

                         reset=cs,aux,aux2
                                 The default setup assumes the BusPirate's CS
                                 output pin connected to the RESET pin on AVR
                                 side. It is however possible to have multiple
                                 AVRs connected to the same BP with SDI, SDO
                                 and SCK lines common for all of them.  In
                                 such a case one AVR should have its RESET
                                 connected to BusPirate's CS pin, second AVR's
                                 RESET connected to BusPirate's AUX pin and if
                                 your BusPirate has an AUX2 pin (only
                                 available on BusPirate version v1a with
                                 firmware 3.0 or newer) use that to activate
                                 RESET on the third AVR.

                                 It may be a good idea to decouple the
                                 BusPirate and the AVR's SPI buses from each
                                 other using a 3-state bus buffer. For example
                                 74HC125 or 74HC244 are some good candidates
                                 with the latches driven by the appropriate
                                 reset pin (cs, aux or aux2). Otherwise the
                                 SPI traffic in one active circuit may
                                 interfere with programming the AVR in the
                                 other design.

                         spifreq=<0..7>
                                 The SPI speed for the Bus Pirate's binary SPI
                                 mode:

                                 0 ..  30 kHz   (default)
                                 1 .. 125 kHz
                                 2 .. 250 kHz
                                 3 ..   1 MHz
                                 4 ..   2 MHz
                                 5 ..   2.6 MHz
                                 6 ..   4 MHz
                                 7 ..   8 MHz

                         rawfreq=<0..3>
                                 Sets the SPI speed and uses the Bus Pirate's
                                 binary "raw-wire" mode:

                                 0 ..   5 kHz
                                 1 ..  50 kHz
                                 2 .. 100 kHz   (Firmware v4.2+ only)
                                 3 .. 400 kHz   (v4.2+)

                                 The only advantage of the "raw-wire" mode is
                                 the different SPI frequencies available.
                                 Paged writing is not implemented in this
                                 mode.

                         ascii   Attempt to use ASCII mode even when the
                                 firmware supports BinMode (binary mode).
                                 BinMode is supported in firmware 2.7 and
                                 newer, older FW's either don't have BinMode
                                 or their BinMode is buggy. ASCII mode is
                                 slower and makes the above reset=, spifreq=
                                 and rawfreq= parameters unavailable. Be aware
                                 that ASCII mode is not guaranteed to work
                                 with newer firmware versions, and is retained
                                 only to maintain compatibility with older
                                 firmware versions.

                         nopagedwrite
                                 Firmware versions 5.10 and newer support a
                                 binary mode SPI command that enables whole
                                 pages to be written to AVR flash memory at
                                 once, resulting in a significant write speed
                                 increase. If use of this mode is not
                                 desirable for some reason, this option
                                 disables it.

                         nopagedread
                                 Newer firmware versions support in binary
                                 mode SPI command some AVR Extended Commands.
                                 Using the "Bulk Memory Read from Flash"
                                 results in a significant read speed increase.
                                 If use of this mode is not desirable for some
                                 reason, this option disables it.

                         cpufreq=<125..4000>
                                 This sets the AUX pin to output a frequency
                                 of n kHz. Connecting the AUX pin to the XTAL1
                                 pin of your MCU, you can provide it a clock,
                                 for example when it needs an external clock
                                 because of wrong fuses settings.  Make sure
                                 the CPU frequency is at least four times the
                                 SPI frequency.

                         serial_recv_timeout=<1...>
                                 This sets the serial receive timeout to the
                                 given value.  The timeout happens every time
                                 avrdude waits for the BusPirate prompt.
                                 Especially in ascii mode this happens very
                                 often, so setting a smaller value can speed
                                 up programming a lot.  The default value is
                                 100ms. Using 10ms might work in most cases.

                         help    Show help menu and exit.

           Micronucleus bootloader

                         wait[=<timeout>]
                                 If the device is not connected, wait for the
                                 device to be plugged in.  The optional
                                 timeout specifies the connection time-out in
                                 seconds.  If no time-out is specified,
                                 AVRDUDE will wait indefinitely until the
                                 device is plugged in.

                         help    Show help menu and exit.

           Teensy bootloader

                         wait[=<timeout>]
                                 If the device is not connected, wait for the
                                 device to be plugged in.  The optional
                                 timeout specifies the connection time-out in
                                 seconds.  If no time-out is specified,
                                 AVRDUDE will wait indefinitely until the
                                 device is plugged in.

                         help    Show help menu and exit.

           Wiring  When using the Wiring programmer type, the following
                   optional extended parameters are accepted:

                         snooze=<n>
                                 After performing the port open phase, AVRDUDE
                                 will wait/snooze for snooze milliseconds
                                 before continuing to the protocol sync phase.
                                 No toggling of DTR/RTS is performed if snooze
                                 is greater than 0.

                         delay=<n>
                                 Add a <n> milliseconds delay after resetting
                                 the part through toggling the DTR/RTS lines.
                                 This can be useful if a board takes a
                                 particularly long time to exit from external
                                 reset. <n> can be negative, in which case the
                                 default 100 ms delay after issuing reset will
                                 be shortened accordingly.

                         help    Show help menu and exit.

           PICkit2
                   Connection to the PICkit2 programmer:

                   (AVR)    (PICkit2)
                   RST  -   VPP/MCLR (1)
                   VDD  -   VDD Target (2) -- possibly optional if AVR self powered
                   GND  -   GND (3)
                   SDI  -   PGD (4)
                   SCLK -   PDC (5)
                   SDO  -   AUX (6)

                         clockrate=<rate>
                                 Sets the SPI clocking rate in Hz (default is
                                 100kHz). Alternately the -B or -i options can
                                 be used to set the period.

                         timeout=<usb-transaction-timeout>
                                 Sets the timeout for USB reads and writes in
                                 milliseconds (default is 1500 ms).

                         help    Show help menu and exit.

           USBasp

                         section_config
                                 Programmer will erase configuration section
                                 with option -e (chip erase), rather than
                                 entire chip.  Only applicable to TPI devices
                                 (ATtiny 4/5/9/10/20/40).

                         help    Show help menu and exit.

           xbee

                         xbeeresetpin=<1..7>
                                 Select the XBee pin DIO<1..7> that is
                                 connected to the MCU's ‘/RESET’ line.  The
                                 programmer needs to know which DIO pin to use
                                 to reset into the bootloader.  The default
                                 (3) is the DIO3 pin (XBee pin 17), but some
                                 commercial products use a different XBee pin.

                                 The remaining two necessary XBee-to-MCU
                                 connections are not selectable - the XBee
                                 DOUT pin (pin 2) must be connected to the
                                 MCU's ‘RXD’ line, and the XBee DIN pin (pin
                                 3) must be connected to the MCU's ‘TXD’ line.

                         help    Show help menu and exit.

           jtag2updi

           serialupdi

                         rtsdtr=low,high
                                 Forces RTS/DTR lines to assume low or high
                                 state during the whole programming session.
                                 Some programmers might use this signal to
                                 indicate UPDI programming state, but this is
                                 strictly hardware specific.

                                 When not provided, driver/OS default value
                                 will be used.

                         help    Show help menu and exit.

           linuxspi

                         disable_no_cs
                                 Ensures the programmer does not use the
                                 SPI_NO_CS bit for the SPI driver. This
                                 parameter is useful for kernels that do not
                                 support the CS line being managed outside the
                                 application.

                         help    Show help menu and exit.

FILES
           /dev/ppi0     Default device to be used for communication with the
                         programming hardware

           avrdude.conf  Programmer and parts configuration file

                         On Windows systems, this file is looked up in the
                         same directory as the executable file.  On all other
                         systems, the file is first looked up in ../etc/,
                         relative to the path of the executable, then in the
                         same directory as the executable itself, and finally
                         in the system default location
                         ${PREFIX}/etc/avrdude.conf.

           ${XDG_CONFIG_HOME}/avrdude/avrdude.rc
                         Local programmer and parts configuration file (per-
                         user overrides); it follows the same syntax as
                         avrdude.conf; if the ${XDG_CONFIG_HOME} environment
                         variable is not set or empty, the directory
                         ${HOME}/.config/ is used instead.

           ${HOME}/.avrduderc
                         Alternative location of the per-user configuration
                         file if above file does not exist

           ~/.inputrc    Initialization file for the readline(3) library

           <prefix>/doc/avrdude/avrdude.pdf
                         User manual

DIAGNOSTICS
     avrdude: jtagmkII_setparm(): bad response to set parameter command: RSP_FAILED
     avrdude: jtagmkII_getsync(): ISP activation failed, trying debugWIRE
     avrdude: Target prepared for ISP, signed off.
     avrdude: Please restart avrdude without power-cycling the target.

     If the target AVR has been set up for debugWIRE mode (i.e., the DWEN fuse
     is programmed), normal ISP connection attempts will fail as the /RESET
     pin is not available.  When using the JTAG ICE mkII in ISP mode, the
     message shown indicates that avrdude has guessed this condition, and
     tried to initiate a debugWIRE reset to the target.  When successful, this
     will leave the target AVR in a state where it can respond to normal ISP
     communication again (until the next power cycle).  Typically, the same
     command is going to be retried again immediately afterwards, and will
     then succeed connecting to the target using normal ISP communication.

SEE ALSO
     avr-objcopy(1), ppi(4), libelf(3), readline(3)

     The AVR microcontroller product description can be found at

           https://www.microchip.com/en-us/products/microcontrollers-and-microprocessors/8-bit-mcus/avr-mcus

AUTHORS
     Avrdude was initially written by Brian S. Dean <bsd@bdmicro.com>.

     This man page is by Joerg Wunsch with updates from Hans Eirik Bull and
     Stefan Rüger amongst others.

BUGS
     Please report bugs via
           https://github.com/avrdudes/avrdude/issues

     The JTAG ICE programmers currently cannot write to the flash ROM one byte
     at a time.  For that reason, updating the flash ROM from terminal mode
     does not work.

     Page-mode programming the EEPROM through JTAG (i.e., through an -U
     option) requires a prior chip erase.  This is an inherent feature of the
     way JTAG EEPROM programming works.  This also applies to the STK500 and
     STK600 in parallel programming mode.

     The USBasp and USBtinyISP drivers do not offer any option to distinguish
     multiple devices connected simultaneously, so effectively only a single
     device is supported.

     Chip Select must be externally held low for direct SPI when using
     USBtinyISP, and send must be a multiple of four bytes.

     The avrftdi driver allows one to select specific devices using any
     combination of vid,pid serial number (usbsn) vendor description
     (usbvendoror part description (usbproduct) as seen with lsusb or whatever
     tool used to view USB device information. Multiple devices can be on the
     bus at the same time. For the H parts, which have multiple MPSSE
     interfaces, the interface can also be selected.  It defaults to interface
     'A'.

FreeBSD 14.1-RELEASE           January 15, 2023           FreeBSD 14.1-RELEASE
