File::Finder(3)       User Contributed Perl Documentation      File::Finder(3)


NAME
       File::Finder - nice wrapper for File::Find ala find(1)

SYNOPSIS
         use File::Finder;
         ## simulate "-type f"
         my $all_files = File::Finder->type('f');

         ## any rule can be extended:
         my $all_files_printer = $all_files->print;

         ## traditional use: generating "wanted" subroutines:
         use File::Find;
         find($all_files_printer, @starting_points);

         ## or, we can gather up the results immediately:
         my @results = $all_files->in(@starting_points);

         ## -depth and -follow are noted, but need a bit of help for find:
         my $deep_dirs = File::Finder->depth->type('d')->ls->exec('rmdir','{}');
         find($deep_dirs->as_options, @places);

DESCRIPTION
       "File::Find" is great, but constructing the "wanted" routine can
       sometimes be a pain.  This module provides a "wanted"-writer, using
       syntax that is directly mappable to the find command's syntax.

       Also, I find myself (heh) frequently just wanting the list of names
       that match.  With "File::Find", I have to write a little accumulator,
       and then access that from a closure.  But with "File::Finder", I can
       turn the problem inside out.

       A "File::Finder" object contains a hash of "File::Find" options, and a
       series of steps that mimic find's predicates.  Initially, a
       "File::Finder" object has no steps.  Each step method clones the
       previous object's options and steps, and then adds the new step,
       returning the new object.  In this manner, an object can be grown, step
       by step, by chaining method calls.  Furthermore, a partial sequence can
       be created and held, and used as the head of many different sequences.

       For example, a step sequence that finds only files looks like:

         my $files = File::Finder->type('f');

       Here, "type" is acting as a class method and thus a constructor.  An
       instance of "File::Finder" is returned, containing the one step to
       verify that only files are selected.  We could use this immediately as
       a "File::Find::find" wanted routine, although it'd be uninteresting:

         use File::Find;
         find($files, "/tmp");

       Calling a step method on an existing object adds the step, returning
       the new object:

         my $files_print = $files->print;

       And now if we use this with "find", we get a nice display:

         find($files_print, "/tmp");

       Of course, we didn't really need that second object: we could have
       generated it on the fly:

         find($files->print, "/tmp");

       "File::Find" supports options to modify behavior, such as depth-first
       searching.  The "depth" step flags this in the options as well:

         my $files_depth_print = $files->depth->print;

       However, the "File::Finder" object needs to be told explictly to
       generate an options hash for "File::Find::find" to pass this
       information along:

         find($files_depth_print->as_options, "/tmp");

       A "File::Finder" object, like the find command, supports AND, OR, NOT,
       and parenthesized sub-expressions.  AND binds tighter than OR, and is
       also implied everywhere that it makes sense.  Like find, the predicates
       are computed in a "short-circuit" fashion, so that a false to the left
       of the (implied) AND keeps the right side from being evaluated,
       including entire parenthesized subexpressions.  Similarly, if the left
       side of an OR is false, the right side is evaluated, and if the left
       side of the OR is true, the right side is skipped.  Nested parens are
       handled properly.  Parens are indicated with the rather ugly "left" and
       "right" methods:

         my $big_or_old_files = $files->left->size("+50")->or->atime("+30")->right;

       The parens here correspond directly to the parens in:

         find somewhere -type f '(' -size +50 -o -atime +30 ')'

       and are needed so that the OR and the implied ANDs have the right
       nesting.

       Besides passing the constructed "File::Finder" object to
       "File::Finder::find" directly as a "wanted" routine or an options hash,
       you can also call "find" implictly, with "in".  "in" provides a list of
       starting points, and returns all filenames that match the criteria.

       For example, a list of all names in /tmp can be generated simply with:

        my @names = File::Finder->in("/tmp");

       For more flexibility, use "collect" to execute an arbitrary block in a
       list context, concatenating all the results (similar to "map"):

         my %sizes = File::Finder
           ->collect(sub { $File::Find::name => -s _ }, "/tmp");

       That's all I can think of for now.  The rest is in the detailed
       reference below.

   META METHODS
       All of these methods can be used as class or instance methods, except
       "new", which is usually not needed and is class only.

       new Not strictly needed, because any instance method called on a class
           will create a new object anyway.

       as_wanted
           Returns a subroutine suitable for passing to "File::Find::find" or
           "File::Find::finddepth" as the wanted routine.  If the object is
           used in a place that wants a coderef, this happens automatically
           through overloading.

       as_options
           Returns a hashref suitable for passing to "File::Find::find" or
           "File::Find::finddepth" as the options hash. This is necessary if
           you want the meta-information to carry forward properly.

       in(@starting_points)
           Calls "File::Find::find($self->as_options, @starting_points)",
           gathering the results, and returns the results as a list.  At the
           moment, it also returns the count of those items in a scalar
           context.  If that's useful, I'll maintain that.

       collect($coderef, @starting_points)
           Calls $coderef in a list context for each of the matching items,
           gathering and concatenating the results, and returning the results
           as a list.

             my $f = File::Finder->type('f');
             my %sizes = $f->collect(sub { $File::Find::name, -s _ }, "/tmp");

           In fact, "in" is implemented by calling "collect" with a coderef of
           just "sub { $File::Find::name }".

   STEPS
       See File::Finder::Steps.

   SPEED
       All the steps can have a compile-time and run-time component.  As much
       work is done during compile-time as possible.  Runtime consists of a
       simple linear pass executing a series of closures representing the
       individual steps (not method calls).  It is hoped that this will
       produce a speed that is within a factor of 2 or 3 of a handcrafted
       monolithic "wanted" routine.

SEE ALSO
       File::Finder::Steps, File::Find, find2perl, File::Find::Rule

BUGS
       Please report bugs to "bug-File-Finder@rt.cpan.org".

AUTHOR
       Randal L. Schwartz, <merlyn@stonehenge.com>, with a tip of the hat to
       Richard Clamp for "File::Find::Rule".

COPYRIGHT AND LICENSE
       Copyright (C) 2003,2004 by Randal L. Schwartz, Stonehenge Consulting
       Services, Inc.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself, either Perl version 5.8.2 or, at
       your option, any later version of Perl 5 you may have available.

perl v5.40.2                      2005-04-08                   File::Finder(3)
