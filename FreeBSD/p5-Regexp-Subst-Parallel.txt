Parallel(3)           User Contributed Perl Documentation          Parallel(3)


NAME
       Regexp::Subst::Parallel - Safely perform multiple substitutions on a
       string in parallel.

VERSION
       Regexp::Subst::Parallel version 0.11, Feb 9, 2003.

SYNOPSIS
           # Rephrase $str into the form of a question.
           my $qstr = subst($str,
                          qr/I|me/  => 'you',
                          qr/my/    => 'your',
                          qr/mine/  => 'yours',
                          qr/you/   => 'me',
                          qr/your/  => 'my',
                          qr/yours/ => 'mine',
                          ...);

           # Apply implicit html highlighting
           my $html = subst($text,
                          qr/\{(.*?)\}/ => '$1',  # Protect things in braces
                          qr/_(\w+)_/   => '<u>$1</u>',
                          qr/<(\w+)>/   => '<i>$1</i>',
                      );

           # Toggle the case of every character
           my $vAR = subst($Var,
                         qr/([a-z]+)/ => sub { uc $_[1] },
                         qr/([A-Z]+)/ => sub { lc $_[1] },
                     );

DESCRIPTION
       "Regexp::Subst::Parallel" is a module that allows you to make multiple
       simultaneous substitutions safely.  Using the sole exported "subst"
       function has a rather different effect from doing each substitution
       sequentially.  For example:

           $text = '{process_the_data} was _called_ without <data>!';
           $text =~ s/\{(.*?)\}/$1/g;
           # $text eq 'process_the_data was _called_ without <data>!'
           $text =~ s/_(\w+)_/<u>$1</u>/g;
           # $text eq 'process<u>the</u>data was <u>called</u> without <data>!'
           $text =~ s/<(\w+)>/<i>$1</i>/g;
           # $text eq 'process<i>u</i>the</u>data was <i>u</i>called</u> without <i>data</i>!'

       Which is clearly the wrong result.  On the other hand,
       "Regexp::Subst::Parallel" does them all in parallel, so:

           $text = '{process_the_data} was _called_ without <data>!';
           $text = subst($text,
                       qr/\{(.*?)\}/ => '$1',  # Protect things in braces
                       qr/_(\w+)_/   => '<u>$1</u>',
                       qr/<(\w+)>/   => '<i>$1</i>',
                   );
           # $text eq 'process_the_data was <u>called</u> without <i>data</i>'

       Which seems to be right.

       The algorithm moves from left to right, and the longest match is
       substituted in case of conflict.  The substitution side of the pairs
       can either be a string, in which non-backslashed $n's are substituted,
       or a coderef, in which the sub is called and passed the list of
       captures in @_.  $_[0] is analogous to $& : it refers to the entire
       match.

   Gotchas
       Make sure when you're using the string method to have the $'s included
       in the string.  That means if you're using an interpolating quote ("",
       qq{}, etc.)  that you backslash $1, $2, etc.  Otherwise you will get
       the $n's from the current lexical scope, which is not what you want.

   Caveats
       To include a single backslash followed by an interpolated capture,
       "subst" needs to see '\\$1', which means that you have to type '\\\\$1'
       when you just want a single backslash.  That's sick.

AUTHORS
       Luke Palmer <fibonaci@babylonia.flatirons.org>

COPYRIGHT
       Copyright (C) 2003 Luke Palmer.  This module is distributed under the
       same terms as Perl itself.

           http://www.perl.com/perl/misc/Artistic.html

perl v5.40.2                      2003-12-17                       Parallel(3)
