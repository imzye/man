AI::Prolog(3)         User Contributed Perl Documentation        AI::Prolog(3)


NAME
       AI::Prolog - Perl extension for logic programming.

SYNOPSIS
        use AI::Prolog;
        use Data::Dumper;

        my $database = <<'END_PROLOG';
          append([], X, X).
          append([W|X],Y,[W|Z]) :- append(X,Y,Z).
        END_PROLOG

        my $prolog = AI::Prolog->new($database);

        my $list   = $prolog->list(qw/a b c d/);
        $prolog->query("append(X,Y,[$list]).");
        while (my $result = $prolog->results) {
            print Dumper $result;
        }

ABSTRACT
        AI::Prolog is merely a convenient wrapper for a pure Perl Prolog compiler.
        Regrettably, at the current time, this requires you to know Prolog.  That will
        change in the future.

EXECUTIVE SUMMARY
       In Perl, we traditionally tell the language how to find a solution.  In
       logic programming, we describe what a solution would look like and let
       the language find it for us.

QUICKSTART
       For those who like to just dive right in, this distribution contains a
       Prolog shell called "aiprolog" and two short adventure games,
       "spider.pro" and "sleepy.pro".  If you have installed the "aiprolog"
       shell, you can run either game with the command:

        aiprolog data/spider.pro
        aiprolog data/sleepy.pro

       When the "aiprolog" shell starts, you can type "start." to see how to
       play the game.  Typing "halt." and hitting return twice will allow you
       to exit.

       See the "bin/" and "data/" directories in the distribution.

       Additionally, you can read AI::Prolog::Article for a better description
       of how to use "AI::Prolog".  This document is an article originally
       published in The Perl Review (<http://www.theperlreview.com/>) and
       which they have graciously allowed me to redistribute.

       See also Robert Pratte's perl.com article, "Logic Programming with Perl
       and Prolog" (<http://www.perl.com/pub/a/2005/12/15/perl_prolog.html>)
       for more more examples.

DESCRIPTION
       "AI::Prolog" is a pure Perl predicate logic engine.  In predicate
       logic, instead of telling the computer how to do something, you tell
       the computer what something is and let it figure out how to do it.
       Conceptually this is similar to regular expressions.

        my @matches = $string =~ /XX(YY?)ZZ/g

       If the string contains data that will satisfy the pattern, @matches
       will contain a bunch of "YY" and "Y"s.  Note that you're not telling
       the program how to find those matches.  Instead, you supply it with a
       pattern and it goes off and does its thing.

       To learn more about Prolog, see Roman Barták's "Guide to Prolog
       Programming" at <http://kti.ms.mff.cuni.cz/~bartak/prolog/index.html>.
       Amongst other things, his course uses the Java applet that "AI::Prolog"
       was ported from, so his examples will generally work with this module.

       Fortunately, Prolog is fairly easy to learn.  Mastering it, on the
       other hand, can be a challenge.

USING AI::Prolog
       There are three basic steps to using "AI::Prolog".

       Create the Prolog program.
       Create a query.
       Run the query.

       For quick examples of how that works, see the "examples/" directory
       with this distribution.  Feel free to contribute more.

   Creating a logic program
       This module is actually remarkable easy to use.  To create a Prolog
       program, you simply pass the Prolog code as a string to the
       constructor:

        my $prolog = AI::Prolog->new(<<'END_PROLOG');
           steals(PERP, STUFF) :-
               thief(PERP),
               valuable(STUFF),
               owns(VICTIM,STUFF),
               not(knows(PERP,VICTIM)).
           thief(badguy).
           valuable(gold).
           valuable(rubies).
           owns(merlyn,gold).
           owns(ovid,rubies).
           knows(badguy,merlyn).
        END_PROLOG

       Side note:  in Prolog, programs are often referred to as databases.

   Creating a query
       To create a query for the database, use "query".

         $prolog->query("steals(badguy,X).");

   Running a query
       Call the "results" method and inspect the "results" object:

         while (my $result = $prolog->results) {
             # $result = [ 'steals', 'badguy', $x ]
             print "badguy steals $result->[2]\n";
         }

BUILTINS
       See AI::Prolog::Builtins for the built in predicates.

CLASS METHODS
   new($program)
       This is the constructor.  It takes a string representing a Prolog
       program:

        my $prolog = AI::Prolog->new($program_text);

       See AI::Prolog::Builtins and the "examples/" directory included with
       this distribution for more details on the program text.

       Returns an "AI::Prolog" object.

   trace([$boolean])
       One can "trace" the program execution by setting this property to a
       true value before fetching engine results:

        AI::Prolog->trace(1);
        while (my $result = $engine->results) {
            # do something with results
        }

       This sends trace information to "STDOUT" and allows you to see how the
       engine is trying to satify your goals.  Naturally, this slows things
       down quite a bit.

       Calling "trace" without an argument returns the current "trace" value.

   raw_results([$boolean])
       You can get access to the full, raw results by setting "raw_results" to
       true.  In this mode, the results are returned as an array reference
       with the functor as the first element and an additional element for
       each term.  Lists are represented as array references.

        AI::Prolog->raw_results(1);
        $prolog->query('steals(badguy, STUFF, VICTIM)');
        while (my $r = $prolog->results) {
            # do stuff with $r in the form:
            # ['steals', 'badguy', $STUFF, $VICTIM]
        }

       Calling "raw_results" without an argument returns the current
       "raw_results" value.

       This is the default behavior.

   quote($string).
       This method quotes a Perl string to allow "AI::Prolog" to treat it as a
       proper Prolog term (and not worry about it accidentally being treated
       as a variable if it begins with an upper-case letter).

        my $perl6 = AI::Prolog->quote('Perl 6'); # returns 'Perl 6' (with quotes)
        $prolog->query(qq'can_program("ovid",$perl6).');

       At the present time, quoted strings may use single or double quotes as
       strings.  This is somewhat different from standard Prolog which treats
       a double-quoted string as a list of characters.

       Maybe called on an instance (the behavior is unchanged).

   list(@list).
       Turns a Perl list into a Prolog list and makes it suitable for
       embedding into a program.  This will quote individual variables, unless
       it thinks they are a number.  If you wish numbers to be quoted with
       this method, you will need to quote them manually.

       This method does not add the list brackets.

        my $list = AI::Prolog->list(qw/foo Bar 7 baz/);
        # returns:  'foo', 'Bar', 7, 'baz'
        $prolog->query(qq/append(X,Y,[$list])./);

       May be called on an instance (the behavior is unchanged).

INSTANCE METHODS
   do($query_string)
       This method is useful when you wish to combine the query() and
       results() methods but don't care about the results returned.  Most
       often used with the assert(X) and retract(X) predicates.

        $prolog->do('assert(loves(ovid,perl)).');

       This is a shorthand for:

        $prolog->query('assert(loves(ovid,perl)).');
        1 while $prolog->results;

       This is important because the query() method merely builds the query.
       Not until the results() method is called is the command actually
       executed.

   query($query_string)
       After instantiating an "AI::Prolog" object, use this method to query
       it.  Queries currently take the form of a valid prolog query but the
       final period is optional:

        $prolog->query('grandfather(Ancestor, julie).');

       This method returns $self.

   "results"
       After a query has been issued, this method will return results
       satisfying the query.  When no more results are available, this method
       returns "undef".

        while (my $result = $prolog->results) {
            # [ 'grandfather', $ancestor, 'julie' ]
            print "$result->[1] is a grandfather of julie.\n";
        }

       If "raw_results" is false, the return value will be a "result" object
       with methods corresponding to the variables.  This is currently
       implemented as a Hash::AsObject so the caveats with that module apply.

       Please note that this interface is experimental and may change.

        $prolog->query('steals("Bad guy", STUFF, VICTIM)');
        while (my $r = $prolog->results) {
            print "Bad guy steals %s from %s\n", $r->STUFF, $r->VICTIM;
        }

       See "raw_results" for an alternate way of generating output.

BUGS
       See AI::Prolog::Builtins and AI::Prolog::Engine for known bugs and
       limitations.  Let me know if (when) you find them.  See the built-ins
       TODO list before that, though.

TODO
       •   Why does this take so long to run?

            perl examples/path.pl 3

           On my Mac that takes over an hour to complete.

       •   Support for more builtins.

       •   Performance improvements.

           I have a number of ideas for this, but it's pretty low-priority
           until things are stabilized.

       •   Add "sugar" interface.

       •   Better docs.

       •   Tutorial.

       •   Data structure cookbook.

       •   Better error reporting.

EXPORT
       None by default.  However, for convenience, you can choose ":all"
       functions to be exported.  That will provide you with "Term", "Parser",
       and "Engine" classes.  This is not recommended and most support and
       documentation will now target the "AI::Prolog" interface.

       If you choose not to export the functions, you may use the fully
       qualified package names instead:

        use AI::Prolog;
        my $database = AI::Prolog::Parser->consult(<<'END_PROLOG');
        append([], X, X).
        append([W|X],Y,[W|Z]) :- append(X,Y,Z).
        END_PROLOG

        my $query  = AI::Prolog::Term->new("append(X,Y,[a,b,c,d]).");
        my $engine = AI::Prolog::Engine->new($query,$database);
        while (my $result = $engine->results) {
            print "$result\n";
        }

SEE ALSO
       AI::Prolog::Introduction

       AI::Prolog::Builtins

       W-Prolog:  <http://goanna.cs.rmit.edu.au/~winikoff/wp/>

       X-Prolog:  <http://www.iro.umontreal.ca/~vaucher/XProlog/>

       Roman Barták's online guide to programming Prolog:
       <http://kti.ms.mff.cuni.cz/~bartak/prolog/index.html>

AUTHOR
       Curtis "Ovid" Poe, <moc tod oohay ta eop_divo_sitruc>

       Reverse the name to email me.

       This work is based on W-Prolog,
       <http://goanna.cs.rmit.edu.au/~winikoff/wp/>, by Dr. Michael Winikoff.
       Many thanks to Dr. Winikoff for granting me permission to port this.

       Many features also borrowed from X-Prolog
       <http://www.iro.umontreal.ca/~vaucher/XProlog/> with Dr. Jean Vaucher's
       permission.

ACKNOWLEDGEMENTS
       Patches and other help has also been provided by: Joshua ben Jore and
       Sean O'Rourke.

COPYRIGHT AND LICENSE
       Copyright 2005 by Curtis "Ovid" Poe

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

perl v5.40.2                      2011-03-26                     AI::Prolog(3)
