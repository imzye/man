DBIx::Class::SQLMaker::Role::SQLA2Passthrough(3)
                                           User Contributed Perl Documentation


NAME
       DBIx::Class::SQLMaker::Role::SQLA2Passthrough - A test of future
       possibilities

SYNOPSIS
       •   select and group_by options are processed using the richer SQLA2
           code

       •   expand_join_condition is provided to more easily express rich joins

       See "examples/sqla2passthrough.pl" for a small amount of running code.

SETUP
         (on_connect_call => sub {
            my ($storage) = @_;
            $storage->sql_maker
                    ->with::roles('DBIx::Class::SQLMaker::Role::SQLA2Passthrough');
         })

   expand_join_condition
         __PACKAGE__->has_many(minions => 'Blah::Person' => sub {
           my ($args) = @_;
           $args->{self_resultsource}
                ->schema->storage->sql_maker
                ->expand_join_condition(
                    $args
                  );
         });

   on
         __PACKAGE__->has_many(minions => 'Blah::Person' => on {
           { 'self.group_id' => 'foreign.group_id',
             'self.rank' => { '>', 'foreign.rank' } }
         });

       Or with ParameterizedJoinHack,

         __PACKAGE__->parameterized_has_many(
             priority_tasks => 'MySchema::Result::Task',
             [['min_priority'] => sub {
                 my $args = shift;
                 return +{
                     "$args->{foreign_alias}.owner_id" => {
                         -ident => "$args->{self_alias}.id",
                     },
                     "$args->{foreign_alias}.priority" => {
                         '>=' => $_{min_priority},
                     },
                 };
             }],
         );

       becomes

         __PACKAGE__->parameterized_has_many(
             priority_tasks => 'MySchema::Result::Task',
             [['min_priority'] => on {
               { 'foreign.owner_id' => 'self.id',
                 'foreign.priority' => { '>=', { -value => $_{min_priority} } } }
             }]
         );

       Note that foreign/self can appear in such a condition on either side,
       BUT if you want DBIx::Class to be able to use a join-less version you
       must ensure that the LHS is all foreign columns, i.e.

         on {
           +{
             'foreign.x' => 'self.x',
             'self.y' => { -between => [ 'foreign.y1', 'foreign.y2' ] }
           }
         }

       is completely valid but DBIC will insist on doing a JOIN even if you
       have a fully populated row object to call "search_related" on - to
       avoid the spurious JOIN, you must specify it with explicit LHS foreign
       cols as:

         on {
           +{
             'foreign.x' => 'self.x',
             'foreign.y1' => { '<=', 'self.y' },
             'foreign.y2' => { '>=', 'self.y' },
           }
         }

perl v5.40.2                      2021-01-21
                              DBIx::Class::SQLMaker::Role::SQLA2Passthrough(3)
