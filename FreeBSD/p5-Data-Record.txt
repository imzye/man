Data::Record(3)       User Contributed Perl Documentation      Data::Record(3)


NAME
       Data::Record - "split" on steroids

VERSION
       Version 0.02

SYNOPSIS
         use Regexp::Common;
         use Data::Record;
         my $record = Data::Record->new({
           split  => "\n",
           unless => $RE{quoted},
         });
         my @data = $record->records($data);

DESCRIPTION
       Sometimes we need data split into records and a simple split on the
       input record separator ($/) or some other value fails because the
       values we're splitting on may allowed in other parts of the data.
       Perhaps they're quoted.  Perhaps they're embedded in other data which
       should not be split up.

       This module allows you to specify what you wish to split the data on,
       but also speficy an "unless" regular expression.  If the text in
       question matches the "unless" regex, it will not be split there.  This
       allows us to do things like split on newlines unless newlines are
       embedded in quotes.

METHODS
   new
       Common usage:

        my $record = Data::Record->new({
           split  => qr/$split/,
           unless => qr/$unless/,
        });

       Advanced usage:

        my $record = Data::Record->new({
           split  => qr/$split/,
           unless => qr/$unless/,  # optional
           token  => $token,       # optional
           chomp  => 0,            # optional
           limit  => $limit,       # optional (do not use with trim)
           trim   => 1,            # optional (do not use with limit)
           fields => {
               split  => ',',
               unless => $RE{quoted}, # from Regexp::Common
           }
        });

       The constructor takes a hashref of key/value pairs to set the behavior
       of data records to be created.

       •   split

           This is the value to split the data on.  It may be either a regular
           expression or a string.

           Defaults to the current input record separator ($/).

       •   unless

           Data will be split into records matching the split value unless
           they also match this value.  No default.

           If you do not have an "unless" value, use of this module is
           overkill.

       •   token

           You will probably never need to set this value.

           Internally, this module attempts to find a token which does not
           match any text found in the data to be split and also does not
           match the split value.  This is necessary because we mask the data
           we don't want to split using this token.  This allows us to split
           the resulting text.

           In the unlikely event that the module cannot find a token which is
           not in the text, you may set the token value yourself to some
           string value.  Do not set it to a regular expression.

       •   chomp

           By default, the split value is discarded (chomped) from each
           record.  Set this to a true value to keep the split value on each
           record.  This differs slightly from how it's done with split and
           capturing parentheses:

             split /(\,)/, '3,4,5';

           Ordinarily, this results in the following list:

            ( 3, ',', 4, ',', 5 )

           This module assumes you want those values with the preceding
           record.  By setting chomp to false, you get the following list:

            ( '3,', '4,' 5 )

       •   limit

           The default split behavior is similar to this:

            split $split_regex, $data;

           Setting "limit" will cause the behavior to act like this:

            split $split_regex, $data, $limit

           See "perldoc -f split" for more information about the behavior of
           "limit".

           You may not set both "limit" and "trim" in the constructor.

       •   trim

           By default, we return all records.  This means that due to the
           nature of split and how we're doing things, we sometimes get a
           trailing null record.  However, setting this value causes the
           module to behave as if we had done this:

            split $split_regex, $data, 0;

           When "split" is called with a zero as the third argument, trailing
           null values are discarded.  See "perldoc -f split" for more
           information.

           You may not set both "limit" and "trim" in the constructor.

           Note:  This does not trim white space around returned records.

       •   fields

           By default, individual records are returned as strings.  If you set
           "fields", you pass in a hashref of arguments that are identical to
           what "new" would take and resulting records are returned as array
           references processed by a new "Data::Record" instance.

           Example:  a quick CSV parser which assumes that commas and newlines
           may both be in quotes:

            # four lines, but there are only three records! (newline in quotes)
            $data = <<'END_DATA';
            1,2,"programmer, perl",4,5
            1,2,"programmer,
            perl",4,5
            1,2,3,4,5
            END_DATA

            $record = $RECORD->new({
                split  => "\n",
                unless => $quoted,
                trim   => 1,
                fields => {
                    split  => ",",
                    unless => $quoted,
                }
            });
            my @records = $record->records($data);
            foreach my $fields (@records) {
              foreach my $field = (@$fields);
                # do something
              }
            }

           Note that above example will not remove the quotes from individual
           fields.

   split
         my $split = $record->split;
         $record->split($on_value);

       Getter/setter for split value.  May be a regular expression or a scalar
       value.

   unless
        my $unless = $self->unless;
        $self->unless($is_value);

       Getter/setter for unless value.  May be a regular expression or a
       scalar value.

   chomp
         my $chomp = $record->chomp;
         $record->chomp(0);

       Getter/setter for boolean chomp value.

   limit
         my $limit = $record->limit;
         $record->limit(3);

       Getter/setter for integer limit value.

   trim
         my $trim = $record->trim;
         $record->trim(1);

       Getter/setter for boolean limit value.  Setting this value will cause
       any previous "limit" value to be overwritten.

   token
         my $token = $record->token;
         $record->token($string_not_found_in_text);

       Getter/setter for token value.  Token must be a string that does not
       match the split value and is not found in the text.

       You can return the current token value if you have set it in your code.
       If you rely on this module to create a token (this is the normal
       behavior), it is not available via this method until "records" is
       called.

       Setting the token to an undefined value causes Data::Record to try and
       find a token itself.

       If the token matches the split value, this method will croak when you
       attempt to set the token.

       If the token is found in the data, the "records" method will croak when
       it is called.

   records
         my @records = $record->records($data);

       Returns @records for $data based upon current split criteria.

BUGS
       It's possible to get erroneous results if the split value is "/\d+/".
       I've tried to work around this.  Please let me know if there is a
       problem.

CAVEATS
       This module must read all of the data at once.  This can make it slow
       for larger data sets.

AUTHOR
       Curtis "Ovid" Poe, "<ovid [at] cpan [dot] org>"

BUGS
       Please report any bugs or feature requests to
       "bug-data-record@rt.cpan.org", or through the web interface at
       <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Data-Record>.  I will
       be notified, and then you'll automatically be notified of progress on
       your bug as I make changes.

ACKNOWLEDGEMENTS
       Thanks to the Monks for inspiration from
       <http://perlmonks.org/index.pl?node_id=492002>.

       0.02 Thanks to Smylers and Stefano Rodighiero for catching POD errors.

COPYRIGHT & LICENSE
       Copyright 2005 Curtis "Ovid" Poe, all rights reserved.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

perl v5.40.2                      2005-09-19                   Data::Record(3)
