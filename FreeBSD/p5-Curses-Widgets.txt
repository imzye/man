Widgets(3)            User Contributed Perl Documentation           Widgets(3)


NAME
       Curses::Widgets - Base widget class for use with the
       Curses::Application framework

MODULE VERSION
       $Id: Widgets.pm,v 1.997 2002/11/14 01:30:19 corliss Exp corliss $

SYNOPSIS
         use Curses::Widgets;

         $rv = test_colour();
         test_color();

         $colpr = select_colour($fore, $back);
         $colpr = select_color($fore, $back);

         $key = scankey($mwh);

         @lines = textwrap($text, 40);

         # The following are provided for use with descendent
         # classes, and while they are not expected to be
         # overridden, they can be.
         $obj = Curses::Widgets->new({KEY => 'value'});
         $obj->_copy($href1, $href2);
         $obj->reset;
         $obj->input($string);
         $value = $obj->getField('VALUE');
         $obj->setField(
           'FIELD1'  => 1,
           'FIELD2'  => 'value'
           );
         $obj->execute($mwh);
         $obj->draw($mwh, 1);
         @geom = $obj->_geometry;
         @geom = $obj->_cgeometry;
         $dwh = $obj->_canvas($mwh, @geom);
         $obj->_save($mwh);
         $obj->_restore($mwh);
         $obj->_border($mwh);
         $obj->_caption

         # The following are provided for use with descendent
         # classes, and are expected to be overridden.
         $obj->_conf(%conf);
         $obj->input_key($ch);
         $obj->_content($mwh);
         $obj->_cursor

REQUIREMENTS
       Curses

DESCRIPTION
       This module serves two purposes:  to provide a framework for creating
       custom widget classes, and importing a few useful functions for global
       use.

       Widget specific methods are documented in each Widget's pod, of which
       the following widgets are currently available:

       Button Set (Curses::Widgets::ButtonSet)
       Calendar (Curses::Widgets::Calendar)
       Combo-Box (Curses::Widgets::ComboBox)
       Label (Curses::Widgets::Label)
       List Box (Curses::Widgets::ListBox)
       Multicolumn List Box (Curses::Widgets::ListBox::MultiColumn)
       Menu (Curses::Widgets::Menu)
       Progress Bar (Curses::Widgets::ProgressBar)
       Text Field (Curses::Widgets::TextField)
       Text Memo (Curses::Widgets::TextMemo)

       The following tutorials are available:

       Widget Usage -- General Usage & Tips (Curses::Widgets::Tutorial)
       Widget Creation (Curses::Widgets::Tutorial::Creation)
       Widget Creation -- ComboBox Example
       (Curses::Widgets::Tutorial::ComboBox)

       For even higher (and simpler) level control over collections of widgets
       on "forms", please see Curses::Forms, which uses this module as well.

EXPORTED FUNCTIONS
   test_colour/test_color
         $rv = test_colour();
         test_color();

       This function tests the console for colour capability, and if found, it
       will set $Curses::Widgets::DEFAULTFG and $Curses::Widgets::DEFAULTBG to
       the default foreground and background colour, respectively.

       It also calls the Curses start_color for you.  Unless you need to know
       the default foreground/background colours ahead of time, you won't need
       to call this, select_colour will do it for you the first time it's
       called, if necessary.

       This function returns a true or false, designating colour support.

   select_colour/select_color
         $colpr = select_colour($fore, $back);
         $colpr = select_color($fore, $back);

       This function returns the number of the specified colour pair.  In
       doing so, it saves quite a few steps.

       After the initial colour test, this function will safely (and quietly)
       return on all subsequent calls if no colour support is found.  It
       returns '0', which is hardwired to your terminal default.  If colour
       support is present, it allocates the colour pair using (n)curses
       init_pair for you, if it hasn't been done already.

       Most terminals have a limited number of colour pairs that can be
       defined.  Because of this 0 (the terminal default colour pair) will be
       returned in lieu of attempting to allocate more colour pairs than the
       terminal supports.  If you need a specific set of colours to be
       available, you might want allocate each pair ahead of time using this
       function to prevent less important pairs from running you out of pairs.

       As a final note, yes, both the British and American spellings of
       'colo(u)r' are supported.

       Known colours:

         black           cyan
         green           magenta
         red             white
         yellow          blue

       The colours are not case sensitive.

   scankey
         $key = scankey($mwh);

       The scankey function returns the key pressed, when it does.  All it
       does is loop over a (n)curses getch call until something other than -1
       is returned.  Whether or not the getch call is (half)-blocking or
       cooked output is determined by how the (n)curses environment was
       initialised by your application.  This is provided only to provide the
       most basic input functionality to your application, should you decide
       not to implement your own.

       The only argument is a handle to a curses/window object.

   textwrap
         @lines = textwrap($text, 40);

       The textwrap function takes a string and splits according to the passed
       column limit, splitting preferrably along whitespace.  Newlines are
       preserved.

METHODS
   new
         $obj = Curses::Widgets->new({KEY => 'value'});

       The new class method provides a basic constructor for all descendent
       widget classes.  Internally, it assumes any configuration information
       to be passed in a hash ref as the sole argument.  It dereferences that
       ref and passes it to the internal method _conf, which is expected to do
       any input validation/initialisation required by your widget.  That
       method should return a 1 or 0, which will determine if new returns a
       handle to the new object.

       If _conf returns a 1, the _copy is called to back up the initial state
       information.

       If descendent widgets use the methods provided in the class (instead of
       overriding them) then the following keys should always be recognised:

         Key             Description
         ====================================================
         FOREGROUND      Foreground colour
         BACKGROUND      Background colour
         BORDERCOL       Border (foreground) colour
         CAPTIONCOL      Caption (foreground) colour
         BORDER          Whether or not to display a border
         CAPTION         The string to use as the caption

       The colours will default to the terminal foreground/background
       defaults.  Other arguments may have defaults defined by the descendent
       classes.

   _conf
         $obj->_conf(%conf);

       This method should be overridden in your descendant class.  As
       mentioned above, it should do any initialisation and validation
       required, based on the passed configuration hash.  It should return a 1
       or 0, depending on whether any critical errors were encountered during
       instantiation.

       Note:  your _conf method should call, as a last act, SUPER::_conf.
       This is important to do, since this method takes care of some colour
       initialisation steps for you automatically.  The following keys are
       known by this module, and are used by certain rendering and initiation
       methods:

         Field              Default      Description
         ============================================================
         FOREGROUND   (terminal default) Default foreground colour
         BACKGROUND   (terminal default) Default background colour
         BORDERCOL       (FOREGROUND)    Default border colour
         CAPTIONCOL      (FOREGROUND)    Default caption colour

       As a final note, here are some rules regarding the structure of your
       configuration hash.  You *must* save your state information in this
       hash.  Another subroutine will copy that information after object
       instantiation in order to support the reset method.  Also note that
       everything stored in this should *not* be more than one additional
       level deep (in other words, values can be hash or array refs, but none
       of the values in *that* structure should be refs), otherwise those refs
       will be copied over, instead of the data inside the structure.  This
       essentially destroys your backup.

       If you have special requirements, override the _copy method as well.

   _copy
         $obj->_copy($href1, $href2);

       This method copies the contents of $href1 to $href2.  This will only
       copy two levels of data, so any reference values deeper than that will
       be passed by reference, not as a copy of reference's (dereferenced)
       value.

   reset
         $obj->reset;

       The reset method resets the object back to the original state by
       copying the original configuration information into the working hash.

   input_key
         $obj->input_key($ch);

       The input_key method should be overridden in all descendent classes.
       This method should accept character input and update it's internal
       state information appropriately.  This method will be used in both
       interactive and non-interactive modes to send keystrokes to the widget.

   input
         $obj->input($string);

       The input method provides a non-interactive method for sending input to
       the widget.  This is essentially just a wrapper for the input_key
       method, but will accept any number of string arguments at once.  It
       splits all of the input into separate characters for feeding to the
       input_key method.

   execute
         $obj->execute($mwh);

       This method puts the widget into interactive mode, which consists of
       calling the draw method, scanning for keyboard input, feeding it to the
       input_key method, and redrawing.

       execute uses the widget's configuration information to allow easy
       modification of its behavoiur.  First, it checks for the existance of a
       INPUTFUNC key.  Setting its value to a subroutine reference allows you
       to substitute any custom keyboard scanning/polling routine in leiu of
       the default  scankey provided by this module.

       Second, it checks the return value of the input function against the
       regular expression stored in FOCUSSWITCH, if any.  Any matches against
       that expression will tell this method to exit, returning the key that
       matches it.  This effectively causes the widget to 'lose focus'.

       The only argument is a handle to a valid curses window object.

       NOTE:  If \t is in your regex, KEY_STAB will also be a trigger for a
       focus switch.

   getField
         $value = $obj->getField('VALUE');

       The getField method retrieves the value(s) for every field requested
       that exists in the configuration hash.

   setField
         $obj->setField(
           'FIELD1'  => 1,
           'FIELD2'  => 'value'
           );

       The setField method sets the value for every key/value pair passed.

   draw
         $obj->draw($mwh, 1);

       The draw method can be overridden in each descendant class.  It is
       reponsible for the rendering of the widget, and only that.  The first
       argument is mandatory, being a valid window handle with which to create
       the widget's derived window.  The second is optional, but if set to
       true, will tell the widget to draw itself in an 'active' state.  For
       instance, the TextField widget will also render a cursor, while a
       ButtonSet widget will render the selected button in standout mode.

       The rendering sequence defined in this class is as follows:

         # Get the canvas geometry and create a window handle to it
         $dwh = $self->_canvas($mwh, $self->_geometry);
         return 0 unless $dwh;

         $self->_init($dwh);
         $self->_border($dwh);
         $self->_caption($dwh);

         # Get the content area geometry and create a window handle to it
         $cwh = $self->_canvas($dwh, $self->_cgeometry);
         unless (defined $cwh) {
           $dwh->delwin;
           return 0;
         }

         $self->_content($cwh);
         $self->_cursor($cwh) if $active;

   _geometry
         @geom = $obj->_geometry;

       This method returns the size of the canvas, with dimensions adjusted to
       account for a border (based on the value of BORDER in the configuration
       hash).

   _cgeometry
         @geom = $obj->_cgeometry;

       This method returns the size of the content area.  The Y and X
       coordinates are adjusted appropriately for rendering in a widget
       canvas.  (0, 0) is returned for widgets with no border, and (1, 1) is
       returned for widgets with a border (based on the value of BORDER in the
       configuration hash).

   _canvas
         $dwh = $obj->_canvas($mwh, @geom);

       This method returns a window handle to a derived window in the passed
       window, using the specified geometry.  This will return undef and
       produce a warning if the call fails for any reason.

   _init
         $obj->_init($mwh);

       This method erases the window and sets the foreground/background
       colours as found in the configuration hash.

   _save
         $obj->_save($mwh);

       This method saves the current attributes and colour pair in the passed
       window.  This method would typically be called by the draw routine
       after _init is called on the derived window (though the current _init
       method calls this for you).

   _restore
         $obj->_restore($mwh);

       This method restores the last saved attributes and colour pair used in
       the window.  This should be called at the end of any rendering phase
       that may alter the default colour and attribute settings.

   _border
         $obj->_border($mwh);

       This method draws the border around the passed window if BORDER is true
       within the configuration hash.

   _caption
         $obj->_caption

       This method draws a caption on the first line of the passed window if
       CAPTION is defined within the configuration hash.

   _content
         $obj->_content($mwh);

       This method should be overridden in all descendent classes, and should
       render any content in the passed window.  The draw method, as defined
       in this class, will pass a window the exact size of the content area,
       so no adjustments will need to be made to accomodate a border.

   _cursor
         $obj->_cursor

       This method should be overriden in all descendent classes that display
       a cursor in the content area.  The draw method, as defined in this
       class, calls this method after the content is rendered, and passes it a
       window handle the exact size of the content area.

HISTORY
       2001/07/05 -- First implementation of the base class.

AUTHOR/COPYRIGHT
       (c) 2001 Arthur Corliss (corliss@digitalmages.com)

perl v5.40.2                      2002-11-14                        Widgets(3)
