Class::Component(3)   User Contributed Perl Documentation  Class::Component(3)


NAME
       Class::Component - pluggable component framework

SYNOPSIS
       base class

         package MyClass;
         use strict;
         use warnings;
         use Class::Component;
         __PACKAGE__->load_component(qw/ Autocall::InjectMethod /);
         __PACKAGE__->load_plugins(qw/ Default /);

       application code

         use strict;
         use warnings;
         use MyClass;
         my $obj = MyClass->new({ load_plugins => [qw/ Hello /] });
         $obj->hello; # autocall
         $obj->run_hook( hello => $args );

DESCRIPTION
       Class::Component is pluggable component framework.  The compatibilities
       such as dump and load such as YAML are good.

METHODS
       new constructor

       load_components
             __PACKAGE__->load_components(qw/ Sample /);

           The candidate is the order of MyClass::Component::Sample and
           Class::Component::Sample.  It looks for the module in order
           succeeded to by @ISA.  It is used to remove + when there is + in
           the head.

       load_plugins
             __PACKAGE__->load_plugins(qw/ Default /);

           The candidate is the MyClass::Plugin::Default.  It looks for the
           module in order succeeded to by @ISA.  It is used to remove + when
           there is + in the head.

       register_method
             $obj->register_method( 'method name' => 'MyClass::Plugin::PluginName' );

           Method attribute is usually used and set. See Also
           Class::Component::Plugin.

       register_hook
             $obj->register_hook( 'hook name' => { plugin => 'MyClass::Plugin::PluginName', method => 'hook method name' } );

           Hook attribute is usually used and set. See Also
           Class::Component::Plugin.

       remove_method
             $obj->remove_method( 'method name' => 'MyClass::Plugin::PluginName' );

       remove_hook
             $obj->remove_hook( 'hook name' => { plugin => 'MyClass::Plugin::PluginName', method => 'hook method name' } );

       call
             $obj->call('plugin method name' => @args)
             $obj->call('plugin method name' => %args)

       run_hook
             $obj->run_hook('hook name' => $args)

PROPERTIES
       class_component_config
       class_component_components
       class_component_plugins
       class_component_methods
       class_component_hooks

METHODS for COMPONENT
       NEXT
             $self->NEXT('methods name', @args);

           It is behavior near maybe::next::method of Class::C3.

       class_component_reinitialize

INTERFACES
       class_component_load_component_resolver
       class_component_load_plugin_resolver
           Given an (possibly) unqualified plugin name (say, "Foo"), resolves
           it into a fully qualified module name (say, "MyApp::Plugin::Foo")

INITIALIZE OPTIONS
       reload_plugin
             use Class::Component reload_plugin => 1;

           or

             MyClass->class_component_reinitialize( reload_plugin => 1 );

           Plugin/Component of the object made with YAML::Load etc. is done
           and require is done automatically.

ATTRIBUTES
       SEE ALSO Class::Component::Attribute::Method and
       Class::Component::Attribute::Hook test code in ./t directory.
       (MyClass::Attribute::Test and MyClass::Plugin::ExtAttribute)

APPENDED COMPONENTS
       It is an outline of Components that the bundle is done in
       Class::Components::Components or less.

       DisableDynamicPlugin
           plugin can be added, lost from new and the object method, and some
           speeds are improved.

             package MyClass;
             use base 'Class::Component';
             __PACKAGE__->load_components(qw/ DisableDynamicPlugin /);
             package main;
             MyClass->load_plugins(qw/ Test /); # is ok!
             my $obj = MyClass->new;
             $obj->load_plugins(qw/ NoNoNo /); # not loaded
             my $obj2 = MyClass->new({ load_plugins => qw/ OOPS / }); # not loaded

       Autocall::Autoload
           It keeps accessible with method defined by register_method.  using
           AUTOLOAD.

             package MyClass::Plugin::Test;
             use base 'Class::Component::Plugin';
             sub test :Method { print "plugin load ok" }
             package MyClass;
             use base 'Class::Component';
             __PACKAGE__->load_components(qw/ Autocall::Autoload /);
             package main;
             MyClass->load_plugins(qw/ Test /);
             my $obj = MyClass->new;
             $obj->test; # plugin load ok

       Autocall::InjectMethod
           It is the same as Autocall::Autoload. The method is actually added.

       Autocall::SingletonMethod
           The method is added in the form of singleton method.  It is not
           influenced by other objects.  It is not possible to use it at the
           same time as DisableDynamicPlugin.

             package MyClass::Plugin::Test;
             use base 'Class::Component::Plugin';
             sub test :Method { print "plugin load ok" }
             package MyClass;
             use base 'Class::Component';
             __PACKAGE__->load_components(qw/ Autocall::Autoload /);
             package main;
             MyClass->;
             my $obj = MyClass->new({ load_plugins => [qw/ Test /] });
             $obj->test; # plugin load ok
             my $obj2 = MyClass->new;
             $obj2->test; # died

       AutoloadPlugin
           AutoloadPlugin is Plagger->autoload_plugin like

             $c->autoload_plugins({ module => 'Hello' });
             $c->autoload_plugins({ module => 'Hello', config => {} });
             $c->autoload_plugins({ module => '+Foo::Plugin::Hello' });
             $c->autoload_plugins({ module => '+Foo::Plugin::Hello', config => {} });

           the under case is same to load_pugins method

             $c->autoload_plugins('Hello');
             $c->autoload_plugins('+Foo::Plugin::Hello');

COMPONENTS
       Plaggerize
           The Plaggerize is extend your module like from Plagger component.

           see. Class::Component::Component::Plaggerize

AUTHOR
       Kazuhiro Osawa <ko@yappo.ne.jp>

THANKS TO
       Tokuhiro Matsuno

SEE ALSO
       Class::Component::Plugin

EXAMPLE
       HTTP::MobileAttribute, Number::Object, App::MadEye

LICENSE
       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

perl v5.40.2                      2008-05-12               Class::Component(3)
