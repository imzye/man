Object::Simple(3)     User Contributed Perl Documentation    Object::Simple(3)


NAME
       Object::Simple - Simple class builder(Mojo::Base porting)

SYNOPSIS
         package SomeClass;
         use Object::Simple -base;

         # Create accessor
         has 'foo';

         # Create accessor with default value
         has foo => 1;
         has foo => sub { [] };
         has foo => sub { {} };
         has foo => sub { OtherClass->new };

         # Create accessors at once
         has [qw/foo bar baz/];
         has [qw/foo bar baz/] => 0;

       Create object.

         # Create a new object
         my $obj = SomeClass->new;
         my $obj = SomeClass->new(foo => 1, bar => 2);
         my $obj = SomeClass->new({foo => 1, bar => 2});

         # Set and get value
         my $foo = $obj->foo;
         $obj->foo(1);

         # set-accessor can be changed
         $obj->foo(1)->bar(2);

       Inheritance

         # Foo.pm
         package Foo;
         use Object::Simple -base;

         # Bar.pm
         package Bar;
         use Foo -base;

         # Bar.pm (another way to inherit)
         package Bar;
         use Object::Simple -base => 'Foo';

DESCRIPTION
       Object::Simple is Mojo::Base porting.  you can use Mojo::Base features.

       Object::Simple is a generator of accessor method, such as
       Class::Accessor, Mojo::Base, or Moose.

       Class::Accessor is simple, but lack offten used features.  "new" method
       can't receive hash arguments.  Default value can't be specified.  If
       multipule values is set through the accessor, its value is converted to
       array reference without warnings.

       Some people find Moose too complex, and dislike that it depends on
       outside modules. Some say that Moose is almost like another language
       and does not fit the familiar perl syntax. In some cases, in particular
       smaller projects, some people feel that Moose will increase complexity
       and therefore decrease programmer efficiency.  In addition, Moose can
       be slow at compile-time and its memory usage can get large.

       Object::Simple is the middle way between Class::Accessor and complex
       class builder. Only offten used features is implemented has no
       dependency.  Object::Simple is almost same as Mojo::Base.

       "new" method can receive hash or hash reference.  You can specify
       default value.

       If you like Mojo::Base, Object::Simple is good choice.

GUIDE
   1. Create accessor
       At first, you create class.

         package SomeClass;
         use Object::Simple -base;

       By using "-base" option, SomeClass inherit Object::Simple and import
       "has" method.

       Object::Simple have "new" method. "new" method is constructor.  "new"
       method can receive hash or hash reference.

         my $obj = SomeClass->new;
         my $obj = SomeClass->new(foo => 1, bar => 2);
         my $obj = SomeClass->new({foo => 1, bar => 2});

       Create accessor by using "has" function.

         has 'foo';

       If you create accessor, you can set or get attribute value.s

         # Set value
         $obj->foo(1);

         # Get value
         my $foo = $obj->foo;

       set-accessor can be changed.

         $obj->foo(1)->bar(2);

       You can define default value.

         has foo => 1;

       If "foo" attribute value is not exists, default value is used.

         my $foo_default = $obj->foo;

       If you want to use reference or object as default value, default value
       must be surrounded by code reference.  the return value become default
       value.

         has foo => sub { [] };
         has foo => sub { {} };
         has foo => sub { SomeClass->new };

       You can create multiple accessors at once.

         has [qw/foo bar baz/];
         has [qw/foo bar baz/] => 0;

   Class example
       I introduce Object::Simple example.

       Point class: two accessor "x" and "y", and "clear" method to set "x"
       and "y" to 0.

         package Point;
         use Object::Simple -base;

         has x => 0;
         has y => 0;

         sub clear {
           my $self = shift;

           $self->x(0);
           $self->y(0);
         }

       Use Point class.

         use Point;
         my $point = Point->new(x => 3, y => 5);
         print $point->x;
         $point->y(9);
         $point->clear;

       Point3D class: Point3D inherit Point class.  Point3D class has "z"
       accessor in addition to "x" and "y".  "clear" method is overriden to
       clear "x", "y" and "z".

         package Point3D;
         use Point -base;

         has z => 0;

         sub clear {
           my $self = shift;

           $self->SUPER::clear;

           $self->z(0);
         }

       Use Point3D class.

         use Point3D;
         my $point = Point->new(x => 3, y => 5, z => 8);
         print $point->z;
         $point->z(9);
         $point->clear;

   2. Concepts of Object-Oriented programing
       I introduce concepts of Object-Oriented programing

       Inheritance

       I explain the essence of Object-Oriented programing.

       First concept is inheritance.  Inheritance means that if Class Q
       inherit Class P, Class Q use all methods of class P.

         +---+
         | P | Base class
         +---+   have method1 and method2
           |
         +---+
         | Q | Sub class
         +---+   have method3

       Class Q inherits Class P, Q can use all methods of P in addition to
       methods of Q.

       In other words, Q can use "method1", "method2", and "method3"

       You can use "-base" option to inherit class.

         # P.pm
         package P;
         use Object::Simple -base;

         sub method1 { ... }
         sub method2 { ... }

         # Q.pm
         package Q;
         use P -base;

         sub method3 { ... }

       Perl have useful functions and methods to help Object-Oriented
       programing.

       If you know what class the object is belonged to, use "ref" function.

         my $class = ref $obj;

       If you know what class the object inherits, use "isa" method.

         $obj->isa('SomeClass');

       If you know what method the object(or class) can use, use "can" method

         SomeClass->can('method1');
         $obj->can('method1');

       Encapsulation

       Second concept is encapsulation.  Encapsulation means that you don't
       touch internal data directory.  You must use public method when you
       access internal data.

       Create accessor and use it to keep thie rule.

         my $value = $obj->foo;
         $obj->foo(1);

       Polymorphism

       Third concept is polymorphism.  Polymorphism is divided into two
       concepts, overload and override

       Perl programer don't need to care overload.  Perl is dynamic type
       language.  Subroutine can receive any value.

       Override means that you can change method behavior in sub class.

         # P.pm
         package P;
         use Object::Simple -base;

         sub method1 { return 1 }

         # Q.pm
         package Q;
         use P -base;

         sub method1 { return 2 }

       P "method1" return 1. Q "method1" return 2.  Q "method1" override P
       "method1".

         # P method1 return 1
         my $obj_a = P->new;
         $obj_p->method1;

         # Q method1 return 2
         my $obj_b = Q->new;
         $obj_q->method1;

       If you want to use super class method from sub class, use SUPER pseudo-
       class.

         package Q;

         sub method1 {
           my $self = shift;

           # Call supper class P method1
           my $value = $self->SUPER::method1;

           return 2 + $value;
         }

       If you understand three concepts, you have learned Object-Oriented
       programming primary parts.

   3. Often used techniques
       Override new method

       "new" method can be overridden.

       Example:

       Initialize the object

         sub new {
           my $self = shift->SUPER::new(@_);

           # Initialization

           return $self;
         }

       Example:

       Change arguments of "new".

         sub new {
           my $self = shift;

           $self->SUPER::new(x => $_[0], y => $_[1]);

           return $self;
         }

       You can pass array to "new" method.

         my $point = Point->new(4, 5);

IMPORT OPTIONS
   -base
       By using "-base" option, the class inherit Object::Simple and import
       "has" function.

         package Foo;
         use Object::Simple -base;

         has x => 1;
         has y => 2;

       strict and warnings is automatically enabled.

       You can also use "-base" option in sub class to inherit other class.

         # Bar inherit Foo
         package Bar;
         use Foo -base;

       You can also use the following syntax.

         # Same as above
         package Bar;
         use Object::Simple -base => 'Foo';

FUNCTIONS
   has
       Create accessor.

         has 'foo';
         has [qw/foo bar baz/];
         has foo => 1;
         has foo => sub { {} };

       Create accessor. "has" receive accessor name and default value.
       Default value is optional.  If you want to create multipule accessors
       at once, specify accessor names as array reference at first argument.

       If you want to specify reference or object as default value, it must be
       code reference not to share the value with other objects.

       Get and set a attribute value.

         my $foo = $obj->foo;
         $obj->foo(1);

       If a default value is specified and the value is not exists, you can
       get default value.

       If a value is set, the accessor return self object.  So you can set a
       value repeatedly.

         $obj->foo(1)->bar(2);

       You can create all accessors at once.

         has [qw/foo bar baz/];

METHODS
   new
         my $obj = Object::Simple->new(foo => 1, bar => 2);
         my $obj = Object::Simple->new({foo => 1, bar => 2});

       Create a new object. "new" receive hash or hash reference as arguments.

   attr
         __PACKAGE__->attr('foo');
         __PACKAGE__->attr([qw/foo bar baz/]);
         __PACKAGE__->attr(foo => 1);
         __PACKAGE__->attr(foo => sub { {} });

         __PACKAGE__->attr([qw/foo bar baz/]);

       Create accessor.  "attr" method usage is equal to "has" method.

DEPRECATED FUNCTIONALITY
         function exporting of C<new> and C<attr> method # Will be removed 2021/6/1

         The syntax of multiple key-value arguments
           has x => 1, y => 2;
           __PACAKGE__->attr(x => 1, y => 2);
         # Will be removed 2021/6/1

         class_attr method # will be removed 2017/1/1
         dual_attr method # will be removed 2017/1/1

BACKWARDS COMPATIBILITY POLICY
       If a functionality is DEPRECATED, you can know it by DEPRECATED
       warnings.  You can check all DEPRECATED functionalities by document.
       DEPRECATED functionality is removed after five years, but if at least
       one person use the functionality and tell me that thing I extend one
       year each time he tell me it.

       EXPERIMENTAL functionality will be changed without warnings.

       (This policy was changed at 2011/10/22)

BUGS
       Tell me the bugs by mail or github
       <http://github.com/yuki-kimoto/Object-Simple>

AUTHOR
       Yuki Kimoto, "<kimoto.yuki at gmail.com>"

COPYRIGHT & LICENSE
       Copyright 2008-2016 Yuki Kimoto, all rights reserved.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Artistic v2(This is same as Mojolicious
       licence).

perl v5.40.2                      2016-05-14                 Object::Simple(3)
