()                                                                          ()

compat/?????????????????????????????????????????????????????????????????????????????????????????????0000755?0000765?0000765?00000000000?11226752541?011746?
5????????????????????????????????????????????????????????????????????????????????????????????????????ustar
?ntoone??????????????????????????ntoone?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????compat/_data/???????????????????????????????????????????????????????????????????????????????????????0000755?0000765?0000765?00000000000?11226752541?013016?
5????????????????????????????????????????????????????????????????????????????????????????????????????ustar
?ntoone??????????????????????????ntoone?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????compat/_data/dijitEditors.js????????????????????????????????????????????????????????????????????????0000644?0000765?0000765?00000011664?11226752541?016021?
0????????????????????????????????????????????????????????????????????????????????????????????????????ustar
?ntoone??????????????????????????ntoone?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????dojo.provide("dojox.grid.compat._data.dijitEditors");
dojo.require("dojox.grid.compat._data.editors");
dojo.require("dijit.form.DateTextBox");
dojo.require("dijit.form.TimeTextBox"); dojo.require("dijit.form.ComboBox");
dojo.require("dojo.data.ItemFileReadStore");
dojo.require("dijit.form.CheckBox"); dojo.require("dijit.form.TextBox");
dojo.require("dijit.form.NumberSpinner");
dojo.require("dijit.form.NumberTextBox");
dojo.require("dijit.form.CurrencyTextBox"); dojo.require("dijit.form.Slider");
dojo.require("dijit.Editor");

dojo.declare("dojox.grid.editors.Dijit", dojox.grid.editors.base, {
     editorClass: "dijit.form.TextBox",      constructor: function(inCell){
          this.editor = null;           this.editorClass =
dojo.getObject(this.cell.editorClass || this.editorClass);  },   format:
function(inDatum, inRowIndex){          this.needFormatNode(inDatum,
inRowIndex);        return "<div></div>";    },   getValue:
function(inRowIndex){         return this.editor.getValue();     },
     setValue: function(inRowIndex, inValue){
          if(this.editor&&this.editor.setValue){            //Look for lazy-
loading editor and handle it via its deferred.
               if(this.editor.onLoadDeferred){                   var self =
this;                    this.editor.onLoadDeferred.addCallback(function(){
                          self.editor.setValue(inValue==null?"":inValue);
                    });            }else{
                    this.editor.setValue(inValue);               }
          }else{              this.inherited(arguments);         }    },
     getEditorProps: function(inDatum){           return dojo.mixin({},
this.cell.editorProps||{}, {            constraints: dojo.mixin({},
this.cell.constraint) || {}, //TODO: really just for ValidationTextBoxes
               value: inDatum           });  },   createEditor:
function(inNode, inDatum, inRowIndex){       return new
this.editorClass(this.getEditorProps(inDatum), inNode);

     },   attachEditor: function(inNode, inDatum, inRowIndex){
          inNode.appendChild(this.editor.domNode);
          this.setValue(inRowIndex, inDatum);     },   formatNode:
function(inNode, inDatum, inRowIndex){       if(!this.editorClass){
               return inDatum;          }         if(!this.editor){
               this.editor = this.createEditor.apply(this, arguments);
          }else{              this.attachEditor.apply(this, arguments);
          }         this.sizeEditor.apply(this, arguments);
          this.cell.grid.rowHeightChanged(inRowIndex);           this.focus();
     },   sizeEditor: function(inNode, inDatum, inRowIndex){          var
               p = this.cell.getNode(inRowIndex),                box =
dojo.contentBox(p);           dojo.marginBox(this.editor.domNode, {w: box.w});
     },   focus: function(inRowIndex, inNode){         if(this.editor){
               setTimeout(dojo.hitch(this.editor, function(){
                    dojox.grid.fire(this, "focus");              }), 0);
          }    },   _finish: function(inRowIndex){
          this.inherited(arguments);
          dojox.grid.removeNode(this.editor.domNode);  } });

dojo.declare("dojox.grid.editors.ComboBox", dojox.grid.editors.Dijit, {
     editorClass: "dijit.form.ComboBox",     getEditorProps:
function(inDatum){       var items=[];       dojo.forEach(this.cell.options,
function(o){             items.push({name: o, value: o});        });       var
store = new dojo.data.ItemFileReadStore({data: {identifier:"name", items:
items}});           return dojo.mixin({}, this.cell.editorProps||{}, {
               value: inDatum,               store: store        });  },
     getValue: function(){         var e = this.editor;          // make sure
to apply the displayed value       e.setDisplayedValue(e.getDisplayedValue());
          return e.getValue();     } });

dojo.declare("dojox.grid.editors.DateTextBox", dojox.grid.editors.Dijit, {
     editorClass: "dijit.form.DateTextBox",  setValue: function(inRowIndex,
inValue){           if(this.editor){              this.editor.setValue(new
Date(inValue));          }else{              this.inherited(arguments);
          }    },   getEditorProps: function(inDatum){           return
dojo.mixin(this.inherited(arguments), {                value: new
Date(inDatum)       });  } });


dojo.declare("dojox.grid.editors.CheckBox", dojox.grid.editors.Dijit, {
     editorClass: "dijit.form.CheckBox",     getValue: function(){
          return this.editor.checked;   },   setValue: function(inRowIndex,
inValue){           if(this.editor&&this.editor.setAttribute){
               this.editor.setAttribute("checked", inValue);          }else{
               this.inherited(arguments);         }    },   sizeEditor:
function(inNode, inDatum, inRowIndex){       return;   } });


dojo.declare("dojox.grid.editors.Editor", dojox.grid.editors.Dijit, {
     editorClass: "dijit.Editor",  getEditorProps: function(inDatum){
          return dojo.mixin({}, this.cell.editorProps||{}, {
               height: this.cell.editorHeight || "100px"         });  },
     createEditor: function(inNode, inDatum, inRowIndex){        // editor
needs its value set after creation           var editor = new
this.editorClass(this.getEditorProps(inDatum), inNode);
          dojo.connect(editor, 'onLoad', dojo.hitch(this, 'populateEditor'));
          return editor;      },   formatNode: function(inNode, inDatum,
inRowIndex){        this.content = inDatum;       this.inherited(arguments);
          if(dojo.isMoz){               // FIXME: seem to need to reopen the
editor and display the toolbar               var e = this.editor;
               e.open();                if(this.cell.editorToolbar){
                    dojo.place(e.toolbar.domNode, e.editingArea, "before");
               }         }    },   populateEditor: function(){
          this.editor.setValue(this.content);
          this.editor.placeCursorAtEnd();    }
});????????????????????????????????????????????????????????????????????????????compat/_data/editors.js?????????????????????????????????????????????????????????????????????????????0000644?0000765?0000765?00000015366?11226752541?015040?
0????????????????????????????????????????????????????????????????????????????????????????????????????ustar
?ntoone??????????????????????????ntoone?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????dojo.provide("dojox.grid.compat._data.editors");
dojo.provide("dojox.grid.compat.editors");

dojo.declare("dojox.grid.editors.Base", null, {   // summary:    //   base
grid editor class. Other grid editors should inherited from this class.
     constructor: function(inCell){          this.cell = inCell;      },
     //private      _valueProp: "value",     _formatPending: false,   format:
function(inDatum, inRowIndex){          // summary:         //   formats the
cell for editing         // inDatum: anything          //   cell data to edit
          // inRowIndex: int       //   grid row index           // returns:
string of html to place in grid cell    },   //protected    needFormatNode:
function(inDatum, inRowIndex){          this._formatPending = true;
          dojox.grid.whenIdle(this, "_formatNode", inDatum, inRowIndex);   },
     cancelFormatNode: function(){           this._formatPending = false;  },
     //private      _formatNode: function(inDatum, inRowIndex){
          if(this._formatPending){                this._formatPending = false;
               // make cell selectable
               dojo.setSelectable(this.cell.grid.domNode, true);
               this.formatNode(this.getNode(inRowIndex), inDatum, inRowIndex);
          }    },   //protected    getNode: function(inRowIndex){
          return (this.cell.getNode(inRowIndex) || 0).firstChild || 0;     },
     formatNode: function(inNode, inDatum, inRowIndex){          // summary:
          //   format the editing dom node. Use when editor is a widget.
          // inNode: dom node           // dom node for the editor         //
inDatum: anything        //   cell data to edit        // inRowIndex: int
          //   grid row index           if(dojo.isIE){                // IE
sux bad             dojox.grid.whenIdle(this, "focus", inRowIndex, inNode);
          }else{              this.focus(inRowIndex, inNode);         }    },
     dispatchEvent: function(m, e){          if(m in this){
               return this[m](e);       }    },   //public  getValue:
function(inRowIndex){         // summary:         //   returns value entered
into editor         // inRowIndex: int       // grid row index        //
returns:       //   value of editor          return
this.getNode(inRowIndex)[this._valueProp];   },   setValue:
function(inRowIndex, inValue){          // summary:         //   set the value
of the grid editor       // inRowIndex: int       // grid row index        //
inValue: anything        //   value of editor          var n =
this.getNode(inRowIndex);          if(n){              n[this._valueProp] =
inValue        };   },   focus: function(inRowIndex, inNode){         //
summary:       //   focus the grid editor         // inRowIndex: int       //
grid row index           // inNode: dom node           //   editor node
          dojox.grid.focusSelectNode(inNode || this.getNode(inRowIndex));  },
     save: function(inRowIndex){        // summary:         //   save editor
state          // inRowIndex: int       // grid row index        this.value =
this.value || this.getValue(inRowIndex);          //console.log("save",
this.value, inCell.index, inRowIndex);  },   restore: function(inRowIndex){
          // summary:         //   restore editor state          //
inRowIndex: int          // grid row index        this.setValue(inRowIndex,
this.value);        //console.log("restore", this.value, inCell.index,
inRowIndex);   },   //protected    _finish: function(inRowIndex){          //
summary:       //   called when editing is completed to clean up editor
          // inRowIndex: int       // grid row index
          dojo.setSelectable(this.cell.grid.domNode, false);
          this.cancelFormatNode(this.cell);  },   //public  apply:
function(inRowIndex){         // summary:         //   apply edit from cell
editor         // inRowIndex: int       // grid row index
          this.cell.applyEdit(this.getValue(inRowIndex), inRowIndex);
          this._finish(inRowIndex);     },   cancel: function(inRowIndex){
          // summary:         //   cancel cell edit         // inRowIndex: int
          // grid row index        this.cell.cancelEdit(inRowIndex);
          this._finish(inRowIndex);     } }); dojox.grid.editors.base =
dojox.grid.editors.Base; // back-compat

dojo.declare("dojox.grid.editors.Input", dojox.grid.editors.Base, {   //
summary   // grid cell editor that provides a standard text input box
     constructor: function(inCell){          this.keyFilter = this.keyFilter
|| this.cell.keyFilter;  },   // keyFilter: object     // optional regex for
disallowing keypresses   keyFilter: null,    format: function(inDatum,
inRowIndex){        this.needFormatNode(inDatum, inRowIndex);         return
'<input class="dojoxGrid-input" type="text" value="' + inDatum + '">';     },
     formatNode: function(inNode, inDatum, inRowIndex){
          this.inherited(arguments);         // FIXME: feels too specific for
this interface           this.cell.registerOnBlur(inNode, inRowIndex);     },
     doKey: function(e){           if(this.keyFilter){                var key
= String.fromCharCode(e.charCode);
               if(key.search(this.keyFilter) == -1){
                    dojo.stopEvent(e);            }         }    },   _finish:
function(inRowIndex){         this.inherited(arguments);         var n =
this.getNode(inRowIndex);          try{                dojox.grid.fire(n,
"blur");       }catch(e){}    } }); dojox.grid.editors.input =
dojox.grid.editors.Input; // back compat

dojo.declare("dojox.grid.editors.Select", dojox.grid.editors.Input, {      //
summary:  // grid cell editor that provides a standard select    // options:
text of each item   // values: value for each item     // returnIndex: editor
returns only the index of the selected option and not the value  constructor:
function(inCell){        this.options = this.options || this.cell.options;
          this.values = this.values || this.cell.values || this.options;   },
     format: function(inDatum, inRowIndex){       this.needFormatNode(inDatum,
inRowIndex);        var h = [ '<select class="dojoxGrid-select">' ];       for
(var i=0, o, v; ((o=this.options[i]) !== undefined)&&((v=this.values[i]) !==
undefined); i++){             h.push("<option", (inDatum==v ? ' selected' :
''), ' value="' + v + '"', ">", o, "</option>");       }
          h.push('</select>');          return h.join('');  },   getValue:
function(inRowIndex){         var n = this.getNode(inRowIndex);       if(n){
               var i = n.selectedIndex, o = n.options[i];             return
this.cell.returnIndex ? i : o.value || o.innerHTML;         }    } });
dojox.grid.editors.select = dojox.grid.editors.Select; // back compat

dojo.declare("dojox.grid.editors.AlwaysOn", dojox.grid.editors.Input, {    //
summary:  // grid cell editor that is always on, regardless of grid editing
state     // alwaysOn: boolean     // flag to use editor to format grid cell
regardless of editing state.       alwaysOn: true,     _formatNode:
function(inDatum, inRowIndex){
          this.formatNode(this.getNode(inRowIndex), inDatum, inRowIndex);  },
     applyStaticValue: function(inRowIndex){           var e =
this.cell.grid.edit;          e.applyCellEdit(this.getValue(inRowIndex),
this.cell, inRowIndex);       e.start(this.cell, inRowIndex, true);   } });
dojox.grid.editors.alwaysOn = dojox.grid.editors.AlwaysOn; // back-compat

dojo.declare("dojox.grid.editors.Bool", dojox.grid.editors.AlwaysOn, {     //
summary:  // grid cell editor that provides a standard checkbox that is always
on   _valueProp: "checked",   format: function(inDatum, inRowIndex){
          return '<input class="dojoxGrid-input" type="checkbox"' + (inDatum ?
' checked="checked"' : '') + ' style="width: auto" />';     },   doclick:
function(e){        if(e.target.tagName == 'INPUT'){
               this.applyStaticValue(e.rowIndex);           }    } });
dojox.grid.editors.bool = dojox.grid.editors.Bool; // back-compat

                                                                            ()
