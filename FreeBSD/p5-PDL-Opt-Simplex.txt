Simplex(3)            User Contributed Perl Documentation           Simplex(3)


NAME
       PDL::Opt::Simplex -- Simplex optimization routines

SYNOPSIS
         use PDL::Opt::Simplex;

         ($optimum,$ssize,$optval) = simplex($init,$initsize,$minsize,
                        $maxiter,
                        sub {evaluate_func_at($_[0])},
                        sub {display_simplex($_[0])}
                        );

         # more involved:
         use PDL;
         use PDL::Opt::Simplex;
         my $count = 0;
         # find value of $x that returns a minimum
         sub f {
           my ($vec) = @_;
           $count++;
           my $x = $vec->slice('(0)');
           # The parabola (x+3)^2 - 5 has a minimum at x=-3:
           return (($x+3)**2 - 5);
         }
         sub log {
           my ($vec, $vals, $ssize) = @_;
           # $vec is the array of values being optimized
           # $vals is f($vec)
           # $ssize is the simplex size, or roughly, how close to being converged.
           my $x = $vec->slice('(0)');
           # each vector element passed to log() has a min and max value.
           # ie: x=[6 0] -> vals=[76 4]
           # so, from above: f(6) == 76 and f(0) == 4
           print "$count [$ssize]: $x -> $vals\n";
         }
         my ($optimum, $ssize, $optval) = simplex(pdl(30), 3, 1e-6, 100, \&f, \&log);
         print "ssize=$ssize  opt=$optimum -> minimum=$optval\n";

DESCRIPTION
       This package implements the commonly used simplex optimization
       algorithm. The basic idea of the algorithm is to move a "simplex" of
       N+1 points in the N-dimensional search space according to certain
       rules. The main benefit of the algorithm is that you do not need to
       calculate the derivatives of your function.

       $init is a 1D vector holding the initial values of the N fitted
       parameters, $optimum is a vector holding the final values.  $optval is
       the evaluation of the final values.

       $initsize is the size of $init. It is only used if your supplied $init
       is a single point in your search space, to construct the simplex
       ("cloud") of N+1 points the algorithm uses, being the distance away
       from your single $init point along each dimension. This is done by the
       exportable function "make_simplex($init, $initsize)", e.g.:

         pdl> use PDL::Opt::Simplex
         pdl> p $t = make_simplex(pdl(0,0,0), pdl(0.12,0.12,0.12))
         [
          [    0 -0.06 -0.08]
          [ 0.12 -0.06 -0.08]
          [    0  0.06 -0.08]
          [    0     0  0.04]
         ]
         pdl> use PDL::Graphics::TriD
         pdl> spheres3d $t # spheres not points so can easily see

       $minsize is the convergence criterion, e.g. $minsize = 1e-6; the
       algorithm will terminate when all the values of $ssize are less than
       $minsize.

       The sub is assumed to understand more than 1 dimensions and
       broadcasting.  Its signature is "inp(nparams); [ret]out()". An example
       would be

               sub evaluate_func_at {
                       my($xv) = @_;
                       my ($x1, $x2) = $xv->using(0,1);
                       return $x1**4 + ($x2-5)**4 + $x1*$x2;
               }

       Here $xv is a vector holding the current values of the parameters being
       fitted which are then sliced out explicitly as $x1 and $x2.

       $ssize gives a very very approximate estimate of how close we might be
       - it might be miles wrong. It is the largest Euclidean distance between
       the first vertex and any other. If it is not very small, the algorithm
       has not converged.

FUNCTIONS
   simplex
       Simplex optimization routine

       Mutates its $init input if given as a full simplex (dims "n,n+1").

        ($optimum,$ssize,$optval) = simplex($init,$initsize,$minsize,
                        $maxiter,
                        sub {evaluate_func_at($_[0])},
                        sub {display_simplex($_[0])}
                        );

       See module "PDL::Opt::Simplex" for more information.

CAVEATS
       Do not use the simplex method if your function has local minima.  It
       will not work. Use genetic algorithms or simulated annealing or
       conjugate gradient or momentum gradient descent.

       They will not really work either but they are not guaranteed not to
       work ;) (if you have infinite time, simulated annealing is guaranteed
       to work but only after it has visited every point in your space).

SEE ALSO
       PDL::Opt::Simplex::Simple - Use names for Simplex-optimized values
       PDL::Opt::ParticleSwarm - A PDL implementation of Particle Swarm
       PDL::Opt::ParticleSwarm::Simple - Use names for Particle
       Swarm-optimized values
       <https://web.archive.org/web/19981206200518/http://chem1.nrl.navy.mil/~shaffer/chemoweb.html>
       - Ron Shaffer's chemometrics web page and references therein (archive
       from 1998)

       The demonstration (Examples/Simplex/tsimp.pl and tsimp2.pl).

AUTHOR
       Copyright(C) 1997 Tuomas J. Lukka.  All rights reserved. There is no
       warranty. You are allowed to redistribute this software / documentation
       under certain conditions. For details, see the file COPYING in the PDL
       distribution. If this file is separated from the PDL distribution, the
       copyright notice should be included in the file.

perl v5.40.2                      2025-01-06                        Simplex(3)
