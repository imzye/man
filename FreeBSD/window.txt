WINDOW(1)               FreeBSD General Commands Manual              WINDOW(1)

NAME
     window – window environment

SYNOPSIS
     window [-t] [-f] [-d] [-e escape-char] [-c command]

DESCRIPTION
     The window utility implements a window environment on ASCII terminals.

     A window is a rectangular portion of the physical terminal screen
     associated with a set of processes.  Its size and position can be changed
     by the user at any time.  Processes communicate with their window in the
     same way they normally interact with a terminal-through their standard
     input, output, and diagnostic file descriptors.  The window program
     handles the details of redirecting input and output to and from the
     windows.  At any one time, only one window can receive input from the
     keyboard, but all windows can simultaneously send output to the display.

     When window starts up, the commands (see long commands below) contained
     in the file .windowrc in the user's home directory are executed.  If it
     does not exist, two equal sized windows spanning the terminal screen are
     created by default.

     The command line options are

     -t          Turn on terse mode (see terse command below).

     -f          Fast.  Do not perform any startup action.

     -d          Ignore .windowrc and create the two default windows instead.

     -e escape-char
                 Set the escape character to escape-char.  Escape-char can be
                 a single character, or in the form ^X where X is any
                 character, meaning control-X.

     -c command  Execute the string command as a long command (see below)
                 before doing anything else.

     Windows can overlap and are framed as necessary.  Each window is named by
     one of the digits ``1'' to ``9''.  This one-character identifier, as well
     as a user definable label string, are displayed with the window on the
     top edge of its frame.  A window can be designated to be in the
     foreground, in which case it will always be on top of all normal, non-
     foreground windows, and can be covered only by other foreground windows.
     A window need not be completely within the edges of the terminal screen.
     Thus a large window (possibly larger than the screen) may be positioned
     to show only a portion of its full size.

     Each window has a cursor and a set of control functions.  Most
     intelligent terminal operations such as line and character deletion and
     insertion are supported.  Display modes such as underlining and reverse
     video are available if they are supported by the terminal.  In addition,
     similar to terminals with multiple pages of memory, each window has a
     text buffer which can have more lines than the window itself.

   Process Environment
     With each newly created window, a shell program is spawned with its
     process environment tailored to that window.  Its standard input, output,
     and diagnostic file descriptors are bound to one end of either a pseudo-
     terminal (see pty(4)) or a UNIX domain socket (see socketpair(2)).  If a
     pseudo-terminal is used, then its special characters and modes (see
     stty(1)) are copied from the physical terminal.  A termcap(5) entry
     tailored to this window is created and passed as environment (see
     environ(7)) variable TERMCAP.  The termcap entry contains the window's
     size and characteristics as well as information from the physical
     terminal, such as the existence of underline, reverse video, and other
     display modes, and the codes produced by the terminal's function keys, if
     any.  In addition, the window size attributes of the pseudo-terminal are
     set to reflect the size of this window, and updated whenever it is
     changed by the user.  In particular, the editor vi(1) uses this
     information to redraw its display.

   Operation
     During normal execution, window can be in one of two states: conversation
     mode and command mode.  In conversation mode, the terminal's real cursor
     is placed at the cursor position of a particular window--called the
     current window--and input from the keyboard is sent to the process in
     that window.  The current window is always on top of all other windows,
     except those in foreground.  In addition, it is set apart by highlighting
     its identifier and label in reverse video.

     Typing window's escape character (normally ^P) in conversation mode
     switches it into command mode.  In command mode, the top line of the
     terminal screen becomes the command prompt window, and window interprets
     input from the keyboard as commands to manipulate windows.

     There are two types of commands: short commands are usually one or two
     key strokes; long commands are strings either typed by the user in the
     command window (see the “:” command below), or read from a file (see
     source below).

   Short Commands
     Below, # represents one of the digits ``1'' to ``9'' corresponding to the
     windows 1 to 9.  ^X means control-X, where X is any character.  In
     particular, ^^ is control-^.  Escape is the escape key, or ^[.

     #       Select window # as the current window and return to conversation
             mode.

     %#      Select window # but stay in command mode.

     ^^      Select the previous window and return to conversation mode.  This
             is useful for toggling between two windows.

     escape  Return to conversation mode.

     ^P      Return to conversation mode and write ^P to the current window.
             Thus, typing two ^P's in conversation mode sends one to the
             current window.  If the window escape is changed to some other
             character, that character takes the place of ^P here.

     ?       List a short summary of commands.

     ^L      Refresh the screen.

     q       Exit window.  Confirmation is requested.

     ^Z      Suspend window.

     w       Create a new window.  The user is prompted for the positions of
             the upper left and lower right corners of the window.  The cursor
             is placed on the screen and the keys ``h'', ``j'', ``k'', and
             ``l'' move the cursor left, down, up, and right, respectively.
             The keys ``H'', ``J'', ``K'', and ``L'' move the cursor to the
             respective limits of the screen.  Typing a number before the
             movement keys repeats the movement that number of times.  Return
             enters the cursor position as the upper left corner of the
             window.  The lower right corner is entered in the same manner.
             During this process, the placement of the new window is indicated
             by a rectangular box drawn on the screen, corresponding to where
             the new window will be framed.  Typing escape at any point
             cancels this command.

             This window becomes the current window, and is given the first
             available ID.  The default buffer size is used (see default_nline
             command below).

             Only fully visible windows can be created this way.

     c#      Close window #.  The process in the window is sent the hangup
             signal (see kill(1)).  The csh(1) utility should handle this
             signal correctly and cause no problems.

     m#      Move window # to another location.  A box in the shape of the
             window is drawn on the screen to indicate the new position of the
             window, and the same keys as those for the w command are used to
             position the box.  The window can be moved partially off-screen.

     M#      Move window # to its previous position.

     s#      Change the size of window #.  The user is prompted to enter the
             new lower right corner of the window.  A box is drawn to indicate
             the new window size.  The same keys used in w and m are used to
             enter the position.

     S#      Change window # to its previous size.

     ^Y      Scroll the current window up by one line.

     ^E      Scroll the current window down by one line.

     ^U      Scroll the current window up by half the window size.

     ^D      Scroll the current window down by half the window size.

     ^B      Scroll the current window up by the full window size.

     ^F      Scroll the current window down by the full window size.

     h       Move the cursor of the current window left by one column.

     j       Move the cursor of the current window down by one line.

     k       Move the cursor of the current window up by one line.

     l       Move the cursor of the current window right by one column.

     y       Yank.  The user is prompted to enter two points within the
             current window.  Then the content of the current window between
             those two points is saved in the yank buffer.

     p       Put.  The content of the yank buffer is written to the current
             window as input.

     ^S      Stop output in the current window.

     ^Q      Start output in the current window.

     :       Enter a line to be executed as long commands.  Normal line
             editing characters (erase character, erase word, erase line) are
             supported.

   Long Commands
     Long commands are a sequence of statements parsed much like a programming
     language, with a syntax similar to that of C.  Numeric and string
     expressions and variables are supported, as well as conditional
     statements.

     There are two data types: string and number.  A string is a sequence of
     letters or digits beginning with a letter.  ``_'' and ``.'' are
     considered letters.  Alternately, non-alphanumeric characters can be
     included in strings by quoting them in ``"'' or escaping them with ``\''.
     In addition, the ``\'' sequences of C are supported, both inside and
     outside quotes (e.g., ``\n'' is a new line, ``\r'' a carriage return).
     For example, these are legal strings: abcde01234, "&#$^*&#", ab"$#"cd,
     ab\$\#cd, "/usr/ucb/window".

     A number is an integer value in one of three forms: a decimal number, an
     octal number preceded by ``0'', or a hexadecimal number preceded by
     ``0x'' or ``0X''.  The natural machine integer size is used (i.e., the
     signed integer type of the C compiler).  As in C, a non-zero number
     represents a boolean true.

     The character ``#'' begins a comment which terminates at the end of the
     line.

     A statement is either a conditional or an expression.  Expression
     statements are terminated with a new line or ``;''.  To continue an
     expression on the next line, terminate the first line with ``\''.

   Conditional Statement
     The window utility has a single control structure: the fully bracketed if
     statement in the form

           if <expr> then
           <statement>
           ...
           elsif <expr> then
           <statement>
           ...
           else
           <statement>
           ...
           endif

     The else and elsif parts are optional, and the latter can be repeated any
     number of times.  <Expr> must be numeric.

   Expressions
     Expressions in window are similar to those in the C language, with most C
     operators supported on numeric operands.  In addition, some are
     overloaded to operate on strings.

     When an expression is used as a statement, its value is discarded after
     evaluation.  Therefore, only expressions with side effects (assignments
     and function calls) are useful as statements.

     Single valued (no arrays) variables are supported, of both numeric and
     string values.  Some variables are predefined.  They are listed below.

     The operators in order of increasing precedence:

     ⟨expr1⟩ = ⟨expr2⟩
                 Assignment.  The variable of name ⟨expr1⟩, which must be
                 string valued, is assigned the result of ⟨expr2⟩.  Returns
                 the value of ⟨expr2⟩.

     ⟨expr1⟩ ? ⟨expr2⟩ : ⟨expr3⟩
                 Returns the value of ⟨expr2⟩ if ⟨expr1⟩ evaluates true (non-
                 zero numeric value); returns the value of ⟨expr3⟩ otherwise.
                 Only one of ⟨expr2⟩ and ⟨expr3⟩ is evaluated.  ⟨Expr1⟩ must
                 be numeric.

     ⟨expr1⟩ || ⟨expr2⟩
                 Logical or.  Numeric values only.  Short circuit evaluation
                 is supported (i.e., if ⟨expr1⟩ evaluates true, then ⟨expr2⟩
                 is not evaluated).

     ⟨expr1⟩ && ⟨expr2⟩
                 Logical and with short circuit evaluation.  Numeric values
                 only.

     ⟨expr1⟩ | ⟨expr2⟩
                 Bitwise or.  Numeric values only.

     ⟨expr1⟩ ^ ⟨expr2⟩
                 Bitwise exclusive or.  Numeric values only.

     ⟨expr1⟩ & ⟨expr2⟩
                 Bitwise and.  Numeric values only.

     ⟨expr1⟩ == ⟨expr2⟩, ⟨expr1⟩ != ⟨expr2⟩
                 Comparison (equal and not equal, respectively).  The boolean
                 result (either 1 or 0) of the comparison is returned.  The
                 operands can be numeric or string valued.  One string operand
                 forces the other to be converted to a string in necessary.

     ⟨expr1⟩ < ⟨expr2⟩, ⟨expr1⟩ > ⟨expr2⟩, ⟨expr1⟩ <= ⟨expr2⟩,
                 Less than, greater than, less than or equal to, greater than
                 or equal to.  Both numeric and string values, with automatic
                 conversion as above.

     ⟨expr1⟩ << ⟨expr2⟩, ⟨expr1⟩ >> ⟨expr2⟩
                 If both operands are numbers, ⟨expr1⟩ is bit shifted left (or
                 right) by ⟨expr2⟩ bits.  If ⟨expr1⟩ is a string, then its
                 first (or last) ⟨expr2⟩ characters are returns (if ⟨expr2⟩ is
                 also a string, then its length is used in place of its
                 value).

     ⟨expr1⟩ + ⟨expr2⟩, ⟨expr1⟩ - ⟨expr2⟩
                 Addition and subtraction on numbers.  For ``+'', if one
                 argument is a string, then the other is converted to a
                 string, and the result is the concatenation of the two
                 strings.

     ⟨expr1⟩ * ⟨expr2⟩, ⟨expr1⟩ / ⟨expr2⟩, ⟨expr1⟩ % ⟨expr2⟩
                 Multiplication, division, modulo.  Numbers only.

     -⟨expr⟩, ~⟨expr⟩, !⟨expr⟩, $⟨expr⟩, $?⟨expr⟩
                 The first three are unary minus, bitwise complement and
                 logical complement on numbers only.  The operator, ``$'',
                 takes ⟨expr⟩ and returns the value of the variable of that
                 name.  If ⟨expr⟩ is numeric with value n and it appears
                 within an alias macro (see below), then it refers to the nth
                 argument of the alias invocation.  ``$?'' tests for the
                 existence of the variable ⟨expr⟩, and returns 1 if it exists
                 or 0 otherwise.

     ⟨expr⟩(⟨arglist⟩)
                 Function call.  ⟨Expr⟩ must be a string that is the unique
                 prefix of the name of a builtin window function or the full
                 name of a user defined alias macro.  In the case of a builtin
                 function, ⟨arglist⟩ can be in one of two forms:

                       <expr1>, <expr2>, ...
                       argname1 = <expr1>, argname2 = <expr2>, ...

                 The two forms can in fact be intermixed, but the result is
                 unpredictable.  Most arguments can be omitted; default values
                 will be supplied for them.  The argnames can be unique
                 prefixes of the argument names.  The commas separating
                 arguments are used only to disambiguate, and can usually be
                 omitted.

                 Only the first argument form is valid for user defined
                 aliases.  Aliases are defined using the alias builtin
                 function (see below).  Arguments are accessed via a variant
                 of the variable mechanism (see ``$'' operator above).

                 Most functions return value, but some are used for side
                 effect only and so must be used as statements.  When a
                 function or an alias is used as a statement, the parentheses
                 surrounding the argument list may be omitted.  Aliases return
                 no value.

   Builtin Functions
     The arguments are listed by name in their natural order.  Optional
     arguments are in square brackets ‘[]’.  Arguments that have no names are
     in angle brackets ‘<>’.  An argument meant to be a boolean flag (often
     named flag) can be one of on, off, yes, no, true, or false, with obvious
     meanings, or it can be a numeric expression, in which case a non-zero
     value is true.

     alias([⟨string⟩], [⟨string-list⟩])
                 If no argument is given, all currently defined alias macros
                 are listed.  Otherwise, ⟨string⟩ is defined as an alias, with
                 expansion ⟨string-list >⟩.  The previous definition of
                 ⟨string⟩, if any, is returned.  Default for ⟨string-list⟩ is
                 no change.

     close(⟨window-list⟩)
                 Close the windows specified in ⟨window-list⟩.  If
                 ⟨window-list⟩ is the word all, than all windows are closed.
                 No value is returned.

     cursormodes([modes])
                 Set the window cursor to modes.  Modes is the bitwise or of
                 the mode bits defined as the variables m_ul (underline),
                 m_rev (reverse video), m_blk (blinking), and m_grp (graphics,
                 terminal dependent).  Return value is the previous modes.
                 Default is no change.  For example, cursor($m_rev$m_blk) sets
                 the window cursors to blinking reverse video.

     default_nline([nline])
                 Set the default buffer size to nline.  Initially, it is 48
                 lines.  Returns the old default buffer size.  Default is no
                 change.  Using a very large buffer can slow the program down
                 considerably.

     default_shell([⟨string-list⟩])
                 Set the default window shell program to ⟨string-list⟩.
                 Returns the first string in the old shell setting.  Default
                 is no change.  Initially, the default shell is taken from the
                 environment variable SHELL.

     default_smooth([flag])
                 Set the default value of the smooth argument to the command
                 window (see below).  The argument is a boolean flag (one of
                 on, off, yes, no, true, false, or a number, as described
                 above).  Default is no change.  The old value (as a number)
                 is returned.  The initial value is 1 (true).

     echo([window], [⟨string-list⟩])
                 Write the list of strings, ⟨string-list⟩, to window,
                 separated by spaces and terminated with a new line.  The
                 strings are only displayed in the window, the processes in
                 the window are not involved (see write below).  No value is
                 returned.  Default is the current window.

     escape([escapec])
                 Set the escape character to escape-char.  Returns the old
                 escape character as a one-character string.  Default is no
                 change.  Escapec can be a string of a single character, or in
                 the form -^X, meaning control-X.

     foreground([window], [flag])
                 Move window in or out of foreground.  Flag is a boolean
                 value.  The old foreground flag is returned.  Default for
                 window is the current window, default for flag is no change.

     label([window], [label])
                 Set the label of window to label.  Returns the old label as a
                 string.  Default for window is the current window, default
                 for label is no change.  To turn off a label, set it to an
                 empty string ("").

     list()      No arguments.  List the identifiers and labels of all
                 windows.  No value is returned.

     select([window])
                 Make window the current window.  The previous current window
                 is returned.  Default is no change.

     source(filename)
                 Read and execute the long commands in filename.  Returns -1
                 if the file cannot be read, 0 otherwise.

     terse([flag])
                 Set terse mode to flag.  In terse mode, the command window
                 stays hidden even in command mode, and errors are reported by
                 sounding the terminal's bell.  Flag can take on the same
                 values as in foreground above.  Returns the old terse flag.
                 Default is no change.

     unalias(alias)
                 Undefine alias.  Returns -1 if alias does not exist, 0
                 otherwise.

     unset(variable)
                 Undefine variable.  Returns -1 if variable does not exist, 0
                 otherwise.

     variables()
                 No arguments.  List all variables.  No value is returned.

     window([row], [column], [nrow], [ncol], [nline], [label], [pty], [frame],
                 [mapnl], [keepopen], [smooth], [shell]).
                 Open a window with upper left corner at row, column and size
                 nrow, ncol.  If nline is specified, then that many lines are
                 allocated for the text buffer.  Otherwise, the default buffer
                 size is used.  Default values for row, column, nrow, and ncol
                 are, respectively, the upper, left-most, lower, or right-most
                 extremes of the screen.  Label is the label string.  Frame,
                 pty, and mapnl are flag values interpreted in the same way as
                 the argument to foreground (see above); they mean,
                 respectively, put a frame around this window (default true),
                 allocate pseudo-terminal for this window rather than
                 socketpair (default true), and map new line characters in
                 this window to carriage return and line feed (default true if
                 socketpair is used, false otherwise).  Normally, a window is
                 automatically closed when its process exits.  Setting
                 keepopen to true (default false) prevents this action.  When
                 smooth is true, the screen is updated more frequently (for
                 this window) to produce a more terminal-like behavior.  The
                 default value of smooth is set by the default_smooth command
                 (see above).  Shell is a list of strings that will be used as
                 the shell program to place in the window (default is the
                 program specified by default_shell, see above).  The created
                 window's identifier is returned as a number.

     write([window], [⟨string-list⟩])
                 Send the list of strings, ⟨string-list⟩, to window, separated
                 by spaces but not terminated with a new line.  The strings
                 are actually given to the window as input.  No value is
                 returned.  Default is the current window.

   Predefined Variables
     These variables are for information only.  Redefining them does not
     affect the internal operation of window.

     baud   The baud rate as a number between 50 and 38400.

     modes  The display modes (reverse video, underline, blinking, graphics)
            supported by the physical terminal.  The value of modes is the
            bitwise or of some of the one bit values, m_blk, m_grp, m_rev, and
            m_ul (see below).  These values are useful in setting the window
            cursors' modes (see cursormodes above).

     m_blk  The blinking mode bit.

     m_grp  The graphics mode bit (not very useful).

     m_rev  The reverse video mode bit.

     m_ul   The underline mode bit.

     ncol   The number of columns on the physical screen.

     nrow   The number of rows on the physical screen.

     term   The terminal type.  The standard name, found in the second name
            field of the terminal's TERMCAP entry, is used.

ENVIRONMENT
     The window utility utilizes these environment variables: HOME, SHELL,
     TERM, TERMCAP, WINDOW_ID.

FILES
     ~/.windowrc       startup command file.
     /dev/[pt]ty[pq]?  pseudo-terminal devices.

DIAGNOSTICS
     Should be self explanatory.

HISTORY
     The window command appeared in 4.3BSD.

FreeBSD 14.1-RELEASE           December 30, 1993          FreeBSD 14.1-RELEASE
