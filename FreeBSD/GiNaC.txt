ginsh(1)                        The GiNaC Group                       ginsh(1)

NAME
       ginsh - GiNaC Interactive Shell

SYNPOSIS
       ginsh [file...]

DESCRIPTION
       ginsh is an interactive frontend for the GiNaC symbolic computation
       framework.  It is intended as a tool for testing and experimenting with
       GiNaC's features, not as a replacement for traditional interactive
       computer algebra systems. Although it can do many things these
       traditional systems can do, ginsh provides no programming constructs
       like loops or conditional expressions. If you need this functionality
       you are advised to write your program in C++, using the "native" GiNaC
       class framework.

USAGE
   INPUT FORMAT
       After startup, ginsh displays a prompt ("> ") signifying that it is
       ready to accept your input. Acceptable input are numeric or symbolic
       expressions consisting of numbers (e.g.  42, 2/3 or 0.17), symbols
       (e.g.  x or result), mathematical operators like + and  *, and
       functions (e.g.  sin or normal).  Every input expression must be
       terminated with either a semicolon (;) or a colon (:).  If terminated
       with a semicolon, ginsh will evaluate the expression and print the
       result to stdout. If terminated with a colon, ginsh will only evaluate
       the expression but not print the result. It is possible to enter
       multiple expressions on one line. Whitespace (spaces, tabs, newlines)
       can be applied freely between tokens. To quit ginsh, enter quit or
       exit, or type an EOF (Ctrl-D) at the prompt.

   COMMENTS
       Anything following a double slash (//) up to the end of the line, and
       all lines starting with a hash mark (#) are treated as a comment and
       ignored.

   NUMBERS
       ginsh accepts numbers in the usual decimal notations. This includes
       arbitrary precision integers and rationals as well as floating point
       numbers in standard or scientific notation (e.g.  1.2E6).  The general
       rule is that if a number contains a decimal point (.), it is an
       (inexact) floating point number; otherwise it is an (exact) integer or
       rational.  Integers can be specified in binary, octal, hexadecimal or
       arbitrary (2-36) base by prefixing them with #b, #o, #x, or  #nR ,
       respectively.

   SYMBOLS
       Symbols are made up of a string of alphanumeric characters and the
       underscore (_), with the first character being non-numeric. E.g.  a and
       mu_1 are acceptable symbol names, while 2pi is not. It is possible to
       use symbols with the same names as functions (e.g.  sin); ginsh is able
       to distinguish between the two.

       Symbols can be assigned values by entering
              symbol = expression;

       To unassign the value of an assigned symbol, type
              unassign('symbol');

       Assigned symbols are automatically evaluated (= replaced by their
       assigned value) when they are used. To refer to the unevaluated symbol,
       put single quotes (') around the name, as demonstrated for the
       "unassign" command above.

       Symbols are considered to be in the complex domain by default, i.e.
       they are treated as if they stand in for complex numbers. This behavior
       can be changed by using the keywords real_symbols and complex_symbols
       and affects all newly created symbols.

       The following symbols are pre-defined constants that cannot be assigned
       a value by the user:

              Pi      Archimedes' Constant

              Catalan Catalan's Constant

              Euler   Euler-Mascheroni Constant

              I       sqrt(-1)

              FAIL    an object of the GiNaC "fail" class

       There is also the special
              Digits
       symbol that controls the numeric precision of calculations with inexact
       numbers.  Assigning an integer value to digits will change the
       precision to the given number of decimal places.

   WILDCARDS
       The has(), find(), match() and subs() functions accept wildcards as
       placeholders for expressions. These have the syntax
              $number
       for example $0, $1 etc.

   LAST PRINTED EXPRESSIONS
       ginsh provides the three special symbols
              %, %% and %%%
       that refer to the last, second last, and third last printed expression,
       respectively.  These are handy if you want to use the results of
       previous computations in a new expression.

   OPERATORS
       ginsh provides the following operators, listed in falling order of
       precedence:

              !       postfix factorial

              ^       powering

              +       unary plus

              -       unary minus

              *       multiplication

              /       division

              +       addition

              -       subtraction

              <       less than

              >       greater than

              <=      less or equal

              >=      greater or equal

              ==      equal

              !=      not equal

              =       symbol assignment


       All binary operators are left-associative, with the exception of ^ and
       = which are right-associative. The result of the assignment operator
       (=) is its right-hand side, so it's possible to assign multiple symbols
       in one expression (e.g.  a = b = c = 2;).

   LISTS
       Lists are used by the subs and lsolve functions. A list consists of an
       opening curly brace ({), a (possibly empty) comma-separated sequence of
       expressions, and a closing curly brace (}).

   MATRICES
       A matrix consists of an opening square bracket ([), a non-empty comma-
       separated sequence of matrix rows, and a closing square bracket (]).
       Each matrix row consists of an opening square bracket ([), a non-empty
       comma-separated sequence of expressions, and a closing square bracket
       (]).  If the rows of a matrix are not of the same length, the width of
       the matrix becomes that of the longest row and shorter rows are filled
       up at the end with elements of value zero.

   FUNCTIONS
       A function call in ginsh has the form
              name(arguments)
       where arguments is a comma-separated sequence of expressions. ginsh
       provides a couple of built-in functions and also "imports" all symbolic
       functions defined by GiNaC and additional libraries. There is no way to
       define your own functions other than linking ginsh against a library
       that defines symbolic GiNaC functions.

       ginsh provides Tab-completion on function names: if you type the first
       part of a function name, hitting Tab will complete the name if
       possible. If the part you typed is not unique, hitting Tab again will
       display a list of matching functions.  Hitting Tab twice at the prompt
       will display the list of all available functions.

       A list of the built-in functions follows. They nearly all work as the
       respective GiNaC methods of the same name, so I will not describe them
       in detail here. Please refer to the GiNaC documentation.


              charpoly(matrix, symbol) - characteristic polynomial of a matrix
              coeff(expression, object, number) - extracts coefficient of
              object^number from a polynomial
              collect(expression, object-or-list) - collects coefficients of
              like powers (result in recursive form)
              collect_distributed(expression, list) - collects coefficients of
              like powers (result in distributed form)
              collect_common_factors(expression) - collects common factors
              from the terms of sums
              conjugate(expression) - complex conjugation
              content(expression, symbol) - content part of a polynomial
              decomp_rational(expression, symbol) - decompose rational
              function into polynomial and proper rational function
              degree(expression, object) - degree of a polynomial
              denom(expression) - denominator of a rational function
              determinant(matrix) - determinant of a matrix
              diag(expression...) - constructs diagonal matrix
              diff(expression, symbol [, number]) - partial differentiation
              divide(expression, expression) - exact polynomial division
              evalf(expression) - evaluates an expression to a floating point
              number
              evalm(expression) - evaluates sums, products and integer powers
              of matrices
              expand(expression) - expands an expression
              factor(expression) - factorizes an expression (univariate)
              find(expression, pattern) - returns a list of all occurrences of
              a pattern in an expression
              fsolve(expression, symbol, number, number) - numerically find
              root of a real-valued function within an interval
              gcd(expression, expression) - greatest common divisor
              has(expression, pattern) - returns "1" if the first expression
              contains the pattern as a subexpression, "0" otherwise
              integer_content(expression) - integer content of a polynomial
              inverse(matrix) - inverse of a matrix
              is(relation) - returns "1" if the relation is true, "0"
              otherwise (false or undecided)
              lcm(expression, expression) - least common multiple
              lcoeff(expression, object) - leading coefficient of a polynomial
              ldegree(expression, object) - low degree of a polynomial
              lsolve(equation-list, symbol-list) - solve system of linear
              equations
              map(expression, pattern) - apply function to each operand; the
              function to be applied is specified as a pattern with the "$0"
              wildcard standing for the operands
              match(expression, pattern) - check whether expression matches a
              pattern; returns a list of wildcard substitutions or "FAIL" if
              there is no match
              nops(expression) - number of operands in expression
              normal(expression) - rational function normalization
              numer(expression) - numerator of a rational function
              numer_denom(expression) - numerator and denumerator of a
              rational function as a list
              op(expression, number) - extract operand from expression
              power(expr1, expr2) - exponentiation (equivalent to writing
              expr1^expr2)
              prem(expression, expression, symbol) - pseudo-remainder of
              polynomials
              primpart(expression, symbol) - primitive part of a polynomial
              quo(expression, expression, symbol) - quotient of polynomials
              rank(matrix) - rank of a matrix
              rem(expression, expression, symbol) - remainder of polynomials
              resultant(expression, expression, symbol) - resultant of two
              polynomials with respect to symbol s
              series(expression, relation-or-symbol, order) - series expansion
              series_to_poly(series) - convert a series into a polynomial by
              dropping the Order() term
              sprem(expression, expression, symbol) - sparse pseudo-remainder
              of polynomials
              sqrfree(expression [, symbol-list]) - square-free factorization
              of a polynomial
              sqrfree_parfrac(expression, symbol) - square-free partial
              fraction decomposition of rational function
              sqrt(expression) - square root
              subs(expression, relation-or-list)
              subs(expression, look-for-list, replace-by-list) - substitute
              subexpressions (you may use wildcards)
              tcoeff(expression, object) - trailing coefficient of a
              polynomial
              time(expression) - returns the time in seconds needed to
              evaluate the given expression
              trace(matrix) - trace of a matrix
              transpose(matrix) - transpose of a matrix
              unassign('symbol') - unassign an assigned symbol (mind the
              quotes, please!)
              unit(expression, symbol) - unit part of a polynomial


   SPECIAL COMMANDS
       To exit ginsh, enter
              quit
       or
              exit

       ginsh can display a (short) help for a given topic (mostly about
       functions and operators) by entering
              ?topic
       Typing
              ??
       will display a list of available help topics.

       The command
              print(expression);
       will print a dump of GiNaC's internal representation for the given
       expression.  This is useful for debugging and for learning about GiNaC
       internals.

       The command
              print_latex(expression);
       prints a LaTeX representation of the given expression.

       The command
              print_csrc(expression);
       prints the given expression in a way that can be used in a C or C++
       program.

       The command
              iprint(expression);
       prints the given expression (which must evaluate to an integer) in
       decimal, octal, and hexadecimal representations.

       Finally, the shell escape
              !  [command  [arguments]]
       passes the given command and optionally arguments to the shell for
       execution. With this method, you can execute shell commands from within
       ginsh without having to quit.

EXAMPLES
       > a = x^2-x-2;
       -2-x+x^2
       > b = (x+1)^2;
       (x+1)^2
       > s = a/b;
       (x+1)^(-2)*(-2-x+x^2)
       > diff(s, x);
       (2*x-1)*(x+1)^(-2)-2*(x+1)^(-3)*(-x+x^2-2)
       > normal(s);
       (x-2)*(x+1)^(-1)
       > x = 3^50;
       717897987691852588770249
       > s;
       717897987691852588770247/717897987691852588770250
       > Digits = 40;
       40
       > evalf(s);
       0.999999999999999999999995821133292704384960990679
       > unassign('x');
       x
       > s;
       (x+1)^(-2)*(-x+x^2-2)
       > series(sin(x),x==0,6);
       1*x+(-1/6)*x^3+1/120*x^5+Order(x^6)
       > lsolve({3*x+5*y == 7}, {x, y});
       {x==-5/3*y+7/3,y==y}
       > lsolve({3*x+5*y == 7, -2*x+10*y == -5}, {x, y});
       {x==19/8,y==-1/40}
       > M = [ [a, b], [c, d] ];
       [[-x+x^2-2,(x+1)^2],[c,d]]
       > determinant(M);
       -2*d-2*x*c-x^2*c-x*d+x^2*d-c
       > collect(%, x);
       (-d-2*c)*x+(d-c)*x^2-2*d-c
       > solve quantum field theory;
       parse error at quantum
       > quit

DIAGNOSTICS
       parse error at foo
              You entered something which ginsh was unable to parse. Please
              check the syntax of your input and try again.

       argument num to function must be a type
              The argument number num to the given function must be of a
              certain type (e.g. a symbol, or a list). The first argument has
              number 0, the second argument number 1, etc.

AUTHOR
       The GiNaC maintainers <https://www.ginac.de/>.

SEE ALSO
       GiNaC Tutorial - An open framework for symbolic computation within the
       C++ programming language

       CLN - A Class Library for Numbers, Bruno Haible

COPYRIGHT
       Copyright © 1999-2025 Johannes Gutenberg Universität Mainz, Germany

       This program is free software; you can redistribute it and/or modify it
       under the terms of the GNU General Public License as published by the
       Free Software Foundation; either version 2 of the License, or (at your
       option) any later version.

       This program is distributed in the hope that it will be useful, but
       WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
       General Public License for more details.

       You should have received a copy of the GNU General Public License along
       with this program; if not, write to the Free Software Foundation, 51
       Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

GiNaC 1.8.9                      January, 2000                        ginsh(1)
