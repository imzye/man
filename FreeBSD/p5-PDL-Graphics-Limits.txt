Limits(3)             User Contributed Perl Documentation            Limits(3)


NAME
       PDL::Graphics::Limits - derive limits for display purposes

DESCRIPTION
       Functions to derive limits for data for display purposes

SYNOPSIS
         use PDL::Graphics::Limits;

FUNCTIONS
   limits
       limits derives global limits for one or more multi-dimensional sets of
       data for display purposes.  It obtains minimum and maximum limits for
       each dimension based upon one of several algorithms.

         @limits = limits( @datasets );
         @limits = limits( @datasets, \%attr );
         $limits = limits( @datasets );
         $limits = limits( @datasets, \%attr );

       Data Sets

       A data set is represented as a set of one dimensional vectors, one per
       dimension. All data sets must have the same dimensions.  Multi-
       dimensional data sets are packaged as arrays or hashs; one dimensional
       data sets need not be.  The different representations may be mixed, as
       long as the dimensions are presented in the same order.  Vectors may be
       either scalars or ndarrays.

       One dimensional data sets
               One dimensional data sets may be passed directly, with no
               additional packaging:

                 limits( $scalar, $ndarray );

       Data sets as arrays
               If the data sets are represented by arrays, each vectors in
               each array must have the same order:

                 @ds1 = ( $x1_pdl, $y1_pdl );
                 @ds2 = ( $x2_pdl, $y2_pdl );

               They are passed by reference:

                 limits( \@ds1, \@ds2 );

       Data sets as hashes
               Hashes are passed by reference as well, but must be further
               embedded in arrays (also passed by reference), in order that
               the last one is not confused with the optional trailing
               attribute hash.  For example:

                 limits( [ \%ds4, \%ds5 ], \%attr );

               If each hash uses the same keys to identify the data, the keys
               should be passed as an ordered array via the "VecKeys"
               attribute:

                 limits( [ \%h1, \%h2 ], { VecKeys => [ 'x', 'y' ] } );

               If the hashes use different keys, each hash must be accompanied
               by an ordered listing of the keys, embedded in their own
               anonymous array:

                 [ \%h1 => ( 'x', 'y' ) ], [ \%h2 => ( 'u', 'v' ) ]

               Keys which are not explicitly identified are ignored.

       Errors

       Error bars must be taken into account when determining limits; care is
       especially needed if the data are to be transformed before plotting
       (for logarithmic plots, for example).  Errors may be symmetric (a
       single value indicates the negative and positive going errors for a
       data point) or asymmetric (two values are required to specify the
       errors).

       If the data set is specified as an array of vectors, vectors with
       errors should be embedded in an array. For symmetric errors, the error
       is given as a single vector (ndarray or scalar); for asymmetric errors,
       there should be two values (one of which may be "undef" to indicate a
       one-sided error bar):

         @ds1 = ( $x,                  # no errors
                  [ $y, $yerr ],       # symmetric errors
                  [ $z, $zn, $zp ],    # asymmetric errors
                  [ $u, undef, $up ],  # one-sided error bar
                  [ $v, $vn, undef ],  # one-sided error bar
                );

       If the data set is specified as a hash of vectors, the names of the
       error bar keys are appended to the names of the data keys in the
       "VecKeys" designations.  The error bar key names are always prefixed
       with a character indicating what kind of error they represent:

               < negative going errors
               > positive going errors
               = symmetric errors

       (Column names may be separated by commas or white space.)

       For example,

         %ds1 = ( x => $x, xerr => $xerr, y => $y, yerr => $yerr );
         limits( [ \%ds1 ], { VecKeys => [ 'x =xerr', 'y =yerr' ] } );

       To specify asymmetric errors, specify both the negative and positive
       going errors:

         %ds1 = ( x => $x, xnerr => $xn, xperr => $xp,
                  y => $y );
         limits( [ \%ds1 ], { VecKeys => [ 'x <xnerr >xperr', 'y' ] } );

       For one-sided error bars, specify a column just for the side to be
       plotted:

         %ds1 = ( x => $x, xnerr => $xn,
                  y => $y, yperr => $yp );
         limits( [ \%ds1 ], { VecKeys => [ 'x <xnerr', 'y >yperr' ] } );

       Data in hashes with different keys follow the same paradigm:

         [ \%h1 => ( 'x =xerr', 'y =yerr' ) ], [ \%h2 => ( 'u =uerr', 'v =verr' ) ]

       In this case, the column names specific to a single data set override
       those specified via the "VecKeys" option.

         limits( [ \%h1 => 'x =xerr' ], { VecKeys => [ 'x <xn >xp' ] } )

       In the case of a multi-dimensional data set, one must specify all of
       the keys:

         limits( [ \%h1 => ( 'x =xerr', 'y =yerr' ) ],
                         { VecKeys => [ 'x <xn >xp', 'y <yp >yp' ] } )

       One can override only parts of the specifications:

         limits( [ \%h1 => ( '=xerr', '=yerr' ) ],
                         { VecKeys => [ 'x <xn >xp', 'y <yp >yp' ] } )

       Use "undef" as a placeholder for those keys for which nothing need by
       overridden:

         limits( [ \%h1 => undef, 'y =yerr' ],
                         { VecKeys => [ 'x <xn >xp', 'y <yp >yp' ] } )

       Data Transformation

       Normally the data passed to limits should be in their final,
       transformed, form. For example, if the data will be displayed on a
       logarithmic scale, the logarithm of the data should be passed to
       limits.  However, if error bars are also to be displayed, the
       untransformed data must be passed, as

         log(data) + log(error) != log(data + error)

       Since the ranges must be calculated for the transformed values, range
       must be given the transformation function.

       If all of the data sets will undergo the same transformation, this may
       be done with the Trans attribute, which is given a list of subroutine
       references, one for each element of a data set.  An "undef" value may
       be used to indicate no transformation is to be performed.  For example,

         @ds1 = ( $x, $y );

         # take log of $x
         limits( \@ds1, { trans => [ \&log10 ] } );

         # take log of $y
         limits( \@ds1, { trans => [ undef, \&log10 ] } );

       If each data set has a different transformation, things are a bit more
       complicated.  If the data sets are specified as arrays of vectors,
       vectors with transformations should be embedded in an array, with the
       last element the subroutine reference:

         @ds1 = ( [ $x, \&log10 ], $y );

       With error bars, this looks like this:

         @ds1 = ( [ $x, $xerr, \&log10 ], $y );
         @ds1 = ( [ $x, $xn, $xp, \&log10 ], $y );

       If the "Trans" attribute is used in conjunction with individual data
       set transformations, the latter will override it.  To explicitly
       indicate that a specific data set element has no transformation
       (normally only needed if "Trans" is used to specify a default) set the
       transformation subroutine reference to "undef".  In this case, the
       entire quad of data element, negative error, positive error, and
       transformation subroutine must be specified to avoid confusion:

         [ $x, $xn, $xp, undef ]

       Note that $xn and $xp may be undef. For symmetric errors, simply set
       both $xn and $xp to the same value.

       For data sets passed as hashes, the subroutine reference is an element
       in the hashes; the name of the corresponding key is added to the list
       of keys, preceded by the "&" character:

         %ds1 = ( x => $x, xerr => $xerr, xtrans => \&log10,
                  y => $y, yerr => $yerr );

         limits( [ \%ds1, \%ds2 ],
                { VecKeys => [ 'x =xerr &xtrans',  'y =yerr' ] });
         limits( [ \%ds1 => 'x =xerr &xtrans', 'y =yerr' ] );

       If the "Trans" attribute is specified, and a key name is also specified
       via the "VecKeys" attribute or individually for a data set element, the
       latter will take precedence.  For example,

         $ds1{trans1} = \&log10;
         $ds1{trans2} = \&sqrt;

         # resolves to exp
         limits( [ \%ds1 ], { Trans => [ \&exp ] });

         # resolves to sqrt
         limits( [ \%ds1 ], { Trans => [ \&exp ],
                             VecKeys => [ 'x =xerr &trans2' ] });

         # resolves to log10
         limits( [ \%ds1 => '&trans1' ], { Trans => [ \&exp ],
                                          VecKeys => [ 'x =xerr &trans2' ] });

       To indicate that a particular vector should have no transformation, use
       a blank key:

         limits( [ \%ds1 => ( 'x =xerr &', 'y =yerr' ) ], [\%ds2],
                  { Trans => [ \&log10 ] } );

       or set the hash element to "undef":

         $ds1{xtrans} = undef;

       Range Algorithms

       Sometimes all you want is to find the minimum and maximum values.
       However, for display purposes, it's often nice to have "clean" range
       bounds.  To that end, limits produces a range in two steps.  First it
       determines the bounds, then it cleans them up.

       To specify the bounding algorithm, set the value of the "Bounds" key in
       the %attr hash to one of the following values:

       MinMax  This indicates the raw minima and maxima should be used.  This
               is the default.

       Zscale  This is valid for two dimensional data only.  The "Y" values
               are sorted, then fit to a line.  The minimum and maximum values
               of the evaluated line are used for the "Y" bounds; the raw
               minimum and maximum values of the "X" data are used for the "X"
               bounds.  This method is good in situations where there are
               "spurious" spikes in the "Y" data which would generate too
               large a dynamic range in the bounds.  (Note that the "Zscale"
               algorithm is found in IRAF and DS9; its true origin is unknown
               to the author).

       To specify the cleaning algorithm, set the value of the "Clean" key in
       the %attr hash to one of the following values:

       None    Perform no cleaning of the bounds.

       RangeFrac
               This is based upon the "PGPLOT" pgrnge function.  It
               symmetrically expands the bounds (determined above) by a
               fractional amount:

                   $expand = $frac * ( $axis->{max} - $axis->{min} );
                   $min = $axis->{min} - $expand;
                   $max = $axis->{max} + $expand;

               The fraction may be specified in the %attr hash with the
               "RangeFrac" key.  It defaults to 0.05.

               Because this is a symmetric expansion, a limit of 0.0 may be
               transformed into a negative number, which may be inappropriate.
               If the "ZeroFix" key is set to a non-zero value in the %attr
               hash, the cleaned boundary is set to 0.0 if it is on the other
               side of 0.0 from the above determined bounds.  For example, If
               the minimum boundary value is 0.1, and the cleaned boundary
               value is -0.1, the cleaned value will be set to 0.0.
               Similarly, if the maximum value is -0.1 and the cleaned value
               is 0.1, it will be set to 0.0.

               This is the default clean algorithm.

       RoundPow
               This is based upon the "PGPLOT" pgrnd routine.  It determines a
               "nice" value, where "nice" is the closest round number to the
               boundary value, where a round number is 1, 2, or 5 times a
               power of 10.

       User Specified Limits

       To fully or partially override the automatically determined limits, use
       the Limits attribute.  These values are used as input to the range
       algorithms.

       The Limits attribute value may be either an array of arrayrefs, or a
       hash.

       Arrays
           The Limits value may be a reference to an array of arrayrefs, one
           per dimension, which contain the requested limits.

           The dimensions should be ordered in the same way as the datasets.
           Each arrayref should contain two ordered values, the minimum and
           maximum limits for that dimension.  The limits may have the
           undefined value if that limit is to be automatically determined.
           The limits should be transformed (or not) in the same fashion as
           the data.

           For example, to specify that the second dimension's maximum limit
           should be fixed at a specified value:

             Limits => [ [ undef, undef ], [ undef, $max ] ]

           Note that placeholder values are required for leading dimensions
           which are to be handled automatically. For convenience, if limits
           for a dimension are to be fully automatically determined, the
           placeholder arrayref may be empty.  Also, trailing undefined limits
           may be omitted.  The above example may be rewritten as:

             Limits => [ [], [ undef, $max ] ]

           If the minimum value was specified instead of the maximum, the
           following would be acceptable:

             Limits => [ [], [ $min ] ]

           If the data has but a single dimension, nested arrayrefs are not
           required:

             Limits => [ $min, $max ]

       Hashes
           Th Limits attribute value may be a hash; this can only be used in
           conjunction with the VecKeys attribute.  If the data sets are
           represented by hashes which do not have common keys, then the user
           defined limits should be specified with arrays.  The keys in the
           Limits hash should be the names of the data vectors in the VecKeys.
           Their values should be hashes with keys "min" and "max",
           representing the minimum and maximum limits.  Limits which have the
           value "undef" or which are not specified will be determined from
           the data.  For example,

             Limits => { x => { min => 30 }, y => { max => 22 } }

       Return Values

       When called in a list context, it returns the minimum and maximum
       bounds for each axis:

         @limits = ( $min_1, $max_1, $min_2, $max_2, ... );

       which makes life easier when using the env method:

         $window->env( @limits );

       When called in a scalar context, it returns a hashref with the keys

         axis1, ... axisN

       where "axisN" is the name of the Nth axis. If axis names have not been
       specified via the "VecKeys" element of %attr, names are concocted as
       "q1", "q2", etc.  The values are hashes with keys "min" and "max".  For
       example:

         { q1 => { min => 1, max => 2},
           q2 => { min => -33, max => 33 } }

       Miscellaneous

       Normally limits complains if hash data sets don't contain specific keys
       for error bars or transformation functions.  If, however, you'd like to
       specify default values using the %attr argument, but there are data
       sets which don't have the data and you'd rather not have to explicitly
       indicate that, set the "KeyCroak" attribute to zero.  For example,

         limits( [ { x => $x }, { x => $x1, xerr => $xerr } ],
                { VecKeys => [ 'x =xerr' ] } );

       will generate an error because the first data set does not have an
       "xerr" key.  Resetting "KeyCroak" will fix this:

         limits( [ { x => $x }, { x => $x1, xerr => $xerr } ],
                { VecKeys => [ 'x =xerr' ], KeyCroak => 0 } );

AUTHOR
       Diab Jerius, <djerius@cpan.org>

COPYRIGHT AND LICENSE
       Copyright (C) 2004 by the Smithsonian Astrophysical Observatory

       This software is released under the GNU General Public License.  You
       may find a copy at <http://www.fsf.org/copyleft/gpl.html>.

perl v5.40.2                      2024-12-09                         Limits(3)
