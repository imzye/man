mem(3)                User Contributed Perl Documentation               mem(3)


NAME
           •ḟmem - use modules in "mem"ory (already declared in same file)

VERSION
       Version "0.4.7"

SYNOPSIS
         use mem;
         use mem(@COMPILE_TIME_DEFINES=qw(a b c));

       "mem" is a syntactic-sugar "pragma" that allows "use"-ing a "package"
       as it is previously defined, in the same file. This allows easy
       declaration of specialized, typed data structures (like C "struct"
       definitions) that increase code legibility and concept clarity.  In a
       similar usage, the constants pragma allows defining low-overhead,
       runtime constants.

       Allowing "use" of packages in the same file allows calling code to
       access classes in a clean, object oriented manner, allowing for
       identical code to exist either in the same file, or in a separate file
       without making code changes or requiring use of non-portable, language
       specific features to accomplish the same thing.

       In the 2nd form, it can allow in-lined BEGIN's for single line
       assignments.  While one could use it as a replacement for multiple
       lines, an actual BEGIN block can often look as much or more tidy.

       In many cases, these compile time assignments are essential to take
       full advantage of perl's strengths.  For example, without compile time
       assignment of '@EXPORT', you can't use perl's function prototypes.  Due
       the overhead and difficulty in getting them right, new perl programmers
       are dissuaded from using such featues.

       When used to force assignments into the early parsing stages of perl,
       Using dynamically allocated, pre-initialized and type-checked data
       structures become possible.

EXAMPLE
       Following, is a sample program, showing two uses of  "mem" .  This
       first example allows declaring a run-time keyword 'ARRAY', that can
       check to see if it's argument is an ARRAY reference, and provide a
       runtime literal,  "ARRAY" , that can be used without quotes.

         use strict; use warnings;

         { package Ar_Type;
             #
             use mem;                                    #1st usage
             our (@EXPORT);
             sub ARRAY (;*) {
                 my $p = $_[0]; my $t="ARRAY";
                 return @_ ? (ref $p && (1+index($p, $t))) : $t;
             }
             #
             use mem( @EXPORT=qw(ARRAY) );               #2nd usage

                               use Xporter;
         }

         package main;
         use Ar_Type;
         use P;

         my @a=(1,2,3);
         my ($ed, $light);
             (@$ed, @$light) = (@a, @a);  #ed & light point to copies of @a
         bless $ed, "bee";

         P "\@a = ref of array" if ARRAY \@a;
         P "ref of \$ed is \"%s\".", ref $ed;
         P "ed still points to underlying type, 'array'" if ARRAY $ed;
         P "Is ref \$light, an ARRAY?: %s", (ref $light eq ARRAY) ? 'yes':'no';
         P "Does \"ref \$ed\" eq ARRAY?: %s", (ref $ed eq ARRAY) ? 'yes':'no';
         P "%s", "#  (Because \"ref \$ed\" is really a bless \"ed\" bee)"

       •   Now, to show what happens using  "mem", and the errors that occur
           if you do not.  First, the correct output:

             @a = ref of array
             ref of $ed is "bee".
             ed still points to underlying type, 'array'
             Is ref $light, an ARRAY?: yes
             Does ref $ed eq ARRAY?: no
             #  (Because ref "ed" is really a bless"ed" bee)

       •   Second, without the first "" use mem "", presuming the line was
           commented out:

             Can't locate Ar_Type.pm in @INC (@INC contains:
               /usr/lib/perl5/5.18.2 ...   /usr/lib/perl5/site_perl .)
               at /tmp/ex line 18.
             BEGIN failed--compilation aborted at /tmp/ex line 18.

           This is due to "package AR_Type", the package already declared and
           in "mem"ory>, being ignored by Perl's "use" statement because some
           Perl-specific, "internal flag" is not set for "package Ar_Type".
           The first "use mem" causes this flag, normally set with the path of
           the of a "use"d file, to be set with the containing file path and
           an added comment, containing the line number.

           This tells perl to use the definition of the package that is
           already in "mem"ory.

               and

       •   Third, instead of dropping the 1st "" use mem "", you drop (or
           comment out) the 2nd usage in the above example, you get:

             Bareword "ARRAY" not allowed while "strict subs"
               in use at /tmp/ex line 27.
             syntax error at /tmp/ex line 27, near "ARRAY \"
             Bareword "ARRAY" not allowed while "strict subs"
               in use at /tmp/ex line 30.
             Bareword "ARRAY" not allowed while "strict subs"
               in use at /tmp/ex line 31.
             Execution of /tmp/ex aborted due to compilation errors.

           This happens because when "use Xporter" is called, the contents of
           @EXPORT is not known.  Even with the assignment to @EXPORT, the
           ""@EXPORT=qw(ARRAY)"" being right above the "use Exporter"
           statement.  Similarly to the first error, above, Perl doesn't use
           the value of @EXPORT just above it.  Having " use mem " in the
           second position forces Perl to put the assignment to @EXPORT in "
           mem "ory, so that when " use Exporter " is called, it can pick up
           the name of "ARRAY" as already being "exported" and defined.

           Without "use mem" putting the value of @EXPORT in "mem"ory, "ARRAY"
           isn't defined, an you get the errors shown above.

   Summary
       The first usage allows '"main"' to find "package Ar_Type", already in
       "mem"ory.

       The second usage forces the definition of '"ARRAY"' into "mem"ory so
       they can be exported by an exporter function.

       In both cases, "mem" allows your already-in-"mem"ory code to be used.
       Thsi allows simplified programming and usage without knowledge of or
       references to Perl's internal-flags or internal run phases.

SEE ALSO
       See Xporter for more help with exporting features from your modules, or
       the older Exporter for the cadillac of exporting that will do
       everything you want (and a bit more). See P for more details about the
       generic print operator that is actually user friendly, and see
       Types::Core for a more complete treatment of the CORE Types (with
       helpers for other perl data types besides  "ARRAY"'s.

perl v5.40.2                      2017-10-28                            mem(3)
