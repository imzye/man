()                                                                          ()

[IMAGE: xlnt
       logo (https://user-
       images.githubusercontent.com/1735211/29433390-f37fa28e-836c-11e7-8a60-f8df4c30b424.png)]

       [IMAGE: Travis Build Status (https://travis-
       ci.org/tfussell/xlnt.svg?branch=master)] (https://travis-
       ci.org/tfussell/xlnt) [IMAGE: AppVeyor Build status
       (https://ci.appveyor.com/api/projects/status/2hs79a1xoxy16sol?svg=true)]
       (https://ci.appveyor.com/project/tfussell/xlnt) [IMAGE: Coverage Status
       (https://coveralls.io/repos/github/tfussell/xlnt/badge.svg?branch=master)]
       (https://coveralls.io/github/tfussell/xlnt?branch=master) [IMAGE:
       ReadTheDocs Documentation Status
       (https://readthedocs.org/projects/xlnt/badge/?version=latest)]
       (http://xlnt.readthedocs.org/en/latest/?badge=latest) [IMAGE: License
       (http://img.shields.io/badge/license-MIT-blue.svg?style=flat)]
       (http://opensource.org/licenses/MIT)

   Introduction
       xlnt is a modern C++ library for manipulating spreadsheets in memory
       and reading/writing them from/to XLSX files as described in ECMA 376
       4th edition (http://www.ecma-
       international.org/publications/standards/Ecma-376.htm).  The first
       public release of xlnt version 1.0 was on May 10th, 2017.  Current work
       is focused on increasing compatibility, improving performance, and
       brainstorming future development goals.  For a high-level summary of
       what you can do with this library, see the feature list
       (https://tfussell.gitbooks.io/xlnt/content/docs/introduction/Features.html).
       Contributions are welcome in the form of pull requests or discussions
       on the repository's Issues page
       (https://github.com/tfussell/xlnt/issues).

   Example
       Including xlnt in your project, creating a new spreadsheet, and saving
       it as "example.xlsx"


              #include <xlnt/xlnt.hpp>

              int main()
              {
                  xlnt::workbook wb;
                  xlnt::worksheet ws = wb.active_sheet();
                  ws.cell("A1").value(5);
                  ws.cell("B2").value("string data");
                  ws.cell("C3").formula("=RAND()");
                  ws.merge_cells("C3:C4");
                  ws.freeze_panes("B2");
                  wb.save("example.xlsx");
                  return 0;
              }
              // compile with -std=c++14 -Ixlnt/include -lxlnt


   Documentation
       Documentation for the current release of xlnt is available here
       (https://tfussell.gitbooks.io/xlnt/content/).

   License
       xlnt is released to the public for free under the terms of the MIT
       License.  See LICENSE.md
       (https://github.com/tfussell/xlnt/blob/master/LICENSE.md) for the full
       text of the license and the licenses of xlnt's third-party
       dependencies.  LICENSE.md
       (https://github.com/tfussell/xlnt/blob/master/LICENSE.md) should be
       distributed alongside any assemblies that use xlnt in source or
       compiled form.

   Introduction
       • Motivation (Motivation.md)

       • Examples (Examples.md)

       • Features (Features.md)

       • Installation (Installation.md)

   Motivation
   Examples
   Simple - reading from an existing xlsx spread sheet.
       The following C plus plus code will read the values from an xlsx file
       and print the string values to the screen.  This is a very simple
       example to get you started.


              #include <iostream>
              #include <xlnt/xlnt.hpp>

              int main()
              {
                  xlnt::workbook wb;
                  wb.load("/home/timothymccallum/test.xlsx");
                  auto ws = wb.active_sheet();
                  std::clog << "Processing spread sheet" << std::endl;
                  for (auto row : ws.rows(false))
                  {
                      for (auto cell : row)
                  {
                      std::clog << cell.to_string() << std::endl;
                  }
                  }
                  std::clog << "Processing complete" << std::endl;
                  return 0;
              }


       Save the contents of the above file


              /home/timothymccallum/process.cpp


       Compile by typing the following command


              g++ -std=c++14 -lxlnt process.cpp -o process


       Excecute by typing the following command


              ./process


       The output of the program, in my case, is as follows


              Processing spread sheet
              This is cell A1.
              This is cell B1
              ... and this is cell C1
              We are now on the second row at cell A2
              B2
              C2
              Processing complete


       As you can see the process.cpp file simply walks through the spread
       sheet values row by row and column by column (A1, B1, C1, A2, B2, C2
       and so on).

   Simple - storing a spread sheet in a 2 dimensional C++ Vector for
       further processing

       Loading a spread sheet into a Vector provides oppourtunities for you to
       perform high performance processing.  There will be more examples on
       performing fast look-ups, merging data, performing deduplication and
       more.  For now, let's just learn how to get the spread sheet loaded
       into memory.


              #include <iostream>
              #include <xlnt/xlnt.hpp>
              #include <vector>

              int main()
              {
                  xlnt::workbook wb;
                  wb.load("/home/timothymccallum/test.xlsx");
                  auto ws = wb.active_sheet();
                  std::clog << "Processing spread sheet" << std::endl;
                  std::clog << "Creating a single vector which stores the whole spread sheet" << std::endl;
                  std::vector< std::vector<std::string> > theWholeSpreadSheet;
                  for (auto row : ws.rows(false))
                  {
                      std::clog << "Creating a fresh vector for just this row in the spread sheet" << std::endl;
                  std::vector<std::string> aSingleRow;
                  for (auto cell : row)
                  {
                      std::clog << "Adding this cell to the row" << std::endl;
                      aSingleRow.push_back(cell.to_string());
                  }
                  std::clog << "Adding this entire row to the vector which stores the whole spread sheet" << std::endl;
                  theWholeSpreadSheet.push_back(aSingleRow);
                  }
                  std::clog << "Processing complete" << std::endl;
                  std::clog << "Reading the vector and printing output to the screen" << std::endl;
                  for (int rowInt = 0; rowInt < theWholeSpreadSheet.size(); rowInt++)
                  {
                      for (int colInt = 0; colInt < theWholeSpreadSheet.at(rowInt).size(); colInt++)
                  {
                      std::cout << theWholeSpreadSheet.at(rowInt).at(colInt) << std::endl;
                      }
                  }
                  return 0;
              }


       Save the contents of the above file


              /home/timothymccallum/process.cpp


       Compile by typing the following command


              g++ -std=c++14 -lxlnt process.cpp -o process


       Excecute by typing the following command


              ./process


       The output of the program, in my case, is as follows


              Processing spread sheet
              Creating a single vector which stores the whole spread sheet
              Creating a fresh vector for just this row in the spread sheet
              Adding this cell to the row
              Adding this cell to the row
              Adding this cell to the row
              Adding this entire row to the vector which stores the whole spread sheet
              Creating a fresh vector for just this row in the spread sheet
              Adding this cell to the row
              Adding this cell to the row
              Adding this cell to the row
              Adding this entire row to the vector which stores the whole spread sheet
              Processing complete
              Reading the vector and printing output to the screen
              This is cell A1.
              This is cell B1
              ... and this is cell C1
              We are now on the second row at cell A2
              B2
              C2


       You will have noticed that this process is very fast.  If you type the
       "time" as shown below, you can measure just how fast loading and
       retrieving your spread sheet is, using xlnt; In this case only a
       fraction of a second.  More on this later.


              time ./process
              ...
              real    0m0.044s


   Simple - writing values to a new xlsx spread sheet.

              #include <iostream>
              #include <xlnt/xlnt.hpp>
              #include <vector>
              #include <string>

              int main()
              {
                  //Creating a 2 dimensional vector which we will write values to
                  std::vector< std::vector<std::string> > wholeWorksheet;
                  //Looping through each row (100 rows as per the second argument in the for loop)
                  for (int outer = 0; outer < 100; outer++)
                  {
                      //Creating a fresh vector for a fresh row
                  std::vector<std::string> singleRow;
                  //Looping through each of the columns (100 as per the second argument in the for loop) in this particular row
                  for(int inner = 0; inner < 100; inner++)
                  {
                      //Adding a single value in each cell of the row
                      std::string val = std::to_string(inner + 1);
                      singleRow.push_back(val);
                  }
                  //Adding the single row to the 2 dimensional vector
                  wholeWorksheet.push_back(singleRow);
                  std::clog << "Writing to row " << outer << " in the vector " << std::endl;
                  }
                  //Writing to the spread sheet
                  //Creating the output workbook
                  std::clog << "Creating workbook" << std::endl;
                  xlnt::workbook wbOut;
                  //Setting the destination output file name
                  std::string dest_filename = "output.xlsx";
                  //Creating the output worksheet
                  xlnt::worksheet wsOut = wbOut.active_sheet();
                  //Giving the output worksheet a title/name
                  wsOut.title("data");
                  //We will now be looping through the 2 dimensional vector which we created above
                  //In this case we have two iterators one for the outer loop (row) and one for the inner loop (column)
                  std::clog << "Looping through vector and writing to spread sheet" << std::endl;
                  for (int fOut = 0; fOut < wholeWorksheet.size(); fOut++)
                  {
                      std::clog << "Row" << fOut << std::endl;
                      for (int fIn = 0; fIn < wholeWorksheet.at(fOut).size(); fIn++)
                      {
                          //Take notice of the difference between accessing the vector and accessing the work sheet
                      //As you may already know Excel spread sheets start at row 1 and column 1 (not row 0 and column 0 like you would expect from a C++ vector)
                      //In short the xlnt cell reference starts at column 1 row 1 (hence the + 1s below) and the vector reference starts at row 0 and column 0
                      wsOut.cell(xlnt::cell_reference(fIn + 1, fOut + 1)).value(wholeWorksheet.at(fOut).at(fIn));
                      //Further clarification to avoid confusion
                      //Cell reference arguments are (column number, row number); e.g. cell_reference(fIn + 1, fOut + 1)
                      //Vector arguments are (row number, column number); e.g. wholeWorksheet.at(fOut).at(fIn)
                  }
                  }
                  std::clog << "Finished writing spread sheet" << std::endl;
                  wbOut.save(dest_filename);
                  return 0;
              }


       This process is also quite quick; a time command showed that xlnt was
       able to create and write 10, 000 values to the output spread sheet in
       0.582 seconds.

   Features

       Feature                  Read   Edit   Write
       ─────────────────────────────────────────────
       Excel-style Workbook     ✓      ✓      ✓
       LibreOffice-style        ✓      ✓      ✓
       Workbook
       Numbers-style Workbook   ✓      ✓      ✓
       Encrypted Workbook       ✓      ✓
       (Excel 2007-2010)
       Encrypted Workbook       ✓      ✓
       (Excel 2013-2016)
       Excel Binary Workbook
       (.xlsb)
       Excel Macro-Enabled
       Workbook (.xlsm)
       Excel Macro-Enabled
       Template (.xltm)
       Document Properties      ✓      ✓      ✓
       Numeric Cell Values      ✓      ✓      ✓
       Inline String Cell       ✓      ✓      ✓
       Values
       Shared String Cell       ✓      ✓      ✓
       Values
       Shared String Text Run   ✓      ✓      ✓
       Formatting (e.g.
       varied fonts within a
       cell)
       Hyperlink Cell Values
       Formula Cell Values
       Formula Evaluation
       Page Margins             ✓      ✓      ✓
       Page Setup
       Print Area
       Comments                 ✓      ✓
       Header and Footer
       Custom Views
       Charts
       Chartsheets
       Dialogsheets
       Themes                   ✓             ✓
       Cell Styles              ✓      ✓      ✓
       Cell Formats             ✓      ✓      ✓
       Formatting->Alignment    ✓      ✓      ✓
       (e.g. right align)
       Formatting->Border       ✓      ✓      ✓
       (e.g. red cell
       outline)
       Formatting->Fill (e.g.   ✓      ✓      ✓
       green cell background)
       Formatting->Font (e.g.   ✓      ✓      ✓
       blue cell text)
       Formatting->Number       ✓      ✓      ✓
       Format (e.g. show 2
       decimals)
       Formatting->Protection   ✓      ✓      ✓
       (e.g. hide formulas)
       Column Styles
       Row Styles
       Sheet Styles
       Conditional Formatting
       Tables
       Table Formatting
       Pivot Tables
       XLSX Thumbnail           ✓             ✓
       Custom OOXML
       Properties
       Custom OOXML Parts
       Drawing
       Text Box
       WordArt
       Embedded Content (e.g.
       images)
       Excel VBA

Getting xlnt
   Binaries
   Homebrew
   Arch
   vcpkg
   Compiling xlnt 1.x.x from Source on Ubuntu 16.04 LTS (Xenial Xerus)
       Time required: Approximately 5 minutes (depending on your internet
       speed)


              sudo apt-get update
              sudo apt-get upgrade
              sudo apt-get install cmake
              sudo apt-get install zlibc


       The following steps update the compiler and set the appropriate
       environment variables - see note [1] below for the reason why we need
       to update the standard available compiler


              sudo add-apt-repository ppa:ubuntu-toolchain-r/test
              sudo apt update
              sudo apt-get upgrade
              sudo apt-get install gcc-6 g++-6
              export CC=/usr/bin/gcc-6
              export CXX=/usr/bin/g++-6


       The following steps will intall xlnt Download the zip file from the
       xlnt repository <https://github.com/tfussell/xlnt/archive/master.zip>


              cd ~
              unzip Downloads/xlnt-master.zip
              cd xlnt-master
              cmake .
              make -j 2
              sudo make install


       The following step will map the shared library names to the location of
       the corresponding shared library files


              sudo ldconfig


       xlnt will now be ready to use on your Ubuntu instance.

       [1] Xlnt requires a minimum of gcc 6.2.0 The most recent gcc version
       available using the standard APT repositories is gcc 5.4.0 (obtained
       through build-essential 12.1ubuntu2).  If these older versions of gcc
       are used an error "workbook.cpp error 1502:31 'extended_property' is
       not a class, namespace or enumeration" will occur during the xlnt make
       command.

   Compiling from Source
       Build configurations for Visual Studio, GNU Make, Ninja, and Xcode can
       be created using cmake (https://cmake.org/) v3.2+.  A full list of
       cmake generators can be found here
       (https://cmake.org/cmake/help/v3.0/manual/cmake-generators.7.html).  A
       basic build would look like (starting in the root xlnt directory):


              mkdir build
              cd build
              cmake ..
              make -j8


       The resulting shared (e.g.  libxlnt.dylib) library would be found in
       the build/lib directory.  Other cmake configuration options for xlnt
       can be found using "cmake -LH".  These options include building a
       static library instead of shared and whether to build sample
       executables or not.  An example of building a static library with an
       Xcode project:


              mkdir build
              cd build
              cmake -D STATIC=ON -G Xcode ..
              cmake --build .
              cd bin && ./xlnt.test


       Note for Windows: cmake defaults to building a 32-bit library project.
       To build a 64-bit library, use the Win64 generator


              cmake -G "Visual Studio 14 2015 Win64" ..


   Basics
       • Workbook (/docs/basics/Workbook.md)

       • Worksheet (/docs/basics/Worksheet.md)

       • Cell (/docs/basics/Cell.md)

       • Iteration (/docs/basics/Iteration.md)

   Workbook
   Worksheet
   Cell
   Iteration
   Advanced
       • Formatting (Formatting.md)

       • Properties (Properties.md)

       • Printing (Printing.md)

       • Encryption (Encryption.md)

       • Views (Views.md)

Formatting
   Format vs. Style

              #include <iostream>
              #include <xlnt/xlnt.hpp>

              int main()
              {
                  xlnt::workbook wb;
                  auto cell = wb.active_sheet().cell("A1");
                  return 0;
              }


       In the context of xlnt, format and style have specific distinct
       meanings.  A style in xlnt corresponds to a named style created in the
       "Cell styles" dropdown in Excel.  It must have a name and optionally
       any of: alignment, border, fill, font, number format, protection.  A
       format in xlnt corresponds to the alignment, border, fill, font, number
       format, and protection settings applied to a cell via
       right-click->"Format Cells".  A cell can have both a format and a
       style.  The style properties will generally override the format
       properties.

   Number Formatting

              #include <iostream>
              #include <xlnt/xlnt.hpp>

              int main()
              {
                  xlnt::workbook wb;
                  auto cell = wb.active_sheet().cell("A1");
                  cell.number_format(xlnt::number_format::percentage());
                  cell.value(0.513);
                  std::cout << cell.to_string() << std::endl;
                  return 0;
              }


       An xlnt::number_format is the format code used when displaying a value
       in a cell.  For example, a number_format of "0.00" implies that the
       number 13.726 should be displayed as "13.73".  Many number formats are
       built-in to Excel and can be access with xlnt::number_format static
       constructors.  Other custom number formats can be created by passing a
       string to the xlnt::number_format constructor (#cell-const-cell-amp).

Properties

              xlnt::workbook wb;

              wb.core_property(xlnt::core_property::category, "hors categorie");
              wb.core_property(xlnt::core_property::content_status, "good");
              wb.core_property(xlnt::core_property::created, xlnt::datetime(2017, 1, 15));
              wb.core_property(xlnt::core_property::creator, "me");
              wb.core_property(xlnt::core_property::description, "description");
              wb.core_property(xlnt::core_property::identifier, "id");
              wb.core_property(xlnt::core_property::keywords, { "wow", "such" });
              wb.core_property(xlnt::core_property::language, "Esperanto");
              wb.core_property(xlnt::core_property::last_modified_by, "someone");
              wb.core_property(xlnt::core_property::last_printed, xlnt::datetime(2017, 1, 15));
              wb.core_property(xlnt::core_property::modified, xlnt::datetime(2017, 1, 15));
              wb.core_property(xlnt::core_property::revision, "3");
              wb.core_property(xlnt::core_property::subject, "subject");
              wb.core_property(xlnt::core_property::title, "title");
              wb.core_property(xlnt::core_property::version, "1.0");

              wb.extended_property(xlnt::extended_property::application, "xlnt");
              wb.extended_property(xlnt::extended_property::app_version, "0.9.3");
              wb.extended_property(xlnt::extended_property::characters, 123);
              wb.extended_property(xlnt::extended_property::characters_with_spaces, 124);
              wb.extended_property(xlnt::extended_property::company, "Incorporated Inc.");
              wb.extended_property(xlnt::extended_property::dig_sig, "?");
              wb.extended_property(xlnt::extended_property::doc_security, 0);
              wb.extended_property(xlnt::extended_property::heading_pairs, true);
              wb.extended_property(xlnt::extended_property::hidden_slides, false);
              wb.extended_property(xlnt::extended_property::h_links, 0);
              wb.extended_property(xlnt::extended_property::hyperlink_base, 0);
              wb.extended_property(xlnt::extended_property::hyperlinks_changed, true);
              wb.extended_property(xlnt::extended_property::lines, 42);
              wb.extended_property(xlnt::extended_property::links_up_to_date, false);
              wb.extended_property(xlnt::extended_property::manager, "johnny");
              wb.extended_property(xlnt::extended_property::m_m_clips, "?");
              wb.extended_property(xlnt::extended_property::notes, "note");
              wb.extended_property(xlnt::extended_property::pages, 19);
              wb.extended_property(xlnt::extended_property::paragraphs, 18);
              wb.extended_property(xlnt::extended_property::presentation_format, "format");
              wb.extended_property(xlnt::extended_property::scale_crop, true);
              wb.extended_property(xlnt::extended_property::shared_doc, false);
              wb.extended_property(xlnt::extended_property::slides, 17);
              wb.extended_property(xlnt::extended_property::template_, "template!");
              wb.extended_property(xlnt::extended_property::titles_of_parts, { "title" });
              wb.extended_property(xlnt::extended_property::total_time, 16);
              wb.extended_property(xlnt::extended_property::words, 101);

              wb.custom_property("test", { 1, 2, 3 });
              wb.custom_property("Editor", "John Smith");

              wb.save("lots_of_properties.xlsx");


   Printing
   Encryption
   Views
   API
       • cell (cell.md)

       • cell_reference (cell_reference.md)

cell
   using xlnt::cell::type =  cell_typeundefined
       Alias xlnt::cell_type to xlnt::cell::type since it looks nicer.

   friend class detail::xlsx_consumerundefined
   friend class detail::xlsx_producerundefined
   friend struct detail::cell_implundefined
   static const std::unordered_map<std::string, int>& xlnt::cell::error_codes()
       Returns a map of error strings such as #DIV/0! and their associated
       indices.

   xlnt::cell::cell(const cell &)=default
       Default copy constructor.

   bool xlnt::cell::has_value() const
       Returns true if value has been set and has not been cleared using
       cell::clear_value().

   T xlnt::cell::value() const
       Returns the value of this cell as an instance of type T.  Overloads
       exist for most C++ fundamental types like bool, int, etc.  as well as
       for std::string and xlnt datetime types: date, time, datetime, and
       timedelta.

   void xlnt::cell::clear_value()
       Makes this cell have a value of type null.  All other cell attributes
       are retained.

   void xlnt::cell::value(std::nullptr_t)
       Sets the type of this cell to null.

   void xlnt::cell::value(bool boolean_value)
       Sets the value of this cell to the given boolean value.

   void xlnt::cell::value(int int_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(unsigned int int_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(long long int int_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(unsigned long long int int_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(float float_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(double float_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(long double float_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const date &date_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const time &time_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const datetime &datetime_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const timedelta &timedelta_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const std::string &string_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const char *string_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const rich_text &text_value)
       Sets the value of this cell to the given value.

   void xlnt::cell::value(const cell other_cell)
       Sets the value and formatting of this cell to that of other_cell.

   void xlnt::cell::value(const std::string &string_value, bool infer_type)
       Analyzes string_value to determine its type, convert it to that type,
       and set the value of this cell to that converted value.

   type xlnt::cell::data_type() const
       Returns the type of this cell.

   void xlnt::cell::data_type(type t)
       Sets the type of this cell.  This should usually be done indirectly by
       setting the value of the cell to a value of that type.

   bool xlnt::cell::garbage_collectible() const
       There's no reason to keep a cell which has no value and is not a
       placeholder.  Returns true if this cell has no value, style, isn't
       merged, etc.

   bool xlnt::cell::is_date() const
       Returns true iff this cell's number format matches a date format.

   cell_reference xlnt::cell::reference() const
       Returns a cell_reference that points to the location of this cell.

   column_t xlnt::cell::column() const
       Returns the column of this cell.

   row_t xlnt::cell::row() const
       Returns the row of this cell.

   std::pair<int, int> xlnt::cell::anchor() const
       Returns the location of this cell as an ordered pair (left, top).

   std::string xlnt::cell::hyperlink() const
       Returns the URL of this cell's hyperlink.

   void xlnt::cell::hyperlink(const std::string &url)
       Adds a hyperlink to this cell pointing to the URL of the given value.

   void xlnt::cell::hyperlink(const std::string &url, const std::string &display)
       Adds a hyperlink to this cell pointing to the URI of the given value
       and sets the text value of the cell to the given parameter.

   void xlnt::cell::hyperlink(xlnt::cell target)
       Adds an internal hyperlink to this cell pointing to the given cell.

   bool xlnt::cell::has_hyperlink() const
       Returns true if this cell has a hyperlink set.

   class alignment xlnt::cell::computed_alignment() const
       Returns the alignment that should be used when displaying this cell
       graphically based on the workbook default, the cell-level format, and
       the named style applied to the cell in that order.

   class border xlnt::cell::computed_border() const
       Returns the border that should be used when displaying this cell
       graphically based on the workbook default, the cell-level format, and
       the named style applied to the cell in that order.

   class fill xlnt::cell::computed_fill() const
       Returns the fill that should be used when displaying this cell
       graphically based on the workbook default, the cell-level format, and
       the named style applied to the cell in that order.

   class font xlnt::cell::computed_font() const
       Returns the font that should be used when displaying this cell
       graphically based on the workbook default, the cell-level format, and
       the named style applied to the cell in that order.

   class number_format xlnt::cell::computed_number_format() const
       Returns the number format that should be used when displaying this cell
       graphically based on the workbook default, the cell-level format, and
       the named style applied to the cell in that order.

   class protection xlnt::cell::computed_protection() const
       Returns the protection that should be used when displaying this cell
       graphically based on the workbook default, the cell-level format, and
       the named style applied to the cell in that order.

   bool xlnt::cell::has_format() const
       Returns true if this cell has had a format applied to it.

   const class format xlnt::cell::format() const
       Returns the format applied to this cell.  If this cell has no format,
       an invalid_attribute exception will be thrown.

   void xlnt::cell::format(const class format new_format)
       Applies the cell-level formatting of new_format to this cell.

   void xlnt::cell::clear_format()
       Removes the cell-level formatting from this cell.  This doesn't affect
       the style that may also be applied to the cell.  Throws an
       invalid_attribute exception if no format is applied.

   class number_format xlnt::cell::number_format() const
       Returns the number format of this cell.

   void xlnt::cell::number_format(const class number_format &format)
       Creates a new format in the workbook, sets its number_format to the
       given format, and applies the format to this cell.

   class font xlnt::cell::font() const
       Returns the font applied to the text in this cell.

   void xlnt::cell::font(const class font &font_)
       Creates a new format in the workbook, sets its font to the given font,
       and applies the format to this cell.

   class fill xlnt::cell::fill() const
       Returns the fill applied to this cell.

   void xlnt::cell::fill(const class fill &fill_)
       Creates a new format in the workbook, sets its fill to the given fill,
       and applies the format to this cell.

   class border xlnt::cell::border() const
       Returns the border of this cell.

   void xlnt::cell::border(const class border &border_)
       Creates a new format in the workbook, sets its border to the given
       border, and applies the format to this cell.

   class alignment xlnt::cell::alignment() const
       Returns the alignment of the text in this cell.

   void xlnt::cell::alignment(const class alignment &alignment_)
       Creates a new format in the workbook, sets its alignment to the given
       alignment, and applies the format to this cell.

   class protection xlnt::cell::protection() const
       Returns the protection of this cell.

   void xlnt::cell::protection(const class protection &protection_)
       Creates a new format in the workbook, sets its protection to the given
       protection, and applies the format to this cell.

   bool xlnt::cell::has_style() const
       Returns true if this cell has had a style applied to it.

   class style xlnt::cell::style()
       Returns a wrapper pointing to the named style applied to this cell.

   const class style xlnt::cell::style() const
       Returns a wrapper pointing to the named style applied to this cell.

   void xlnt::cell::style(const class style &new_style)
       Sets the named style applied to this cell to a style named style_name.
       Equivalent to style(new_style.name()).

   void xlnt::cell::style(const std::string &style_name)
       Sets the named style applied to this cell to a style named style_name.
       If this style has not been previously created in the workbook, a
       key_not_found exception will be thrown.

   void xlnt::cell::clear_style()
       Removes the named style from this cell.  An invalid_attribute exception
       will be thrown if this cell has no style.  This will not affect the
       cell format of the cell.

   std::string xlnt::cell::formula() const
       Returns the string representation of the formula applied to this cell.

   void xlnt::cell::formula(const std::string &formula)
       Sets the formula of this cell to the given value.  This formula string
       should begin with '='.

   void xlnt::cell::clear_formula()
       Removes the formula from this cell.  After this is called,
       has_formula() will return false.

   bool xlnt::cell::has_formula() const
       Returns true if this cell has had a formula applied to it.

   std::string xlnt::cell::to_string() const
       Returns a string representing the value of this cell.  If the data type
       is not a string, it will be converted according to the number format.

   bool xlnt::cell::is_merged() const
       Returns true iff this cell has been merged with one or more surrounding
       cells.

   void xlnt::cell::merged(bool merged)
       Makes this a merged cell iff merged is true.  Generally, this shouldn't
       be called directly.  Instead, use worksheet::merge_cells on its parent
       worksheet.

   std::string xlnt::cell::error() const
       Returns the error string that is stored in this cell.

   void xlnt::cell::error(const std::string &error)
       Directly assigns the value of this cell to be the given error.

   cell xlnt::cell::offset(int column, int row)
       Returns a cell from this cell's parent workbook at a relative offset
       given by the parameters.

   class worksheet xlnt::cell::worksheet()
       Returns the worksheet that owns this cell.

   const class worksheet xlnt::cell::worksheet() const
       Returns the worksheet that owns this cell.

   class workbook& xlnt::cell::workbook()
       Returns the workbook of the worksheet that owns this cell.

   const class workbook& xlnt::cell::workbook() const
       Returns the workbook of the worksheet that owns this cell.

   calendar xlnt::cell::base_date() const
       Returns the base date of the parent workbook.

   std::string xlnt::cell::check_string(const std::string &to_check)
       Returns to_check after verifying and fixing encoding, size, and illegal
       characters.

   bool xlnt::cell::has_comment()
       Returns true if this cell has a comment applied.

   void xlnt::cell::clear_comment()
       Deletes the comment applied to this cell if it exists.

   class comment xlnt::cell::comment()
       Gets the comment applied to this cell.

   void xlnt::cell::comment(const std::string &text, const std::string &author="Microsoft Office User")
       Creates a new comment with the given text and optional author and
       applies it to the cell.

   void xlnt::cell::comment(const std::string &comment_text, const class font &comment_font, const std::string &author="Microsoft Office User")
       Creates a new comment with the given text, formatting, and optional
       author and applies it to the cell.

   void xlnt::cell::comment(const class comment &new_comment)
       Apply the comment provided as the only argument to the cell.

   double xlnt::cell::width() const
       Returns the width of this cell in pixels.

   double xlnt::cell::height() const
       Returns the height of this cell in pixels.

   cell& xlnt::cell::operator=(const cell &rhs)
       Makes this cell interally point to rhs.  The cell data originally
       pointed to by this cell will be unchanged.

   bool xlnt::cell::operator==(const cell &comparand) const
       Returns true if this cell the same cell as comparand (compared by
       reference).

   bool xlnt::cell::operator==(std::nullptr_t) const
       Returns true if this cell is uninitialized.

cell_reference
   static std::pair<std::string, row_t> xlnt::cell_reference::split_reference(const std::string &reference_string)
       Splits a coordinate string like "A1" into an equivalent pair like {"A",
       1}.

   static std::pair<std::string, row_t> xlnt::cell_reference::split_reference(const std::string &reference_string, bool &absolute_column, bool &absolute_row)
       Splits a coordinate string like "A1" into an equivalent pair like {"A",
       1}.  Reference parameters absolute_column and absolute_row will be set
       to true if column part or row part are prefixed by a dollar-sign
       indicating they are absolute, otherwise false.

   xlnt::cell_reference::cell_reference()
       Default constructor makes a reference to the top-left-most cell, "A1".

   xlnt::cell_reference::cell_reference(const char *reference_string)
       Constructs a cell_reference from a string reprenting a cell coordinate
       (e.g.  $B14).

   xlnt::cell_reference::cell_reference(const std::string &reference_string)
       Constructs a cell_reference from a string reprenting a cell coordinate
       (e.g.  $B14).

   xlnt::cell_reference::cell_reference(column_t column, row_t row)
       Constructs a cell_reference from a 1-indexed column index and row
       index.

   cell_reference& xlnt::cell_reference::make_absolute(bool absolute_column=true, bool absolute_row=true)
       Converts a coordinate to an absolute coordinate string (e.g.  B12 ->
       $B$12) Defaulting to true, absolute_column and absolute_row can
       optionally control whether the resulting cell_reference has an absolute
       column (e.g.  B12 -> $B12) and absolute row (e.g.  B12 -> B$12)
       respectively.

   bool xlnt::cell_reference::column_absolute() const
       Returns true if the reference refers to an absolute column, otherwise
       false.

   void xlnt::cell_reference::column_absolute(bool absolute_column)
       Makes this reference have an absolute column if absolute_column is
       true, otherwise not absolute.

   bool xlnt::cell_reference::row_absolute() const
       Returns true if the reference refers to an absolute row, otherwise
       false.

   void xlnt::cell_reference::row_absolute(bool absolute_row)
       Makes this reference have an absolute row if absolute_row is true,
       otherwise not absolute.

   column_t xlnt::cell_reference::column() const
       Returns a string that identifies the column of this reference (e.g.
       second column from left is "B")

   void xlnt::cell_reference::column(const std::string &column_string)
       Sets the column of this reference from a string that identifies a
       particular column.

   column_t::index_t xlnt::cell_reference::column_index() const
       Returns a 1-indexed numeric index of the column of this reference.

   void xlnt::cell_reference::column_index(column_t column)
       Sets the column of this reference from a 1-indexed number that
       identifies a particular column.

   row_t xlnt::cell_reference::row() const
       Returns a 1-indexed numeric index of the row of this reference.

   void xlnt::cell_reference::row(row_t row)
       Sets the row of this reference from a 1-indexed number that identifies
       a particular row.

   cell_reference xlnt::cell_reference::make_offset(int column_offset, int row_offset) const
       Returns a cell_reference offset from this cell_reference by the number
       of columns and rows specified by the parameters.  A negative value for
       column_offset or row_offset results in a reference above or left of
       this cell_reference, respectively.

   std::string xlnt::cell_reference::to_string() const
       Returns a string like "A1" for cell_reference(1, 1).

   range_reference xlnt::cell_reference::to_range() const
       Returns a 1x1 range_reference containing only this cell_reference.

   range_reference xlnt::cell_reference::operator,(const cell_reference &other) const
       I've always wanted to overload the comma operator.  cell_reference("A",
       1), cell_reference("B", 1) will return
       range_reference(cell_reference("A", 1), cell_reference("B", 1))

   bool xlnt::cell_reference::operator==(const cell_reference &comparand) const
       Returns true if this reference is identical to comparand including in
       absoluteness of column and row.

   bool xlnt::cell_reference::operator==(const std::string &reference_string) const
       Constructs a cell_reference from reference_string and return the result
       of their comparison.

   bool xlnt::cell_reference::operator==(const char *reference_string) const
       Constructs a cell_reference from reference_string and return the result
       of their comparison.

   bool xlnt::cell_reference::operator!=(const cell_reference &comparand) const
       Returns true if this reference is not identical to comparand including
       in absoluteness of column and row.

   bool xlnt::cell_reference::operator!=(const std::string &reference_string) const
       Constructs a cell_reference from reference_string and return the result
       of their comparison.

   bool xlnt::cell_reference::operator!=(const char *reference_string) const
       Constructs a cell_reference from reference_string and return the result
       of their comparison.

Change Log
       This project adheres to Semantic Versioning (http://semver.org/).
       Every release is documented on the Github Releases
       (https://github.com/tfussell/xlnt/releases) page.

Contributing to xlnt
       xlnt welcomes contributions from everyone regardless of skill level
       (provided you can write C++ or documentation).

   Getting Started
       Look through the list of issues to find something interesting to work
       on.  Help is appreciated with any issues, but important timely issues
       are labeled as "help wanted".  Issues labeled "docs" might be good for
       those who want to contribute without having to know too much C++.  You
       might also find something that the code is missing without an
       associated issue.  That's fine to work on to, but it might be best to
       make an issue first in case someone else is working on it.

   Contributions
       Contributions to xlnt should be made in the form of pull requests on
       GitHub.  Each pull request will be reviewed and either merged into the
       current development branch or given feedback for changes that would be
       required to do so.

       All code in this repository is under the MIT License.  You should agree
       to these terms before submitting any code to xlnt.

   Pull Request Checklist
       • Branch from the head of the current development branch.  Until
         version 1.0 is released, this the master branch.

       • Commits should be as small as possible, while ensuring that each
         commit is correct independently (i.e.  each commit should compile and
         pass all tests).  Commits that don't follow the coding style
         indicated in .clang-format (e.g.  indentation) are less likely to be
         accepted until they are fixed.

       • If your pull request is not getting reviewed or you need a specific
         person to review it, you can @-reply a reviewer asking for a review
         in the pull request or a comment.

       • Add tests relevant to the fixed defect or new feature.  It's best to
         do this before making any changes, make sure that the tests fail,
         then make changes ensuring that it ultimately passes the tests (i.e.
         TDD).  xlnt uses cxxtest for testing.  Tests are contained in a tests
         directory inside each module (e.g.
         source/workbook/tests/testworkbook.hpp) in the form of a header file.
         Each test is a separate function with a name that starts like "test".
         See <http://cxxtest.com/guide.html> for information about CxxTest or
         take a look at existing tests.

   Conduct
       Just try to be nice--we're all volunteers here.

   Communication
       Add a comment to an existing issue on GitHub, open a new issue for
       defects or feature requests, or contact @tfussell if you want.

License
   xlnt (https://github.com/tfussell/xlnt)

              MIT License
              (https://github.com/tfussell/xlnt/blob/master/LICENSE.md)


              Copyright (c) 2014-2017 Thomas Fussell

              Permission is hereby granted, free of charge, to any person obtaining a
              copy of this software and associated documentation files (the
              "Software"), to deal in the Software without restriction, including
              without limitation the rights to use, copy, modify, merge, publish,
              distribute, sublicense, and/or sell copies of the Software, and to
              permit persons to whom the Software is furnished to do so, subject to
              the following conditions:

              The above copyright notice and this permission notice shall be included
              in all copies or substantial portions of the Software.

              THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
              IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
              CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
              TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
              SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


   POLE (http://www.dimin.net/software/pole/)

              BSD 2-Clause License
              (https://bitbucket.org/dimin/pole/src/c15e513bdce4c3a52b3dbc925d4d2bb520dc71d8/pole/LICENSE)


              POLE - Portable C++ library to access OLE Storage
              Copyright (C) 2002-2007 Ariya Hidayat (ariya@kde.org). All rights reserved.

              Redistribution and use in source and binary forms, with or without
              modification, are permitted provided that the following conditions
              are met:

              1. Redistributions of source code must retain the above copyright
                 notice, this list of conditions and the following disclaimer.
              2. Redistributions in binary form must reproduce the above copyright
                 notice, this list of conditions and the following disclaimer in the
                 documentation and/or other materials provided with the distribution.

              THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
              IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
              OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
              IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
              INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
              NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
              DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
              THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
              (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
              THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   libstudxml (http://www.codesynthesis.com/projects/libstudxml/)

              MIT License (http://www.codesynthesis.com/licenses/mit.txt)


              Summary: Everything is licensed under the MIT License (text below).

              Code found in the xml/details/expat/ directory is distributed under
              the MIT License (see the xml/details/expat/LICENSE file for copyright
              information).

              Code found in the xml/details/genx/ directory is distributed under
              the MIT License (see the xml/details/genx/LICENSE file for copyright
              information).

              The rest is Copyright (c) 2013-2014 Code Synthesis Tools CC and is
              distributed under the MIT License:

              Permission is hereby granted, free of charge, to any person obtaining
              a copy of this software and associated documentation files (the
              "Software"), to deal in the Software without restriction, including
              without limitation the rights to use, copy, modify, merge, publish,
              distribute, sublicense, and/or sell copies of the Software, and to
              permit persons to whom the Software is furnished to do so, subject to
              the following conditions:

              The above copyright notice and this permission notice shall be included
              in all copies or substantial portions of the Software.

              THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
              EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
              IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
              CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
              TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
              SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


   CxxTest (http://cxxtest.com/)

              LGPL License
              (https://github.com/CxxTest/cxxtest/blob/master/COPYING)


                                 GNU LESSER GENERAL PUBLIC LICENSE
                                     Version 3, 29 June 2007

               Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
               Everyone is permitted to copy and distribute verbatim copies
               of this license document, but changing it is not allowed.


                This version of the GNU Lesser General Public License incorporates
              the terms and conditions of version 3 of the GNU General Public
              License, supplemented by the additional permissions listed below.

                0. Additional Definitions.

                As used herein, "this License" refers to version 3 of the GNU Lesser
              General Public License, and the "GNU GPL" refers to version 3 of the GNU
              General Public License.

                "The Library" refers to a covered work governed by this License,
              other than an Application or a Combined Work as defined below.

                An "Application" is any work that makes use of an interface provided
              by the Library, but which is not otherwise based on the Library.
              Defining a subclass of a class defined by the Library is deemed a mode
              of using an interface provided by the Library.

                A "Combined Work" is a work produced by combining or linking an
              Application with the Library.  The particular version of the Library
              with which the Combined Work was made is also called the "Linked
              Version".

                The "Minimal Corresponding Source" for a Combined Work means the
              Corresponding Source for the Combined Work, excluding any source code
              for portions of the Combined Work that, considered in isolation, are
              based on the Application, and not on the Linked Version.

                The "Corresponding Application Code" for a Combined Work means the
              object code and/or source code for the Application, including any data
              and utility programs needed for reproducing the Combined Work from the
              Application, but excluding the System Libraries of the Combined Work.

                1. Exception to Section 3 of the GNU GPL.

                You may convey a covered work under sections 3 and 4 of this License
              without being bound by section 3 of the GNU GPL.

                2. Conveying Modified Versions.

                If you modify a copy of the Library, and, in your modifications, a
              facility refers to a function or data to be supplied by an Application
              that uses the facility (other than as an argument passed when the
              facility is invoked), then you may convey a copy of the modified
              version:

                 a) under this License, provided that you make a good faith effort to
                 ensure that, in the event an Application does not supply the
                 function or data, the facility still operates, and performs
                 whatever part of its purpose remains meaningful, or

                 b) under the GNU GPL, with none of the additional permissions of
                 this License applicable to that copy.

                3. Object Code Incorporating Material from Library Header Files.

                The object code form of an Application may incorporate material from
              a header file that is part of the Library.  You may convey such object
              code under terms of your choice, provided that, if the incorporated
              material is not limited to numerical parameters, data structure
              layouts and accessors, or small macros, inline functions and templates
              (ten or fewer lines in length), you do both of the following:

                 a) Give prominent notice with each copy of the object code that the
                 Library is used in it and that the Library and its use are
                 covered by this License.

                 b) Accompany the object code with a copy of the GNU GPL and this license
                 document.

                4. Combined Works.

                You may convey a Combined Work under terms of your choice that,
              taken together, effectively do not restrict modification of the
              portions of the Library contained in the Combined Work and reverse
              engineering for debugging such modifications, if you also do each of
              the following:

                 a) Give prominent notice with each copy of the Combined Work that
                 the Library is used in it and that the Library and its use are
                 covered by this License.

                 b) Accompany the Combined Work with a copy of the GNU GPL and this license
                 document.

                 c) For a Combined Work that displays copyright notices during
                 execution, include the copyright notice for the Library among
                 these notices, as well as a reference directing the user to the
                 copies of the GNU GPL and this license document.

                 d) Do one of the following:

                     0) Convey the Minimal Corresponding Source under the terms of this
                     License, and the Corresponding Application Code in a form
                     suitable for, and under terms that permit, the user to
                     recombine or relink the Application with a modified version of
                     the Linked Version to produce a modified Combined Work, in the
                     manner specified by section 6 of the GNU GPL for conveying
                     Corresponding Source.

                     1) Use a suitable shared library mechanism for linking with the
                     Library.  A suitable mechanism is one that (a) uses at run time
                     a copy of the Library already present on the user's computer
                     system, and (b) will operate properly with a modified version
                     of the Library that is interface-compatible with the Linked
                     Version.

                 e) Provide Installation Information, but only if you would otherwise
                 be required to provide such information under section 6 of the
                 GNU GPL, and only to the extent that such information is
                 necessary to install and execute a modified version of the
                 Combined Work produced by recombining or relinking the
                 Application with a modified version of the Linked Version. (If
                 you use option 4d0, the Installation Information must accompany
                 the Minimal Corresponding Source and Corresponding Application
                 Code. If you use option 4d1, you must provide the Installation
                 Information in the manner specified by section 6 of the GNU GPL
                 for conveying Corresponding Source.)

                5. Combined Libraries.

                You may place library facilities that are a work based on the
              Library side by side in a single library together with other library
              facilities that are not Applications and are not covered by this
              License, and convey such a combined library under terms of your
              choice, if you do both of the following:

                 a) Accompany the combined library with a copy of the same work based
                 on the Library, uncombined with any other library facilities,
                 conveyed under the terms of this License.

                 b) Give prominent notice with the combined library that part of it
                 is a work based on the Library, and explaining where to find the
                 accompanying uncombined form of the same work.

                6. Revised Versions of the GNU Lesser General Public License.

                The Free Software Foundation may publish revised and/or new versions
              of the GNU Lesser General Public License from time to time. Such new
              versions will be similar in spirit to the present version, but may
              differ in detail to address new problems or concerns.

                Each version is given a distinguishing version number. If the
              Library as you received it specifies that a certain numbered version
              of the GNU Lesser General Public License "or any later version"
              applies to it, you have the option of following the terms and
              conditions either of that published version or of any later version
              published by the Free Software Foundation. If the Library as you
              received it does not specify a version number of the GNU Lesser
              General Public License, you may choose any version of the GNU Lesser
              General Public License ever published by the Free Software Foundation.

                If the Library as you received it specifies that a proxy can decide
              whether future versions of the GNU Lesser General Public License shall
              apply, that proxy's public statement of acceptance of any version is
              permanent authorization for you to choose that version for the
              Library.


   PartIO (https://www.disneyanimation.com/technology/partio.html)

              BSD 3-Clause License (with specific non-attribution clause)
              (https://github.com/wdas/partio/blob/master/src/lib/io/ZIP.h)


              Copyright 2010 Disney Enterprises, Inc. All rights reserved

              Redistribution and use in source and binary forms, with or without
              modification, are permitted provided that the following conditions are
              met:

              * Redistributions of source code must retain the above copyright
              notice, this list of conditions and the following disclaimer.

              * Redistributions in binary form must reproduce the above copyright
              notice, this list of conditions and the following disclaimer in
              the documentation and/or other materials provided with the
              distribution.

              * The names "Disney", "Walt Disney Pictures", "Walt Disney Animation
              Studios" or the names of its contributors may NOT be used to
              endorse or promote products derived from this software without
              specific prior written permission from Walt Disney Pictures.

              Disclaimer: THIS SOFTWARE IS PROVIDED BY WALT DISNEY PICTURES AND
              CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
              BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
              FOR A PARTICULAR PURPOSE, NONINFRINGEMENT AND TITLE ARE DISCLAIMED.
              IN NO EVENT SHALL WALT DISNEY PICTURES, THE COPYRIGHT HOLDER OR
              CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
              EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
              PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
              PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND BASED ON ANY
              THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
              (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
              OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


   miniz (https://github.com/richgel999/miniz)

              Public Domain/MIT License
              (https://github.com/richgel999/miniz/blob/master/LICENSE)


              This is free and unencumbered software released into the public domain.

              Anyone is free to copy, modify, publish, use, compile, sell, or
              distribute this software, either in source code form or as a compiled
              binary, for any purpose, commercial or non-commercial, and by any
              means.

              In jurisdictions that recognize copyright laws, the author or authors
              of this software dedicate any and all copyright interest in the
              software to the public domain. We make this dedication for the benefit
              of the public at large and to the detriment of our heirs and
              successors. We intend this dedication to be an overt act of
              relinquishment in perpetuity of all present and future rights to this
              software under copyright law.

              THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
              EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
              IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
              OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
              ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
              OTHER DEALINGS IN THE SOFTWARE.

              For more information, please refer to <http://unlicense.org/>

              Copyright 2013-2014 RAD Game Tools and Valve Software
              Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
              All Rights Reserved.

              Permission is hereby granted, free of charge, to any person obtaining a copy
              of this software and associated documentation files (the "Software"), to deal
              in the Software without restriction, including without limitation the rights
              to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
              copies of the Software, and to permit persons to whom the Software is
              furnished to do so, subject to the following conditions:

              The above copyright notice and this permission notice shall be included in
              all copies or substantial portions of the Software.

              THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
              IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
              FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
              AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
              LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
              OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
              THE SOFTWARE.


                                                                            ()
