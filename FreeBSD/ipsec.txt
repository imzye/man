IPSEC(4)               FreeBSD Kernel Interfaces Manual               IPSEC(4)

NAME
     ipsec – Internet Protocol Security protocol

SYNOPSIS
     options IPSEC
     options IPSEC_SUPPORT
     device crypto

     #include <sys/types.h>
     #include <netinet/in.h>
     #include <netipsec/ipsec.h>
     #include <netipsec/ipsec6.h>

DESCRIPTION
     ipsec is a security protocol implemented within the Internet Protocol
     layer of the networking stack.  ipsec is defined for both IPv4 and IPv6
     (inet(4) and inet6(4)).  ipsec is a set of protocols, ESP (for
     Encapsulating Security Payload) AH (for Authentication Header), and
     IPComp (for IP Payload Compression Protocol) that provide security
     services for IP datagrams.  AH both authenticates and guarantees the
     integrity of an IP packet by attaching a cryptographic checksum computed
     using one-way hash functions.  ESP, in addition, prevents unauthorized
     parties from reading the payload of an IP packet by also encrypting it.
     IPComp tries to increase communication performance by compressing IP
     payload, thus reducing the amount of data sent.  This will help nodes on
     slow links but with enough computing power.  ipsec operates in one of two
     modes: transport mode or tunnel mode.  Transport mode is used to protect
     peer-to-peer communication between end nodes.  Tunnel mode encapsulates
     IP packets within other IP packets and is designed for security gateways
     such as VPN endpoints.

     System configuration requires the crypto(4) subsystem.

     The packets can be passed to a virtual enc(4) interface, to perform
     packet filtering before outbound encryption and after decapsulation
     inbound.

     To properly filter on the inner packets of an ipsec tunnel with
     firewalls, you can change the values of the following sysctls

     Name                             Default    Enable
     net.inet.ipsec.filtertunnel      0          1
     net.inet6.ipsec6.filtertunnel    0          1

   Kernel interface
     ipsec is controlled by a key management and policy engine, that reside in
     the operating system kernel.  Key management is the process of
     associating keys with security associations, also know as SAs.  Policy
     management dictates when new security associations created or destroyed.

     The key management engine can be accessed from userland by using PF_KEY
     sockets.  The PF_KEY socket API is defined in RFC2367.

     The policy engine is controlled by an extension to the PF_KEY API,
     setsockopt(2) operations, and sysctl(3) interface.  The kernel implements
     an extended version of the PF_KEY interface and allows the programmer to
     define IPsec policies which are similar to the per-packet filters.  The
     setsockopt(2) interface is used to define per-socket behavior, and
     sysctl(3) interface is used to define host-wide default behavior.

     The kernel code does not implement a dynamic encryption key exchange
     protocol such as IKE (Internet Key Exchange).  Key exchange protocols are
     beyond what is necessary in the kernel and should be implemented as
     daemon processes which call the APIs.

   Policy management
     IPsec policies can be managed in one of two ways, either by configuring
     per-socket policies using the setsockopt(2) system calls, or by
     configuring kernel level packet filter-based policies using the PF_KEY
     interface, via the setkey(8) you can define IPsec policies against
     packets using rules similar to packet filtering rules.  Refer to
     setkey(8) on how to use it.

     Depending on the socket's address family, IPPROTO_IP or IPPROTO_IPV6
     transport level and IP_IPSEC_POLICY or IPV6_IPSEC_POLICY socket options
     may be used to configure per-socket security policies.  A properly-formed
     IPsec policy specification structure can be created using
     ipsec_set_policy(3) function and used as socket option value for the
     setsockopt(2) call.

     When setting policies using the setkey(8) command, the “default” option
     instructs the system to use its default policy, as explained below, for
     processing packets.  The following sysctl variables are available for
     configuring the system's IPsec behavior.  The variables can have one of
     two values.  A 1 means “use”, which means that if there is a security
     association then use it but if there is not then the packets are not
     processed by IPsec.  The value 2 is synonymous with “require”, which
     requires that a security association must exist for the packets to move,
     and not be dropped.  These terms are defined in ipsec_set_policy(8).

     Name                                 Type          Changeable
     net.inet.ipsec.esp_trans_deflev      integer       yes
     net.inet.ipsec.esp_net_deflev        integer       yes
     net.inet.ipsec.ah_trans_deflev       integer       yes
     net.inet.ipsec.ah_net_deflev         integer       yes
     net.inet6.ipsec6.esp_trans_deflev    integer       yes
     net.inet6.ipsec6.esp_net_deflev      integer       yes
     net.inet6.ipsec6.ah_trans_deflev     integer       yes
     net.inet6.ipsec6.ah_net_deflev       integer       yes

     If the kernel does not find a matching, system wide, policy then the
     default value is applied.  The system wide default policy is specified by
     the following sysctl(8) variables.  0 means “discard” which asks the
     kernel to drop the packet.  1 means “none”.

     Name                           Type          Changeable
     net.inet.ipsec.def_policy      integer       yes
     net.inet6.ipsec6.def_policy    integer       yes

   Miscellaneous sysctl variables
     When the ipsec protocols are configured for use, all protocols are
     included in the system.  To selectively enable/disable protocols, use
     sysctl(8).

     Name                             Default
     net.inet.esp.esp_enable          On
     net.inet.ah.ah_enable            On
     net.inet.ipcomp.ipcomp_enable    On

     In addition the following variables are accessible via sysctl(8), for
     tweaking the kernel's IPsec behavior:

     Name                                 Type          Changeable
     net.inet.ipsec.ah_cleartos           integer       yes
     net.inet.ipsec.ah_offsetmask         integer       yes
     net.inet.ipsec.dfbit                 integer       yes
     net.inet.ipsec.ecn                   integer       yes
     net.inet.ipsec.debug                 integer       yes
     net.inet.ipsec.natt_cksum_policy     integer       yes
     net.inet.ipsec.check_policy_history  integer       yes
     net.inet6.ipsec6.ecn                 integer       yes
     net.inet6.ipsec6.debug               integer       yes

     The variables are interpreted as follows:

     ipsec.ah_cleartos
             If set to non-zero, the kernel clears the type-of-service field
             in the IPv4 header during AH authentication data computation.
             This variable is used to get current systems to inter-operate
             with devices that implement RFC1826 AH.  It should be set to non-
             zero (clear the type-of-service field) for RFC2402 conformance.

     ipsec.ah_offsetmask
             During AH authentication data computation, the kernel will
             include a 16bit fragment offset field (including flag bits) in
             the IPv4 header, after computing logical AND with the variable.
             The variable is used for inter-operating with devices that
             implement RFC1826 AH.  It should be set to zero (clear the
             fragment offset field during computation) for RFC2402
             conformance.

     ipsec.dfbit
             This variable configures the kernel behavior on IPv4 IPsec tunnel
             encapsulation.  If set to 0, the DF bit on the outer IPv4 header
             will be cleared while 1 means that the outer DF bit is set
             regardless from the inner DF bit and 2 indicates that the DF bit
             is copied from the inner header to the outer one.  The variable
             is supplied to conform to RFC2401 chapter 6.1.

     ipsec.ecn
             If set to non-zero, IPv4 IPsec tunnel encapsulation/decapsulation
             behavior will be friendly to ECN (explicit congestion
             notification), as documented in draft-ietf-ipsec-ecn-02.txt.
             gif(4) talks more about the behavior.

     ipsec.debug
             If set to non-zero, debug messages will be generated via
             syslog(3).

     ipsec.natt_cksum_policy
             Controls how the kernel handles TCP and UDP checksums when ESP in
             UDP encapsulation is used for IPsec transport mode.  If set to a
             non-zero value, the kernel fully recomputes checksums for inbound
             TCP segments and UDP datagrams after they are decapsulated and
             decrypted.  If set to 0 and original addresses were configured
             for corresponding SA by the IKE daemon, the kernel incrementally
             recomputes checksums for inbound TCP segments and UDP datagrams.
             If addresses were not configured, the checksums are ignored.

     ipsec.check_policy_history
             Enables strict policy checking for inbound packets.  By default,
             inbound security policies check that packets handled by IPsec
             have been decrypted and authenticated.  If this variable is set
             to a non-zero value, each packet handled by IPsec is checked
             against the history of IPsec security associations.  The IPsec
             security protocol, mode, and SA addresses must match.

     Variables under the net.inet6.ipsec6 tree have similar meanings to those
     described above.

PROTOCOLS
     The ipsec protocol acts as a plug-in to the inet(4) and inet6(4)
     protocols and therefore supports most of the protocols defined upon those
     IP-layer protocols.  The icmp(4) and icmp6(4) protocols may behave
     differently with ipsec because ipsec can prevent icmp(4) or icmp6(4)
     routines from looking into the IP payload.

SEE ALSO
     ioctl(2), socket(2), ipsec_set_policy(3), crypto(4), enc(4), if_ipsec(4),
     icmp6(4), intro(4), ip6(4), setkey(8), sysctl(8)

     S. Kent and R. Atkinson, IP Authentication Header, RFC 2404.

     S. Kent and R. Atkinson, IP Encapsulating Security Payload (ESP), RFC
     2406.

STANDARDS
     Daniel L. McDonald, Craig Metz, and Bao G. Phan, PF_KEY Key Management
     API, Version 2, RFC, 2367.

     D. L. McDonald, A Simple IP Security API Extension to BSD Sockets,
     internet draft, draft-mcdonald-simple-ipsec-api-03.txt, work in progress
     material.

HISTORY
     The original ipsec implementation appeared in the WIDE/KAME IPv6/IPsec
     stack.

     For FreeBSD 5.0 a fully locked IPsec implementation called fast_ipsec was
     brought in.  The protocols drew heavily on the OpenBSD implementation of
     the IPsec protocols.  The policy management code was derived from the
     KAME implementation found in their IPsec protocols.  The fast_ipsec
     implementation lacked ip6(4) support but made use of the crypto(4)
     subsystem.

     For FreeBSD 7.0 ip6(4) support was added to fast_ipsec.  After this the
     old KAME IPsec implementation was dropped and fast_ipsec became what now
     is the only ipsec implementation in FreeBSD.

BUGS
     There is no single standard for the policy engine API, so the policy
     engine API described herein is just for this implementation.

     AH and tunnel mode encapsulation may not work as you might expect.  If
     you configure inbound “require” policy with an AH tunnel or any IPsec
     encapsulating policy with AH (like “esp/tunnel/A-B/use
     ah/transport/A-B/require”), tunnelled packets will be rejected.  This is
     because the policy check is enforced on the inner packet on reception,
     and AH authenticates encapsulating (outer) packet, not the encapsulated
     (inner) packet (so for the receiving kernel there is no sign of
     authenticity).  The issue will be solved when we revamp our policy engine
     to keep all the packet decapsulation history.

     When a large database of security associations or policies is present in
     the kernel the SADB_DUMP and SADB_SPDDUMP operations on PF_KEY sockets
     may fail due to lack of space.  Increasing the socket buffer size may
     alleviate this problem.

     The IPcomp protocol may occasionally error because of zlib(3) problems.

     This documentation needs more review.

FreeBSD 13.1-RELEASE-p2        February 6, 2017        FreeBSD 13.1-RELEASE-p2
