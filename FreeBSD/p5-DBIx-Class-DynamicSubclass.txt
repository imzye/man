DBIx::Class::DynamicSubclass(3)            User Contributed Perl Documentation


NAME
       DBIx::Class::DynamicSubclass - Convenient way to use dynamic
       subclassing.

SYNOPSIS
           package My::Schema::Game;

           __PACKAGE__->load_components(qw/DynamicSubclass Core/);
           __PACKAGE__->add_column(qw/id name data type/);

           __PACKAGE__->typecast_map(type => {
               1 => 'My::Schema::Game::Online',
               2 => 'My::Schema::Game::Shareware',
               3 => 'My::Schema::Game::PDA',
           });

           $game = $schema->resultset('Game')->new({..., type => 1});
           #  ref $game = 'My::Schema::Game::Online'

           @games = $game->search({type => 2});
           # @games are all of class My::Schema::Game::Shareware

           $game->type(3); # game is now of class My::Schema::Game::PDA

           $game =  $schema->resultset('Game')->new({});
           # or
           $game->type(undef);
           # game is now of type My::Schema::Game


           #Dynamic properties with DBIx::Class::FrozenColumns
           package My::Schema::Game;
           __PACKAGE__->load_components(qw/... FrozenColumns .../);

           package My::Schema::Game::Online;
           use base 'My::Schema::Game';
           __PACKAGE__->add_frozen_columns(data => qw/flash server_host server_port/);

           package My::Schema::Game::Shareware;
           use base 'My::Schema::Game';
           __PACKAGE__->add_frozen_columns(data => qw/price download_url/);

           ...

           $game->type(1); #game would have now additional columns 'flash', 'server_host', etc.
           $game->server_host('...'); #(stored in 'data')

           $game->type(2);
           $game->server_host; #error
           $game->price('$3.00'); #ok

           $game = $rs->new({
               type  => 1,
               flash => 'game.swf',
           }); #ok

           #More flexible way

           package My::Schema::Game;
           __PACKAGE__->typecast_column('type');

           sub classify { #called each time the object gets or losses its 'type'
               my $self = shift;
               #decide which class do you want
               bless $self, $class;
           }

DESCRIPTION
       This plugin implements methodics described here
       "Dynamic_Sub-classing_DBIx::Class_proxy_classes_(AKA_multi-class_object_inflation_from_one_table)"
       in DBIx::Class::Manual::Cookbook.

       DynamicSubclass has 2 ways to work: static defining and dynamic
       defining.

       Static defining is used in most cases. This is when you define

           __PACKAGE__->typecast_map(defining_column => {column_value => 'subclass', ...});

       The plugin preloads all of the subclasses and changes the class of the
       row object when you are creating new object or fetching it from a
       database or changing 'defining_column' value.  If the value is not
       exists in the 'typecast_map' then object is blessed into the base class
       and losses all of its additional methods/columns/etc.

       Dynamic defining is when you only say

           __PACKAGE__->typecast_column('defining_column');

       and define a method 'classify' that would bless a row object into
       proper class.  This method is called when object is created, fetched or
       have its 'defining_column' value changed.

METHODS
   typecast_map
       Arguments: $column, %typecast_hash

       %typecast_hash is a hash with keys equal to possible $column values and
       with subclasses as values.

   classify
       A standart method for static subclassing. You should redefine this
       method in your result source in order to use dynamic subclassing
       (second way).

OVERLOADED METHODS
       new, inflate_result, store_column

SEE ALSO
       DBIx::Class, DBIx::Class::FrozenColumns.

AUTHOR
       Pronin Oleg <syber@cpan.org>

LICENSE
       You may distribute this code under the same terms as Perl itself.

perl v5.40.2                      2008-06-24   DBIx::Class::DynamicSubclass(3)
