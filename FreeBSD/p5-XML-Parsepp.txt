XML::Parsepp(3)       User Contributed Perl Documentation      XML::Parsepp(3)


NAME
       XML::Parsepp - Simplified pure perl parser for XML

SYNOPSIS
         use XML::Parsepp;

         $p1 = new XML::Parsepp;
         $p1->parsefile('REC-xml-19980210.xml');
         $p1->parse('<foo id="me">Hello World</foo>');

         # Alternative
         $p2 = new XML::Parsepp(Handlers => {Start => \&handle_start,
                                             End   => \&handle_end,
                                             Char  => \&handle_char});
         $p2->parse($socket);

         # Another alternative
         $p3 = new XML::Parsepp;

         $p3->setHandlers(Char    => \&text,
                          Default => \&other);

         open(FOO, 'xmlgenerator |');
         $p3->parse(*FOO);
         close(FOO);

         $p3->parsefile('junk.xml');

       Allow duplicate attributes with option: dupatt => ';'

       The concatenation string XML::Parsepp->new(dupatt => $str) is
       restricted to printable ascii excluding " and '

         $p1 = new XML::Parsepp(dupatt => ';');
         $p1->parse('<foo id="me" id="too">Hello World</foo>');

       This will fire the Start event with the following parameters

         start($ExpatNB, 'foo', 'id', 'me;too');

DESCRIPTION
       This module provides a pure Perl implementation to parse XML documents.
       Its interface is very close to that of XML::Parser (in fact, the
       synopsis has, with some minor modifications, been copied from
       XML::Parser).

USAGE
       XML::Parsepp can be used as a pure Perl alternative to XML::Parser. The
       main use case is with XML::Reader where it can be used as a drop-in
       replacement. Here is a sample:

         use XML::Reader qw(XML::Parsepp);

         my $text = q{<init>n <?test pi?> t<page node="400">m <!-- remark --> r</page></init>};

         my $rdr = XML::Reader->new(\$text) or die "Error: $!";
         while ($rdr->iterate) {
             printf "Path: %-19s, Value: %s\n", $rdr->path, $rdr->value;
         }

AUTO-GENERATE TESTCASES
       You can use the module XML::Parsepp::Testgen to generate testcases.

       For example, you can generate a test file from an existing XML with the
       following program:

         use XML::Parsepp::Testgen qw(xml_2_test);

         my $xml =
           qq{#! Testdata for XML::Parsepp\n}.
           qq{#! Ver 0.01\n}.
           qq{<?xml version="1.0" encoding="ISO-8859-1"?>\n}.
           qq{<!DOCTYPE dialogue [\n}.
           qq{  <!ENTITY nom0 "<data>y<item>y &nom1; zz</data>">\n}.
           qq{  <!ENTITY nom1 "<abc>def</abc></item>">\n}.
           qq{]>\n}.
           qq{<root>&nom0;</root>\n}.
           qq{#! ===\n}.
           qq{<?xml version="1.0" encoding="ISO-8859-1"?>\n}.
           qq{<!DOCTYPE dialogue\n}.
           qq{[\n}.
           qq{  <!ENTITY nom1 "aa &nom2; tt &nom4; bb">\n}.
           qq{  <!ENTITY nom2 "c <xx>abba</xx> c tx <ab> &nom3; dd">\n}.
           qq{  <!ENTITY nom3 "dd </ab> <yy>&nom4;</yy> ee">\n}.
           qq{  <!ENTITY nom4 "gg">\n}.
           qq{]>\n}.
           qq{<root>hh &nom1; ii</root>\n};

         print xml_2_test(\$xml), "\n";

       You can also extract the XML from an already existing test file (for
       example 'test.t') as follows:

         use XML::Parsepp::Testgen qw(test_2_xml);

         say test_2_xml('test.t');

AUTHOR
       Klaus Eichner <klaus03@gmail.com>

COPYRIGHT AND LICENSE
       Copyright (C) 2009-2011 by Klaus Eichner

       All rights reserved. This program is free software; you can
       redistribute it and/or modify it under the terms of the artistic
       license 2.0, see
       http://www.opensource.org/licenses/artistic-license-2.0.php

SEE ALSO
       XML::Parsepp::Testgen, XML::Reader, XML::Parser.

perl v5.40.2                      2014-12-28                   XML::Parsepp(3)
