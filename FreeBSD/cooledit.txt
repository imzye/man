cooledit(1)             FreeBSD General Commands Manual            cooledit(1)

NAME
       cooledit-4.1.0 - Full featured text editor for the X Window System,
       Version 11.

USAGE
       cooledit [-AabCEhiPsSUVv?] [options] [[+<line>] [<path>/]<file>]
       [[+<line>] [<path>/]<file>] ...

DISCLAIMER
       The information in this file is provided without warranty for its
       accuracy or completeness. Use of this file or its information is
       entirely at your own risk.

DESCRIPTION
       This is a portable, fast X Window text editor with beautiful 3D
       widgets. It requires only the X11 library to run. The engine is the
       same as that used for the internal editor of the Midnight Commander and
       hence cooledit represents a X Window version of that editor. The
       library that comes with Cooledit is now standalone. You can use it to
       write your own Cool applications. Check out the included programs
       Coolman and Smalledit.

OPTIONS
       -d, -display <display>
              The X server and display you would like to display to.

       -g, -geom, -geometry <geometry>
              Main window size and position on the screen, eg cooledit -geom
              630x490+95+5.  If cooledit is envoked with the size, the size
              will be saved on exit. If cooledit is envoked with the position,
              the position will be saved on exit.  cooledit -geom + envokes
              the default size.

       -lines <n>
              Size of the edit window in text lines.

       -columns <n>
              Size of the edit window in mean character widths.

       -vis, --visual <visual-class> (experimental)
              Without this option, the visual class is selected from a list of
              preferred classes and depth ranges. Use cooledit -vis help for
              more information.

       -C, -cmap, --own-colormap (experimental)
              Force use of own colormap. If Cooledit is started after other
              colour-hungry application, and you are using one of the colour-
              palette visuals (like PseudoColor) the colors may look poor. In
              this case, use this option for a separate colour palette.
              (Contact me if you are forced to use this option.)

       -defcmap, --default-colormap (experimental)
              Force use of default colormap. If Cooledit is started with a
              visual other than the default, then it creates its own colormap.
              This overrides this behaviour.  (Contact me if you are forced to
              use this option.)

       --edit-bg <nn>
              Editor background colour. Rather edit your
              ~/.cedit/.cooledit.ini file, look for the option
              option_editor_bg_normal and others. This can be 0 to 26. Useful
              options are probably only 1 and 0 for dark blue and black.

       -bg, --background-color <color>
              Specifies the background color for a solid background. If
              <color> is igloo (default) then a background color is not used,
              and the background is set to the igloo logo.

       -R, --foreground-red <value>
              Red component of actual widget colors (buttons, windows),
              default: 0.9.

       -G, --foreground-green <value>
              Green component, default: 1.1.

       -B, --foreground-blue <value>
              Blue component, default: 1.4.

       -f, -fn, -font <font-name>
              See FONTS below. Try -fn ? or -fn -h for help.

       --8bit-term-font <font-name>
              If you need the menu option 8-Bit Terminal to use an older X
              font, then use this option.

       --widget-font <font-name>
              Proportional font for the GUI elements.

       -locale, --locale-encoding
              Use locale encoding interpretation.

       -fontset, --fontset
              Tries to load font as a fontset. See FONTS below.  Try -fn ? for
              help. See also --utf8-interpretation.

       --anti-aliasing
              This is depreciated. See FONTS below.

       --interchar-spacing <n>
              Add extra pixels of space between each character. This option
              works with --anti-aliasing only. (Default is 0.)

       --interwidget-spacing <n>
              Spacing between widgets in dialog boxes. Make larger for a more
              spacious. Different defaults for different looks.

       --look [gtk|cool]
              Cooledit widget style Look.

       --red-first
              For LCD displays use R-G-B pixel ordering. (Default.)

       --blue-first
              For LCD displays use B-G-R pixel ordering. Try both of these
              options and see which looks better.

       -S, --suppress-load-files
              Don't load saved desktop on startup.

       -U, --suppress-load-options
              Don't load any saved options on startup.

       -E, -no-override
              Command line must not override any options already set in the
              initialisation file.

       -I, --use-initialisation-file <file>
              Use alternative intialisation file. Default:
              ~/.cedit/.cooledit.ini

       -i, --all-characters
              No longer an option. Now the default.

       --word-wrap <length>
              The maximum length of a line. See the next two options.

       --type-writer
              This option causes a newline to be inserted when the line you
              are typing becomes longer than --word-wrap length.

       --auto-paragraph
              This is a more advanced form of the option above: it causes the
              entire paragraph to be reformatted with each edit of a
              paragraph.  See WORD PROCESSOR MODE below.

       -t, -tab, --tab-spacing <spacing>
              Interpret the tab character as being the length of <spacing>
              characters. Default is 8. You should avoid using other than 8
              since most other editors and text viewers assume a tab spacing
              of 8. Use -fake-half-tabs to simulate a smaller tab spacing.

       -s, -space, --space-filled-tabs
              Never insert a tab space. Rather insert spaces (ascii 20h) to
              fill to the desired tab size.

       -nospace, --no-space-filled-tabs
              Default.

       -a, --auto-indent
              Pressing return will tab across to match the indentation of the
              first line above that has text on it (default).

       -noautoi, --no-auto-indent
              Turn off auto tabs.

       -b, --backspace-through-tabs
              Make a single backspace delete all the space to the left margin
              if there is no text between the cursor and the left margin.

       -noback, --no-backspace-through-tabs
              Default.

       -half, --fake-half-tabs
              This will emulate a half tab for those who want to program with
              a tab spacing of 4, but do not want the tab size changed from 8
              (so that the code will be formatted the same when displayed by
              other programs). When editing between text and the left margin,
              moving and tabbing will be as though a tab space were 4, while
              actually using spaces and normal tabs for an optimal fill.  When
              editing anywhere else, a normal tab is inserted.

       -no-half, --no-fake-half-tabs
              Turn off half tabbing.

       -toolbar
              Edit windows have a toolbar on the left: default.

       --no-xim
              Disable XIM support.

       -no-toolbar
              Edit windows do not have a toolbar.

       -m, --minimal-main-window
              This is used internally to create a new main window with one
              edit window when the user activates `New Main Window' from the
              Window menu. You can also use it to force the main window to be
              just large enough to hold all the sub-windows.

       -A, -save-setup
              Save options on exit (default).

       -P, -no-save-setup
              Don't save options on exit.

       -W, --whole-chars-search <chars>
              Characters that constitute a whole word when searching, default:
              0-9a-z_ (typed out in full)

       -w, --whole-chars-move <chars>
              Characters that constitute a whole word when moving and
              deleting, default: 0-9a-z_; ,[](){} (typed out in full)

       -verbose
              Print info about X intialisation.

       -h, -H, -?, --help
              Print out commandline options summary.

       -V, -v, --version
              Print out version number.

Commandline examples
       cooledit +10 hello.c -S -geom +
              Start cooledit with one file, with minimum geometry, with cursor
              at line 10.

       cooledit hello.c program.c
              Start cooledit with two files, the file hello.c being the
              current file. The previous files are also loaded underneath
              these two files.

DEFAULT KEY DEFINITIONS
       Keys may be redefined using an easy to use key learner.  See the next
       section on how to get this to work.

       The following is a partial list of all default key bindings and their
       actions, for reference. You will probably never need to refer to it
       because most of the editor actions can be found in the menus. Note that
       F14 is analogous to Shift-F4 etc. Also be aware that on some machines,
       what X percieves as an Alt is actually some other modifier key (our
       Sun-Sparc uses the diamond key).

       Movement keys:
          Left                    left one char
          Right                   right one char
          Up                      up one line
          Down                    down one line
          Home                    beginning of line
          End                     end of line
          PgUp                    up one screen full
          PgDn                    down one screen full
          Ctrl-PgUp               beginning of file
          Ctrl-PgDn               end file
          Ctrl-Home               beginning of page
          Ctrl-End                end of page
          Ctrl-Left               left one word
          Ctrl-Right              right one word
          Ctrl-Up                 up one paragraph
          Ctrl-Down               down one paragraph
          Alt-Up                  scroll up one line
          Alt-Down                scroll down one line

       Highlight keys:
          Shift with any of the above keys will highlight
          at the same time.

       Column highlighting:
          Holding down the Control key while using the mouse to highlight text,
          will cause the highlighted text to be displayed in inverse colour. You
          will be able to select columns (arbitrary rectangles) of text and
          drag and drop them as usual.

       Input History:
          When editing an input line, Shift-Up or Shift-Down
          will bring up a history of previous inputs.

       Editing keys:
          Delete                  delete char to the right
          Backspace               delete char to the left
          Alt-Del                 delete to line end
          Alt-Backspace           delete to line begin
          Alt-Right               delete word to the right
          Alt-Left                delete word to the left
          F5                      copy highlighted text to cursor
          F6                      move highlighted text to cursor
          F8                      delete highlighted text
          Ctrl-y                  delete line
          Shift-Enter             insert a newline
          Enter                   insert a newline with auto indent (default)
          Tab                     insert a tab (see options menu)
          Insert                  toggle insert/overwrite
          Ctrl-q                  quote - the next key pressed will be
                                  interpreted as a literal
       Undo:
          Ctrl-u
          Ctrl-Backspace

       File
          Ctrl-F1                 man page
          F2                      save
          F12 or
          Shift-F2                save as
          Ctrl-o                  load
          Ctrl-j                  jump to file under cursor
          Ctrl-n                  new
          Ctrl-f                  save highlighted text as
          Shift-F5 or
          F15                     insert file at cursor

       Mark:
          F3                      toggle highlight
          Ctrl-b                  toggle highlight columns

       Search and replace:
          F7                      search
          F17 or
          Shift-F7                search again
          F4                      replace
          F14 or
          Shift-F4                replace again

       X Clipboard:
          Ctrl-Ins                copy to clipboard
          Shift-Ins               paste to clipboard
          Shift-Delete            cut to clipboard
          Ctrl-Delete             delete highlighted text
          Alt-Ins                 insert from selection history

       General:
          F10                     exit (current editor)
          Alt-F10                 exit (editor at the bottom of the stack)
          Ctrl-F3                 new edit window
          Shift-F3                new main window
          Alt-F6                  maximise the window
          Ctrl-F6                 window cycle
          Ctrl-F2                 save state of desktop
          Ctrl-d                  insert date and time
          Alt-l                   goto line number
          Alt-F7                  run make
          Alt-t                   sort
          Ctrl-r                  start/end record macro
          Ctrl-a                  execute macro
          Ctrl-p                  spell check highlighted text
          Shift-F9                C formatter
          Ctrl-Tab                complete word
          Alt-i                   insert unicode character
          Shift/F1                rxvt/xterm terminal

       Debug:
          Alt-F2                  toggle breakpoint
          Alt-F3                  continue until cursor
          Alt-F4                  continue
          Alt-F5                  run from beginning
          Alt-F8                  single step, dive into functions
          Alt-F9                  single step, skip over functions
          Ctrl-c                  interrupt program
       New shell scripts will be added from time to time. Consult the Scripts
       menu for the hotkeys that envoke these.

EMERGENCIES
       keywords: hang, crash, halt, pause, stop, infinite loop, SIGHUP,
       SIGUSR1.

       There are some circumstances when Cooledit may go into an infinite
       loop, like if there is a bug in the editor movement commands, or if you
       create a recursive macro. In this case, you can  restore Cooledit by
       using the kill shell function. Try kill -SIGUSR1 pid  where pid is the
       process ID of cooledit from: ps | grep cooledit, for example. This will
       send SIGUSR1, a user signal, which, for Cooledit, will force a jump
       into its main loop, and restore operation. It is a good idea to then
       save what you have done and exit immediately in case there has been
       memory corruption.

SPELL CHECK AS YOU TYPE
       Cooledit spell checks typed words on the fly, placing the traditional
       wavy red line under miss-spelled words. This works by feeding typed
       words through ispell and placing them amidst the syntax highlighting
       rules if ispell returns a non-match. These rules expire after 60
       seconds - which mean they won't stay underlined indefinitely. Word
       feeding is initiated by most key presses and applies only to the word
       under the cursor.

       ispell or some alternative like aspell must be installed.

UNICODE AND UTF-8 SUPPORT
       Cooledit has full Unicode support without character combining.

       See See FONTS below.

THE INTERACTIVE GRAPHICAL DEBUGGER
       Cooledit features an interface to gdb(1) under the Debug menu. This
       means that you can seamlessly debug C/C++ programs from within
       Cooledit. You can set and clear breakpoints (the line is bookmarked in
       red) and follow the program flow with the green cursor line. Please
       remember that this an interface to gdb: Cooledit has no debugging
       features of its own. Some versions of gdb are better supported than
       others.

       Interfaces are given to the common gdb commands. Any other commands can
       be executed with the Enter Command menu item. Automatic variable
       displays will soon be available though.

       When a program stops for some reason (either a breakpoint or a signal),
       Cooledit tries to determine the file and line number. If this cannot be
       done, a backtrace is displayed. Backtraces do not contain full paths,
       hence files cannot be located if they are not already loaded. If the
       file is already loaded, then hitting enter on a file:line backtrace
       line will jump to the currect line number.

       Programs must of course be compiled with the -g option and preferably
       the -O0 option (without -O0 gcc's optimizations may make the program
       flow appear a little strange and some variables will not be
       accessible).

       Break-points are set and cleared from the menu or with Alt-F2. If you
       set a break point manually (with Alt-F1) it will not display in the
       edit window. Similarly if you clear a break point manually or close a
       window (thus clearing the breakpoints) there will be discrepancy
       between the book marks and the actual breakpoints. The same goes if you
       modify a file without restarting gdb.

       Variables can be displayed by selecting Display variable.... A listbox
       will show all the variables you have selected. Click on the listbox and
       press Del to delete from this list. Use Ins to highlight a variable -
       this will cause a watchpoint to be inserted for this variable (i.e. the
       program will thereafter stop whenever the value of that variable
       changes). The listbox will also show an X in the second column if the
       variable has been altered since the last time the listbox was refreshed
       - this enables you to easily see which variable changes as you step
       through the lines of your program.

       Everything else you need to know is obvious from the menu. You would do
       well to read gdb's info pages if you have never used a debugger under
       Unix before.

       See also the section JUMP TO FILE AND YOUR PERSONAL FILE LIST regarding
       how Cooledit will consult your personal file list to resolve a path to
       a file.

SYNTAX HIGHLIGHTING
       The following section explains the format of the file ~/.cedit/syntax
       which is the initiation file for colorizing source.

       The file ~/.cedit/Syntax is rescanned on opening of any new editor
       file. It contains a list of file types and how to identify what rule
       set the text you are editing belongs to. The file token dictates how to
       match up your text. On the same line as a file token must appear a
       regular expression to match the filename, a string to be displayed on
       the left of the editor window for description purposes, and a regular
       expression to match the first line of the file. If either of the
       regular expressions match, the file is deemed to have the particular
       type. For example

       file ..\*\\.(py|PY])$ Python\sProgram ^#!\s\*/.\*/python

       Will cause a file to be labelled as Python Program if it contains say,
       #!/usr/bin/python, on the first line OR of it ends in say .py.

       Note that *, + and \ have to be escaped with a \, and space must be
       presented with a \s.

       After the file keyword may come the include keyword. The include
       keyword says to load a rule set from a separate file, and is the
       preferred way of adding new rule sets. The path from where it loads
       defaults to cooledit/syntax/ under the lib/ directory where you
       installed Cooledit. See the examples in your own Syntax file and in
       this directory.

       Each rule set is divided into contexts, and each context contains
       keyword definitions. A context is a scope within the text that a
       particular set of keywords applies to. For instance, the region within
       a C style quote (i.e. between " quotations) has its own separate colour
       and hence its own separate context. Within it, the normal C tokens,
       like if and while, will not apply, but %d should be highlighted in a
       different colour. Contexts are usually for when you have something that
       must be coloured across multiple lines. The default context contains
       the list of keywords to fall back on should there be no other
       applicable context. This is usually normal programming code.

       A trivial C programming rule set might look like this:

       file .\*\\.c C\sProgram\sFile (#include|/\\\*)

       wholechars abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_

       # default colors
       context default
         keyword  whole  if       yellow/24
         keyword  whole  else     yellow/24
         keyword  whole  for      yellow/24
         keyword  whole  while    yellow/24
         keyword  whole  do       yellow/24
         keyword  whole  switch   yellow/24
         keyword  whole  case     yellow/24
         keyword  whole  static   yellow/24
         keyword  whole  extern   yellow/24
         keyword         {        brightcyan/14
         keyword         }        brightcyan/14
         keyword         '*'      green/6

       # C comments
       context /\* \*/ brown/22

       # C preprocessor directives
       context linestart # \n brightred/18
         keyword  \\\n  yellow/24

       # C string constants
       context " " green/6
         keyword  %d    yellow/24
         keyword  %s    yellow/24
         keyword  %c    yellow/24
         keyword  \\"   yellow/24

       Each context starts with a line of the form:
       context [exclusive] [whole|wholeright|wholeleft] [linestart] delim
       [linestart] delim [foreground] [background]

       One exception is the first context. It must start with the command
       context default [foreground] [background]
       or else cooledit will return an error.

       The linestart option dictates that delim must start at the beginning of
       a line.

       The whole option tells that delim must be a whole word. What
       constitutes a whole word are a set of characters that can be changed at
       any point in the file with the wholechars command. The wholechars
       command at the top just sets the set exactly to its default and could
       therefore have been omitted. To specify that a word must be whole on
       the left only, you can use the wholeleft option, and similarly on the
       right. The left and right set of characters can be set separately with,
       wholechars [left|right] characters

       The exclusive option causes the text between the delimiters to be
       colourised, but not the delimiters themselves.

       Each rule is a line of the form:
       keyword [whole|wholeright|wholeleft] [linestart] string foreground
       [background]

       Important to note is the line
         keyword  \\\n  yellow/24
       This line defines a keyword containing the \ and newline characters.
       Because keywords have a higher precedence than context delimiters, this
       keyword prevents the context from ending at the end of a line if the
       line ends in a \ thus allowing C preprocessor directive to continue
       across multiple lines.

       The colours themselves need to apply to the Midnight Commander internal
       editor as well as to Cooledit. Therefore the form
           midnight-commander-color/cooledit-color
       is used. See some of the many rule sets given, for examples on using
       this. Usually the background colour is omitted, thus defaulting to the
       usual background colour.

       Context or keyword strings are interpreted so that you can include tabs
       and spaces with the sequences \t and \s. Newlines and the \ are
       specified with \n and \\ respectively. Since whitespace is used as a
       seperator, it may not be used explicitedly. Also, \* must be used to
       specify a *, and a \+ to specify a +. The * itself is a wildcard that
       matches any length of characters. The + is like the * but matches a
       length of non-whitespace characters only. For example,
         keyword         '+'      green/6
         keyword         '\s'      green/6
       colours all C single character constants green. You could also have
       used
         keyword         "*"      green/6
       to colour string constants, except that the matched string may not
       cross newlines.

       The \{ wild card matches any characters that exists between it and its
       matching \}. For example, the following matches C style octals:
         keyword '\\\{0123\}\{01234567\}\{01234567\}' brightgreen/16

       The \[ \] wild card is similar and matches any number of characters.

       All wild cards may be used within context delimiters as well, but you
       cannot have a wildcard as the first character of a context delimiter.
       In addition, using a wildcard as the first character of a keyword,
       impacts hugely on performance.

       The colours themselves are numbered 0 to 26 and are explained below in
       FURTHER BEHAVIOURAL OPTIONS. You can also use any of the named colors
       specified in /usr/lib/X11/rgb.txt, though only one word versions of
       them. It is better to stick to the numerical colors to limit use of the
       color palette.

       Comments may be included on a line of there own and begin with a #.

       Because of the simplicity of the implementation, there are a few
       intricacies that will not be coped with correctly but these are a minor
       irritation. On the whole, a broad spectrum of quite complicated
       situations are handled with these simple rules. It is a good idea to
       take a look at the syntax file to see some of the nifty tricks you can
       do with a little imagination. If you can't get by with the rules I have
       coded, and you think you have a rule that would be useful, please email
       me with your request. However, do not ask for regular expression
       support, because this is flatly impossible.

       A useful hint is to work as much as possible with the things you can do
       rather than try to do things that this implementation can't cope with.
       Also remember that the aim of syntax highlighting is to make
       programming less prone to error, not to make code look pretty.

COLOURS
       Syntax colours can be any of the integer values 0 through 26. The
       options option_editor_bg_normal in your ~/.cedit/.cooledit.ini file
       (and their counterparts option_editor_fg_normal etc.) can also be set
       to a value of 0 through 26. Each of these 27 colours' RGB values can be
       set to specific values in your ~/.cedit/.cooledit.ini file. They are
       called option_color_0 through option_color_26.  They are in hex with 2
       digits per Red, Green and Blue, (just like HTML specified colours).

COMPLETION
       This would typically be used by typing in half a word (for example
       "str") and then pressing the completion key, "Ctrl-Tab" (Note that
       anything can be completed eg. email addresses.)  A list box will then
       appear showing you all the words on your system  that begin with str:
       strcat, strchr, strcpy etc.  You can select the word to type out. If
       there is only one match then the word will be completed without showing
       the list box. If there is no match then nothing will happen. Note that
       completion is case sensitive Thanks to Michael Zagorsky for this idea.

       Unfortunately, a word-list of completion words is highly dependent on
       your system and the programming language you are using. It is very
       easy to create your own word-list though. The word-list must reside in
       the file "/.cedit/cooledit.completion". The file is simply a list of
       words separated by newlines, preferably  with no duplications. It may
       have leading or trailing blank lines, but there must be no blank lines
       in the text. Of course, having a word in the word-list therefore has
       nothing to do with whether the word will or will not be accepted by the
       programming language you are using.

       The easiest way to create a really comprehensive word-list for C
       programming is just to concatenate, sift and sort all the system header
       files. This is done with the shell script below.  If your system
       commands do not support some of the options used, you should replace
       them with GNU versions from your sunsite mirror. On my system, the
       script creates a file of about a megabyte in size, 83k words, which is
       reasonably small.  The word-list will be loaded when you first press
       the completion key.  You can append to the word-list email addresses,
       TeX commands, shell commands or any other kind of data. You need not
       sort the entries as I have done here, but you should ensure that there
       are no duplicate entries, or the word-list is going to be very long -
       of course 'sort -u' is the easiest way of avoiding duplications. Here
       is an example script that generates a completion list for TeX and C.
       You will have to change TEXDIR and INCLUDEDIR to point to locations for
       your system. This script uses a lot of memory and may take a long time
       to run.

       #!/bin/sh
       #
       TEXDIR="/usr/lib/tex /usr/local/lib/tex /usr/lib/texmf /usr/local/lib/texmf"
       INCLUDEDIR="/usr/qt/include /usr/local/include /usr/include /usr/openwin/include"
       #
       cat `find $INCLUDEDIR \
       -follow -regex '.*\.h'` \
       | sed -e 's/[^A-Za-z0-9_#]/\
       /g' | sed \
       -e 's/^[0-9].*$//g' \
       -e 's/^#[0-9#].*$//g' \
       -e 's/^[A-Za-z0-9_#]$//g' \
       -e 's/^[A-Za-z0-9_#][A-Za-z0-9_#]$//g' \
       -e 's/^[A-Za-z0-9_#][A-Za-z0-9_#][A-Za-z0-9_#]$//g' \
       | cat -s | sort -u > ~/.cedit/cooledit.completion
       cat `find $TEXDIR -follow -regex '.*\.tex'` | \
       sed -e 's/[A-Za-z0-9]\\/&\
       \\/g' | \
       sed -e 's/\\$//g' | \
       sed -e 's/[^A-Za-z0-9\\]/\
       /g' | \
       sed -e 's/\\\\*/\\/g' | \
       sed -e 's/^[A-Za-z0-9].*$//g' \
       -e 's/^\\$//g' \
       -e 's/^\\[A-Za-z0-9\\]$//g' \
       | cat -s | sort -u >> ~/.cedit/cooledit.completion

SCRIPT EXECUTION
       The Scripts  menu has a list of commands that can be executed from hot-
       keys. You can create your own scripts by clicking on New script  and
       filling in the various fields of the dialog. Several predefined
       examples are given in the menu. To get a feel for how this works click
       on Edit a script  and select a predefined script from the list. The
       switches you see in the dialog box are self explanatory.  They cause
       cooledit to perform various functions before and after the execution of
       the script and provide for seamless interfacing between cooledit  and
       compilers or shell commands. The script text may also contain the %
       character to substitute for the editor's file-name, path, etc. For
       instance, if %f is found in the script, it will be, before execution,
       replaced with the file-name of the file you are currently editing. The
       complete list of substitutions is as follows:

       %d     The current directory as set from the Command menu.

       %f     The full file-name of the file you are currently editing,
              without the path.

       %n     The file-name without the extension.

       %x     The file-name extension only.

       %p     The full path of the file-name without the trailing slash.

       %t     The name of a temporary file if needed.

       %b     The name of the block file.

       %c     The name of the clipboard file.

       %e     The name of the error message file.

       %a     The string typed in by the user if they where prompted.

       %F     The current font, or 8x13bold if the current font is a
              proportionally spaced font - use for terminal apps.

       %O     The current font regardless of its size.

       %%     Inserts a literal %.

       Typically commands will process the editor file, or some highlighted
       text, and then output error messages to the error file, which might be
       displayed for viewing.  Studying the examples will give an explanation
       of this.  Note that the options "Display script's stdout/err
       continuously" must not be set simultaneously with "Insert stdout/err on
       completion".  If both are set, the former take precedence.  Also, if
       the script runs in the background, none of the on completion options
       will have effect.

WORD PROCESSOR MODE - AUTO PARAGRAPH FORMATTING
       If the Auto paragraph formatting option is on (Select General from the
       Options menu) then paragraphs will be reformatted as you type. The Word
       wrap line length option specifies the paragraph's maximum width. The
       key Alt-p (`Paragraph_Format' in the Define keys dialog) will force a
       paragraph to be formatted when Auto paragraph formatting is off, and
       will find a paragraph between the illegal lines defined below. A
       paragraph start and end are specified by two consecutive newline
       characters. A "non"-paragraph is one of the following (non-paragraphs
       are not formatted except with with Alt-p):

       -      Paragraphs containing any line that begins with the characters:
              -+*.;:&>.

       -      Paragraphs containing any line (other than the first line) that
              begins with a space or tab character. The first line may contain
              an indent for example.

       This means that all contiguous blocks of text can be bordered by a
       blank line, and they will be nicely paragraphed. Because of the above
       rules, you can pretty much leave paragraph formatting on even when
       programming, since program text will break these rules every time. One
       difference though is that pressing `Enter' in the middle of a line will
       properly break a paragraph with a double newline, unlike normal mode,
       where a only a single newline is inserted.

       One other nifty feature is the formatting of fully indented paragraphs.
       If a paragraph's lines are all identically indented (like a quote),
       then the indent will be retained, while normal formatting occurs. This
       may be a problem when you are trying to type something that must be
       indented, but must not be paragraphed, like a postal address. In this
       case you can make one line begin with an illegal character, or make one
       line be indented more or less than the other lines.

       See also the command-line option "--auto-paragraph", above.

RXVT/XTERM BACKSPACE NOT WORKING
       Some systems use ^? (127d) for Backspace, whereas others use ^H (8d).
       Cooledit's terminal will try to make the correct guess for the local
       system.  This does not work if you ssh somewhere else, and hence you
       may find that Backspace does not work.

       To set the backspace key to produce a ^H character, run this command in
       your shell:

       printf '\e[?67h'

       To set the backspace key to produce a ^? character, run this command in
       your shell:

       printf '\e[?67l'

       It is advisable to add the above commands to your login scripts.  Most
       xterm/rxvt terminals support this control sequence, called "DECBKM -
       Backarrow Key Mode" from VT320 and later terminals, hence it is
       harmless.



RAW CHARACTER INPUT
       The quote key Ctrl-q can be used to insert any decimal or hexidecimal
       number. Ctrl-q and then an ordinary key press interprets that key
       literally,  eg. Ctrl-q then Ctrl-m inserts an ascii Carriage Return or
       13 decimal. This is useful to convert DOS text files to Unix and back.
       Just do a search and replace with   Ctrl-q Ctrl-j Ctrl-q Ctrl-m   as
       one string, and   Ctrl-q Ctrl-j   as the other. Ctrl-q Ctrl-l is a
       line-break character.

       You can also type out a three digit decimal number after Ctrl-q  to
       insert the character code point corresponding to that number.
       Hexidecial numbers can be inserted by typing the two digit number and
       then pressing the h key. E.g. Ctrl-q 0 6 4 inserts an @ symbol decimal
       64; the sequence Ctrl-q 1 4 2 or Ctrl-q 8 e h inserts an 8E
       hexidecimal. This use of Ctrl-q honors the UTF8 Interpretion switch in
       the Options-Switches menu.  This means it will not encode the result as
       UTF8 if the switch is off.

       Ctrl-q u encodes full 6-digit UTF8 character. Try Ctrl-q u 0 1 f 6 0 0
       to insert a smile emoticon, or Ctrl-q u 0 0 9 0 5 3 to insert the Tao.


MISCELLANEOUS USAGE
       The input widget can be found in most dialogs and allows the editing of
       one line of text. By pressing Shift-Up or Shift-Down, you can see a
       history of previous entries. This is the same as pressing the input
       widget's button.

       Pressing Alt Ins in the editor will show you a history of cuts/copies
       you made to the X buffer. Pressing Space or Enter will insert the
       selected selection.

       To define a macro, press Ctrl-R and then type out the key strokes you
       want to be executed. Press Ctrl-R again when finished. You can then
       assign the macro to any key you like by pressing that key. The macro is
       executed when you press Ctrl-A and then the assigned key. The macro is
       also executed if the key is pressed on its own and is not assigned to
       any other function. Once defined, the macro commands go into the file
       .cedit/cooledit.macros in your home directory. The macro will overwrite
       any existing definition that was assigned to that same key. You can
       also delete macros from the command menu. The maximum number of macros
       you are allowed is 1024, thereafter you may get a crash. Do not delete
       or edit the macro file without restarting cooledit because cooledit
       caches the macros hot-keys in memory. This also means that macros will
       not be available to other cooledit's that are running simultaneously
       without them being restarted.

Running Make and Man
       Cooledit has an interactive man page reader. To bring up a man page,
       type it out in the editor, highlight it with the mouse or cursor, and
       then press Ctrl-F1. The browser will appear in the root window.  Inside
       the browser, you can double-click on words to bring up new man pages.
       You can also highlight text, drag it, and drop it into an edit window.

       Press Alt-F7 to run make in the current directory. The make command is
       run via the generic script execution feature (see SCRIPT EXECUTION).
       The current directory can be changed in the Command menu. The output of
       make will go to a viewer in the root window. Here you can double-click
       or press enter on an error message to take you directly to the file and
       line number where the error appears (provided the file is already
       open).

Search and Replace
       You can use scanf search and replace to search and replace a C format
       string. First take a look at the sscanf and sprintf man pages to see
       what a format string is and how it works. An example is as follows:
       Suppose you want to replace all instances of say, an open bracket,
       three comma separated numbers, and a close bracket, with the word
       apples , the third number, the word oranges and then the second number,
       you would fill in the Replace dialog box as follows:

       Enter search string
       (%d,%d,%d)
       Enter replace string
       apples %d oranges %d
       Enter replacement argument order
       3,2

       The last line specifies that the third and then the second number are
       to be used in place of the first and second.

       Note that the scanf() C function treats whitespace as being elastic.
       Read about the scanf format %[ in the scanf man page: it is very useful
       for scanning strings, and whitespace. For example, here is how to
       change C++ comments into C comments: For the search string type `/' `/'
       `%' `[' `^' Ctrl-q Enter `]', then in the replace string enter `/' `*'
       `%' `s' ` ' `*' `/'. Then make sure that you have depressed the scanf
       option button, and replace all.

       Also, the Case sensitive switch should be turned on when using scanf
       strings. The conversion specifiers in scanf and printf (i.e.  search
       and replace respectively) must match exactly in their type - float must
       match with float etc. Searching with %f and replacing with %f, may not
       work, since, if you read the man page, scanf treats %f as a type float,
       while printf treats it as a type double. Instead use %lf to search, and
       replace with %f - both of type double.

       Regular expression substring replacement is available. (For those
       breathing a huge sigh of relief: note that you could always use Sed
       under the Scripts menu to do this anyway.) Substrings are not indicated
       by \1 \2 ... as with sed(1), but with %s. You must then use the Enter
       argument order field to specify the order of subtrings replacement.
       Hence the above example becomes:

       Enter search string
       \( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *\)
       Enter replace string
       apples %s oranges %s
       Enter replacement argument order
       3,2

       The option Backwards is provided to reverse search and replace.
       Although this is fully  functional, it is not an efficient
       implementation of reverse searching,  even to the extent that searches
       using scanf or regexp may be extremely slow. Hence beware, and remember
       that you can kill -SIGUSR1 pid to restore Cooledit.

OPTIONS MENU
       Besides the define keys menu item, there is a general options item, a
       switches item, and a save mode item. The options in the general and
       switches options dialogs are analogous to those on the command line.
       The save mode dialog allows you to change the method of saving a file.
       Quick save saves the file by immediately, truncating the disk file to
       zero length (i.e. erasing it) and then writing the editor contents to
       the file. This method is fast, but dangerous, since a system error
       during a file save will leave the file only partially written, possibly
       rendering the data irretrievable. When saving, the safe save option
       enables creation of a temporary file into which the file contents are
       first written. In the event of an problem, the original file is
       untouched.  When the temporary file is successfully written, it is
       renamed to the name of the original file, thus replacing it. The safest
       method is create backups.  Where a backup file is created before any
       changes are made. You can specify your own backup file extension in the
       dialog. Note that saving twice will replace your backup as well as your
       original file.

FURTHER BEHAVIOURAL OPTIONS
       Other options may be set by hand through editing the file
       ~/.cedit/.cooledit.ini (see FILES below). The section [Options]
       contains various settings (search for the string [Options]). Most of
       the settings are self explanatary. Unless otherwise stated, the setting
       is 0 for off and 1 for on. Some of these settings can be set from the
       Options menu, while others only take effect on startup and should
       therefore be edited by hand. Some of the settings are explained as
       follows:

       option_edit_bottom_extreme
              (and its counterparts) These define the extents of cursor
              movement within the edit window. Text will be scrolled to keep
              the cursor this distance from the edit window border. The units
              are in character widths and heights.

       option_find_bracket
              Sets whether matching brackets will be highlighted.

       option_pull_down_window_list
              Sets whether the Window menu will be displayed when cycling
              through edit windows or opening a new file.

       option_cursor_blink_rate
              Changes the cursor blink rate per second. This also effects the
              rate at which background script file outputs are updated. Use
              option_flashing_cursor = 0 to turn off cursor blinking.

       option_xor_cursor
              Changes the cursor style to an exclusive OR cursor.

       option_flashing_cursor
              Turn on/off cursor flashing.

       option_hint_messages
              Tells how often (in seconds) to change the window title hint
              message; 0 disables.

       options_text_ and options_editor_
              These settings set the colours of text display boxes (usually
              having a pinkish backround) and the editor (usually having a
              dark blue background).  The colour palette is 3x3x3 for red,
              green and blue. The formula is R*3^2 + G*3^1 + B*3^0 =
              ColourValue. Where R, G and B are the red, green and blue
              components of the colour and range from 0 to 2. Hence
              option_editor_bg_normal = 1 is a dark blue and
              option_editor_fg_normal = 26 is a bright white.

       option_man_cmdline3
              Sets the shell command that will be used to run the man command.
              %m will be substituted for the man page entered. The -a option
              is preferred because it forces man to display all matching man
              pages across all sections. This may not be supported on some
              systems.

       option_text_line_spacing
              Number of pixel widths between lines. You can specify this as 0
              for condensed text or a larger number for broadly spaced lines.

       option_mouse_double_click
              Maximum time-out to recognise a double click in milliseconds.
              Default is 300.

       option_max_undo
              This is the maximum number of keypresses recorded.  Each key
              press is recorded on an undo stack.  Memory space set aside for
              the stack starts off small, but is doubled  whenever the stack
              is filled. This option sets the maximum size that  the stack is
              allowed to reach, and should be a power of 2. The amount  of
              memory used in bytes will be four times this number (eight times
              on  64 bit machines). Beware of making this number to large
              because memory  will eventually be used up. The default is 8192
              which is roughly 10 pages  of C program code.

       option_interwidget_spacing
              Pixel distance between each widget's bounding box. Set to 5 or 6
              widen things up a bit.

       option_toolbar
              Causes a vertical convenience tool-bar to be displayed to the
              left of each edit window, default: on.

       option_interpret_numlock
              Cooledit can try to be clever by checking for the numlock key to
              switch between arrow keys and numeric keys on the keypad. May
              not be a good idea, default: off.

       option_long_whitespace
              For proportional fonts, the space character (ASCII 32 decimal)
              can be so thin that programming code is difficult to manipulate.
              This option doubles its width, default off.

COMPOSING INTERNATIONAL CHARACTERS
       To use cooledit's built-in character composing see "Non-ASCII key
       composing..." in the Readme menu.

       To compose non-Latin characters or to enable standard "Compose Key"
       behavior for Linux you will first need to set your X Server to
       recognize a regular key as a Compose Key.  Edit the configuration file
       /etc/default/keyboard and add the line,

       XKBOPTIONS="compose:ralt"

       for using the right Alt key as a Compose Key. Then reboot.

       Alternatively do as follows to configure your Compose Key. First look
       in this file to find how the X Windows System can map the compose key,
       then use the setxkbmap command to pick a key.

       grep 'compose:' /usr/share/X11/xkb/rules/base.lst
       grep 'compose:' /usr/X11R6/share/X11/xkb/rules/base.lst
       grep 'compose:' /usr/local/share/X11/xkb/rules/base.lst
       setxkbmap -option compose:ralt

       Note the importance of the XMODIFIERS and LANG environment variables.
       XMODIFIERS tells cooledit what "Input Method (IM)" service to connect
       to.  LANG tells cooledit that UTF8 is supported.

       Once you start scim or ibus-daemon you cannot restart them without also
       restarting cooledit.

       The following shell commands will enable English UTF8 key composing and
       Asian language key composing with the ibus IM package properly
       installed. The following OS packages may be needed say, for Chinese
       support: ibus, language-pack-zh-hans-base, ibus-pinyin, dbus-x11.  Note
       the "next input method" and "trigger" options in the setup GUI: you may
       need to press these keys within cooledit to enable the input method.

       export XMODIFIERS=@im=ibus
       export LANG=en_US.UTF-8
       ibus-setup
       ibus-daemon --xim &
       cooledit

       The following shell commands will enable English UTF8 key composing and
       Asian language key composing with the scim IM package properly
       installed. The following OS packages may be needed say, for Chinese
       support: scim, scim-pinyin.  Note the "next input method" and "trigger"
       options in the setup GUI: you may need to press these keys within
       cooledit to enable the input method.

       export XMODIFIERS=@im=SCIM
       export LANG=en_US.UTF-8
       scim-setup
       scim -e pinyin -f x11 &
       cooledit


       For composing plain English and, say, other Latin diacriticals,

       export XMODIFIERS=
       export LANG=en_US.UTF-8

       The key sequence,

       right-Alt-Press
       right-Alt-release
       single-quote-press
       single-quote-release
       i-press
       i-release

       will insert a character "i" with an acute accent.


BINARY FILES
       No translation of characters is made between the raw binary bytes and
       the font glyph lookup, aside from locale or UTF8 encoding (the encoding
       is selectable from the Options-Switches menu). If a font glyph is
       missing or has zero width, then a substitute character string is made,
       say, ^A for 00000001b (1d) or 10FFFFh for Unicode character
       000100001111111111111111b (1114111d).

TABBING OPTIONS
       A variety of tabbing and auto indent options are available. One of the
       problems I've encountered with tabbing is that the programmer often
       wants to indent code with half tabs (four spaces) instead of the
       standard tab (eight characters).  It would be easy to mearly change the
       tab width to four, but then the resulting code would not display
       correctly under viewers or other character devices.  To solve this, a
       Fake Half Tabs option is available.  This makes it appear as though you
       are using a half sized tab by inserting and moving through four space
       characters when you are to the left of your text. When eight space
       characters are inserted, they are automatically replaced with a tab.

       The --widget-font option also works with this.

FONTS
       Fonts are specified on the command-line and not from any menu.

       Two fonts groups are loaded, one using the -font option and one using
       the --widget-font option. Both proportional and fixed-width fonts are
       supported, but fixed-width fonts are most appropriate for code editing.
       Type cooledit -fn ? for help. cooledit -fn large configures a slightly
       larger font for higher-DPI displays. Fonts glyphs are looked up
       interpreting UTF-8 encoding on the raw edit text buffer and then
       indexing the glyph. No other interpretation takes place and if the
       glyph is not present, then Cooledit renders a substitute Hex sequence.
       If the --locale-encoding option is set then OS Locale settings are used
       instead of UTF-8. See "Use Locale encoding" and "UTF8 interpretation"
       in the Options-Switches menu.

       There are 4 ways to specify fonts:


1. Truetype fonts in the cooledit installation
       If Cooledit is compiled with Freetype Library support, then options of
       the form,

       -font NotoSansMono-Bold.ttf,NotoSansMonoCJKsc-Regular.otf:15

       are supported. Any number of comma-separated fonts will all be loaded
       as and when a character code-point needs to be rendered. 15 is the
       desired pixel size.

       Cooledit searches the directories ./, ./notosans/,
       <prefix>/share/cooledit/fonts/, /usr/local/share/fonts/noto, and
       /usr/local/share/fonts/misc for all installed fonts. The latter two
       directories are the FreeBSD install paths for the noto and font-misc-
       misc packages. The FreeBSD noto package is large, so you may want to
       install cooledit from source. As of FreeBSD 13, their fonts are missing
       NotoSansMath-Regular.ttf and NotoMusic-Regular.ttf, as well as many
       less-common languages.  See INSTALL.freebsd for more info.



2. Truetype fonts on file
       Cooledit can load any PCF, TTF, or OTF font and any font supported by
       the FreeType library using the full path to the font:

       -font /usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf:20


3. Font structs
       For older X Servers Font Structs are still supported using, for
       example,

       -font "-*-fixed-bold-r-normal--13-*"

       This is the fastest font rendering and simply loads a single legacy
       font for a single character set. Type xlsfonts for a full list of
       installed fonts.


4. Font sets
       For older X servers Font Sets are still supported using, for example,

       -fontset -font "-*-fixed-bold-r-normal--13-*"

       Note that the Cooledit legacy feature -font "-*-fixed-bold-r-
       normal--13-*/3" still works for scaling a font struct by 3.

FILES
       $HOME/.cedit/

              User's own temporary directory.

       $HOME/.cedit/.cooledit.ini

              Initialisation file. This stores a list of files that were open
              when the user last exited cooledit.  It also stores scripts,
              options, and user defined keys.  The file is broken into
              sections separated by double newlines.  Each section is headed
              by the section name in square brackets on it own line.

       $HOME/.cedit/.password

              Read AES keys for remotefs from this file. The format of this
              file is a list of remote host IP addresses, one per line, with
              an options field and the AES key for each. AES keys
              autogenerated by remotefs are a string of 44 alpha-numeric
              characters excluding characters that look similar. This is to
              give sufficient randomness to 256-bit AES. Internally, the
              characters are passed through SHA256 to produce the AES key.

              When prompted by the dialog box to input an AES key, copy the
              key from AESKEYFILE produced by remotefs.

       $HOME/.cedit/cooledit.macros

              is generated automatically when macros are recorded. Each line
              in the file represents a macro definition. Do not edit this file
              while cooledit is running unless you are not going to run a
              macro during that cooledit session.

       $HOME/.cedit/cooledit.block

              When the option Save block on commance is on in the script
              editor, the block will be saved with this file-name, on
              execution of the script.

       $HOME/.cedit/cooledit.clip

              This is the default file to use when you save a highlighted
              block to a file. A copy of the highlighted text is also saved to
              this file whenever you cut or copy to the X buffer.

       $HOME/.cedit/cooledit.temp

              This is a temporary file you can use in your shell scripts.

       $HOME/.cedit/cooledit.script

              This is a file-name of the shell script when it is saved for
              execution. You can view it for debugging purposes.

AVAILABILITY
       The latest public release of this program can be found at
       http://www.ibiblio.org/pub/Linux/apps/editors/X/cooledit/

SEE ALSO
       mc(1), mcedit(1), X(1), scanf(3), remotefs(1).

AUTHORS
       Paul Sheer

                                 4 April 2005                      cooledit(1)
