CGI::Simple(3)        User Contributed Perl Documentation       CGI::Simple(3)


NAME
       CGI::Simple - A Simple totally OO CGI interface that is CGI.pm
       compliant

VERSION
       This document describes CGI::Simple version 1.281.

SYNOPSIS
           use CGI::Simple;
           $CGI::Simple::POST_MAX = 1024;       # max upload via post default 100kB
           $CGI::Simple::DISABLE_UPLOADS = 0;   # enable uploads

           $q = CGI::Simple->new;
           $q = CGI::Simple->new( { 'foo'=>'1', 'bar'=>[2,3,4] } );
           $q = CGI::Simple->new( 'foo=1&bar=2&bar=3&bar=4' );
           $q = CGI::Simple->new( \*FILEHANDLE );

           $q->save( \*FILEHANDLE );   # save current object to a file as used by new

           @params = $q->param;        # return all param names as a list
           $value = $q->param('foo');  # return the first value supplied for 'foo'
           @values = $q->param('foo'); # return all values supplied for foo

           %fields   = $q->Vars;      # returns untied key value pair hash
           $hash_ref = $q->Vars;      # or as a hash ref
           %fields   = $q->Vars("|"); # packs multiple values with "|" rather than "\0";

           @keywords = $q->keywords;  # return all keywords as a list

           $q->param( 'foo', 'some', 'new', 'values' );      # set new 'foo' values
           $q->param( -name=>'foo', -value=>'bar' );
           $q->param( -name=>'foo', -value=>['bar','baz'] );

           $q->param( 'foo', 'some', 'new', 'values' );      # append values to 'foo'
           $q->append( -name=>'foo', -value=>'bar' );
           $q->append( -name=>'foo', -value=>['some', 'new', 'values'] );

           $q->delete('foo'); # delete param 'foo' and all its values
           $q->delete_all;    # delete everything

           <INPUT TYPE="file" NAME="upload_file" SIZE="42">

           $files    = $q->upload()                # number of files uploaded
           @files    = $q->upload();               # names of all uploaded files
           $filename = $q->param('upload_file')    # filename of uploaded file
           $mime     = $q->upload_info($filename,'mime'); # MIME type of uploaded file
           $size     = $q->upload_info($filename,'size'); # size of uploaded file

           my $fh = $q->upload($filename);         # get filehandle to read from
           while ( read( $fh, $buffer, 1024 ) ) { ... }

           # short and sweet upload
           $ok = $q->upload( $q->param('upload_file'), '/path/to/write/file.name' );
           print "Uploaded ".$q->param('upload_file')." and wrote it OK!" if $ok;

           $decoded    = $q->url_decode($encoded);
           $encoded    = $q->url_encode($unencoded);
           $escaped    = $q->escapeHTML('<>"&');
           $unescaped  = $q->unescapeHTML('&lt;&gt;&quot;&amp;');

           $qs = $q->query_string; # get all data in $q as a query string OK for GET

           $q->no_cache(1);        # set Pragma: no-cache + expires
           print $q->header();     # print a simple header
           # get a complex header
           $header = $q->header(   -type       => 'image/gif'
                                   -nph        => 1,
                                   -status     => '402 Payment required',
                                   -expires    =>'+24h',
                                   -cookie     => $cookie,
                                   -charset    => 'utf-7',
                                   -attachment => 'foo.gif',
                                   -Cost       => '$2.00'
                               );
           # a p3p header (OK for redirect use as well)
           $header = $q->header( -p3p => 'policyref="http://somesite.com/P3P/PolicyReferences.xml' );

           @cookies = $q->cookie();        # get names of all available cookies
           $value   = $q->cookie('foo')    # get first value of cookie 'foo'
           @value   = $q->cookie('foo')    # get all values of cookie 'foo'
           # get a cookie formatted for header() method
           $cookie  = $q->cookie(  -name    => 'Password',
                                   -values  => ['superuser','god','my dog woofie'],
                                   -expires => '+3d',
                                   -domain  => '.nowhere.com',
                                   -path    => '/cgi-bin/database',
                                   -secure  => 1
                                );
           print $q->header( -cookie=>$cookie );       # set cookie

           print $q->redirect('http://go.away.now');   # print a redirect header

           dienice( $q->cgi_error ) if $q->cgi_error;

DESCRIPTION
       CGI::Simple provides a relatively lightweight drop in replacement for
       CGI.pm.  It shares an identical OO interface to CGI.pm for parameter
       parsing, file upload, cookie handling and header generation. This
       module is entirely object oriented, however a complete functional
       interface is available by using the CGI::Simple::Standard module.

       Essentially everything in CGI.pm that relates to the CGI (not HTML)
       side of things is available. There are even a few new methods and
       additions to old ones! If you are interested in what has gone on under
       the hood see the Compatibility with CGI.pm section at the end.

       In practical testing this module loads and runs about twice as fast as
       CGI.pm depending on the precise task.

CALLING CGI::Simple ROUTINES USING THE OBJECT INTERFACE
       Here is a very brief rundown on how you use the interface. Full details
       follow.

   First you need to initialize an object
       Before you can call a CGI::Simple method you must create a CGI::Simple
       object.  You do that by using the module and then calling the new()
       constructor:

           use CGI::Simple;
           my $q = CGI::Simple->new;

       It is traditional to call your object $q for query or perhaps $cgi.

   Next you call methods on that object
       Once you have your object you can call methods on it using the -> arrow
       syntax For example to get the names of all the parameters passed to
       your script you would just write:

           @names = $q->param();

       Many methods are sensitive to the context in which you call them. In
       the example above the param() method returns a list of all the
       parameter names when called without any arguments.

       When you call param('arg') with a single argument it assumes you want
       to get the value(s) associated with that argument (parameter). If you
       ask for an array it gives you an array of all the values associated
       with it's argument:

           @values = $q->param('foo');  # get all the values for 'foo'

       whereas if you ask for a scalar like this:

           $value = $q->param('foo');   # get only the first value for 'foo'

       then it returns only the first value (if more than one value for 'foo'
       exists).

       In case you ased for a list it will return all the values preserving
       the order in which the values of the given key were passed in the
       request.

       Most CGI::Simple routines accept several arguments, sometimes as many
       as 10 optional ones!  To simplify this interface, all routines use a
       named argument calling style that looks like this:

           print $q->header( -type=>'image/gif', -expires=>'+3d' );

       Each argument name is preceded by a dash.  Neither case nor order
       matters in the argument list.  -type, -Type, and -TYPE are all
       acceptable.

       Several routines are commonly called with just one argument.  In the
       case of these routines you can provide the single argument without an
       argument name.  header() happens to be one of these routines.  In this
       case, the single argument is the document type.

          print $q->header('text/html');

       Sometimes methods expect a scalar, sometimes a reference to an array,
       and sometimes a reference to a hash.  Often, you can pass any type of
       argument and the routine will do whatever is most appropriate.  For
       example, the param() method can be used to set a CGI parameter to a
       single or a multi-valued value.  The two cases are shown below:

          $q->param(-name=>'veggie',-value=>'tomato');
          $q->param(-name=>'veggie',-value=>['tomato','tomahto','potato','potahto']);

CALLING CGI::Simple ROUTINES USING THE FUNCTION INTERFACE
       For convenience a functional interface is provided by the
       CGI::Simple::Standard module. This hides the OO details from you and
       allows you to simply call methods. You may either use AUTOLOADING of
       methods or import specific method sets into you namespace. Here are the
       first few examples again using the function interface.

           use CGI::Simple::Standard qw(-autoload);
           @names  = param();
           @values = param('foo');
           $value  = param('foo');
           print header(-type=>'image/gif',-expires=>'+3d');
           print header('text/html');

       Yes that's it. Not a $q-> in sight. You just use the module and select
       how/which methods to load. You then just call the methods you want
       exactly as before but without the $q-> notation.

       When (if) you read the following docs and are using the functional
       interface just pretend the $q-> is not there.

   Selecting which methods to load
       When you use the functional interface Perl needs to be able to find the
       functions you call. The simplest way of doing this is to use
       autoloading as shown above. When you use CGI::Simple::Standard with the
       '-autoload' pragma it exports a single AUTOLOAD sub into you namespace.
       Every time you call a non existent function AUTOLOAD is called and will
       load the required function and install it in your namespace. Thus only
       the AUTOLOAD sub and those functions you specifically call will be
       imported.

       Alternatively CGI::Simple::Standard provides a range of function sets
       you can import or you can just select exactly what you want. You do
       this using the familiar

           use CGI::Simple::Standard qw( :func_set  some_func);

       notation. This will import the ':func_set' function set and the
       specific function 'some_func'.

   To Autoload or not to Autoload, that is the question.
       If you do not have a AUTOLOAD sub in you script it is generally best to
       use the '-autoload' option. Under autoload you can use any method you
       want but only import and compile those functions you actually use.

       If you do not use autoload you must specify what functions to import.
       You can only use functions that you have imported. For comvenience
       functions are grouped into related sets. If you choose to import one or
       more ':func_set' you may have potential namespace collisions so check
       out the docs to see what gets imported. Using the ':all' tag is pretty
       slack but it is there if you want. Full details of the function sets
       are provided in the CGI::Simple::Standard docs

       If you just want say the param and header methods just load these two.

           use CGI::Simple::Standard qw(param header);

   Setting globals using the functional interface
       Where you see global variables being set using the syntax:

           $CGI::Simple::DEBUG = 1;

       You use exactly the same syntax when using CGI::Simple::Standard.

THE CORE METHODS
   new() Creating a new query object
       The first step in using CGI::Simple is to create a new query object
       using the new() constructor:

            $q = CGI::Simple->new;

       This will parse the input (from both POST and GET methods) and store it
       into an object called $q.

       If you provide a file handle to the new() method, it will read
       parameters from the file (or STDIN, or whatever).

       Historically people were doing this way:

            open FH, "test.in" or die $!;
            $q = CGI::Simple->new(\*FH);

       but this is the recommended way:

            open $fh, '<', "test.in" or die $!;
            $q = CGI::Simple->new($fh);

       The file should be a series of newline delimited TAG=VALUE pairs.
       Conveniently, this type of file is created by the save() method (see
       below). Multiple records can be saved and restored.  IO::File objects
       work fine.

       If you are using the function-oriented interface provided by
       CGI::Simple::Standard and want to initialize from a file handle, the
       way to do this is with restore_parameters().  This will (re)initialize
       the default CGI::Simple object from the indicated file handle.

           restore_parameters($fh);

       In fact for all intents and purposes restore_parameters() is identical
       to new() Note that restore_parameters() does not exist in CGI::Simple
       itself so you can't use it.

       You can also initialize the query object from an associative array
       reference:

           $q = CGI::Simple->new( { 'dinosaur' => 'barney',
                                   'song'     => 'I love you',
                                   'friends'  => [qw/Jessica George Nancy/] }
                               );

       or from a properly formatted, URL-escaped query string:

           $q = CGI::Simple->new( 'dinosaur=barney&color=purple' );

       or from a previously existing CGI::Simple object (this generates an
       identical clone including all global variable settings, etc that are
       stored in the object):

           $old_query = CGI::Simple->new;
           $new_query = CGI::Simple->new($old_query);

       To create an empty query, initialize it from an empty string or hash:

           $empty_query = CGI::Simple->new("");

              -or-

           $empty_query = CGI::Simple->new({});

   keywords() Fetching a list of keywords from a query
           @keywords = $q->keywords;

       If the script was invoked as the result of an <ISINDEX> search, the
       parsed keywords can be obtained as an array using the keywords()
       method.

   param() Fetching the names of all parameters passed to your script
           @names = $q->param;

       If the script was invoked with a parameter list (e.g.
       "name1=value1&name2=value2&name3=value3"), the param() method will
       return the parameter names as a list.  If the script was invoked as an
       <ISINDEX> script and contains a string without ampersands (e.g.
       "value1+value2+value3") , there will be a single parameter named
       "keywords" containing the "+"-delimited keywords.

       NOTE: The array of parameter names returned will be in the same order
       as they were submitted by the browser.  Usually this order is the same
       as the order in which the parameters are defined in the form (however,
       this isn't part of the spec, and so isn't guaranteed).

   param() Fetching the value or values of a simple named parameter
           @values = $q->param('foo');

                 -or-

           $value = $q->param('foo');

       Pass the param() method a single argument to fetch the value of the
       named parameter. If the parameter is multi-valued (e.g. from multiple
       selections in a scrolling list), you can ask to receive an array.
       Otherwise the method will return a single value.

       If a value is not given in the query string, as in the queries
       "name1=&name2=" or "name1&name2", it will be returned by default as an
       empty string. If you set the global variable:

           $CGI::Simple::NO_UNDEF_PARAMS = 1;

       Then value-less parameters will be ignored, and will not exist in the
       query object. If you try to access them via param you will get an undef
       return value.

   param() Setting the values of a named parameter
           $q->param('foo','an','array','of','values');

       This sets the value for the named parameter 'foo' to an array of
       values.  This is one way to change the value of a field.

       param() also recognizes a named parameter style of calling described in
       more detail later:

           $q->param(-name=>'foo',-values=>['an','array','of','values']);

                         -or-

           $q->param(-name=>'foo',-value=>'the value');

   param() Retrieving non-application/x-www-form-urlencoded data
       If POSTed or PUTed data is not of type
       application/x-www-form-urlencoded or multipart/form-data, then the data
       will not be processed, but instead be returned as-is in a parameter
       named POSTDATA or PUTDATA.  To retrieve it, use code like this:

           my $data = $q->param( 'POSTDATA' );

                         -or-

           my $data = $q->param( 'PUTDATA' );

       (If you don't know what the preceding means, don't worry about it.  It
       only affects people trying to use CGI::Simple for REST webservices)

   add_param() Setting the values of a named parameter
       You nay also use the new method add_param to add parameters. This is an
       alias to the _add_param() internal method that actually does all the
       work.  You can call it like this:

           $q->add_param('foo', 'new');
           $q->add_param('foo', [1,2,3,4,5]);
           $q->add_param( 'foo', 'bar', 'overwrite' );

       The first argument is the parameter, the second the value or an array
       ref of values and the optional third argument sets overwrite mode. If
       the third argument is absent of false the values will be appended. If
       true the values will overwrite any existing ones

   append() Appending values to a named parameter
          $q->append(-name=>'foo',-values=>['yet','more','values']);

       This adds a value or list of values to the named parameter.  The values
       are appended to the end of the parameter if it already exists.
       Otherwise the parameter is created.  Note that this method only
       recognizes the named argument calling syntax.

   import_names() Importing all parameters into a namespace.
       This method was silly, non OO and has been deleted. You can get all the
       params as a hash using Vars or via all the other accessors.

   delete() Deleting a parameter completely
           $q->delete('foo');

       This completely clears a parameter. If you are using the function call
       interface, use Delete() instead to avoid conflicts with Perl's built-in
       delete operator.

       If you are using the function call interface, use Delete() instead to
       avoid conflicts with Perl's built-in delete operator.

   delete_all() Deleting all parameters
           $q->delete_all();

       This clears the CGI::Simple object completely. For CGI.pm compatibility
       Delete_all() is provided however there is no reason to use this in the
       function call interface other than symmetry.

       For CGI.pm compatibility Delete_all() is provided as an alias for
       delete_all however there is no reason to use this, even in the function
       call interface.

   param_fetch() Direct access to the parameter list
       This method is provided for CGI.pm compatibility only. It returns an
       array ref to the values associated with a named param. It is
       deprecated.

   Vars() Fetching the entire parameter list as a hash
           $params = $q->Vars;  # as a tied hash ref
           print $params->{'address'};
           @foo = split "\0", $params->{'foo'};

           %params = $q->Vars;  # as a plain hash
           print $params{'address'};
           @foo = split "\0", $params{'foo'};

           %params = $q->Vars(','); # specifying a different separator than "\0"
           @foo = split ',', $params{'foo'};

       Many people want to fetch the entire parameter list as a hash in which
       the keys are the names of the CGI parameters, and the values are the
       parameters' values.  The Vars() method does this.

       Called in a scalar context, it returns the parameter list as a tied
       hash reference. Because this hash ref is tied changing a key/value
       changes the underlying CGI::Simple object.

       Called in a list context, it returns the parameter list as an ordinary
       hash.  Changing this hash will not change the underlying CGI::Simple
       object

       When using Vars(), the thing you must watch out for are multi-valued
       CGI parameters.  Because a hash cannot distinguish between scalar and
       list context, multi-valued parameters will be returned as a packed
       string, separated by the "\0" (null) character.  You must split this
       packed string in order to get at the individual values.  This is the
       convention introduced long ago by Steve Brenner in his cgi-lib.pl
       module for Perl version 4.

       You can change the character used to do the multiple value packing by
       passing it to Vars() as an argument as shown.

   url_param() Access the QUERY_STRING regardless of 'GET' or 'POST'
       The url_param() method makes the QUERY_STRING data available regardless
       of whether the REQUEST_METHOD was 'GET' or 'POST'. You can do anything
       with url_param that you can do with param(), however the data set is
       completely independent.

       Technically what happens if you use this method is that the
       QUERY_STRING data is parsed into a new CGI::Simple object which is
       stored within the current object. url_param then just calls param() on
       this new object.

   parse_query_string() Add QUERY_STRING data to 'POST' requests
       When the REQUEST_METHOD is 'POST' the default behavior is to ignore
       name/value pairs or keywords in the $ENV{'QUERY_STRING'}. You can
       override this by calling parse_query_string() which will add the
       QUERY_STRING data to the data already in our CGI::Simple object if the
       REQUEST_METHOD was 'POST'

           $q = CGI::Simple->new;
           $q->parse_query_string;  # add $ENV{'QUERY_STRING'} data to our $q object

       If the REQUEST_METHOD was 'GET' then the QUERY_STRING will already be
       stored in our object so parse_query_string will be ignored.

       This is a new method in CGI::Simple that is not available in CGI.pm

   save() Saving the state of an object to file
           $q->save(\*FILEHANDLE)

       This will write the current state of the form to the provided
       filehandle.  You can read it back in by providing a filehandle to the
       new() method.

       The format of the saved file is:

           NAME1=VALUE1
           NAME1=VALUE1'
           NAME2=VALUE2
           NAME3=VALUE3
           =

       Both name and value are URL escaped.  Multi-valued CGI parameters are
       represented as repeated names.  A session record is delimited by a
       single = symbol.  You can write out multiple records and read them back
       in with several calls to new().

           open my $fh, '<', "test.in" or die $!;
           $q1 = CGI::Simple->new($fh);  # get the first record
           $q2 = CGI::Simple->new($fh);  # get the next record

       Note: If you wish to use this method from the function-oriented (non-
       OO) interface, the exported name for this method is save_parameters().
       Also if you want to initialize from a file handle, the way to do this
       is with restore_parameters().  This will (re)initialize the default
       CGI::Simple object from the indicated file handle.

           restore_parameters($fh);

FILE UPLOADS
       File uploads are easy with CGI::Simple. You use the upload() method.
       Assuming you have the following in your HTML:

           <FORM
            METHOD="POST"
            ACTION="http://somewhere.com/cgi-bin/script.cgi"
            ENCTYPE="multipart/form-data">
               <INPUT TYPE="file" NAME="upload_file1" SIZE="42">
               <INPUT TYPE="file" NAME="upload_file2" SIZE="42">
           </FORM>

       Note that the ENCTYPE is "multipart/form-data". You must specify this
       or the browser will default to "application/x-www-form-urlencoded"
       which will result in no files being uploaded although on the surface
       things will appear OK.

       When the user submits this form any supplied files will be spooled onto
       disk and saved in temporary files. These files will be deleted when
       your script.cgi exits so if you want to keep them you will need to
       proceed as follows.

   upload() The key file upload method
       The upload() method is quite versatile. If you call upload() without
       any arguments it will return a list of uploaded files in list context
       and the number of uploaded files in scalar context.

           $number_of_files = $q->upload;
           @list_of_files   = $q->upload;

       Having established that you have uploaded files available you can get
       the browser supplied filename using param() like this:

           $filename1 = $q->param('upload_file1');

       You can then get a filehandle to read from by calling upload() and
       supplying this filename as an argument. Warning: do not modify the
       value you get from param() in any way - you don't need to untaint it.

           $fh = $q->upload( $filename1 );

       Now to save the file you would just do something like:

           $save_path = '/path/to/write/file.name';
           open my $out, '>', $save_path or die "Oops $!\n";
           binmode $out;
           print $out $buffer while read( $fh, $buffer, 4096 );
           close $out;

       By utilizing a new feature of the upload method this process can be
       simplified to:

           $ok = $q->upload( $q->param('upload_file1'), '/path/to/write/file.name' );
           if ($ok) {
               print "Uploaded and wrote file OK!";
           } else {
               print $q->cgi_error();
           }

       As you can see upload will accept an optional second argument and will
       write the file to this file path. It will return 1 for success and
       undef if it fails. If it fails you can get the error from cgi_error

       You can also use just the fieldname as an argument to upload ie:

           $fh = $q->upload( 'upload_field_name' );

           or

           $ok = $q->upload( 'upload_field_name', '/path/to/write/file.name' );

       BUT there is a catch. If you have multiple upload fields, all called
       'upload_field_name' then you will only get the last uploaded file from
       these fields.

   upload_info() Get the details about uploaded files
       The upload_info() method is a new method. Called without arguments it
       returns the number of uploaded files in scalar context and the names of
       those files in list context.

           $number_of_upload_files   = $q->upload_info();
           @filenames_of_all_uploads = $q->upload_info();

       You can get the MIME type of an uploaded file like this:

           $mime = $q->upload_info( $filename1, 'mime' );

       If you want to know how big a file is before you copy it you can get
       that information from uploadInfo which will return the file size in
       bytes.

           $file_size = $q->upload_info( $filename1, 'size' );

       The size attribute is optional as this is the default value returned.

       Note: The old CGI.pm uploadInfo() method has been deleted.

   $POST_MAX and $DISABLE_UPLOADS
       CGI.pm has a default setting that allows infinite size file uploads by
       default. In contrast file uploads are disabled by default in
       CGI::Simple to discourage Denial of Service attacks. You must enable
       them before you expect file uploads to work.

       When file uploads are disabled the file name and file size details will
       still be available from param() and upload_info respectively but the
       upload filehandle returned by upload() will be undefined - not
       surprising as the underlying temp file will not exist either.

       You can enable uploads using the '-upload' pragma. You do this by
       specifying this in you use statement:

           use CGI::Simple qw(-upload);

       Alternatively you can enable uploads via the $DISABLE_UPLOADS global
       like this:

           use CGI::Simple;
           $CGI::Simple::DISABLE_UPLOADS = 0;
           $q = CGI::Simple->new;

       If you wish to set $DISABLE_UPLOADS you must do this *after* the use
       statement and *before* the new constructor call as shown above.

       The maximum acceptable data via post is capped at 102_400kB rather than
       infinity which is the CGI.pm default. This should be ample for most
       tasks but you can set this to whatever you want using the $POST_MAX
       global.

           use CGI::Simple;
           $CGI::Simple::DISABLE_UPLOADS = 0;      # enable uploads
           $CGI::Simple::POST_MAX = 1_048_576;     # allow 1MB uploads
           $q = CGI::Simple->new;

       If you set to -1 infinite size uploads will be permitted, which is the
       CGI.pm default.

           $CGI::Simple::POST_MAX = -1;            # infinite size upload

       Alternatively you can specify all the CGI.pm default values which allow
       file uploads of infinite size in one easy step by specifying the
       '-default' pragma in your use statement.

           use CGI::Simple qw( -default ..... );

   binmode() and Win32
       If you are using CGI::Simple be sure to call binmode() on any handle
       that you create to write the uploaded file to disk. Calling binmode()
       will do no harm on other systems anyway.

MISCELANEOUS METHODS
   escapeHTML() Escaping HTML special characters
       In HTML the < > " and & chars have special meaning and need to be
       escaped to &lt; &gt; &quot; and &amp; respectively.

           $escaped = $q->escapeHTML( $string );

           $escaped = $q->escapeHTML( $string, 'new_lines_too' );

       If the optional second argument is supplied then newlines will be
       escaped to.

   unescapeHTML() Unescape HTML special characters
       This performs the reverse of escapeHTML().

           $unescaped = $q->unescapeHTML( $HTML_escaped_string );

   url_decode() Decode a URL encoded string
       This method will correctly decode a url encoded string.

           $decoded = $q->url_decode( $encoded );

   url_encode() URL encode a string
       This method will correctly URL encode a string.

           $encoded = $q->url_encode( $string );

   parse_keywordlist() Parse a supplied keyword list
           @keywords = $q->parse_keywordlist( $keyword_list );

       This method returns a list of keywords, correctly URL escaped and split
       out of the supplied string

   put() Send output to browser
       CGI.pm alias for print. $q->put('Hello World!') will print the usual

   print() Send output to browser
       CGI.pm alias for print. $q->print('Hello World!') will print the usual

HTTP COOKIES
       CGI.pm has several methods that support cookies.

       A cookie is a name=value pair much like the named parameters in a CGI
       query string.  CGI scripts create one or more cookies and send them to
       the browser in the HTTP header.  The browser maintains a list of
       cookies that belong to a particular Web server, and returns them to the
       CGI script during subsequent interactions.

       In addition to the required name=value pair, each cookie has several
       optional attributes:

       1. an expiration time
           This is a time/date string (in a special GMT format) that indicates
           when a cookie expires.  The cookie will be saved and returned to
           your script until this expiration date is reached if the user exits
           the browser and restarts it.  If an expiration date isn't
           specified, the cookie will remain active until the user quits the
           browser.

       2. a domain
           This is a partial or complete domain name for which the cookie is
           valid.  The browser will return the cookie to any host that matches
           the partial domain name.  For example, if you specify a domain name
           of ".capricorn.com", then the browser will return the cookie to Web
           servers running on any of the machines "www.capricorn.com",
           "www2.capricorn.com", "feckless.capricorn.com", etc.  Domain names
           must contain at least two periods to prevent attempts to match on
           top level domains like ".edu".  If no domain is specified, then the
           browser will only return the cookie to servers on the host the
           cookie originated from.

       3. a path
           If you provide a cookie path attribute, the browser will check it
           against your script's URL before returning the cookie.  For
           example, if you specify the path "/cgi-bin", then the cookie will
           be returned to each of the scripts "/cgi-bin/tally.pl",
           "/cgi-bin/order.pl", and "/cgi-bin/customer_service/complain.pl",
           but not to the script "/cgi-private/site_admin.pl".  By default,
           path is set to "/", which causes the cookie to be sent to any CGI
           script on your site.

       4. a "secure" flag
           If the "secure" attribute is set, the cookie will only be sent to
           your script if the CGI request is occurring on a secure channel,
           such as SSL.

   cookie() A simple access method to cookies
       The interface to HTTP cookies is the cookie() method:

           $cookie = $q->cookie( -name      => 'sessionID',
                                 -value     => 'xyzzy',
                                 -expires   => '+1h',
                                 -path      => '/cgi-bin/database',
                                 -domain    => '.capricorn.org',
                                 -secure    => 1
                                );
           print $q->header(-cookie=>$cookie);

       cookie() creates a new cookie.  Its parameters include:

       -name
           The name of the cookie (required).  This can be any string at all.
           Although browsers limit their cookie names to non-whitespace
           alphanumeric characters, CGI.pm removes this restriction by
           escaping and unescaping cookies behind the scenes.

       -value
           The value of the cookie.  This can be any scalar value, array
           reference, or even associative array reference.  For example, you
           can store an entire associative array into a cookie this way:

               $cookie=$q->cookie( -name   => 'family information',
                                   -value  => \%childrens_ages );

       -path
           The optional partial path for which this cookie will be valid, as
           described above.

       -domain
           The optional partial domain for which this cookie will be valid, as
           described above.

       -expires
           The optional expiration date for this cookie.  The format is as
           described in the section on the header() method:

               "+1h"  one hour from now

       -secure
           If set to true, this cookie will only be used within a secure SSL
           session.

       The cookie created by cookie() must be incorporated into the HTTP
       header within the string returned by the header() method:

           print $q->header(-cookie=>$my_cookie);

       To create multiple cookies, give header() an array reference:

           $cookie1 = $q->cookie( -name  => 'riddle_name',
                                  -value => "The Sphynx's Question"
                                );
           $cookie2 = $q->cookie( -name  => 'answers',
                                  -value => \%answers
                                );
           print $q->header( -cookie => [ $cookie1, $cookie2 ] );

       To retrieve a cookie, request it by name by calling cookie() method
       without the -value parameter:

           use CGI::Simple;
           $q = CGI::Simple->new;
           $riddle  = $q->cookie('riddle_name');
           %answers = $q->cookie('answers');

       Cookies created with a single scalar value, such as the "riddle_name"
       cookie, will be returned in that form.  Cookies with array and hash
       values can also be retrieved.

       The cookie and CGI::Simple  namespaces are separate.  If you have a
       parameter named 'answers' and a cookie named 'answers', the values
       retrieved by param() and cookie() are independent of each other.
       However, it's simple to turn a CGI parameter into a cookie, and vice-
       versa:

           # turn a CGI parameter into a cookie
           $c = $q->cookie( -name=>'answers', -value=>[$q->param('answers')] );
           # vice-versa
           $q->param( -name=>'answers', -value=>[$q->cookie('answers')] );

   raw_cookie()
       Returns the HTTP_COOKIE variable. Cookies have a special format, and
       this method call just returns the raw form (?cookie dough). See
       cookie() for ways of setting and retrieving cooked cookies.

       Called with no parameters, raw_cookie() returns the packed cookie
       structure.  You can separate it into individual cookies by splitting on
       the character sequence "; ".  Called with the name of a cookie,
       retrieves the unescaped form of the cookie.  You can use the regular
       cookie() method to get the names, or use the raw_fetch() method from
       the CGI::Simmple::Cookie module.

CREATING HTTP HEADERS
       Normally the first thing you will do in any CGI script is print out an
       HTTP header.  This tells the browser what type of document to expect,
       and gives other optional information, such as the language, expiration
       date, and whether to cache the document.  The header can also be
       manipulated for special purposes, such as server push and pay per view
       pages.

   header() Create simple or complex HTTP headers
           print $q->header;

                -or-

           print $q->header('image/gif');

                -or-

           print $q->header('text/html','204 No response');

                -or-

           print $q->header( -type       => 'image/gif',
                             -nph        => 1,
                             -status     => '402 Payment required',
                             -expires    => '+3d',
                             -cookie     => $cookie,
                             -charset    => 'utf-7',
                             -attachment => 'foo.gif',
                             -Cost       => '$2.00'
                           );

       header() returns the Content-type: header.  You can provide your own
       MIME type if you choose, otherwise it defaults to text/html.  An
       optional second parameter specifies the status code and a human-
       readable message.  For example, you can specify 204, "No response" to
       create a script that tells the browser to do nothing at all.

       The last example shows the named argument style for passing arguments
       to the CGI methods using named parameters.  Recognized parameters are
       -type, -status, -cookie, -target, -expires, -nph, -charset and
       -attachment.  Any other named parameters will be stripped of their
       initial hyphens and turned into header fields, allowing you to specify
       any HTTP header you desire.

       For example, you can produce non-standard HTTP header fields by
       providing them as named arguments:

         print $q->header( -type            => 'text/html',
                           -nph             => 1,
                           -cost            => 'Three smackers',
                           -annoyance_level => 'high',
                           -complaints_to   => 'bit bucket'
                         );

       This will produce the following non-standard HTTP header:

           HTTP/1.0 200 OK
           Cost: Three smackers
           Annoyance-level: high
           Complaints-to: bit bucket
           Content-type: text/html

       Note that underscores are translated automatically into hyphens. This
       feature allows you to keep up with the rapidly changing HTTP
       "standards".

       The -type is a key element that tell the browser how to display your
       document. The default is 'text/html'. Common types are:

           text/html
           text/plain
           image/gif
           image/jpg
           image/png
           application/octet-stream

       The -status code is the HTTP response code. The default is 200 OK.
       Common status codes are:

           200 OK
           204 No Response
           301 Moved Permanently
           302 Found
           303 See Other
           307 Temporary Redirect
           400 Bad Request
           401 Unauthorized
           403 Forbidden
           404 Not Found
           405 Not Allowed
           408 Request Timed Out
           500 Internal Server Error
           503 Service Unavailable
           504 Gateway Timed Out

       The -expires parameter lets you indicate to a browser and proxy server
       how long to cache pages for. When you specify an absolute or relative
       expiration interval with this parameter, some browsers and proxy
       servers will cache the script's output until the indicated expiration
       date.  The following forms are all valid for the -expires field:

           +30s                                30 seconds from now
           +10m                                ten minutes from now
           +1h                                 one hour from now
           -1d                                 yesterday (i.e. "ASAP!")
           now                                 immediately
           +3M                                 in three months
           +10y                                in ten years time
           Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time & date

       The -cookie parameter generates a header that tells the browser to
       provide a "magic cookie" during all subsequent transactions with your
       script.  Netscape cookies have a special format that includes
       interesting attributes such as expiration time.  Use the cookie()
       method to create and retrieve session cookies.

       The -target is for frames use

       The -nph parameter, if set to a true value, will issue the correct
       headers to work with a NPH (no-parse-header) script.  This is important
       to use with certain servers that expect all their scripts to be NPH.

       The -charset parameter can be used to control the character set sent to
       the browser.  If not provided, defaults to ISO-8859-1.  As a side
       effect, this sets the charset() method as well.

       The -attachment parameter can be used to turn the page into an
       attachment.  Instead of displaying the page, some browsers will prompt
       the user to save it to disk.  The value of the argument is the
       suggested name for the saved file.  In order for this to work, you may
       have to set the -type to 'application/octet-stream'.

   no_cache() Preventing browser caching of scripts
       Most browsers will not cache the output from CGI scripts. Every time
       the browser reloads the page, the script is invoked anew. However some
       browsers do cache pages. You can discourage this behavior using the
       no_cache() function.

           $q->no_cache(1); # turn caching off by sending appropriate headers
           $q->no_cache(1); # do not send cache related headers.

           $q->no_cache(1);
           print header (-type=>'image/gif', -nph=>1);

           This will produce a header like the following:

           HTTP/1.0 200 OK
           Server: Apache - accept no substitutes
           Expires: Thu, 15 Nov 2001 03:37:50 GMT
           Date: Thu, 15 Nov 2001 03:37:50 GMT
           Pragma: no-cache
           Content-Type: image/gif

       Both the Pragma: no-cache header field and an Expires header that
       corresponds to the current time (ie now) will be sent.

   cache() Preventing browser caching of scripts
       The somewhat ill named cache() method is a legacy from CGI.pm. It
       operates the same as the new no_cache() method. The difference is/was
       that when set it results only in the Pragma: no-cache line being
       printed.  Expires time data is not sent.

   redirect() Generating a redirection header
           print $q->redirect('http://somewhere.else/in/movie/land');

       Sometimes you don't want to produce a document yourself, but simply
       redirect the browser elsewhere, perhaps choosing a URL based on the
       time of day or the identity of the user.

       The redirect() function redirects the browser to a different URL.  If
       you use redirection like this, you should not print out a header as
       well.

       One hint I can offer is that relative links may not work correctly when
       you generate a redirection to another document on your site.  This is
       due to a well-intentioned optimization that some servers use.  The
       solution to this is to use the full URL (including the http: part) of
       the document you are redirecting to.

       You can also use named arguments:

           print $q->redirect( -uri=>'http://somewhere.else/in/movie/land',
                               -nph=>1
                             );

       The -nph parameter, if set to a true value, will issue the correct
       headers to work with a NPH (no-parse-header) script.  This is important
       to use with certain servers, such as Microsoft ones, which expect all
       their scripts to be NPH.

PRAGMAS
       There are a number of pragmas that you can specify in your use
       CGI::Simple statement. Pragmas, which are always preceded by a hyphen,
       change the way that CGI::Simple functions in various ways. You can
       generally achieve exactly the same results by setting the underlying
       $GLOBAL_VARIABLES.

       For example the '-upload' pargma will enable file uploads:

           use CGI::Simple qw(-upload);

       In CGI::Simple::Standard Pragmas, function sets , and individual
       functions can all be imported in the same use() line.  For example, the
       following use statement imports the standard set of functions and
       enables debugging mode (pragma -debug):

           use CGI::Simple::Standard qw(:standard -debug);

       The current list of pragmas is as follows:

       -no_undef_params
           If a value is not given in the query string, as in the queries
           "name1=&name2=" or "name1&name2", by default it will be returned as
           an empty string.

           If you specify the '-no_undef_params' pragma then CGI::Simple
           ignores parameters with no values and they will not appear in the
           query object.

       -nph
           This makes CGI.pm produce a header appropriate for an NPH (no
           parsed header) script.  You may need to do other things as well to
           tell the server that the script is NPH.  See the discussion of NPH
           scripts below.

       -newstyle_urls
           Separate the name=value pairs in CGI parameter query strings with
           semicolons rather than ampersands.  For example:

               ?name=fred;age=24;favorite_color=3

           Semicolon-delimited query strings are always accepted, but will not
           be emitted by self_url() and query_string() unless the
           -newstyle_urls pragma is specified.

       -oldstyle_urls
           Separate the name=value pairs in CGI parameter query strings with
           ampersands rather than semicolons.  This is the default.

               ?name=fred&age=24&favorite_color=3

       -autoload
           This is only available for CGI::Simple::Standard and uses AUTOLOAD
           to load functions on demand. See the CGI::Simple::Standard docs for
           details.

       -no_debug
           This turns off the command-line processing features. This is the
           default.

       -debug1 and debug2
           This turns on debugging.  At debug level 1 CGI::Simple will read
           arguments from the command-line. At debug level 2 CGI.pm will
           produce the prompt "(offline mode: enter name=value pairs on
           standard input)" and wait for input on STDIN. If no number is
           specified then a debug level of 2 is used.

           See the section on debugging for more details.

       -default
           This sets the default global values for CGI.pm which will enable
           infinite size file uploads, and specify the '-newstyle_urls' and
           '-debug1' pragmas

       -no_upload
           Disable uploads - the default setting

       - upload
           Enable uploads - the CGI.pm default

       -unique_header
           Only allows headers to be generated once per script invocation

       -carp
           Carp when cgi_error() called, default is to do nothing

       -croak
           Croak when cgi_error() called, default is to do nothing

USING NPH SCRIPTS
       NPH, or "no-parsed-header", scripts bypass the server completely by
       sending the complete HTTP header directly to the browser.  This has
       slight performance benefits, but is of most use for taking advantage of
       HTTP extensions that are not directly supported by your server, such as
       server push and PICS headers.

       Servers use a variety of conventions for designating CGI scripts as
       NPH.  Many Unix servers look at the beginning of the script's name for
       the prefix "nph-".  The Macintosh WebSTAR server and Microsoft's
       Internet Information Server, in contrast, try to decide whether a
       program is an NPH script by examining the first line of script output.

       CGI.pm supports NPH scripts with a special NPH mode.  When in this
       mode, CGI.pm will output the necessary extra header information when
       the header() and redirect() methods are called. You can set NPH mode in
       any of the following ways:

       In the use statement
           Simply add the "-nph" pragma to the use:

               use CGI::Simple qw(-nph)

       By calling the nph() method:
           Call nph() with a non-zero parameter at any point after using
           CGI.pm in your program.

               $q->nph(1)

       By using -nph parameters
           in the header() and redirect()  statements:

               print $q->header(-nph=>1);

       The Microsoft Internet Information Server requires NPH mode.
       CGI::Simple will automatically detect when the script is running under
       IIS and put itself into this mode.  You do not need to do this
       manually, although it won't hurt anything if you do.  However, note
       that if you have applied Service Pack 6, much of the functionality of
       NPH scripts, including the ability to redirect while setting a cookie,
       b<do not work at all> on IIS without a special patch from Microsoft.
       See http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:
       Non-Parsed Headers Stripped From CGI Applications That Have nph- Prefix
       in Name.

SERVER PUSH
       CGI.pm provides four simple functions for producing multipart documents
       of the type needed to implement server push.  These functions were
       graciously provided by Ed Jordan <ed@fidalgo.net> with additions from
       Andrew Benham <adsb@bigfoot.com>

       You are also advised to put the script into NPH mode and to set $| to 1
       to avoid buffering problems.

       Browser support for server push is variable.

       Here is a simple script that demonstrates server push:

           #!/usr/local/bin/perl
           use CGI::Simple::Standard qw/:push -nph/;
           $| = 1;
           print multipart_init(-boundary=>'----here we go!');
           foreach (0 .. 4) {
               print multipart_start(-type=>'text/plain'),
               "The current time is ",scalar(localtime),"\n";
               if ($_ < 4) {
                   print multipart_end;
               }
               else {
                   print multipart_final;
               }
               sleep 1;
           }

       This script initializes server push by calling multipart_init().  It
       then enters a loop in which it begins a new multipart section by
       calling multipart_start(), prints the current local time, and ends a
       multipart section with multipart_end().  It then sleeps a second, and
       begins again. On the final iteration, it ends the multipart section
       with multipart_final() rather than with multipart_end().

   multipart_init() Initialize the multipart system
           multipart_init(-boundary=>$boundary);

       Initialize the multipart system.  The -boundary argument specifies what
       MIME boundary string to use to separate parts of the document.  If not
       provided, CGI.pm chooses a reasonable boundary for you.

   multipart_start() Start a new part of the multipart document
           multipart_start(-type=>$type)

       Start a new part of the multipart document using the specified MIME
       type.  If not specified, text/html is assumed.

   multipart_end() End a multipart part
           multipart_end()

       End a part.  You must remember to call multipart_end() once for each
       multipart_start(), except at the end of the last part of the multipart
       document when multipart_final() should be called instead of
       multipart_end().

   multipart_final()
           multipart_final()

       End all parts.  You should call multipart_final() rather than
       multipart_end() at the end of the last part of the multipart document.

   CGI::Push
       Users interested in server push applications should also have a look at
       the CGI::Push module.

DEBUGGING
       If you are running the script from the command line or in the perl
       debugger, you can pass the script a list of keywords or parameter=value
       pairs on the command line or from standard input (you don't have to
       worry about tricking your script into reading from environment
       variables).  Before you do this you will need to change the debug level
       from the default level of 0 (no debug) to either 1 if you want to debug
       from @ARGV (the command line) of 2 if you want to debug from STDIN. You
       can do this using the debug pragma like this:

           use CGI::Simple qw(-debug2);  # set debug to level 2 => from STDIN

               or this:

           $CGI::Simple::DEBUG = 1;      # set debug to level 1 => from @ARGV

       At debug level 1 you can pass keywords and name=value pairs like this:

           your_script.pl keyword1 keyword2 keyword3

               or this:

           your_script.pl keyword1+keyword2+keyword3

               or this:

           your_script.pl name1=value1 name2=value2

               or this:

           your_script.pl name1=value1&name2=value2

       At debug level 2 you can feed newline-delimited name=value pairs to the
       script on standard input. You will be presented with the following
       prompt:

           (offline mode: enter name=value pairs on standard input)

       You end the input with your system dependent end of file character.
       You should try ^Z ^X ^D and ^C if all else fails. The ^ means hold down
       the [Ctrl] button while you press the other key.

       When debugging, you can use quotes and backslashes to escape characters
       in the familiar shell manner, letting you place spaces and other funny
       characters in your parameter=value pairs:

           your_script.pl "name1='I am a long value'" "name2=two\ words"

   Dump() Dumping the current object details
       The Dump() method produces a string consisting of all the query's
       object attributes formatted nicely as a nested list.  This dump
       includes the name/value pairs and a number of other details. This is
       useful for debugging purposes:

           print $q->Dump

       The actual result of this is HTML escaped formatted text wrapped in
       <pre> tags so if you send it straight to the browser it produces
       something that looks like:

           $VAR1 = bless( {
                '.parameters' => [
                                   'name',
                                   'color'
                                 ],
                '.globals' => {
                                'FATAL' => -1,
                                'DEBUG' => 0,
                                'NO_NULL' => 1,
                                'POST_MAX' => 102400,
                                'USE_CGI_PM_DEFAULTS' => 0,
                                'HEADERS_ONCE' => 0,
                                'NPH' => 0,
                                'DISABLE_UPLOADS' => 1,
                                'NO_UNDEF_PARAMS' => 0,
                                'USE_PARAM_SEMICOLONS' => 0
                              },
                '.fieldnames' => {
                                   'color' => '1',
                                   'name' => '1'
                                 },
                '.mod_perl' => '',
                'color' => [
                             'red',
                             'green',
                             'blue'
                           ],
                'name' => [
                            'JaPh,'
                          ]
               }, 'CGI::Simple' );

       You may recognize this as valid Perl syntax (which it is) and/or the
       output from Data::Dumper (also true). This is the actual guts of how
       the information is stored in the query object. All the internal params
       start with a . char

       Alternatively you can dump your object and the current environment
       using:

           print $q->Dump(\%ENV);

   PrintEnv() Dumping the environment
       You can get a similar browser friendly dump of the current %ENV hash
       using:

           print $q->PrintEnv;

       This will produce something like (in the browser):

           $VAR1 = {
                 'QUERY_STRING' => 'name=JaPh%2C&color=red&color=green&color=blue',
                 'CONTENT_TYPE' => 'application/x-www-form-urlencoded',
                 'REGRESSION_TEST' => 'simple.t.pl',
                 'VIM' => 'C:\\WINDOWS\\Desktop\\vim',
                 'HTTP_REFERER' => 'xxx.sex.com',
                 'HTTP_USER_AGENT' => 'LWP',
                 'HTTP_ACCEPT' => 'text/html;q=1, image/gif;q=0.42, */*;q=0.001',
                 'REMOTE_HOST' => 'localhost',
                 'HTTP_HOST' => 'the.restaurant.at.the.end.of.the.universe',
                 'GATEWAY_INTERFACE' => 'bleeding edge',
                 'REMOTE_IDENT' => 'None of your damn business',
                 'SCRIPT_NAME' => '/cgi-bin/foo.cgi',
                 'SERVER_NAME' => 'nowhere.com',
                 'HTTP_COOKIE' => '',
                 'CONTENT_LENGTH' => '42',
                 'HTTPS_A' => 'A',
                 'HTTP_FROM' => 'spammer@nowhere.com',
                 'HTTPS_B' => 'B',
                 'SERVER_PROTOCOL' => 'HTTP/1.0',
                 'PATH_TRANSLATED' => '/usr/local/somewhere/else',
                 'SERVER_SOFTWARE' => 'Apache - accept no substitutes',
                 'PATH_INFO' => '/somewhere/else',
                 'REMOTE_USER' => 'Just another Perl hacker,',
                 'REMOTE_ADDR' => '127.0.0.1',
                 'HTTPS' => 'ON',
                 'DOCUMENT_ROOT' => '/vs/www/foo',
                 'REQUEST_METHOD' => 'GET',
                 'REDIRECT_QUERY_STRING' => '',
                 'AUTH_TYPE' => 'PGP MD5 DES rot13',
                 'COOKIE' => 'foo=a%20phrase; bar=yes%2C%20a%20phrase&;I%20say;',
                 'SERVER_PORT' => '8080'
               };

   cgi_error() Retrieving CGI::Simple error messages
       Errors can occur while processing user input, particularly when
       processing uploaded files.  When these errors occur, CGI::Simple will
       stop processing and return an empty parameter list.  You can test for
       the existence and nature of errors using the cgi_error() function.  The
       error messages are formatted as HTTP status codes. You can either
       incorporate the error text into an HTML page, or use it as the value of
       the HTTP status:

           my $error = $q->cgi_error;
           if ($error) {
               print $q->header(-status=>$error);
               print "<H2>$error</H2>;
             exit;
           }

ACCESSOR METHODS
   version() Get the CGI::Simple version info
           $version = $q->version();

       The version() method returns the value of $VERSION

   nph() Enable/disable NPH (Non Parsed Header) mode
           $q->nph(1);  # enable NPH mode
           $q->nph(0);  # disable NPH mode

       The nph() method enables and disables NPH headers. See the NPH section.

   all_parameters() Get the names/values of all parameters
           @all_parameters = $q->all_parameters();

       The all_parameters() method is an alias for param()

   charset() Get/set the current character set.
           $charset = $q->charset(); # get current charset
           $q->charset('utf-42');    # set the charset

       The charset() method gets the current charset value if no argument is
       supplied or sets it if an argument is supplied.

   crlf() Get the system specific line ending sequence
           $crlf = $q->crlf();

       The crlf() method returns the system specific line ending sequence.

   globals() Get/set the value of the remaining global variables
           $globals = $q->globals('FATAL');     # get the current value of $FATAL
           $globals = $q->globals('FATAL', 1 ); # set croak mode on cgi_error()

       The globals() method gets/sets the values of the global variables after
       the script has been invoked. For globals like $POST_MAX and
       $DISABLE_UPLOADS this makes no difference as they must be set prior to
       calling the new constructor but there might be reason the change the
       value of others.

   auth_type() Get the current authorization/verification method
           $auth_type = $q->auth_type();

       The auth_type() method returns the value of $ENV{'AUTH_TYPE'} which
       should contain the authorization/verification method in use for this
       script, if any.

   content_length() Get the content length submitted in a POST
           $content_length = $q->content_length();

       The content_length() method returns the value of $ENV{'AUTH_TYPE'}

   content_type() Get the content_type of data submitted in a POST
           $content_type = $q->content_type();

       The content_type() method returns the content_type of data submitted in
       a POST, generally 'multipart/form-data' or
       'application/x-www-form-urlencoded' as supplied in $ENV{'CONTENT_TYPE'}

   document_root() Get the document root
           $document_root = $q->document_root();

       The document_root() method returns the value of $ENV{'DOCUMENT_ROOT'}

   gateway_interface() Get the gateway interface
           $gateway_interface = $q->gateway_interface();

       The gateway_interface() method returns the value of
       $ENV{'GATEWAY_INTERFACE'}

   path_translated() Get the value of path translated
           $path_translated = $q->path_translated();

       The path_translated() method returns the value of
       $ENV{'PATH_TRANSLATED'}

   referer() Spy on your users
           $referer = $q->referer();

       The referer() method returns the value of $ENV{'REFERER'} This will
       return the URL of the page the browser was viewing prior to fetching
       your script.  Not available for all browsers.

   remote_addr() Get the remote address
           $remote_addr = $q->remote_addr();

       The remote_addr() method returns the value of $ENV{'REMOTE_ADDR'} or
       127.0.0.1 (localhost) if this is not defined.

   remote_host() Get a value for remote host
           $remote_host = $q->remote_host();

       The remote_host() method returns the value of $ENV{'REMOTE_HOST'} if it
       is defined. If this is not defined it returns $ENV{'REMOTE_ADDR'} If
       this is not defined it returns 'localhost'

   remote_ident() Get the remote identity
           $remote_ident = $q->remote_ident();

       The remote_ident() method returns the value of $ENV{'REMOTE_IDENT'}

   remote_user() Get the remote user
           $remote_user = $q->remote_user();

       The remote_user() method returns the authorization/verification name
       used for user verification, if this script is protected. The value
       comes from $ENV{'REMOTE_USER'}

   request_method() Get the request method
           $request_method = $q->request_method();

       The request_method() method returns the method used to access your
       script, usually one of 'POST', 'GET' or 'HEAD' as supplied by
       $ENV{'REQUEST_METHOD'}

   script_name() Get the script name
           $script_name = $q->script_name();

       The script_name() method returns the value of $ENV{'SCRIPT_NAME'} if it
       is defined. Otherwise it returns Perl's script name from $0. Failing
       this it returns a null string ''

   server_name() Get the server name
           $server_name = $q->server_name();

       The server_name() method returns the value of $ENV{'SERVER_NAME'} if
       defined or 'localhost' otherwise

   server_port() Get the port the server is listening on
           $server_port = $q->server_port();

       The server_port() method returns the value $ENV{'SERVER_PORT'} if
       defined or 80 if not.

   server_protocol() Get the current server protocol
           $server_protocol = $q->server_protocol();

       The server_protocol() method returns the value of
       $ENV{'SERVER_PROTOCOL'} if defined or 'HTTP/1.0' otherwise

   server_software() Get the server software
           $server_software = $q->server_software();

       The server_software() method returns the value $ENV{'SERVER_SOFTWARE'}
       or 'cmdline' If the server software is IIS it formats your hard drive,
       installs Linux, FTPs to www.apache.org, installs Apache, and then
       restores your system from tape. Well maybe not, but it's a nice
       thought.

   user_name() Get a value for the user name.
           $user_name = $q->user_name();

       Attempt to obtain the remote user's name, using a variety of different
       techniques.  This only works with older browsers such as Mosaic.  Newer
       browsers do not report the user name for privacy reasons!

       Technically the user_name() method returns the value of
       $ENV{'HTTP_FROM'} or failing that $ENV{'REMOTE_IDENT'} or as a last
       choice $ENV{'REMOTE_USER'}

   user_agent() Get the users browser type
           $ua = $q->user_agent();          # return the user agent
           $ok = $q->user_agent('mozilla'); # return true if user agent 'mozilla'

       The user_agent() method returns the value of $ENV{'HTTP_USER_AGENT'}
       when called without an argument or true or false if the
       $ENV{'HTTP_USER_AGENT'} matches the passed argument. The matching is
       case insensitive and partial.

   virtual_host() Get the virtual host
           $virtual_host = $q->virtual_host();

       The virtual_host() method returns the value of  $ENV{'HTTP_HOST'} if
       defined or $ENV{'SERVER_NAME'} as a default. Port numbers are removed.

   path_info() Get any extra path info set to the script
           $path_info = $q->path_info();

       The path_info() method returns additional path information from the
       script URL. E.G. fetching /cgi-bin/your_script/additional/stuff will
       result in $q->path_info() returning "/additional/stuff".

       NOTE: The Microsoft Internet Information Server is broken with respect
       to additional path information.  If you use the Perl DLL library, the
       IIS server will attempt to execute the additional path information as a
       Perl script.  If you use the ordinary file associations mapping, the
       path information will be present in the environment, but incorrect.
       The best thing to do is to avoid using additional path information in
       CGI scripts destined for use with IIS.

   Accept() Get the browser MIME types
           $Accept = $q->Accept();

       The Accept() method returns a list of MIME types that the remote
       browser accepts. If you give this method a single argument
       corresponding to a MIME type, as in $q->Accept('text/html'), it will
       return a floating point value corresponding to the browser's preference
       for this type from 0.0 (don't want) to 1.0.  Glob types (e.g. text/*)
       in the browser's accept list are handled correctly.

   accept() Alias for Accept()
           $accept = $q->accept();

       The accept() Method is an alias for Accept()

   http() Get a range of HTTP related information
           $http = $q->http();

       Called with no arguments the http() method returns the list of HTTP or
       HTTPS environment variables, including such things as HTTP_USER_AGENT,
       HTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the
       like-named HTTP header fields in the request. Called with the name of
       an HTTP header field, returns its value.  Capitalization and the use of
       hyphens versus underscores are not significant.

       For example, all three of these examples are equivalent:

          $requested_language = $q->http('Accept-language');
          $requested_language = $q->http('Accept_language');
          $requested_language = $q->http('HTTP_ACCEPT_LANGUAGE');

   https() Get a range of HTTPS related information
           $https = $q->https();

       The https() method is similar to the http() method except that when
       called without an argument it returns the value of $ENV{'HTTPS'} which
       will be true if a HTTPS connection is in use and false otherwise.

   protocol() Get the current protocol
           $protocol = $q->protocol();

       The protocol() method returns 'https' if a HTTPS connection is in use
       or the server_protocol() minus version numbers ('http') otherwise.

   url() Return the script's URL in several formats
           $full_url      = $q->url();
           $full_url      = $q->url(-full=>1);
           $relative_url  = $q->url(-relative=>1);
           $absolute_url  = $q->url(-absolute=>1);
           $url_with_path = $q->url(-path_info=>1);
           $url_with_path_and_query = $q->url(-path_info=>1,-query=>1);
           $netloc        = $q->url(-base => 1);

       url() returns the script's URL in a variety of formats.  Called without
       any arguments, it returns the full form of the URL, including host name
       and port number

           http://your.host.com/path/to/script.cgi

       You can modify this format with the following named arguments:

       -absolute
           If true, produce an absolute URL, e.g.

               /path/to/script.cgi

       -relative
           Produce a relative URL.  This is useful if you want to reinvoke
           your script with different parameters. For example:

               script.cgi

       -full
           Produce the full URL, exactly as if called without any arguments.
           This overrides the -relative and -absolute arguments.

       -path (-path_info)
           Append the additional path information to the URL.  This can be
           combined with -full, -absolute or -relative.  -path_info is
           provided as a synonym.

       -query (-query_string)
           Append the query string to the URL.  This can be combined with
           -full, -absolute or -relative.  -query_string is provided as a
           synonym.

       -base
           Generate just the protocol and net location, as in
           http://www.foo.com:8000

   self_url() Get the scripts complete URL
           $self_url = $q->self_url();

       The self_url() method returns the value of:

          $self->url( '-path_info'=>1, '-query'=>1, '-full'=>1 );

   state() Alias for self_url()
           $state = $q->state();

       The state() method is an alias for self_url()

COMPATIBILITY WITH cgi-lib.pl 2.18
       To make it easier to port existing programs that use cgi-lib.pl all the
       subs within cgi-lib.pl are available in CGI::Simple.  Using the
       functional interface of CGI::Simple::Standard porting is as easy as:

           OLD VERSION
               require "cgi-lib.pl";
               &ReadParse;
               print "The value of the antique is $in{'antique'}.\n";

           NEW VERSION
               use CGI::Simple::Standard qw(:cgi-lib);
               &ReadParse;
               print "The value of the antique is $in{'antique'}.\n";

       CGI:Simple's ReadParse() routine creates a variable named %in, which
       can be accessed to obtain the query variables.  Like ReadParse, you can
       also provide your own variable via a glob. Infrequently used features
       of ReadParse(), such as the creation of @in and $in variables, are not
       supported.

       You can also use the OO interface of CGI::Simple and call ReadParse()
       and other cgi-lib.pl functions like this:

           &CGI::Simple::ReadParse;       # get hash values in %in

           my $q = CGI::Simple->new;
           $q->ReadParse();                # same thing

           CGI::Simple::ReadParse(*field); # get hash values in %field function style

           my $q = CGI::Simple->new;
           $q->ReadParse(*field);          # same thing

       Once you use ReadParse() under the functional interface , you can
       retrieve the query object itself this way if needed:

           $q = $in{'CGI'};

       Either way it allows you to start using the more interesting features
       of CGI.pm without rewriting your old scripts from scratch.

       Unlike CGI.pm all the cgi-lib.pl functions from Version 2.18 are
       supported:

           ReadParse()
           SplitParam()
           MethGet()
           MethPost()
           MyBaseUrl()
           MyURL()
           MyFullUrl()
           PrintHeader()
           HtmlTop()
           HtmlBot()
           PrintVariables()
           PrintEnv()
           CgiDie()
           CgiError()

COMPATIBILITY WITH CGI.pm
       I has long been suggested that the CGI and HTML parts of CGI.pm should
       be split into separate modules (even the author suggests this!),
       CGI::Simple represents the realization of this and contains the
       complete CGI side of CGI.pm. Code-wise it weighs in at a little under
       30% of the size of CGI.pm at a little under 1000 lines.

       A great deal of care has been taken to ensure that the interface
       remains unchanged although a few tweaks have been made. The test suite
       is extensive and includes all the CGI.pm test scripts as well as a
       series of new test scripts. You may like to have a look at /t/concur.t
       which makes 160 tests of CGI::Simple and CGI in parallel and compares
       the results to ensure they are identical. This is the case as of CGI.pm
       2.78.

       You can't make an omelet without breaking eggs. A large number of
       methods and global variables have been deleted as detailed below. Some
       pragmas are also gone. In the tarball there is a script /misc/check.pl
       that will check if a script seems to be using any of these now non
       existent methods, globals or pragmas. You call it like this:

           perl check.pl <files>

       If it finds any likely candidates it will print a line with the line
       number, problem method/global and the complete line. For example here
       is some output from running the script on CGI.pm:

           ...
           3162: Problem:'$CGI::OS'   local($CRLF) = "\015\012" if $CGI::OS eq 'VMS';
           3165: Problem:'fillBuffer' $self->fillBuffer($FILLUNIT);
           ....

DIFFERENCES FROM CGI.pm
       CGI::Simple is strict and warnings compliant.

       There are 4 modules in this distribution:

           CGI/Simple.pm           supplies all the core code.
           CGI/Simple/Cookie.pm    supplies the cookie handling functions.
           CGI/Simple/Util.pm      supplies a variety of utility functions
           CGI/Simple/Standard.pm  supplies a functional interface for Simple.pm

       Simple.pm is the core module that provide all the essential
       functionality.  Cookie.pm is a shortened rehash of the CGI.pm module of
       the same name which supplies the required cookie functionality. Util.pm
       has been recoded to use an internal object for data storage and
       supplies rarely needed non core functions and/or functions needed for
       the HTML side of things. Standard.pm is a wrapper module that supplies
       a complete functional interface to the OO back end supplied by
       CGI::Simple.

       Although a serious attempt has been made to keep the interface
       identical, some minor changes and tweaks have been made. They will
       likely be insignificant to most users but here are the gory details.

   Globals Variables
       The list of global variables has been pruned by 75%. Here is the
       complete list of the global variables used:

           $VERSION = "0.01";
           # set this to 1 to use CGI.pm default global settings
           $USE_CGI_PM_DEFAULTS = 0 unless defined $USE_CGI_PM_DEFAULTS;
           # see if user wants old  CGI.pm defaults
           do{ _use_cgi_pm_global_settings(); return } if $USE_CGI_PM_DEFAULTS;
           # no file uploads by default, set to 0 to enable uploads
           $DISABLE_UPLOADS = 1 unless defined $DISABLE_UPLOADS;
           # use a post max of 100K, set to -1 for no limits
           $POST_MAX = 102_400 unless defined $POST_MAX;
           # do not include undefined params parsed from query string
           $NO_UNDEF_PARAMS = 0 unless defined $NO_UNDEF_PARAMS;
           # separate the name=value pairs with ; rather than &
           $USE_PARAM_SEMICOLONS = 0 unless defined $USE_PARAM_SEMICOLONS;
           # only print headers once
           $HEADERS_ONCE = 0 unless defined $HEADERS_ONCE;
           # Set this to 1 to enable NPH scripts
           $NPH = 0 unless defined $NPH;
           # 0 => no debug, 1 => from @ARGV,  2 => from STDIN
           $DEBUG = 0 unless defined $DEBUG;
           # filter out null bytes in param - value pairs
           $NO_NULL  = 1 unless defined $NO_NULL;
           # set behavior when cgi_err() called -1 => silent, 0 => carp, 1 => croak
           $FATAL = -1 unless defined $FATAL;

       Four of the default values of the old CGI.pm variables have been
       changed.  Unlike CGI.pm which by default allows unlimited POST data and
       file uploads by default CGI::Simple limits POST data size to 100kB and
       denies file uploads by default. $USE_PARAM_SEMICOLONS is set to 0 by
       default so we use (old style) & rather than ; as the pair separator for
       query strings. Debugging is disabled by default.

       There are three new global variables. If $NO_NULL is true (the default)
       then CGI::Simple will strip null bytes out of names, values and
       keywords. Null bytes can do interesting things to C based code like
       Perl. Uploaded files are not touched. $FATAL controls the behavior when
       cgi_error() is called.  The default value of -1 makes errors silent.
       $USE_CGI_PM_DEFAULTS reverts the defaults to the CGI.pm standard values
       ie unlimited file uploads via POST for DNS attacks. You can also get
       the defaults back by using the '-default' pragma in the use:

           use CGI::Simple qw(-default);
           use CGI::Simple::Standard qw(-default);

       The values of the global variables are stored in the CGI::Simple object
       and can be referenced and changed using the globals() method like this:

           my $value = $q->globals( 'VARNAME' );      # get
           $q->globals( 'VARNAME', 'some value' );    # set

       As with many CGI.pm methods if you pass the optional value that will be
       set.

       The $CGI::Simple::VARNAME = 'N' syntax is only useful prior to calling
       the new() constructor. After that all reference is to the values stored
       in the CGI::Simple object so you must change these using the globals()
       method.

       $DISABLE_UPLOADS and $POST_MAX *must* be set prior to calling the
       constructor if you want the changes to have any effect as they control
       behavior during initialization. This is the same a CGI.pm although some
       people seem to miss this rather important point and set these after
       calling the constructor which does nothing.

       The following globals are no longer relevant and have all been deleted:

           $AUTOLOADED_ROUTINES
           $AUTOLOAD_DEBUG
           $BEEN_THERE
           $CRLF
           $DEFAULT_DTD
           $EBCDIC
           $FH
           $FILLUNIT
           $IIS
           $IN
           $INITIAL_FILLUNIT
           $JSCRIPT
           $MAC
           $MAXTRIES
           $MOD_PERL
           $NOSTICKY
           $OS
           $PERLEX
           $PRIVATE_TEMPFILES
           $Q
           $QUERY_CHARSET
           $QUERY_PARAM
           $SCRATCH
           $SL
           $SPIN_LOOP_MAX
           $TIMEOUT
           $TMPDIRECTORY
           $XHTML
           %EXPORT
           %EXPORT_OK
           %EXPORT_TAGS
           %OVERLOAD
           %QUERY_FIELDNAMES
           %SUBS
           @QUERY_PARAM
           @TEMP

       Notes: CGI::Simple uses IO::File->new_tmpfile to get tempfile
       filehandles.  These are private by default so $PRIVATE_TEMPFILES is no
       longer required nor is $TMPDIRECTORY. The value that were stored in
       $OS, $CRLF, $QUERY_CHARSET and $EBCDIC are now stored in the
       CGI::Simple::Util object where they find most of their use. The
       $MOD_PERL and $PERLEX values are now stored in our CGI::Simple object.
       $IIS was only used once in path_info().  $SL the system specific / \ :
       path delimiter is not required as we let IO::File handle our tempfile
       requirements. The rest of the globals are HTML related, export related,
       hand rolled autoload related or serve obscure purposes in CGI.pm

   Changes to pragmas
       There are some new pragmas available. See the pragmas section for
       details.  The following CGI.pm pragmas are not available:

           -any
           -compile
           -nosticky
           -no_xhtml
           -private_tempfiles

   Filehandles
       Unlike CGI.pm which tries to accept all filehandle like objects only
       \*FH and $fh are accepted by CGI::Simple as file accessors for new()
       and save().  IO::File objects work fine.

   Hash interface
           %hash = $q->Vars();     # pack values with "\0";
           %hash = $q->Vars(",");  # comma separate values

       You may optionally pass Vars() a string that will be used to separate
       multiple values when they are packed into the single hash value. If no
       value is supplied the default "\0" (null byte) will be used. Null bytes
       are dangerous things for C based code (ie Perl).

   cgi-lib.pl
       All the cgi-lib.pl 2.18 routines are supported. Unlike CGI.pm all the
       subroutines from cgi-lib.pl are included. They have been GOLFED down to
       25 lines but they all work pretty much the same as the originals.

CGI::Simple COMPLETE METHOD LIST
       Here is a complete list of all the CGI::Simple methods.

   Guts (hands off, except of course for new)
           _initialize_globals
           _use_cgi_pm_global_settings
           _store_globals
           import
           _reset_globals
           new
           _initialize
           _read_parse
           _parse_params
           _add_param
           _parse_keywordlist
           _parse_multipart
           _save_tmpfile
           _read_data

   Core Methods
           param
           add_param
           param_fetch
           url_param
           keywords
           Vars
           append
           delete
           Delete
           delete_all
           Delete_all
           upload
           upload_info
           query_string
           parse_query_string
           parse_keywordlist

   Save and Restore from File Methods
           _init_from_file
           save
           save_parameters

   Miscellaneous Methods
           url_decode
           url_encode
           escapeHTML
           unescapeHTML
           put
           print

   Cookie Methods
           cookie
           raw_cookie

   Header Methods
           header
           cache
           no_cache
           redirect

   Server Push Methods
           multipart_init
           multipart_start
           multipart_end
           multipart_final

   Debugging Methods
           read_from_cmdline
           Dump
           as_string
           cgi_error

   cgi-lib.pl Compatibility Routines - all 2.18 functions available
           _shift_if_ref
           ReadParse
           SplitParam
           MethGet
           MethPost
           MyBaseUrl
           MyURL
           MyFullUrl
           PrintHeader
           HtmlTop
           HtmlBot
           PrintVariables
           PrintEnv
           CgiDie
           CgiError

   Accessor Methods
           version
           nph
           all_parameters
           charset
           crlf                # new, returns OS specific CRLF sequence
           globals             # get/set global variables
           auth_type
           content_length
           content_type
           document_root
           gateway_interface
           path_translated
           referer
           remote_addr
           remote_host
           remote_ident
           remote_user
           request_method
           script_name
           server_name
           server_port
           server_protocol
           server_software
           user_name
           user_agent
           virtual_host
           path_info
           Accept
           accept
           http
           https
           protocol
           url
           self_url
           state

NEW METHODS IN CGI::Simple
       There are a few new methods in CGI::Simple as listed below. The
       highlights are the parse_query_string() method to add the QUERY_STRING
       data to your object if the method was POST. The no_cache() method adds
       an expires now directive and the Pragma: no-cache directive to the
       header to encourage some browsers to do the right thing. PrintEnv()
       from the cgi-lib.pl routines will dump an HTML friendly list of the
       %ENV and makes a handy addition to Dump() for use in debugging. The
       upload method now accepts a filepath as an optional second argument as
       shown in the synopsis. If this is supplied the uploaded file will be
       written to there automagically.

   Internal Routines
           _initialize_globals()
           _use_cgi_pm_global_settings()
           _store_globals()
           _initialize()
           _init_from_file()
           _read_parse()
           _parse_params()
           _add_param()
           _parse_keywordlist()
           _parse_multipart()
           _save_tmpfile()
           _read_data()

   New Public Methods
           add_param()             # adds a param/value(s) pair +/- overwrite
           upload_info()           # uploaded files MIME type and size
           url_decode()            # decode s url encoded string
           url_encode()            # url encode a string
           parse_query_string()    # add QUERY_STRING data to $q object if 'POST'
           no_cache()              # add both the Pragma: no-cache
                                   # and Expires/Date => 'now' to header

   cgi-lib.pl methods added for completeness
           _shift_if_ref()         # internal hack reminiscent of self_or_default :-)
           MyBaseUrl()
           MyURL()
           MyFullUrl()
           PrintVariables()
           PrintEnv()
           CgiDie()
           CgiError()

   New Accessors
           crlf()                  # returns CRLF sequence
           globals()               # global vars now stored in $q object - get/set
           content_length()        # returns $ENV{'CONTENT_LENGTH'}
           document_root()         # returns $ENV{'DOCUMENT_ROOT'}
           gateway_interface()     # returns $ENV{'GATEWAY_INTERFACE'}

METHODS IN CGI.pm NOT IN CGI::Simple
       Here is a complete list of what is not included in CGI::Simple.
       Basically all the HTML related stuff plus large redundant chunks of the
       guts. The check.pl script in the /misc dir will check to see if a
       script is using any of these.

   Guts - rearranged, recoded, renamed and hacked out of existence
           initialize_globals()
           compile()
           expand_tags()
           self_or_default()
           self_or_CGI()
           init()
           to_filehandle()
           save_request()
           parse_params()
           add_parameter()
           binmode()
           _make_tag_func()
           AUTOLOAD()
           _compile()
           _setup_symbols()
           new_MultipartBuffer()
           read_from_client()
           import_names()     # I dislike this and left it out, so shoot me.

   HTML Related
           autoEscape()
           URL_ENCODED()
           MULTIPART()
           SERVER_PUSH()
           start_html()
           _style()
           _script()
           end_html()
           isindex()
           startform()
           start_form()
           end_multipart_form()
           start_multipart_form()
           endform()
           end_form()
           _textfield()
           textfield()
           filefield()
           password_field()
           textarea()
           button()
           submit()
           reset()
           defaults()
           comment()
           checkbox()
           checkbox_group()
           _tableize()
           radio_group()
           popup_menu()
           scrolling_list()
           hidden()
           image_button()
           nosticky()
           default_dtd()

   Upload Related
       CGI::Simple uses anonymous tempfiles supplied by IO::File to spool
       uploaded files to.

           private_tempfiles() # automatic in CGI::Simple
           tmpFileName()       # all upload files are anonymous
           uploadInfo()        # relied on FH access, replaced with upload_info()

   Really Private Subs (marked as so)
           previous_or_default()
           register_parameter()
           get_fields()
           _set_values_and_labels()
           _compile_all()
           asString()
           compare()

   Internal Multipart Parsing Routines
           read_multipart()
           readHeader()
           readBody()
           read()
           fillBuffer()
           eof()

EXPORT
       Nothing.

AUTHOR INFORMATION
       Originally copyright 2001 Dr James Freeman <jfreeman@tassie.net.au>
       This release by Andy Armstrong <andy@hexten.net>

       This package is free software and is provided "as is" without express
       or implied warranty. It may be used, redistributed and/or modified
       under the terms of the Perl Artistic License (see
       http://www.perl.com/perl/misc/Artistic.html)

       Address bug reports and comments to: andy@hexten.net.  When sending bug
       reports, please provide the version of CGI::Simple, the version of
       Perl, the name and version of your Web server, and the name and version
       of the operating system you are using.  If the problem is even remotely
       browser dependent, please provide information about the affected
       browsers as well.

       Address bug reports and comments to: andy@hexten.net

CREDITS
       Lincoln D. Stein (lstein@cshl.org) and everyone else who worked on the
       original CGI.pm upon which this module is heavily based

       Brandon Black for some heavy duty testing and bug fixes

       John D Robinson and Jeroen Latour for helping solve some interesting
       test failures as well as Perlmonks: tommyw, grinder, Jaap, vek, erasei,
       jlongino and strider_corinth

       Thanks for patches to:

       Ewan Edwards, Joshua N Pritikin, Mike Barry, Michael Nachbaur, Chris
       Williams, Mark Stosberg, Krasimir Berov, Yamada Masahiro

LICENCE AND COPYRIGHT
       Copyright (c) 2007, Andy Armstrong "<andy@hexten.net>". All rights
       reserved.

       This module is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself. See perlartistic.

SEE ALSO
       CGI, CGI::Simple::Standard, CGI::Simple::Cookie, CGI::Simple::Util,
       CGI::Minimal

perl v5.40.2                      2024-01-31                    CGI::Simple(3)
